
* Chapter 2 Building Abstractions with Data
  We concentrated in chapter 1 on computational processes and on the
  role of procedures in program design. We saw how to use primitive
  data (numbers) and primitive operations (arithmetic operations), how
  to combine procedures to form compound procedures through

  composition, conditionals, and the use of parameters, and how to
  abstract procedures by using define. We saw that a procedure can


  classified, reasoned about, and performed simple algorithmic
  analyses of some common patterns for processes as embodied in
  procedures. We also saw that higher-order procedures enhance the
  power of our language by enabling us to manipulate, and thereby to
  reason in terms of, general methods of computation. This is much of
  the essence of programming.

  In this chapter we are going to look at more complex data. All the
  procedures in chapter 1 operate on simple numerical data, and simple
  data are not sufficient for many of the problems we wish to address
  using computation. Programs are typically designed to model complex
  phenomena, and more often than not one must construct computational
  objects that have several parts in order to model real-world
  phenomena that have several aspects. Thus, whereas our focus on
  chapter 1 was on building abstractions by combining procedures to
  form compound procedures, we turn in this chapter to another key
  aspect of any programming language: the means it provides for
  building abstractions by combining data objects to form _compound
  data_.

  Why do we want compound data in a programming language? For the same
  reasons we want compound procedures: to elevate the conceptual level
  at which we can design our programs, to increase the modularity of
  our designs, and to enhance the expressive power of our
  language. Just as the ability to define procedures enables us to
  deal with processes at a higher conceptual level than that of the
  primitive operations of the language, the ability to construct
  compound data objects enables us to deal with data at a higher
  conceptual level than that of the primitive data objects of our
  language.

  Consider the task of designing a system to perform arithmetic with
  rational numbers. We could imagine an operation add-rat that takes
  two rational numbers and produces their sum. In terms of simple
  data, a rational number can be thought of as two integers: a
  numerator and a denominator. Thus, we could design a program in
  which each rational number would be represented by two integers (a
  numerator and denominator) and where add-rat would be implemented by
  two procedures (one producing a numerator of the sum and one
  producing the denominator). But this would be awkward, because we
  would then need to explicitly keep track of which numerators
  corresponded to which denominators. In a system intended to perform
  many operations on many rational numbers, such bookkeeping details
  would clutter the programs substantially, to say nothing of what
  they would do to our minds. It would be much better if we could
  "glue together" a numerator and denominator to form a pair -- a
  _compound data object_ -- that our programs could manipulate in a
  way that would be consistent with regarding a rational number as a
  single conceptual unit.

  The use of compound data also enables us to increase the modularity
  of our programs. If we can manipulate rational numbers directly as
  objects in their own right then we can separate the part of our
  program that deals with rational numbers per se from the details of
  how rational numbers may be represeted as pairs of integers. The
  general technique of isolating the parts of a program that deal with
  how data objects are represented from the parts of the program that
  deal with how data objects are used is a powerful design methodology
  called _data abstraction_. We will see how data abstraction makes
  programs much easier to design, maintain, and modify.

  The use of compound data leads to a real increase in the expressive
  power of our programming language. Consider the idea of forming a
  "linear combination" ax + by. We might like to write a procedure
  that would accept a, b, x, and y as arguments and return the value
  of ax + by. This presents no difficulty if the arguments are to be
  numbers, because we can readily define the procedure

  #+BEGIN_SRC scheme
  (define (linear-combination a b x y)
   (+ (* a x) (* b y)))
  #+END_SRC

  But suppose we are not concerned only with numbers. Suppose we would
  like to express, in procedural terms, the idea that one can form
  linear combinations whenever addition and multiplication are defined
  -- for rational numbers, complex numbers, polynomials, or
  whatever. We could express this as a procedure of the form 
  
  #+BEGIN_SRC scheme
  (define (linear-combination a b x y)
   (add (mul a x) (mul b y)))
  #+END_SRC

  where add and mul are not primitive procedures + and * but rather
  more complex things that will perform the appropriate operations for
  whatever kinds of data we pass in as the arguments a, b, x, and
  y. The key point is that the only thing linear-combination should
  need to know about a, b, x, and y is that the procedures add and mul
  will perform the appropriate manipulations. From the perspective of
  the procedure linear-combination, it is irrelevant what a, b, x, and
  y are and even more irrelevant how they might happen to be
  represented in terms of more primitive data. This same example shows
  why it is important that our programming language provide the
  ability to manipulate compound objects directly: Without this, there
  is no way for a procedure such as linear-combination to pass its
  arguments along to add and mul without having to know their detailed
  structure. We begin this chapter by implementing the rational-number
  arithmetic system mentioned above. This will form the background for
  our discussion of compound data and data abstraction. As with
  compound procedures, the main issue to be addressed is that of
  abstraction as a technique for coping with complexity, and we will
  see how data abstraction enables us to erect suitable _abstraction
  barriers_ between different parts of a program.

  We will see that the key to forming compound data is that a
  programming language should provide some kind of "glue" so that data
  objects can be combined to form more complex data objects. There are
  many possible kinds of glue. Indeed, we will discover how to form
  compound data using no special "data" operations at all, but only
  procedures. This will further blur the distinction between
  "procedure" and "data", which was already becoming tenuous toward
  the end of chapter 1. We will also explore some conventional
  techniques for representing sequences and trees. One key idea in
  dealing with compound data is the nothion of _closure_ -- that the
  glue we use for combining data objects should allow us to combine
  not only primitive data objects, but compound data objects as
  well. Another key idea is that compound data objects can serve as
  _conventional interfaces_ for combining program modules in
  mix-and-match ways. We illustrate some of these ideas by presenting
  a simple graphics language that exploits closure.

  We will then augment the representational power of our language by
  introducing _symbolic expressions_ -- data whose elementary parts
  can be arbitrary symbols rather than only numbers. We explore
  various alternatives for representing sets of objects. We will find
  that, just as a given numerical function can be computed by many
  different computational processes, there are many ways in which a
  given data structure can be represented in terms of simpler objects,
  and the choice of representation can have significant impact on the
  time and space requirements of processes that manipulate the
  data. We will investigate these ideas in the context of symbolic
  differentiation, the representation of sets, and the encoding of
  information.

  Next we will take up the problem of working with data that may be
  represented differently by different parts of the program. This
  leads to the need to implement _generic operations_, which must
  handle many different types of data. Maintaining modularity in the
  presence of generic operations requires more powerful abstraction
  barriers than can be erected with simple data abstraction alone. In
  particular, we introduce _data-directed programming_ as a technique
  that allows individual data representations to be designed in
  isolation and then combined _additively_ (i.e. without
  modification). To illustrate the power of this approach to system
  design, we close the chapter by applying what we have learned to the
  implementation of a package for performing symbolic arithmetic on
  polynomials, in which the coefficients of the polynomials can be
  integers, rational numbers, complex numbers, and even other
  polynomials.

** 2.1 Introduction to Data Abstraction

   In section 1.1.8, we noted that a procedure used as an element in
   creating a more complex procedure could be regarded not only as a
   collection of particular operations but also as a procedural
   abstraction. That is, the details of how the procedure was
   implemented could be suppressed, and the particular procedure
   itself could be replaced by any other procedure with the same
   overall behavior. In other words, we could make an abstraction that
   would separate the way the procedure would be used from the details
   of how the procedure would be implemented in terms of more
   primitive procedures. The analogous notion for compound data is
   called _data abstraction_. Data abstraction is a methodology that
   enables us to isolate how a compound data object is used from the
   details of how it is constructed from more primitive data objects.

   The basic idea of data abstraction is to structure the programs
   that are to use compound data objects so that they operate on
   "abstract data." That is, our programs should use data in such a
   way as to make no assumptions about the data that are not strictly
   necessary for performing the task at hand. At the same time, a
   "concrete" data representation is defined independent of the
   programs that use the data. The interface between these two parts
   of our system will be a set of procedures, called _selectors_ and
   _constructors_, that implement the abstract data in terms of
   concrete representation. To illustrate this technique, we will
   consider how to design a set of procedures for manipulating
   rational numbers.

*** 2.1.1 Example: Arithmetic Operations for Rational Numbers
    
    Suppose we want to do arithmetic with rational numbers. We want to
    be able to add, subtract, multiply, and divide them and to test
    whether two rational numbers are equal. 

    Let us begin by assuming that we already have a way of
    constructing a rational number from a numerator and a
    denominator. We also assume that, given a rational number, we have
    a way of extracting (or selecting) its numerator and its
    denominator. Let us further assume that the constructor and
    selectors are available as procedures:

    - (make-rat <n> <d>) returns the rational number whose numerator
      is the integer <n> and whose denominator is the integer <d>.
    - (numer <x>) returns the numerator of the rational number <x>.
    - (denom <x>) returns the denominator of the rational number <x>.

    
    We are using here a powerful strategy of synthesis: _wishful
    thinking_. We haven't yet said how a rational number is
    represented, or how the procedures numer, denom, and make-rat
    should be implemented. Even so, if we did have these three
    procedures, we could then add, subtract, multiply, divide, and
    test equality by using the following relations:

    \begin{rats}
    \frac{n_1}{d_1} + \frac{n_{2}}{d_{2}} = \frac{n_1d_2 + n_2d_1}{d_1d_2}
    
    \frac{n_1}{d_1} - \frac{n_{2}}{d_{2}} = \frac{n_1d_2 - n_2d_1}{d_1d_2}

    \frac{n_{1}}{d_{1}} * \frac{n_{2}}{d_{2}} = \frac{n_{1}n_{2}}{d_{1}d_{2}}

    \frac{n_{1}/d_{1}}{n_{2}/d_{2}} = \frac{n_{1}d_{2}}{d_{1}n_{2}}

    \frac{n_{1}}{d_{1}} = \frac{n_{2}}{d_{2}} if and only if n_{1}d_{2} = n_{2}d_{1}
    \end{rats}

    We can express these rules as procedures:

    #+BEGIN_SRC scheme
    (define (add-rat x y)
     (make-rat (+ (* (numer x) (denom y))
                  (* (numer y) (denom x)))
               (* (denom x) (denom y))))
    (define (sub-rat x y)
     (make-rat (- (* (numer x) (denom y))
                  (* (numer y) (denom x)))
               (* (denom x) (denom y))))

    (define (mul-rat x y)
     (make-rat (* (numer x) (numer y))
               (* (denom x) (denom y))))

    (define (div-rat x y)
     (make-rat (* (numer x) (denom y))
               (* (denom x) (numer y))))
    (define (equal-rat? x y)
     (= (* (numer x) (denom y))
        (* (numer y) (denom x))))
    #+END_SRC

    Now we have the operations on rational numbers defined in terms of
    the selector and constructor procedures numer, denom, and
    make-rat. But we haven't yet defined these. What we need is some
    way to glue together a numerator and a denominator to form a
    rational number.

**** Pairs
     To enable us to implement the concrete level of our data
     abstraction, our language provides a compound structure called a
     pair, which can be constructed with the primitive procedure
     cons. This procedure takes two arguments and returns a compound
     data object that contains the two arguments as parts. Given a
     pair, we can extract the parts using the primitive procedures car
     and cdr. Thus, we can use cons, car, and cdr as follows:

     #+BEGIN_SRC
     (define x (cons 1 2))
     (car x)
     1
     (cdr x)
     2
     #+END_SRC

     Notice that a pair is a data object that can be given a name and
     manipulated, just like a primitive data object. Moreover, cons
     can be used to form pairs whose elements are pairs and so on:

     #+BEGIN_SRC scheme
     (define x (cons 1 2))
     (define y (cons 3 4))
     (define z (cons x y))
     (car (car z))
     1
     (car (cdr z))
     3
     #+END_SRC

     In section 2.2 we will see how this ability to combine pairs
     means that pairs can be used as general-purpose building blocks
     to create all sorts of complex data structures. The single
     compound-data primitive _pair_, implemented by the procedures
     cons, car, and cdr, is the only glue we need. Data objects
     constructed from pairs are called _list-structured_ data.

**** Representing rational numbers

     Pairs offer a natural way to complete the rational-number
     system. Simply represent a rational number as a pair fo two
     integers: a numerator and a denominator. Then make-rat, numer,
     and denom are readily implemented as follows:

     #+BEGIN_SRC scheme
     (define (make-rat n d) (cons n d))
     (define (numer x) (car x))
     (define (denom x) (cdr x))
     #+END_SRC

     Also, in order to display the results of our computations, we can
     print rational numbers by printing the numerator, a slash, and
     the denominator:

     #+BEGIN_SRC scheme
     (define (print-rat x)
      (newline)
      (display (numer x))
      (display "/")
      (display (denom x)))
     #+END_SRC

     Now we can try our rational-number procedures:

     #+BEGIN_SRC scheme
     1 (user) => (print-rat (add-rat one-half one-third))
     
     5/6
     ;Unspecified return value
     
     1 (user) => (print-rat (add-rat one-third one-third))
     
     6/9
     ;Unspecified return value
     
     1 (user) => (print-rat (add-rat one-half one-third))
     
     5/6
     ;Unspecified return value
     
     1 (user) => (print-rat one-half)
     
     1/2
     ;Unspecified return value
     
     1 (user) => (print-rat one-third)
     
     1/3
     ;Unspecified return value
     
     1 (user) => (print-rat (mul-rat one-half one-third))
     
     1/6
     ;Unspecified return value
     
     1 (user) => (print-rat (add-rat one-third one-half))
     
     5/6
     ;Unspecified return value
     
     1 (user) => 
     #+END_SRC

     
     As the final example shows, our rational number implementation
     does not reduce rational numbers to lowest terms. We can remedy
     this by changing make-rat. If we have a gcd procedure like the
     one in section 1.2.5 that produces the greatest common divisor of
     two integers, we can use gcd to reduce the numerator and the
     denominator to lowest terms before constructing the pair:

     #+BEGIN_SRC scheme
     (define (make-rat n d)
      (let ((g (gcd n d)))
       (cons (/ n g) (/ d g))))
     #+END_SRC

     Now we have

     #+BEGIN_SRC scheme
     (print-rat (add-rat one-third one-third))
     2/3
     #+END_SRC

     as desired. This modification was accomplished by changing the
     constructor make-rat without changing any of the procedures (such
     as add-rat and mul-rat) that implement the actual operations.

     - Exercise 2.1. Define a better version of make-rat that handles
       both positive and negative arguments. Make-rat should normalize
       the sign so that if the rational number is positive, both the
       numerator and denominator are positive, and if the rational
       number is negative, only the numerator is negative.

       #+BEGIN_SRC scheme
       (define (make-rat n d)
        (define (make-rat-gcd n d) 
         (let ((g (gcd n d)))
          (cons (/ n g) (/ d g))))
        (cond ((< (* n d) 0) (make-rat-gcd (* -1 (abs n)) (abs d)))
              (else (make-rat-gcd (abs n) (abs d)))))
       #+END_SRC

*** 2.1.2 Abstraction Barriers

    Before continuing with more examples of compound data and data
    abstraction, let us consider some of the issues raised by the
    rational-number example. We defined the rational-number operations
    in terms of a constructor make-rat and selectors numer and
    denom. In general, the underlying idea of data abstraction is to
    identify for each type of data object a basic set of operations in
    terms of which all manipulations of data objects of that type will
    be expressed, and then to use only those operations in
    manipulating the data.

    We can envision the structure of the rational-number system as
    shown in figure 2.1. The horizontal lines represent _abstraction
    barriers_ that isolate different "levels" of the system. 
     

    

    
  
*** 2.1.4 Extended Exercise: Interval Arithmetic
    Alyssa P. Hacker is designing a system to help people solve
    engineering problems. One feature she wants to provide in her
    system is the ability to manipulate inexact quantities (such as
    measured parameters of physical devices) with known precision, so
    that when computations are done with such approximate quantities
    the results will be numbers of known precision.

    Electrical engineers will be using Alyssa's system to compute
    electrical quantities. It is sometimes necessary for them to
    compute the value of a parallel equivalent resistance R_p of two
    resistors R_1 and R_2 using the formula

    \begin{parallel_resistors}
    R_{p} = \frac{1}{\frac{1}{R_{1}} + \frac{1}{R_2}}
    \end{parallel_resistors}

    Resistance values are usually known only up to some tolerance
    guaranteed by the manufacturer of the resistor. For example, if
    you buy a resistor labeled "6.8 ohms with 10% tolerance" you can
    only be sure that the resistor has a resistance between 6.8 - 0.68
    = 6.12 and 6.8 + 0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10%
    resistor in parallel with a 4.7-ohm 5% resistor, the resistance of
    the combination can range from about 2.58 ohms (if the two
    resistors are at the lower bounds) to about 2.97 ohms (if the two
    resistors are at the upper bounds).

    Alyssa's idea is to implement "interval arithmetic" as a set of
    arithmetic operations for combining "intervals" (objects that
    represent the range of possible values of an inexact
    quantity). The result of adding, subtracting, multiplying, or
    dividing two intervals is itself an interval, representing the
    range of the result.

    Alyssa postulates the existence of an abstract object called an
    "interval" that has two endpoints: a lower bound and an upper
    bound. She also presumes that, given the endpoints of an interval,
    she can construct the interval using the data constructor
    make-interval. Alyssa first writes a procedure for adding two
    intervals. She reasons that the minimum value the sum could be is
    the sum of two lower bounds and the maximum value it could be is
    the sum of the two upper bounds:

    #+BEGIN_SRC scheme
    (define (add-interval x y)
     (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))
    #+END_SRC

    Alyssa also works out the product of two intervals by finding the
    minimum and the maximum of the products of the bounds and using
    them as the bounds of the resulting interval. (Min and max are
    primitives that find the minimum or maximum of any number of
    arguments.)

    #+BEGIN_SRC scheme
    (define (mul-interval x y)
     (let ((p1 (* (lower-bound x) (lower-bound y)))
           (p2 (* (lower-bound x) (upper-bound y)))
           (p3 (* (upper-bound x) (lower-bound y)))
           (p4 (* (upper-bound x) (upper-bound y))))
     (make-interval (min p1 p2 p3 p4)
                    (max p1 p2 p3 p4))))
    #+END_SRC

    To divide two intervals, Alyssa multiplies the first by the
    reciprocal of the second. Note that the bounds of the reciprocal
    interval are the reciprocal of the upper bound and the reciprocal
    of the lower bound, in that order.

    #+BEGIN_SRC scheme
    (define (div-interval x y)
     (mul-interval x
                   (make-interval (/ 1.0 (upper-bound y))
                                  (/ 1.0 (lower-bound y)))))
    #+END_SRC

    - Exercise 2.7 Alyssa's program is incomplete because she has not
      specified the implementation of the interval abstraction. Here
      is a definition of the interval constructor:

      #+BEGIN_SRC scheme
      (define (make-interval a b) (cons a b))
      #+END_SRC

      Define selectors upper-bound and lower-bound to complete the
      implementation.

      #+BEGIN_SRC scheme
      (define (upper-bound interval) (cdr interval))
      (define (lower-bound interval) (car interval))
      #+END_SRC

    - Exercise 2.8. Using reasoning analogous to Alyssa's, describe
      how the difference of two intervals may be computed. Define 
      corresponding subtraction procedure, called sub-interval.

      If we think of the difference between two intervals as an
      interval describing the smallest and largest difference between
      the two, then the smallest difference is actually the difference
      between the closest two peices -- probably the upper of one and
      the lower of the other -- and the largest is the difference
      between the furthest two. 

      #+BEGIN_SRC scheme
      (define (sub-interval x y)
       (let ((d1 (- (lower-bound x) (upper-bound y)))
             (d2 (- (lower-bound x) (lower-bound y)))
             (d3 (- (upper-bound x) (upper-bound y)))
             (d4 (- (upper-bound x) (lower-bound y))))
        (make-interval (min d1 d2 d3 d4)
                       (max d1 d2 d3 d4))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (sub-interval x y)
       (make-interval (- (lower-bound x) (upper-bound y))
                      (- (upper-bound x) (lower-bound y))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (print-interval i)
       (newline)
       (display "[ ")
       (display (lower-bound i))
       (display ", ")
       (display (upper-bound i))
       (display " ]"))
      #+END_SRC

    - Exercise 2.9. The _width_ of an interval is half of the
      difference between its upper and lower bounds. The width is a
      measure of the uncertainty of the number specified by the
      interval. For some arithmetic operations the width of the result
      of combining two intervals is a function only of the widths of
      the argument intervals. Show that the width of the sum (or
      difference) of two intervals is a function only of the widths of
      the intervals being added (or subtracted). Give examples to show
      that this is not true for multiplication or division.

      In addition if we have two intervals:
      a = [x, y]
      b =  [t, u]
      the sum is = [x + t, y + u]
      And the width is therefore:
      ((y + u) - (x + t)) / 2

      The width of a is:
      (y - x) / 2
      and the width of b is:
      (u - t) / 2

      We can just add the two widths without reference to anything
      else and get:
      ((y + u) - (x + t)) / 2

      And we know what the width is even without knowing the actual
      interval; just by adding the two. Subtraction is nearly the
      same. 

      a = [x, y]
      b = [t, u]
      
      The difference is always
      [x - t, y - u]

      THe width is therefore
      ((x - t) - (y - u)) / 2

      While the widths of the intervals are
      (x - t) / 2
      and 
      (y - u) / 2

      So all we do is subtract w_b from w_a and get the same result
      for width.
      
      But for multiplication 

      a = [x, y]
      b = [t, u]

      There are actually different cases here depending on which
      numbers are negative.

      There are many different cases here. If x and t are both
      negative and y and u are positive, the lower bound will be the
      most negative number of the pair x * u, t * y. 

      [x * u, t * y]
      [t * y, x * u]

      This will result in two different calculations for the width,
      just on one case. Not only that, but if we take only one case
      and try to calculate the resulting width from the inputs, it's
      impossible to get.
      
      One width case:
      ((t * y) - (x * u)) / 2
      
      The input widths:
      (y - x) / 2
      (u - t) / 2

      There is no way to take these input widths and get the output
      width, even for this one case.

    - Exercise 2.10. Ben Bitdiddle, an expert systems programmer,
      looks over Alyssa's shoulder and comments that it is not clear
      what it means to divide by an interval that spans zero. Modify
      Alyssa's code to check for this condition and signal an error if
      it occurs. 

      #+BEGIN_SRC scheme
      (define (div-interval x y)
       (cond 
        ((and (< (lower-bound y) 0)
              (> (upper-bound y) 0))         
         (error "Divide by an interval spanning 0."))
        (else
         (mul-interval x
                       (make-interval (/ 1.0 (upper-bound y))
                                      (/ 1.0 (lower-bound y)))))))
      #+END_SRC

    - Exercise 2.11. In passing, Ben also cryptically comments: "By
      testing the signs of the endpoints of the intervals, it is
      possible to break mul-interval into nine cases, only one of
      which requires more than two multiplications." Rewrite this
      program using Ben's suggestion.

      #+BEGIN_SRC scheme
      (define (mul-interval x y)
       (define (interval-below-zero i)
        (and (< (lower-bound i) 0)
             (<= (upper-bound i) 0)))
       (define (interval-zero i)
        (and (= (lower-bound i) 0)
             (= (upper-bound i) 0)))
       (define (interval-above-zero i)
        (and (>= (lower-bound i) 0)
             (> (upper-bound i) 0)))
       (define (interval-spans-zero i)
        (and (< (lower-bound i) 0)
             (> (upper-bound i) 0)))
       (cond
        ((or (interval-zero x)
             (interval-zero y))
         (make-interval 0 0))
        ((and (interval-above-zero x)
              (interval-above-zero y))
         (make-interval
          (* (lower-bound x) (lower-bound y))
          (* (upper-bound x) (upper-bound y))))
        ((and (interval-below-zero x)
              (interval-below-zero y))
         (make-interval
          (* (upper-bound x) (upper-bound y))
          (* (lower-bound x) (lower-bound y))))
        ((and (interval-spans-zero x)
              (interval-above-zero y))
         (make-interval
          (* (lower-bound x) (upper-bound y))
          (* (upper-bound x) (upper-bound y))))
        ((and (interval-above-zero x)
              (interval-spans-zero y))
         (make-interval
          (* (upper-bound x) (lower-bound y))
          (* (upper-bound x) (upper-bound y))))
        ((and (interval-below-zero x)
              (interval-above-zero y))
         (make-interval
          (* (lower-bound x) (upper-bound y))
          (* (upper-bound x) (lower-bound y))))
        ((and (interval-above-zero x)
              (interval-below-zero y))
         (make-interval
          (* (upper-bound x) (lower-bound y))
          (* (lower-bound x) (upper-bound y))))
        ((and (interval-spans-zero y)
              (interval-below-zero x))
         (make-interval (* (lower-bound x) (upper-bound y))
                        (* (lower-bound x) (lower-bound y))))
        ((and (interval-spans-zero x)
              (interval-below-zero y))
         (make-interval (* (lower-bound y) (upper-bound x))
                        (* (lower-bound x) (lower-bound y))))
        ((and (interval-spans-zero x)
              (interval-spans-zero y))
         (make-interval (min (* (lower-bound x) (upper-bound y))
                             (* (lower-bound y) (upper-bound x)))
                        (max (* (upper-bound x) (upper-bound y))
                             (* (lower-bound x) (lower-bound y)))))))
      #+END_SRC

      
    After debugging her program, Alyssa shows it to a potential user,
    who complains that her program solves the wrong problem. He wants
    a program that can deal with numbers represented as a center value
    and an additive tolerance; for example, he wants to work with
    intervals such as 3.5 +/- 0.15 rather than [3.35, 3.65]. Alyssa
    returns to her desk and fixes this problem by supplying an
    alternate constructor and alternate selectors:

    #+BEGIN_SRC scheme
    (define (make-center-width c w)
     (make-interval (- c w) (+ c w)))
    (define (center i)
     (/ (+ (lower-bound i) (upper-bound i)) 2))
    (define (width i)
     (/ (- (upper-bound i) (lower-bound i)) 2))
    #+END_SRC

    Unfortunately, most of Alyssa's users are engineers. Real
    engineering situations usually involve measurements with only a
    small uncertainty, measured as the ratio of the width of the
    interval to the midpoint of the interval. Engineers usually
    specify percentage tolerances on the parameters of devices, as in
    the resistor specifications given earlier. 

    - Exercise 2.12. Define a constructor make-center-percent that
      takes a center and a percentage tolerance and produces the
      desired interval. You must also define a selector percent that
      produces the percentage tolerance for a given interval. The
      center selector is the same as the one shown above.

      #+BEGIN_SRC scheme
      (define (make-center-percent center percent)
       (let ((width (* center (/ percent 100.0))))
        (make-interval (- center width) (+ center width))))
      (define (width interval)
       (/ (- (upper-bound interal) (lower-bound interval)) 2))
      (define (interval-center interval)
       (- (upper-bound interval) (width interval)))
      #+END_SRC

    - Exercise 2.13. Show that under the assumption of small
      percentage tolerances there is a simple formula for the
      approximate percentage tolerance of the product of two intervals
      in terms of tolerances of the factors. You may simplify the
      problem by assuming that all numbers are positive. 

      You only have to add the two percentages to get the approximate
      new percentage tolerance; 1% + 1% =~ 2%. This only works because
      we assume that the multiplication of the two widths is a very
      small number that we then dismiss. The algebra should be done by hand.

    
    After considerable work, Alyssa P. Hacker delivers her finished
    system. Several years later, after she has forgotten all about it,
    she gets a frenzied call from an irate user, Lem E. Tweakit. It
    seems that Lem has noticed that the formula for parallel resistors
    can be written in two algebraically equivalent ways:

    \frac{R_{1}R_{2}}{R_{1} + R_{2}}

    and

    \frac{1}{1/R_{1} + 1/R_{2}}

    He has written the following two programs, each of which computes
    the parallel-resistors formula differently:

    #+BEGIN_SRC scheme
    (define (par1 r1 r2)
     (div-interval (mul-interval r1 r2)
                   (add-interval r1 r2)))
    (define (par2 r1 r2)
     (let ((one (make-interval 1 1)))
      (div-interval 
       one
       (add-interval (div-interval one r1)
                     (div-interval one r2)))))             
    #+END_SRC

    Lem complains that Alyssa's program gives different answers for
    the two ways of computing. This is a serious complaint.

    - Exercise 2.14. Demonstrate that Lem is right. Investigate the
      behavior of the system on a variety of arithmetic
      expressions. Make some intervals A and B, and use them in
      computing the expressions A/A and A/B. You will get the most
      insight by using intervals whose width is a small percentage of
      the center value. Examine the results of the computation in
      center-percent form (see exercise 2.12).

      #+BEGIN_SRC scheme
      1 (user) => (par2 (make-center-percent 3 1) (make-center-percent 4 2))
      
      ;Value 60: (1.6897532656023222 . 1.7387341772151899)
      
      1 (user) => (par1 (make-center-percent 3 1) (make-center-percent 4 2))
      
      ;Value 61: (1.63746835443038 . 1.794252539912917)
      #+END_SRC

      The second definition has a much tighter tolerance. Probably
      because division works with smaller intervals since it inverts
      the numbers before multiplying. Adding and multiplying both
      can't reduce tolerance but division can actually reduce
      tolerance. 

      #+BEGIN_SRC scheme
      (define (interval-percent-tol interval)
       (* 100.0 (/ (width interval) (interval-center interval))))
      (define (print-center-percent interval)
       (newline)
       (display "[ ")
       (display (interval-center interval))
       (display " +/- ")
       (display (interval-percent-tol interval))
       (display " ]"))
      (define A (make-center-percent 30 2))
      (define B (make-center-percent 15 1))
      (define C (make-center-percent 8 3))
      (define D (make-center-percent 5 2))
    
      (display "Add intervals")
      (print-center-percent (add-interval A B))
      (print-center-percent (add-interval A C))
      (print-center-percent (add-interval B C))
      (print-center-percent (add-interval D A))

      (newline)
      (display "Sub intervals")
      (print-center-percent (sub-interval A B))
      (print-center-percent (sub-interval B C))
      (print-center-percent (sub-interval C D))
      (print-center-percent (sub-interval A D))

      (newline) 
      (display "Mul intervals")
      (print-center-percent (mul-interval A B))
      (print-center-percent (mul-interval A C))
      (print-center-percent (mul-interval B C))
      (print-center-percent (mul-interval D A))
      
      (newline)
      (display "Div intervals")
      (print-center-percent (div-interval A B))
      (print-center-percent (div-interval A C))
      (print-center-percent (div-interval B C))
      (print-center-percent (div-interval D A)) 


      (newline) 
      (display "Compound mul/div")
      (print-center-percent (mul-interval A (div-interval A B)))
      (print-center-percent (div-interval A (mul-interval D C)))
      (print-center-percent (div-interval (mul-interval D C) D))
      

      (newline)
      (display "Compound add")
      (print-center-percent (add-interval A (add-interval D C)))
      #+END_SRC

      output:
      #+BEGIN_SRC scheme
      1 (user) => Add intervals
      ;Unspecified return value
      
      1 (user) => 
      [ 45. +/- 1.6666666666666667 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 38. +/- 2.2105263157894828 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 23. +/- 1.6956521739130461 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 35. +/- 2.000000000000008 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Unspecified return value
      
      1 (user) => Sub intervals
      ;Unspecified return value
      
      1 (user) => 
      [ 15. +/- 5.000000000000012 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 7. +/- 5.571428571428579 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 3. +/- 11.333333333333329 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 25. +/- 2.8000000000000114 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Unspecified return value
      
      1 (user) => Mul intervals
      ;Unspecified return value
      
      1 (user) => 
      [ 450.09000000000003 +/- 2.999400119976011 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 240.144 +/- 4.997001798920653 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 120.036 +/- 3.998800359892042 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 150.06 +/- 3.998400639744102 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Unspecified return value
      
      1 (user) => Div intervals
      ;Unspecified return value
      
      1 (user) => 
      [ 2.0006000600060005 +/- 2.9994001199760105 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 3.7556300670603546 +/- 4.997001798920656 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 1.877252026824142 +/- 3.998800359892036 ]
      ;Unspecified return value
      
      1 (user) => 
      [ .1668000533546752 +/- 3.998400639744098 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Unspecified return value
      
      1 (user) => Compound mul/div
      ;Unspecified return value
      
      1 (user) => 
      [ 60.05400540054005 +/- 4.99640287769785 ]
      ;Unspecified return value
      
      1 (user) => 
      [ .7521775600441357 +/- 6.990015974440896 ]
      ;Unspecified return value
      
      1 (user) => 
      [ 8.016006402561025 +/- 6.990015974440879 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Unspecified return value
      
      1 (user) => Compound add
      ;Unspecified return value
      
      1 (user) => 
      [ 43. +/- 2.1860465116279015 ]
      ;Unspecified return value
      
      1 (user) => 
      ;Value: #f
      
      1 (user) => 
      #+END_SRC
 
      The reason why the par2 algorithm is more efficent is that
      although it has more operations, it never has the two input
      values in a single mul/div operation together; they always are
      with 'one' which we defined earlier and has ZERO
      TOLERANCE. Generally speaking an addition or subtraction averages the
      tolerances and a division or multiplication adds the
      tolerances. Inversion with dividing one by a value does not
      introduce extra tolerance into the system and acts as a no-op as
      far as tolerance is concerned. So our equations become more
      accurate if we use more tolerant terms as little as possible and
      use constants as much as possible. It also helps if we avoid
      compound multiplications or divisions.

    - Exercise 2.15. Eva Lu Ator, another user, has also noticed the
      different intervals computed by different but algebraically
      equivalent expressions. She says that a formula to compute with
      intervals using Alyssa's system will produce tighter error
      bounds if it can be written in such a form that no variable that
      represents an uncertain number is repeated. Thus, she says, par2
      is a "better" program for parallel resistances than par1. Is she
      right? Why?

      Yes, since (make-interval 1 1) has zero tolerance, putting it in
      a divison introduces no more tolerance to anything. Any time you
      put a variable that has tolerance in an expression, it can at
      best keep the tolerance the same but probably make it worse if
      any kind of multiplication is happening. So relying on
      zero-tolerance constants and keeping the number of repeated
      terms to a minimum helps.

    - Exercise 2.16. Explain, in general, why equivalent algebraic
      expressions may lead to different answers. Can you devise an
      interval-arithmetic package that does not have this shortcoming,
      or is this task impossible?

      The order of operations matters; technically any fraction can be
      made indefinitely long by multiplying it by A/A or something,
      lots of expressions are algebraically equivalent that require
      more steps by the computer to evaluate. If we introduce extra
      steps, more error bounds are going to creep in. 

      It's probably possible to in some circumstances automatically
      reduce error bounds by lazy evaluation; if you stack up
      operations into some data structure and then reorder the
      operations or find ways to algebraically reduce the number of
      terms in the expression you may benefit.

** 2.2 Hierarchical Data and the Closure property
   As we have seen, pairs provide a primitive "glue" that we can use
   to construct compound data objects. Figure 2.2 shows a standard way
   to visualize a pair -- in this case, the pair formed by (cons 1
   2). In this representation, which is called _box-and-pointer
   notation_, each object is shown as a _pointer_ to a box. The box
   for a primitive object contains a representation of the object. For
   example, the box for a number contains a numeral. The box for a
   pair is actually a double box, the left part containing (a pointer
   to) the car of the pair and the right containing the CDR.

   We have already seen that cons can be used to combine not only
   numbers but pairs as well. (You made use of this fact, or should
   have, in doing exercises 2.2 and 2.3.) As a consequence, pairs
   provide a universal building block from which we can construct all
   sorts of data structures. Figure 2.3 shows two ways to use pairs to
   combine the numbers 1, 2, 3, and 4.

   The ability to create pairs whose elements are pairs is the essence
   of lists structure's importance as a representational tool. We
   refer to this ability as the _closure property_ of cons. In
   general, an operation for combining data objects satisfies the
   closure property if the results of combining things with that
   operation can themselves be combined using the same
   operation. Closure is the key to power in any means of combination
   because it permits us to create _hierarchical_ structures --
   structures made up of parts, which themselves are made up of parts,
   and so on.

   From the outset of chapter 1, we've made essential use of closure
   in dealing with procedures, because all but the very simplest
   programs rely on the fact that the elements of a combination can
   themselves be combinations. In this section, we take up the
   consequences of closure for compound data. We describe some
   conventional techniques for using pairs to represent sequences and
   trees, and we exhibit a graphics language that illustrates closure
   in a vivid way.

*** 2.2.1. Representing Sequences
    One of the useful structures we can build with pairs is a
    _sequence_ -- an ordered collection of data objects. There are, of
    course, many ways to represent sequences in terms of pairs. One
    particularly striaghtforward representation is illustrated in
    figure 2.4, where the sequence 1, 2, 3, 4 is represented as a
    chain of pairs. The car of each pair is the corresponding item in
    the chain, and the cdr of the pair is the next pair in the
    chain. The cdr of the final pair signals the end of the sequence
    by pointing to a distinguished value that is not a pair,
    represented in box-and-pointer diagrams as a diagonal line and in
    programs as the value of the variable nil. The entire sequence is
    constructed by nested cons operations:

    #+BEGIN_SRC scheme
    (cons 1
          (cons 2
                (cons 3
                      (cons 4 nil))))
    #+END_SRC

    Such a sequence of pairs, formed by nested conses, is called a
    _list_, and Scheme provides a primitive called list to help in
    constructing lists. The above sequence could be produced by (list
    1 2 3 4). In general,

    #+BEGIN_SRC scheme
    (list <a1> <a2> ... <an>)
    #+END_SRC

    is equivalent to

    #+BEGIN_SRC scheme
    (cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))
    #+END_SRC

    Lisp systems conventionally print lists by printing the sequence
    of elements, enclosed in parentheses. Thus, the data object in
    figure 2.4 is printed as (1 2 3 4):

    
**** List operations
     The use of pairs to represent sequences of elements as lists is
     accompanied by conventional programming techniques for
     manipulating lists by successively "cdring down" the lists. For
     example, the procedure list-ref takes as arguments a list and a
     number _n_ and returns the _n_th item of the list. It is
     customary to number the elements of the list beginning
     with 0. The method for computing list-ref is the following:

     - For n = 0, list-ref should return the car of the list.
     - Otherwise, list-ref should return the (n-1)st item of the cdr
       of the list.

     #+BEGIN_SRC scheme
     (define (list-ref items n)
      (if (= n 0)
          (car items)
          (list-ref (cdr items) (- n 1))))
     (define squares (list 1 4 9 16 25))
     (list-ref squares 3)
     16
     #+END_SRC

     Often we cdr down the whole list. To aid in this, Scheme includes
     a primitive predicate null?, which tests whether its argument is
     the empty list. The procedure length, which returns the number of
     items in a list, illustrates this typical pattern of use:

     #+BEGIN_SRC scheme
     (define (length items)
      (if (null? items)
          0
          (+ 1 (length (cdr items)))))
     (define odds (list 1 3 5 7))
     (length odds)
     4
     #+END_SRC

     The length procedure implements a simple recursive plan. The
     reduction step is:

     - The length of any list is 1 plus the length of the cdr of the
       list.
       
       
     This is applied successively until we reach the base case:

     - The length of the empty list is 0.

       
     We could also compute length in an iterative style:

     #+BEGIN_SRC scheme
     (define (length items)
      (define (length-iter a count)
       (if (null? a)
           count
           (length-iter (cdr a) (+ 1 count))))
      (length-iter items 0))
     #+END_SRC

     Another conventional programming technique is to "cons up" an
     answer list while cdring down a list, as in the procedure append,
     which takes two lists as arguments and combines the elements to
     make a new list:

     #+BEGIN_SRC scheme
     (append squares odds)
     (1 4 9 16 25 1 3 5 7)
     (append odds squares)
     (1 3 5 7 1 4 9 16 25)
     #+END_SRC

     Append is also implemented using a recursive plan. To append
     lists list1 and list2, do the following:

     - If list1 is the empty list, then the result is just list2.
     - Otherwise, append teh cdr of list1 and list2, and ocns the car
       of list1 onto the result:
       
       
     #+BEGIN_SRC scheme
     (define (append list1 list2)
      (if (null? list1)
          list2
          (cons (car list1) (append (cdr list1) list2))))
     #+END_SRC

     - Exercise 2.17. Define a procedure last-pair that returns the
       list that contains only the last element of a given (nonempty)
       list:

       #+BEGIN_SRC scheme
       (last-pair (list 23 72 149 34))
       (34)
       #+END_SRC

     - Exercise 2.18. Define a procedure reverse that takes a list as
       argument and returns a list of the same elements in the reverse
       order:

       #+BEGIN_SRC scheme
       (reverse (list 1 4 9 16 25))
       (25 16 9 4 1)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (reverse items)
        (cond ((null? items) '())
              (else (append (reverse (cdr items)) (list (car items))))))
       #+END_SRC

     - Exercise 2.19. Consider the change-counting program of section
       1.2.2. It would be nicer to be able to easily change the
       currency used by the program, so that we could compute the
       number of ways to change a British pound, for example. As the
       program is written, the knowledge of the currency is
       distributed partly into the procedure first-denomination and
       partly into the procedure count-change (which knows that there
       are five kidns of U.S. coins). It would be nicer to be able to
       supply a list of coins to be sued for making change.

       We want to rewrite the procedure cc so that its second argument
       is a list of values of the coins to use rather than an integer
       specifying which coins to use. We could then have lists that
       defined each kind of currency:

       #+BEGIN_SRC scheme
       (define us-coins (list 50 25 10 5 1))
       (define uk-coins (list 100 50 20 10 5 2 1 0.5))
       #+END_SRC

       We could then call cc as follows:

       #+BEGIN_SRC scheme
       (cc 100 us-coins)
       292
       #+END_SRC

       To do this will require changing the program cc somewhat. It
       will still have the same form, but it will access its second
       argument differently, as follows:

       #+BEGIN_SRC scheme
       (define (cc amount coin-values)
        (cond ((= amount 0) 1)
              ((or (< amount 0) (no-more? coin-values)) 0)
              (else
               (+ (cc amount
                      (except-first-denomination coin-values))
                  (cc (- amount
                         (first-denomination coin-values))
                      coin-values)))))
       #+END_SRC

       Define the procedures first-denomination,
       except-first-denomination, and no-more? in terms of primitive
       operations on list structures. Does the order of the list
       coin-values affect the answer produced by cc? Why or why not?

       #+BEGIN_SRC scheme
       (define (first-denomination coin-values)
        (car coin-values))
       (define (except-first-denomination coin-values)
        (cdr coin-values))
       (define no-more? null?)
       #+END_SRC

       The order does not appear to matter. No matter what order you
       do subtractions in, if you're subtracting some set of values,
       you end up going to zero with the same number of
       subtractions. So if you subtract fifty and twenty-five from 100
       to get 0, You can do:

       100 - 50 - 25 - 25 = 0
       100 - 50 - 50 = 0
       100 - 25 - 25 - 25 -25 = 0

       We can reorder this way:
       100 - 25 - 25 - 50 = 0
       for one of the subtractions. So if we ran cc with just 50 and
       25 and the value 100, it would do these:

       100 - 50 - 25 - 25 = 0
       100 - 50 - 50 = 0
       100 - 25 - 25 - 25 -25 = 0

       But if we ran it with 25 and 50, it would do these:
       100 - 25 - 25 - 50 = 0
       100 - 50 - 50 = 0
       100 - 25 - 25 - 25 -25 = 0

       but it's three either way because in counting change, order
       doesn't matter. So logically a correct program wouldn't change
       its answer, and cc doesn't. You can see from this clause:

       #+BEGIN_SRC scheme
       (else
        (+ (cc amount
               (except-first-denomination coin-values))
           (cc (- amount
                  (first-denomination coin-values))
               coin-values)))
       #+END_SRC

       Each denomination is taken into account in order and never
       revisted. That is, we subtract one denomination until we can't;
       and then move on to other denominations. In this way it doesn't
       matter what order the list is in; because the first clause
       looks over the entire list without first subtracting anything
       from the total amount.

     - Exercise 2.20. The procedures +, *, and list take arbitrary
       numbers of arguments. One way to define such procedures is to
       use define with _dotted-tail notation_. In a procedure
       definition, a parameter list that has a dot before the last
       parameter name indicates that, when the procedure is called,
       the initial parameters (if any) will have as values the initial
       arguments, as usual, but the final parameter's value will be a
       _list_ of any remaining arguments. For instance, given the
       definition

       #+BEGIN_SRC scheme
       (define (f x y . z) <body>)
       #+END_SRC
    
       the procedure f can be called with two or more arguments. If we
       evaluate

       #+BEGIN_SRC scheme
       (f 1 2 3 4 5 6)
       #+END_SRC

       then in the body of f, x will be 1, y will be 2, and z will be
       the list (3 4 5 6). Given the definition

       (define (g . w) <body>)

       the procedure g can be called with zero or more arguments. If
       we evaluate 

       (g 1 2 3 4 5 6)

       Then in the body of g, w will be the list (1 2 3 4 5 6).

       Use this notation to write a procedure same-parity that takes
       one or more integers and returns a list of all the arguments
       that have the same even-odd parity as the first argument. For
       example,

       #+BEGIN_SRC scheme
       (same-parity 1 2 3 4 5 6 7)
       (1 3 5 7)
       (same-parity 2 3 4 5 6 7)
       (2 4 6)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (same-parity . items)
        (define (same-parity-iter first rest result)
         (cond ((null? rest) result)
               ((or (and (odd? first) (odd? (car rest)))
                    (and (even? first) (even? (car rest))))
                (same-parity-iter first (cdr rest) (cons (car rest) result)))
               (else
                (same-parity-iter first (cdr rest) result))))
         (reverse (same-parity-iter (car items) (cdr items) (list (car items)))))
       #+END_SRC

**** Mapping over lists
     One extremely useful operation is to apply some transformation to
     each element in a list and generate the list of results. For
     instance, the following procedure scales each number in a list by
     a given factor:

     #+BEGIN_SRC scheme
     (define (scale-list items factor)
      (if (null? items)
          '()
          (cons (* (car items) factor)
                (scale-list (cdr items) factor))))
     (scale-list (list 1 2 3 4 5) 10)
     (10 20 30 40 50)
     #+END_SRC

     We can abstract this general idea and capture it as a common
     pattern expressed as a higher-order procedure, just as in section
     1.3. The higher-order procedure here is called map. Map takes as
     arguments a procedure of one argument and a list, and returns a
     list of the results produced by applying the procedure to each
     element in the list:

     #+BEGIN_SRC scheme
     (define (map proc items)
      (if (null? items)
          '()
          (cons (proc (car items))
                (map proc (cdr items)))))
     (map abs (list -10 2.5 -11.6 17))
     (10 2.5 11.6 17)
     (map (lambda (x) (* x x))
          (list 1 2 3 4))
     (1 4 9 6)
     #+END_SRC

     Now we can give a new definition of scale-list in terms of map:

     #+BEGIN_SRC scheme
     (define (scale-list items factor)
      (map (lambda (x) (* x factor))
           items))
     #+END_SRC

     map is an important construct, not only because it captures a
     common pattern, but because it establishes a higher level of
     abstraction in dealing with lists. In the original definition of
     scale-list, the recursive structure of the program draws
     attention to the element-by-element processing of the
     list. Defining scale-list in terms of map suppresses that level
     of detail and emphasizes that scaling transforms a list of
     elements to a list of results. The difference between the two
     definitions is not that the computer is performing a different
     process (it isn't) but that we think about the process
     differently. In effect, map helps establish an abtraction barrier
     that isolates the implementation of procedures that transform
     lists from the details of how the elements of the list are
     extracted and combined. Like the barriers shown in figure 2.1,
     this abstraction gives us the flexibility to change the low-level
     details of how sequences are implemented, while preserving the
     conceptual framework of operations that transform sequences to
     sequences. Section 2.2.3 expands on this use of sequences as a
     framework for organizing programs.

     - Exercise 2.21. The procedure square-list takes a list of
       numbers as argument and returns a list of squares of those
       numbers.

       #+BEGIN_SRC scheme
       (square-list (list 1 2 3 4))
       (1 4 9 16)
       #+END_SRC

       Here are two different definitions of square-list. Complete
       both of them by filling in the missing expressions:

       #+BEGIN_SRC scheme
       (define (square-list items)
        (if (null? items)
            '()
            (cons <??> <??>)))
       (define (square-list items)
        (map <??> <??>))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (square-list items)
        (if (null? items)
            '()
            (cons (square (car items))
                  (square-list (cdr items)))))
       (define (square-list items)
        (map square items))
       #+END_SRC

     - Exercise 2.22. Louis Reasoner tries to rewrite the first
       square-list procedure of exercise 2.21 so that it evolves an
       iterative process:

       #+BEGIN_SRC scheme
       (define (square-list items)
        (define (iter things answer)
         (if (null? things)
             answer
             (iter (cdr things)
                   (cons (square (car things))
                          answer))))
        (iter items nil)) 
       #+END_SRC

       Unfortunately, defining square-list this way produces the
       answer list in the reverse order of the one desired. Why?

       Things are not consed in order. You build up the answer
       starting at the first element of the list and then cons on from
       there, meaning the first element becomes the last of the
       result.

       Louis then tries to fix his bug by interchanging the arguments
       to cons:

       #+BEGIN_SRC scheme
       (define (square-list items)
        (define (iter things answer)
         (if (null? things)
             answer
             (iter (cdr things)
                   (cons answer
                         (square (car things))))))
        (iter items nil))
       #+END_SRC
       
       This doesn't work either. Explain.

       cons lists only make sense if for every cons you cons an item
       to another cons cell. So the car can be anything but if the
       answer is going to be an intelligible list the second item must
       be either a list (a cons cell) or nil. The thing constructed
       here is not really a list in that sense; it's a bunch of cons
       cells where the cdr is an atomic item and the car is a list. So
       although you do actually get a result where 1 4 9 16 and 25
       appear when written in order, the actual data structure isn't
       interpretable as a list. Moreover, the only way to access the
       elements is by cdr, and so if you actually try to iterate it
       it's with cdr followed by car, and the items come off in
       reverse order.

     - Exercise 2.23. The procedure for-each is similar to map. It
       takes as arguments a procedure and a list of elements. However,
       rather than forming a list of the results, for-each just
       applies the procedure to each of the elements in turn, from
       left to right. The values returned by applying the procedure to
       the elements are not used at all -- for-each is used with
       procedures that perform an action, such as printing. For
       example,

       #+BEGIN_SRC scheme
       (for-each (lambda (x) (newline) (display x))
                 (list 57 321 88))
       ; (printed)
       57
       321
       88 
       #+END_SRC

       The value returned by the call to for-each (not illustrated
       above) can be something arbitrary, such as true. Given an
       implementation of for-each.

       #+BEGIN_SRC scheme
       (define (for-each proc items)
        (if (null? items) 
            true
            (and (proc (car items))
                 (for-each proc (cdr items)))))
       #+END_SRC

*** 2.2.2. Hierarchical Structures       
    The representation of sequences in terms of lists generalizes
    naturally to represent sequences whose elements may themselves be
    sequences. For example, we can regard the object ((1 2) 3 4)
    constructed by

    (cons (list 1 2) (list 3 4))

    as a list of three items, the first of which is itself a list, (1
    2). Indeed, this is suggested by the form in which the result is
    printed by the interpreter. Figure 2.5 shows the representation of
    this structure in terms of pairs.

    Another way to think of sequences whose elements are sequences is
    as _trees_. The elements of the sequence are the branches of the
    tree, and elements that are themselves sequences are
    subtrees. Figure 2.6 shows the structure in figure 2.5 viewed as a
    tree.

    Recursion is a natural tool for dealing with tree structures,
    since we can often reduce operations on trees to operations on
    their branches, which reduce in turn to operations on the branches
    of the branches, and so on, until we reach the leaves of the
    tree. As an example, compare the length procedure of section 2.2.1
    with the count-leaves procedure, which returns the total number of
    leaves of a tree:

    #+BEGIN_SRC scheme
    (define x (cons (list 1 2) (list 3 4)))
    (length x)
    3
    (count-leaves x)
    4
    (list x x)
    (((1 2) 3 4) ((1 2) 3 4))
    (length (list x x))
    2
    (count-leaves (list x x))
    8
    #+END_SRC

    To implement count-leaves, recall the recursive plan for computing
    length:

    - Length of a list x is 1 plus length of the cdr of x.
    - Length of the empty list is 0.

    
    Count-leaves is similar. The value for the empty list is the same:

    - Count-leaves of the empty list is 0.

     
    But in the reduction step, where we strip off the car of the list,
    we must take into account that the car may itself be a tree whose
    leaves we need to count. Thus, the appropriate reduction step is

    - Count-leaves of a tree x is count-leaves of the car of x plus
      count-leaves of the cdr of x.

      
    Finally, by taking cars we reach actual leaves, so we need another
    base case:

    - Count-leaves of a leaf is 1.

      
    To aid in writing recursive procedures on trees, Scheme provides
    the primitive predicate pair?, which tests whether its argument is
    a pair. Here is the complete procedure:

    #+BEGIN_SRC scheme
    (define (count-leaves x)
     (cond ((null? x) 0)
           ((not (pair? x)) 1)
           (else (+ (count-leaves (car x))
                    (count-leaves (cdr x))))))
    #+END_SRC

    - Exercise 2.24. Suppose we evaluate the expression (list 1 (list
      2 (list 3 4))). Give the result printed by the interpreter, the
      corresponding box-and-pointer structure, and the interpretation
      of this as a tree.

      The interpreter will print:
      (1 (2 (3 4)))

    - Exercise 2.25. Give combinations of cars and cdrs that will pick
      7 from each of the following lists:

      #+BEGIN_SRC scheme
      (1 3 (5 7) 9)
      ((7))
      (1 (2 (3 (4 (5 (6 7))))))
      #+END_SRC

      (1 3 (5 7) 9)
      (car (cdr (car (cdr (cdr items)))))
      car cdr car cdr cdr

      ((7))
      (car (car items))
      car car

      (1 (2 (3 (4 (5 (6 7))))))
      (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr
      items))))))))))))

    - Exercise 2.26. Suppose we define x and y to be two lists:
      #+BEGIN_SRC scheme
      (define x (list 1 2 3))
      (define y (list 4 5 6))
      #+END_SRC
      
      What result is printed by the interpreter in response to
      evaluating each of the following expressions:

      #+BEGIN_SRC scheme
      (append x y)
      (cons x y)
      (list x y)
      #+END_SRC
      
      In order:
      #+BEGIN_SRC scheme
      (1 2 3 4 5 6)
      ((1 2 3) 4 5 6)
      ((1 2 3) (4 5 6))
      #+END_SRC

    - Exercise 2.27. Modify your reverse procedure of exercise 2.18 to
      produce a deep-reverse procedure that takes a list as argument
      and returns as its value the list with its elements reversed and
      all sublists deep-reversed as well. For example,

      #+BEGIN_SRC scheme
      (define x (list (list 1 2) (list 3 4)))
      x
      ((1 2) (3 4))
      (reverse x)
      ((3 4) (1 2))
      (deep-reverse x)
      ((4 3) (2 1))
      #+END_SRC

      Original reverse:

      #+BEGIN_SRC scheme
      (define (reverse x)
       (cond ((null? x) x)
             (else (append (reverse (cdr x)) (list (car x))))))
      #+END_SRC

      New reverse:

      #+BEGIN_SRC scheme
      (define (reverse x)
       (cond ((null? x) x)
             ((pair? (car x))
              (append (reverse (cdr x)) (list (reverse (car x)))))
             (else
              (append (reverse (cdr x)) (list (car x))))))
      #+END_SRC

    - Exercise 2.28. Write a procedure fringe that takes as argument a
      tree (represented as a list) and returns a list whose elements
      are all the leaves of the tree arranged in left-to-right
      order. For example,

      #+BEGIN_SRC scheme
      (define x (list (list 1 2) (list 3 4)))
      (fringe x)
      (1 2 3 4)
      (fringe (list x x))
      (1 2 3 4 1 2 3 4)
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (fringe items)
       (cond ((null? items) '())
             ((pair? (car items))
              (append (fringe (car items)) (fringe (cdr items))))
             (else (cons (car items) (fringe (cdr items))))))
      #+END_SRC

    - Exercise 2.29. A binary mobile consists of two branches, a left
      branch and a right branch. Each branch is a rod of a certain
      length, from which hangs either a weight or another binary
      mobile. We can represent a binary mobile using compound data by
      constructing it from two branches (for example, using list):

      #+BEGIN_SRC scheme
      (define (make-mobile left right)
       (list left right))
      #+END_SRC

      A branch is constructed from a length (which must be a number)
      together with a structure, which may be either a number
      (representing a simple weight) or another mobile:

      #+BEGIN_SRC scheme
      (define (make-branch length structure)
       (list length structure))
      #+END_SRC

      a. Write the corresponding selectors left-branch and
      right-branch, which return the branches of a mobile, and
      branch-length and branch-structure, which return the components
      of a branch.

      #+BEGIN_SRC scheme
      (define (left-branch a-mobile)
       (car a-mobile))
      (define (right-branch a-mobile)
       (car (cdr a-mobile)))

      (define (branch-length a-branch)
       (car a-branch))
      (define (branch-structure a-branch)
       (car (cdr a-branch)))
      #+END_SRC
      
      b. Using your selectors, define a procedure total-weight that
      returns the total weight of a mobile.

      #+BEGIN_SRC scheme
      (define (branch-weight mobile-branch)
       (cond ((not (pair? (branch-structure mobile-branch)))
              (branch-structure mobile-branch))
             (else (total-weight (branch-structure mobile-branch)))))

      (define (total-weight mobile)
       (+ (branch-weight (left-branch mobile))
          (branch-weight (right-branch mobile))))
      #+END_SRC

      c. A mobile is said to be _balanced_ if the torque applied by
      its top-left branch is equal to that applied by its top-right
      branch (that is, if the length of the left rod multiplied by the
      weight hanging from that rod is equal to the corresponding
      product for the right side) and if each of the submobiles
      hanging off its branches is balanced. Design a predicate that
      tests whether a binary mobile is balanced.

      #+BEGIN_SRC scheme
      (define (torque a-branch)
       (* (branch-length a-branch)
          (branch-weight a-branch)))
 
      (define (balanced? a-mobile)
       (define (branch-balanced? a-branch)
        (cond ((pair? (branch-structure a-branch)) 
               (balanced? (branch-structure a-branch)))
              (else true)))
       (and (= (torque (left-branch a-mobile))
               (torque (right-branch a-mobile)))
            (and (branch-balanced? (left-branch a-mobile))
                 (branch-balanced? (right-branch a-mobile)))))
      #+END_SRC

      d. Suppose we change the representation of mobiles so that the
      constructors are 

      #+BEGIN_SRC scheme
      (define (make-mobile left right)
       (cons left right))
      (define (make-branch length structure)
       (cons length structure))     
      #+END_SRC

      How much do you need to change your programs to convert to the
      new representation?

      All you have to do is

      #+BEGIN_SRC scheme
      (define branch-length car)
      (define branch-structure cdr)
      (define left-branch car)
      (define right-branch cdr)
      #+END_SRC

      And the programs work the same way. There is an abstraction leak
      when we use pair? and we should probably have defined another
      predicate, like mobile? instead. But even so the programs work
      after only changing the selectors.

**** Mapping over trees
     Just as map is a powerful abstraction for dealing with sequences,
     map together with recursion is a powerful abstraction for dealing
     with trees. For instance, the scale-tree procedure, analogous to
     scale-list of section 2.2.1, takes as arguments a numeric factor
     and a tree whose leaves are numbers. It returns a tree of the
     same shape, where each number is multiplied by a factor. The
     recursive plan for scale-tree is similar to the one for
     count-leaves:

     #+BEGIN_SRC scheme
     (define (scale-tree tree factor)
      (cond ((null? tree) '())
            ((not (pair? tree)) (* tree factor))
            (else (cons (scale-tree (car tree) factor)
                        (scale-tree (cdr tree) factor)))))
     #+END_SRC

     #+BEGIN_EXAMPLE scheme
     (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
     (10 (20 (30 40) 50) (60 70))
     #+END_EXAMPLE

     Another way to implement scale-tree is to regard the tree as a
     sequence of sub-trees and use map. We map over the sequence,
     scaling each sub-tree in turn, and return the list of results. In
     the base case, where the tree is a leaf, we simply multiply by
     the factor:

     #+BEGIN_SRC scheme
     (define (scale-tree tree factor)
      (map (lambda (sub-tree)
            (if (pair? sub-tree)
                (scale-tree sub-tree factor)
                (* sub-tree factor)))
      tree))
     #+END_SRC

     Many tree operations can be implemented by similar combinations
     of sequence operations and recursion.

     - Exercise 2.30. Define a procedure square-tree analogous to
       square-list procedure of exercise 2.21. That is, square-list
       should behave as follows:

       #+BEGIN_SRC scheme
       (square-tree (list 1
                          (list 2 (list 3 4) 5)
                          (list 6 7)))
       (1 (4 (9 16) 25) (36 49))
       #+END_SRC

       Define square-tree both directly (i.e. without using any
       higher-order procedures) and also by using map and recursion.

       #+BEGIN_SRC scheme
       (define (square-tree a-tree)
        (cond ((null? a-tree) '())
              ((pair? (car a-tree))
               (cons (square-tree (car a-tree))
                     (square-tree (cdr a-tree))))
              (else (cons (square (car a-tree)) 
                          (square-tree (cdr a-tree))))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (square-tree-map a-tree)
        (map (lambda (node) (if (pair? node) (square-tree-map node)
                                             (square node))) a-tree))
       #+END_SRC

     - Exercise 2.31. Abstract your answer to exercise 2.30 to produce
       a procedure tree-map with the property that square-tree could
       be defined as

       #+BEGIN_SRC scheme
       (define (square-tree tree) (tree-map square tree))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (tree-map proc tree)
        (map (lambda (node) (if (pair? node) (tree-map proc node) (proc node))) tree))
       #+END_SRC

     - Exercise 2.32. We can represent a set as a list of distinct
       elements, and we can represent the set of all subsets of the
       set as a list of lists. For example, if the set is (1 2 3),
       then the set of all subsets is (() (3) (2) (2 3) (1) (1 3)
       (1 2) (1 2 3)). Complete the following definition of a
       procedure that generates the set of subsets of a set and give a
       clear explanation of why it works:

       #+BEGIN_SRC scheme
       (define (subsets s)
        (if (null? s)
            (list nil)
            (let ((rest (subsets (cdr s))))
             (append rest (map (lambda (x) (cons (car s) x)) rest)))))
       #+END_SRC

       So you cdr down the whole list and eventually get to an empty
       list at which point you start with the base subset, the empty
       subset. At this point your list of lists, or list of possible
       subsets is

       (())
      
       A list with a single subset, the empty set. Next you have the
       last element in the list of elements, in this case 3. You
       preserve your old list of possible subsets which are correct;
       the recursive solution to the sublist (which starts with (())),
       and then append that old list to a new generated list where you
       add the current item in the list to all possible subsets of the
       old list. If you have a set of items and you generate all
       possible subsets, and then add an item to that set and want to
       know the possible subsets of _that_ set, the answer is all the
       old subsets plus all the old subsets with the new element
       added. And that's exactly what this procedure does. So if you
       only have one item (3), you first generate (()). Then you
       concatenate two lists: the old one, plus a new one with 3 added
       to each element: (() (3)), and this is the list of all possible
       subsets. Continue doing this. SO say you also want to, or (2
       3). THen all you would do is take the old list, and concatenate
       it to a new list which is the old list with every item having a
       2 inserted: (() (3) (2) (2 3)). And so on.

*** 2.2.3 Sequences as Conventional Interfaces

    In working with compound data, we've stressed how data abstraction
    permits us to design programs without becoming enmeshed in the
    details of data representations. In this section, we introduce
    another powerful design principle for working with data structures
    -- the use of _conventional interfaces_. 

    In section 1.3 we saw how program abstractions, implemented as
    higher-order procedures, can capture common patterns in programs
    that deal with numerical data. Our ability to formulate analogous
    operations for working with compound data depends crucially on the
    style in which we manipulate our data structures. Consider, for
    example, the following procedure, analogous to the count-leaves
    procedure of section 2.2.2, which takes a tree as argument and
    computes the sum of the squares of the leaves that are odd:

    #+BEGIN_SRC scheme
    (define (sum-odd-squares tree)
     (cond ((null? tree) 0)
           ((not (pair? tree))
            (if (odd? tree) (square tree) 0))
           (else (+ (sum-odd-squares (car tree))
                    (sum-odd-squares (cdr tree))))))
    #+END_SRC

    On the surface, this procedure is very different from the
    following one, which constructs a list of all the even Fibonacci
    numbers Fib(k), where k is less than or equal to a given integer
    n:

    #+BEGIN_SRC scheme
    (define (even-fibs n)
     (define (next k)
      (if (> k n)
          nil
          (let ((f (fib k)))
           (if (even? f)
               (cons f (next (+ k 1)))
               (next (+ k 1))))))
     (next 0))
    #+END_SRC
    
    Despite the fact that these two procedures are structurally very
    different, a more abstract description of the two computations
    reveals a great deal of similarity. The first program

    * Enumerates the leaves of a tree;
    * Filters them, selecting the odd ones;
    * Squares each of the selected ones; and
    * accumulates the results using +, starting with 0.


    The second program 

    * Enumerates the integers from 0 to _n_;
    * Computes the Fibonacci number for each integer;
    * Filters them, selecting the even ones; and
    * Accumulates the results using cons, starting with the empty
      list.

      
    A signal-processing engineer would find it natural to
    conceptualize these processes in terms of signals flowing through
    a cascade of stages, each of which implements part of the program
    plan, as shown in figure 2.7. In sum-odd-squares, we begin with
    an _enumerator_, which generates a "signal" consisting of the
    leaves of a given tree. This signal is passed through a _filter_,
    which eliminates all but the odd elements. The resulting signal is
    in turn passed through a _map_, which is a "transducer" that
    applies the square procedure to each element. The output of the
    map is then fed into an _accumulator_, which combines the elements
    using +, starting from an initial 0. The plan for even-fibs is
    analogous.

    Unfortunately, the two procedure definitions above fail to exhibit
    this signal-flow structure. For instance, if we examine the
    sum-odd-squares procedure, we find that the enumeration is
    implemented partly by the null? and pair? tests and partly by the
    tree-recursive structure of the procedure. Similarly, the
    accumulation is found partly in the tests and partly in the
    addition used in the recursion. In general, there are no distinct
    parts of either procedure that correspond to the elements in the
    signal-flow description. Our two procedures decompose the
    computations in a different way, spreading the enumeration over
    the program and mingling it with the map, the filter, and the
    accumulation. If we could organize our programs to make the
    signal-flow structure manifest the procedures we write, this would
    increase the conceptual clarity of the resulting code.

**** Sequence Operations    
     
     The key in organizing programs so as to more clearly reflect the
     signal-flow structure is to concentrate on the "signals" that
     flow from one stage in the process to the next. If we represent
     these signals as lists, then we can use list operations to
     implement the processing at each of the stages. For instance, we
     can implement the mapping stages of the signal-flow diagrams
     using the map procedure from section 2.2.1:

     #+BEGIN_SRC scheme
     (map square (list 1 2 3 4 5))
     (1 4 9 16 25)
     #+END_SRC

     Filtering a sequence to select only those elements that satisfy a
     given predicate is accomplished by

     #+BEGIN_SRC scheme
     (define (filter predicate sequence)
      (cond ((null? sequence) '())
            ((predicate (car sequence))
             (cons (car sequence)
                   (filter predicate (cdr sequence))))
            (else (filter predicate (cdr sequence)))))
     #+END_SRC

     For example,

     #+BEGIN_SRC scheme
     (filter odd? (list 1 2 3 4 5))
     (1 3 5)
     #+END_SRC

     Accumulations can be implemented by

     #+BEGIN_SRC scheme
     (define (accumulate op initial sequence)
      (if (null? sequence)
          initial
          (op (car sequence)
              (accumulate op initial (cdr sequence)))))
     (accumulate + 0 (list 1 2 3 4 5))
     15
     (accumulate * 1 (list 1 2 3 4 5))
     120
     (accumulate cons nil (list 1 2 3 4 5))
     (1 2 3 4 5)
     #+END_SRC
     
     All that remains to implement signal-flow diagrams is to
     enumerate the sequence of elements to be processed. For
     even-fibs, we need to generate the sequence of integers in a
     given range, which we can do as follows:

     #+BEGIN_SRC scheme
     (define (enumerate-interval low high)
      (if (> low high)
          nil
          (cons low (enumerate-interval (+ 1 low) high))))
     (enumerate-interval 2 7)
     (2 3 4 5 6 7)
     #+END_SRC

     To enumerate the leaves of a tree, we can use

     #+BEGIN_SRC scheme
     (define (enumerate-tree tree)
      (cond ((null? tree) nil)
            ((not (pair? tree)) (list tree))
            (else (append (enumerate-tree (car tree))
                          (enumerate-tree (cdr tree))))))
     (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
     (1 2 3 4 5)
     #+END_SRC

     Now we can reformulate sum-odd-squares and even-fibs as in the
     signal-flow diagrams. For sum-odd-squares, we enumerate the
     sequence of leaves of the tree, filter this to keep only the odd
     numbers in the sequence, square each element, and sum the
     results:

     #+BEGIN_SRC scheme
     (define (sum-odd-squares tree)
      (accumulate +
                  0
                  (map square
                       (filter odd?
                               (enumerate-tree tree)))))
     #+END_SRC

     For even-fibs, we enumerate the integers from 0 to n, generate
     the Fibonacci number for each of these integers, filter the
     resulting sequence to keep only the even elements, and accumulate
     the results into a list:

     #+BEGIN_SRC scheme
     (define (even-fibs n)
      (accumulate cons
                  nil
                  (filter even?
                          (map fib
                               (enumerate-interval 0 n)))))
     #+END_SRC

     The value of expressing programs as sequence operations is that
     this helps us make program designs that are modular, that is,
     designs that are constructed by combining relatively independent
     pieces. We can encourage modular design by providing a library of
     standard components together with a conventional interface for
     connecting the components in flexible ways.

     Modular construction is a powerful strategy for controlling
     complexity in engineering design. In real signal-processing
     applications, for example, designers regularly build systems by
     cascading elements selected from standardized families of filters
     and transducers. Similarly, sequence operations provide a library
     of standard program elements that we can mix and match. For
     instance, we can reuse pieces from the sum-odd-squares and
     even-fibs procedures in a program that constructs a list of the
     squares of the first _n_ + 1 Fibonacci numbers:

     #+BEGIN_SRC scheme
     (define (list-fib-squares n)
      (accumulate cons
                  nil
                  (map square
                       (map fib
                            (enumerate-interval 0 n)))))
     (list-fib-squares 10)
     (0 1 1 4 9 25 64 169 441 1156 3025)
     #+END_SRC

     We can rearrange the pieces and use them in computing the product
     of the odd integers in a sequence:

     #+BEGIN_SRC scheme
     (define (product-of-squares-of-odd-elements sequence)
      (accumulate *
                  1
                  (map square
                       (filter odd? sequence))))
     (product-of-squares-of-odd-elements (list 1 2 3 4 5))
     225
     #+END_SRC

     We can also formulate conventional data-processing applications
     in terms of sequence operations. Suppose we have a sequence of
     personnel records and we want to find the salary of the
     highest-paid programmer. Assume that we have a selector salary
     that returns the salary of a record, and a predicate programmer?
     that tests if a record is for a programmer. Then we can write

     #+BEGIN_SRC scheme
     (define (salary-of-highest-paid-programmer records)
      (accumulate max
                  0
                  (map salary
                       (filter programmer? records))))
     #+END_SRC

     Sequences, implemented here as lists, serve as a conventional
     interface that permits us to combine processing
     modules. Additionally, when we uniformly represent structures as
     sequences, we have localized the data-structure dependencies in
     our programs to a small number of sequence operations. By
     changing these, we can experiment with alternative
     representations of sequence operations, while leaving the overall
     design of our programs intact. We will exploit this capability in
     section 3.5, when we generalize the sequence-processing paradigm
     to admit infinite sequences.

     - Exercise 2.33. Fill in the missing expressions to complete the
       following definitions of some basic list-manipulation
       operations as accumulations:

       #+BEGIN_SRC scheme
       (define (map p sequence)
        (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
       (define (append seq1 seq2)
        (accumulate (lambda (x y) (cons x y)) seq2 seq1))
       (define (length sequence)
        (accumulate (lambda (x y) (+ y 1)) 0 sequence))
       #+END_SRC

     - Exercise 2.34 Evaluating a polynomial in x at a given value of
       x can be formulated as an accumulation. We evaluate the
       polynomial

       \begin{poly}
       a_{n}x^{n} + a_{n - 1}x^{n-1} + ... + a_{1}x + a_{0}
       \end{poly}
       
       using a well-known algorithm called _Horner's rule_, which
       structures the computation as

       \begin{horner}
       (...(a_{n}x + a_{n - 1})x + ... + a_{1})x + a_{0}
       \end{horner}

       In other words, we start with a_n, multiply by x, add a_{n-1},
       multiply by x, and so on, until we reach a_0. Fill in the
       following template to produce a procedure that evaluates a
       polynomial using Horner's rule. Assume that the coefficients of
       the polynomial are arranged in a sequence, from a_0 through
       a_n.

       #+BEGIN_SRC scheme
       (define (horner-eval x coefficient-sequence)
        (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
                    0
                    coefficient-sequence))
       #+END_SRC

       For example, to compute 1 + 3x + 5x^3 + x^5 at x = 2 you would
       evaluate

       #+BEGIN_SRC scheme
       (horner-eval 2 (list 1 3 0 5 0 1))
       #+END_SRC

     - Exercise 2.35 Redefine count-leaves from section 2.2.2 as an
       accumulation:

       #+BEGIN_SRC scheme
       (define (count-leaves t)
        (accumulate <??> <??> (map <??> <??>)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (count-leaves t)
        (accumulate (lambda (x y) (+ x y)) 
         0 
         (map (lambda (x) (if (pair? x) (count-leaves x) 1)) t)))
       #+END_SRC

     - Exercise 2.36. The procedure accumulate-n is similar to
       accumulate except that it takes as its third argument a
       sequence of sequences, which are all assumed to have the same
       number of elements. It applies the designated accumulation
       procedure to combine all the first elements of the sequences,
       all the second elements of the sequences, and so on, and
       returns a sequence of the results. For instance, if s is a
       sequence containing four sequences, ((1 2 3) (4 5 6) (7 8 9)
       (10 11 12)), then the value of (accumulate-n + 0 s) should be
       the sequence (22 26 30). Fill in the missing expressions in the
       following definition of accumulate-n:

       #+BEGIN_SRC scheme
       (define (accumulate-n op init seqs)
        (if (null? (car seqs))
            '()
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))
       #+END_SRC

     - Exercise 2.37 Suppose we represent vectors v = (v_i) as
       sequences of numbers, and matrices m = (m_ij) as sequences of
       vectors (the rows of the matrix). For example, the matrix

       #+BEGIN_EXAMPLE
       [ 1 2 3 4 ]
       [ 4 5 6 6 ]
       [ 6 7 8 9 ]
       #+END_EXAMPLE

       is represented as a sequence ((1 2 3 4) (4 5 6 6) (6 7 8
       9)). With this representation, we can use sequence operations
       to concisely express the basic matrix and vector
       operations. These operations (which are described in any book
       on matrix algebra) are the following:

       #+BEGIN_SRC scheme
       (dot-product v w) ; returns the sum(w_i * v_i)
       (matrix-*-vector m v) ; returns the vector t, where t_i = sum_{j}m_{i}{j} * v_{j}
       (matrix-*-matrix m n) ; returns the matrix p, where p_{i}{j} = sum_{k} m_{i}{k} * n
       (transpose n)         ; returns the matrix n, where n_{i}{j} = m_{j}{i}
       #+END_SRC 

       We can define the dot product as

       #+BEGIN_SRC scheme
       (define (dot-product v w)
        (accumulate + 0 (map * v w)))
       #+END_SRC

       Fill in the missing expressions in the following procedures for
       computing the other matrix operations. (The procedure
       accumulate-n is defined in exercise 2.36.)

       #+BEGIN_SRC scheme
       (define (matrix-*-vector m v)
        (map (lambda (matrix-vector) 
              (dot-product matrix-vector v))
             m))
       #+END_SRC

       Beautifully, all you need to do with transpose is:
       #+BEGIN_SRC scheme
       (define (transpose mat)
        (accumulate-n cons '() mat))
       #+END_SRC

       Because with a matrix ((1 2 3) (4 5 6)) the accumulate function
       will be passed (1 4) (2 5) (3 6) respectively, if we cons those
       together we get:

       ((1 4) (2 5) (3 6))

       Which is an effective transposition.

       #+BEGIN_SRC scheme
       (define (matrix-*-matrix m n)
        (let ((cols (transpose n)))
         (map (lambda (n-col)
               (map 
                (lambda (m-row)
                 (dot-product m-row n-col))
                m)) cols)))
                 
       #+END_SRC

     - Exercise 2.38. The accumulate procedure is also known as
       fold-right, because it combines the first element of the
       sequence with the result of combining all the elements to the
       right. There is also a fold-left, which is similar to
       fold-right, except that it combines elements working in the
       opposite direction:

       #+BEGIN_SRC scheme
       (define (fold-left op initial sequence)
        (define (iter result rest)
         (if (null? rest)
             rest
             (iter (op result (car rest))
                   (cdr rest))))
        (iter initial sequence))
       #+END_SRC

       What are the values of
       (fold-right / 1 (list 1 2 3)) -> 3/2
       (fold-left / 1 (list 1 2 3)) -> 1/6
       (fold-right list nil (list 1 2 3)) -> (1 (2 (3 ())))
       (fold-left list nil (list 1 2 3)) -> (((() 1) 2) 3)
       
       Give a property that op should satisfy to guarantee that
       fold-right and fold-left will produce the same values for any
       sequence.

       - Exercise 2.39. Complete the following definitions of reverse
         (exercise 2.18) in terms of fold-right and fold-left from
         exercise 2.38:

	 #+BEGIN_SRC scheme
         (define (reverse sequence)
          (fold-right (lambda (x y) <??>) nil sequence))

         (define (reverse sequence)
          (fold-right (lambda (x y) (append y (list x))) nil sequence))
	 #+END_SRC
     
	 #+BEGIN_SRC scheme
         (define (reverse sequence)
          (fold-left (lambda (x y) <??>) nil sequence))
 
         (define (reverse sequence)
          (fold-left 
           (lambda (x y) (cons y x)) '() sequence))
	 #+END_SRC

**** Nested Mappings

     We can extend the sequence paradigm to include many computations
     that are commonly expressed using nested loops. Consider this
     problem: Given a positive integer n, find all ordered pairs of
     distinct positive integers i and j, where 1<= j < i <= n, such
     that i + j is prime. For example, if n is 6, then the pairs are
     the following:

     #+BEGIN_EXAMPLE
     i     | 2 3 4 4 5 6 6
     j     | 1 2 1 3 2 1 5
     i + j | 3 5 5 7 7 7 11
     #+END_EXAMPLE

     A natural way to organize this computation is to generate the
     sequence of all ordered pairs of positive integers less than or
     equal to n, filter to select those pairs whose sum is prime, and
     then, for each pair (i, j) that passes through the filter,
     produce the triple (i, j, i + j).

     Here is a way to generate the sequence of pairs: For each integer
     i <= n, enumerate the integers j < i, and for each such i and j
     generate a pair (i, j). In terms of sequence operations, we map
     along the sequence (enumerate-interval 1 n). For each i in this
     sequence, we map along the sequence (enumerate-interval 1 (- i
     1)). For each _j_ in this latter sequence, we generate the pair
     (list i j). This gives us a sequence of pairs for each
     i. Combining all the sequences for all the _i_ (by accumulating
     with append) produces the required sequence of pairs:

     #+BEGIN_SRC scheme
     (accumulate append
                 nil
                 (map (lambda (i)
                       (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n)))
     #+END_SRC

     The combination of mapping and accumulating with append is so
     common in this sort of program that we will isolate it as a
     separate procedure:

     #+BEGIN_SRC scheme
     (define (flatmap proc seq)
      (accumulate append nil (map proc seq)))
     #+END_SRC

     Now filter this sequence of pairs to find those whose sum is
     prime. The filter predicate is called for each element of the
     sequence; its argument is a pair and it must extract the integers
     from the pair. Thus, the predicate to apply to each element in
     the sequence is:

     #+BEGIN_SRC scheme
     (define (prime-sum? pair)
      (prime? (+ (car pair) (cadr pair))))
     #+END_SRC

     Finally, generate the sequence of results by mapping over the
     filtered pairs using the following procedure, which constructs a
     triple consisting of the two elements of the pair along with
     their sum:

     #+BEGIN_SRC scheme
     (define (make-pair-sum pair)
      (list (car pair) 
            (cadr pair) 
            (+ (car pair) (cadr pair))))
     #+END_SRC

     Combining all these steps yields the complete procedure:

     #+BEGIN_SRC scheme
     (define (prime-sum-pairs n)
      (map make-pair-sum
           (filter prime-sum?
                   (flatmap
                    (lambda (i)
                     (map (lambda (j) (list i j))
                          (enumerate-interval i (- i 1))))
                    (enumerate-interval 1 n)))))
     #+END_SRC

     Nested mappings are also useful for sequences other than those
     that enumerate intervals. Suppose we wish to generate all the
     permutations of a set S; that is, all the ways of ordering the
     items in the set. For instance, the permutations of {1, 2, 3} are
     {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, and {3, 2,
     1}. Here is a plan for generating the permutations of S: For each
     item x in S, recursively generate the sequence of permutations of
     S - x, so and adjoin x to the front of each one. This yields, for
     each x in S, the sequence of permutations of S that begin with
     x. Combining these sequences for all x gives all the permutations
     of S:

     #+BEGIN_SRC scheme
     (define (permutations s)
      (if (null? s)
          (list nil)
          (flatmap (lambda (x)
                    (map (lambda (p) (cons x p))
                         (permutations (remove x s))))
                   s)))
     #+END_SRC

     Notice how this strategy reduces the problem of generating
     permutations of S to the problem of generating the permutations
     of sets with fewer elements than S. In the terminal case, we work
     our way down to the empty list, which represents a set of no
     elements. For this, we generate (list nil), which is a sequence
     with one item, namely the set with no elements. The remove
     procedure used in permutations returns all the items in a given
     sequence except for a given item. This can be expressed as a
     simple filter:

     #+BEGIN_SRC scheme
     (define (remove item sequence)
      (filter (lambda (x) (not (= x item))) sequence))
     #+END_SRC

     - Exercise 2.40 Define a procedure unique-pairs that, given an
       integer _n_, generates the sequence of pairs (i, j) with 1 <= j
       <= i <= n. Use unique-pairs to simplify the definition of
       prime-sum-pairs given above.

       #+BEGIN_SRC scheme
       (define (unique-pairs n)
        (flatmap (lambda (i) 
              (map (lambda (j) (list i j)) 
                    (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (prime-sum-pairs n)
        (map
         make-prime-sum-triple
         (filter
          prime-sum?
          (unique-pairs n))))
       #+END_SRC

     - Exercise 2.41 Write a procedure to find all ordered triples of
       distinct positive integers i, j, and k less than or equal to a
       given integer n that sum to a given integer s

       #+BEGIN_SRC scheme
       ;; ordered-triples: integer integer -> (listof triple)
       ;; find all triples of distinct positive integers i, j, and k
       ;; less than or equal to a given integer n that sum to a given
       ;; integer s.
       (define (ordered-triples n s)
        (unique-only
         (filter ordered-triple? 
          (filter (lambda (x) (triple-adds-to? x s))
                   (generate-distinct-triples n)))))

       (define (triple=? triple1 triple2)
        (and (= (car triple1) (car triple2))
             (= (cadr triple1) (cadr triple2))
             (= (caddr triple1) (caddr triple2))))

       (define (unique-only list-of-items)
        (accumulate (lambda (i rest)
                     (cons i 
                      (filter (lambda (j)
                               (not (triple=? i j))) rest))) '() list-of-items))

       (define (ordered-triple? triple)
        (< (car triple) (cadr triple) (caddr triple)))
       
       (define (triple-adds-to? triple s)
        (= (+ (car triple) (cadr triple) (caddr triple)) s))
       ;; generate-distinct-triples: integer -> (listof triple)
       ;; generate a list of all triples less than n where no single 
       ;; element of the triple is equal to any other.
       (define (generate-distinct-triples n)
        (flatmap (lambda (i) 
              (flatmap (lambda (j)
                    (map (lambda (k)
                         (list k j i))
                         (enumerate-interval 1 (- j 1))))
                   (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

       ;; (insert-into-triples 4 ((1 2 3))) ->
       ;; ((1 2 4) (1 4 3) (4 2 3))
       (define (insert-into-triples n triples)
        (flatmap (lambda (triple) (insert-into-triple n triple))
                 triples))
       (define (insert-into-triple n triple)
        (map (lambda (index) 
              (replace-index-with-n index n triple))
             (enumerate-interval 1 3)))

       (define (replace-index-with-n index n the-triple)
        (define (iter i input)
         (cond ((null? input) '())
               ((= i index) (cons n (iter (+ i 1) (cdr input))))
               (else (cons (car input) (iter (+ i 1) (cdr input))))))
        (iter 1 the-triple))
       #+END_SRC

     - Exercise 2.42.

       The "eight-queens puzzle" asks how to place eight queens on a
       chessboard so that no queen is in check from any other (i.e. no
       two queens are in the same row, column, or diagonal). One
       possible solution is shown in figure 2.8. One way to solve the
       puzzle is to work across the board, placing a queen in each
       column. Once we have placed k - 1 queens, we must place the kth
       queen in a position where it does not check any of the queens
       already on the board. We can formulate this approach
       recursively: Assume that we have already generated the sequence
       of all possible ways to place k - 1 queens in the first k - 1
       columns of the board. For each of these ways, generate an
       extended set of positions by placing a queen in each row of the
       kth column. Now filter these, keeping only the positions for
       which the queen in the kth column is safe with respect to the
       other queens. This produces the sequence of all ways to place k
       queens in the first k columns. By continuing this process, we
       will produce not only one solution, but all solutions to the
       puzzle. We implement this solution as a procedure queens, which
       returns a sequence of all solutions to the problem of placing n
       queens on an nxn chessboard. Queens has an internal procedure
       queen-cols that returns the sequence of all ways to place
       queens in the first k columns of the board.

       #+BEGIN_SRC scheme
       (define (queens board-size)
        (define (queen-cols k)
         (if (= k 0)
             (list empty-board)
             (filter
              (lambda (positions) (safe? k positions))
              (flatmap
               (lambda (rest-of-queens)
                (map (lambda (new-row)
                      (adjoin-position new-row k rest-of-queens))
                     (enumerate-interval 1 board-size)))
               (queen-cols (- k 1))))))
        (queen-cols board-size))
       #+END_SRC

       In this procedure rest-of-queens is a way to place k - 1 queens
       in the first k - 1 columns, and new-row is a proposed row in
       which to place the queen for the kth column. Complete the
       program by implementing the representation for sets of board
       positions, including the procedure adjoin-position, which
       adjoins a new row-column position to a set of positions, and
       empty-board, which represents an empty set of positions. You
       must also write the procedure safe?, which determines for a set
       of positions, whether the queen in the kth column is safe with
       respect to others. (Note that we need only check whether the
       new queen is safe -- the other queens are already guaranteed
       safe with respect to each other.)

       #+BEGIN_SRC scheme
       (define (safe? column-number queen-positions)
        ...)
       (define (adjoin-position new-row-number number-of-rows rest-of-queen-positions)
        ...)
       (define empty-board ...)
       #+END_SRC

       An initial approximation could be a board as just a list of
       positions, where a position is a cons of two numbers, the row
       and column.
       
       #+BEGIN_SRC scheme
       ;; add new positions at new-row-number for every column, given a list of current positions.
       (define (adjoin-position new-row-number number-of-columns other-positions)
        (cons (make-queen new-row-number number-of-columns) other-positions))
       (define empty-board '())
       (define (safe? column-number queen-positions)
        ...)
       #+END_SRC

       Now the hard work is ahead. We need to look at the first
       position and see if it's safe from all other positions. For a
       single piece, we need to see if it's on a common row with other
       pieces (we've been adding columns so it can't be on the same
       column) and then see if it's on the same diagonal.

       #+BEGIN_SRC scheme
       (define (queen-row queen)
        (car queen))
       (define (queen-column queen)
        (cdr queen))
       (define (make-queen row column)
         (cons row column))
       (define (safe-from-queen? queen1 queen2)
        (and (not (= (queen-column queen1) (queen-column queen2)))
             (not (= (queen-row queen1) (queen-row queen2)))
             (not (is-same-diagonal? queen1 queen2))))
       (define (is-same-diagonal? queen1 queen2)
        (= (abs (- (queen-row queen1) (queen-row queen2)))
           (abs (- (queen-column queen1) (queen-column queen2)))))
       (define (safe? column-number queen-positions)
        (define (safe-from-all-others? a-queen queen-positions)
          (if (null? queen-positions) true
             (and (safe-from-queen? a-queen (car queen-positions))
                  (safe-from-all-others? a-queen (cdr queen-positions)))))
        (safe-from-all-others? (car queen-positions) (cdr queen-positions)))
       #+END_SRC

     - Exercise 2.43 Louis Reasoner is having a terrible time doing
       exercise 2.42. His queens procedure seems to work, but it runs
       extremely slowly. (Louis never does manage to wait long enough
       for it to solve even the 6x6 case.) When Louis asks Eva Lu Ator
       for help, she points out that he has interchanged the order of
       the nested mappings in the flatmap, writing it as

       #+BEGIN_SRC scheme
       (flatmap
        (lambda (new-row)
         (map (lambda (rest-of-queens)
               (adjoin-position new-row k rest-of-queens))
              (queen-cols (- k 1))))
         (enumerate-interval 1 board-size))
       #+END_SRC

       You are unecessarily solving (queen-cols (- k 1)) board-size
       times when you only need to solve it once. The solution for
       (queen-cols (- k 1)) will always be the same but the row number
       will not, meaning the positions of queen-cols and
       enumerate-interval should be swapped. As it is, for each
       iteration through the loop, you call queen-cols board-size
       times. If queen-colls for (- k 1) takes T time you're taking
       board-size times as much, board-size * T. However, that's not a
       fully accurate picture since the call is recursive. Every
       recursive call also takes board-size times as long. There are
       basically the same number of _levels_ of recursion (board-size)
       with different values of k but each level is board-size times
       as long. So it would be board-size * board-size * board-size
       ... or (board-size ^ board-size) * T.

*** 2.2.4 Example: A Picture Language
    This section presents a simple language for drawing pictures that
    illustrates the power of data abstraction and closure, and also
    exploits higher-order procedures in an essential way. The language
    is designed to make it easy to experiment with patterns such as
    the ones in figure 2.9, which are composed of repeated elements
    that are shifted and scaled. In this language, the data objects
    being combined are represented as porcedures rather than as list
    structure. Just as cons, which satisfies the closure property,
    allowed us to easily build arbitrarily complicated list structure,
    the operation in this language, which also satisfy the closure
    property, allow us to e asily build arbitrarily complicated
    patterns.

**** The picture language

     When we began our study of programming in section 1.1, we
     emphasized the importance of describing a language by focusing on
     the language's primitives, its means of combination, and its
     means of abstraction. We'll follow that framework here.

     Part of the elegance of this picture language is that there is
     only one kind of element, called a _painter_. A painter draws an
     image that is shifted and scaled to fit within a designated
     parallelogram-shaped frame. For example, there's a primitive
     painter we'll call wave that makes a crude line drawing, as shown
     in figure 2.10. The actual shape of the drawing depends on the
     frame -- all four images in figure 2.10 are produced by the same
     wave painter, but with respect to four different frames. Painters
     can be more elaborate than this: The primitive painter called
     rogers paints a picture of MIT's founder, William Barton Rogers,
     as shown in figure 2.11. The four images in figure 2.11 are drawn
     with respect to the same four frames as the wave images in figure
     2.10. 

     To combine images, we use various operations that construct new
     painters from given painters. For example, the beside operation
     takes two painters and produces a new, compound painter that
     draws the first painter's image in the left half of the frame and
     the second painter's image in the right half of the
     frame. Similarly, below takes two painters and produces a
     compound painter that draws the first painter's image below the
     second painter's image. Some operations transform a single
     painter to produce a new painter. For example, flip-vert takes a
     painter and produces a painter that draws its image upside-down,
     and flip-horiz produces a painter that draws the original
     painter's image left-to-right reversed.

     Figure 2.12 shows the drawing of a painter called wave4 that is
     built up in two stages starting  from wave:

     #+BEGIN_SRC scheme
     (define wave2 (beside wave (flip-vert wave)))
     (define wave4 (below wave2 wave2))
     #+END_SRC

     In building up a complex image in this manner we are exploiting
     the fact that painters are closed under the language's means of
     combination. The beside or below of two painters is itself a
     painter; therefore, we can use it as an element in making more
     complex painters. As with building up list structure using cons,
     the closure of our data under the means of combination is crucial
     to the ability to create complex structures while using only a
     few operations.

     Once we can combine painters, we would like to be able to
     abstract the typical patterns of combining painters. We will
     implement the painter operations as Scheme procedures. This means
     that we don't need a special abstraction mechanism in the picture
     language: Since the means of combination are ordinary Scheme
     procedures, we automatically have the capability to do anything
     with painter operations that we can do with procedures. For
     example, we can abstract the pattern in wave4 as
     
     #+BEGIN_SRC scheme
     (define (flipped-pairs painter)
      (let ((painter2 (beside painter (flip-vert painter))))
       (below painter2 painter2)))
     #+END_SRC

     and define wave4 as an instance of this pattern:

     #+BEGIN_SRC scheme
     (define wave4 (flipped-pairs wave))
     #+END_SRC

     We can also define recursive operations. Here's one that makes
     painters split and branch towards the right as shown in figures
     2.13 and 2.14:

     #+BEGIN_SRC scheme
     (define (right-split painter n)
      (if (= n 0)
          painter
          (let ((smaller (right-split painter (- n 1))))
           (beside painter (below smaller smaller)))))
     #+END_SRC

     We can produce balanced patterns by branching upwards as well as
     towards the right (see exercise 2.44 and figures 2.13 and 2.14):

     #+BEGIN_SRC scheme
     (define (corner-split painter n)
      (if (= n 0)
          painter
          (let ((up (up-split painter (- n 1)))
                (right (right-split painter (- n 1))))
           (let ((top-left (beside up up))
                 (bottom-right (below right right))
                 (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))
     #+END_SRC

     By placing four copies of a corner-split appropriately, we obtain
     a pattern called square-limit, whose application to wave and
     rogers is shown in figure 2.9:

     #+BEGIN_SRC scheme
     (define (square-limit painter n)
      (let ((quarter (corner-split painter n)))
       (let ((half (beside (flip-horiz quarter) quarter)))
        (below (flip-vert half) half))))
     #+END_SRC

     - Exercise 2.44 Define the procedure up-split used by
       corner-split. It is similar to right-split, except that it
       switches the roles of below and beside.

       #+BEGIN_SRC scheme
       (define (up-split painter n)
        (if (= n 0)
            painter
            (let ((up (up-split painter (- n 1))))
             (below painter (beside up up)))))
       #+END_SRC

**** Higher-order operations
     In addition to abstracting patterns of combining painters, we can
     work at a higher level, abstracting patterns of combining painter
     operations. That is, we can view the painter operations as
     elements to manipulate and can write means of combination for
     these elements -- procedures that take painter operations as
     arguments and create new painter operations.

     For example, flipped-pairs and square-limit each arrange four
     copies of a painter's image in a square pattern; they differ only
     in how they orient the copies. One way to abstract this pattern
     of painter combination is with the following procedure, which
     takes four one-argument painter operations and produces a painter
     operation that transforms a given painter with four operations
     and arranges the results in a square. Tl, tr, bl, and br are the
     transformations to apply to the top left copy, the top right
     copy, the bottom left copy, and the bottom right copy,
     respectively.

     #+BEGIN_SRC scheme
     (define (square-of-four tl tr bl br)
      (lambda (painter)
       (let ((top (beside (tl painter) (tr painter)))
             (bottom (beside (bl painter) (br painter))))
        (below bottom top))))
     #+END_SRC

     Then flipped-pairs can be defined in terms of square-of-four as
     follows:

     #+BEGIN_SRC scheme
     (define (flipped-pairs painter)
      (let ((combine4 (square-of-four identity flip-vert
                                      identity flip-vert)))
       (combine4 painter)))
     #+END_SRC

     and square-limit can be expressed as

     #+BEGIN_SRC scheme
     (define (square-limit painter n)
      (let ((combine4 (square-of-four flip-horiz identity
                                      rotate180 flip-vert)))
       (combine4 (corner-split painter n))))
     #+END_SRC

     - Exercise 2.45 Right-split and up-split can be expressed as
       instances of a general splitting operation. Define a procedure
       split with the property that evaluating

       #+BEGIN_SRC scheme
       (define right-split (split beside below))
       (define up-split (split below beside))
       #+END_SRC

       produces procedures right-split and up-split with the same
       behaviors as the ones already defined.

       #+BEGIN_SRC scheme
       (define (split op1 op2)
        (define (do-split painter n)
         (if (= n 0)
             painter
             (let ((splits (do-split painter (- n 1))))
              (op1 painter (op2 splits splits)))))
        do-split)
       #+END_SRC

       
**** Frames
     Before we can show how to implement painters and their means of
     combination, we must first consider frames. A frame can be
     described by three vectors -- an origin vector and two edge
     vectors. The origin vector specifies the offset of the frame's
     origin from some absolute origin in the plane, and the edge
     vectors specify the offsets of the frame's corners from its
     origin. If the edges are perpendicular, the frame will be
     rectangular. Otherwise the frame will be a more general
     parallelogram.

     Figure 2.15 shows a frame and its associated vectors. In
     accordance with data abstraction, we need not be specific yet
     about how frames are represented, other than to say that there is
     a constructor make-frame, which takes three vectors and produces
     a frame, and three corresponding selectors origin-frame,
     edge1-frame, and edge2-frame.

     We will use coordinates in the unit square (0 <= x,y <= 1) to
     specify images. With each frame, we associate a _frame coordinate
     map_, which will be used to shift and scale images to fit the
     frame. The map transforms the unit square into the frame by
     mapping the vector v = (x, y) to the vector sum

     Origin(Frame) + x * Edge1(Frame) + y * Edge2(Frame)

     For example, (0, 0) is mapped to the origin of the frame, (1, 1)
     to the vertex diagonally opposite the origin, and (0.5, 0.5) to
     the center of the frame. We can create a frame's coordinate map
     with the following procedure:

     #+BEGIN_SRC scheme
     (define (frame-coord-map frame)
      (lambda (v)
       (add-vect
        (origin-frame frame)
        (add-vect (scale-vect (xcor-vect v)
                              (edge1-frame frame))
                  (scale-vect (ycor-vect v)
                              (edge2-frame frame))))))
     #+END_SRC

     Observe that applying frame-coord-map to a frame returns a
     procedure that, given a vector, returns a vector. If the argument
     vector is in the unit square, the result vector will be in the
     frame. For example,

     #+BEGIN_SRC scheme
     ((frame-coord-map a-frame) (make-vect 0 0))
     #+END_SRC

     returns the same vector as

     #+BEGIN_SRC scheme
     (origin-frame a-frame)
     #+END_SRC

     - Exercise 2.46. A two-dimensional vector v running from the
       origin to a point can be represented as a pair consisting of an
       x-coordinate and a y-coordinate. Implement a data abstraction
       for vectors by giving a constructor make-vect and corresponding
       selectors xcor-vect and ycor-vect. In terms of your selectors
       and constructor, implement procedures add-vect, sub-vect, and
       scale-vect that perform the operations vector addition, vector
       subtraction, and multiplying a vector by a scalar:

       \begin{fragment}
       (x_{1}, y_{1}) + (x_{2}, y_{2}) = (x_{1} + x_{2}, y_{1} + y_{2})
       (x_{1}, y_{1}) - (x_{2}, y_{2}) = (x_{1} - x_{2}, y_{1} - y_{2})
                            s * (x, y) = (sx, sy)
       \end{fragment}

       #+BEGIN_SRC scheme
       (define (make-vect x y)
        (cons x y))
       (define (xcor-vect vec)
        (car vec))
       (define (ycor-vect vec)
        (cdr vec))
       (define (add-vect v1 v2)
        (make-vect
         (+ (xcor-vect v1) (xcor-vect v2))
         (+ (ycor-vect v1) (ycor-vect v2))))
       (define (sub-vect v1 v2)
        (make-vect
         (- (xcor-vect v1) (xcor-vect v2))
         (- (ycor-vect v1) (ycor-vect v2))))

       (define (scale-vect s v)
        (make-vect (* s (xcor-vect v))
                   (* s (ycor-vect v))))
       #+END_SRC

     - Exercise 2.47 Here are two possible constructors for frames:

       #+BEGIN_SRC scheme
       (define (make-frame origin edge1 edge2)
        (list origin edge1 edge2))
       (define (make-frame origin edge1 edge2)
        (cons origin (cons edge1 edge2)))
       #+END_SRC

       For each constructor supply the appropriate selectors to
       produce an implementation for frames.

       #+BEGIN_SRC scheme
       (define (make-frame origin edge1 edge2)
        (list origin edge1 edge2))
       (define (origin-frame frame)
        (car frame))
       (define (edge1-frame frame)
        (cadr frame))
       (define (edge2-frame frame)
        (caddr frame))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (make-frame origin edge1 edge2)
        (cons origin (cons edge1 edge2)))
       (define (origin-frame frame)
        (car frame))
       (define (edge1-frame frame)
        (cadr frame))
       (define (edge2-frame frame)
        (cddr frame))
       #+END_SRC



**** Painters
     A painter is represented as a procedure that, given a frame as
     argument, draws a particular image shifted and scaled to fit the
     frame. That is to say, if p is a painter and f is a frame, then
     we produce p's image in f by calling p with f as argument.

     The details of how primitive painters are implemented depend on
     the particular characteristics of the graphics system and the
     type of image to be drawn. For instance, suppose we have a
     procedure draw-line that draws a line on the screen between two
     specified points. Then we can create painters for line drawings,
     such as the wave painter in figure 2.10, from lists of line
     segments as follows:

     #+BEGIN_SRC scheme
     (define (segments->painter segment-list)
      (lambda (frame)
       (for-each
        (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
        segment-list)))
     #+END_SRC

     The segments are given using coordinates with respect to the unit
     square. For each segment in the list, the painter transforms the
     segment endpoints with the frame coordinate map and draws a line
     between the transformed points.

     Representing painters as procedures erects a powerful abstraction
     barrier in the picture language. We can create and intermix all
     sorts of primitive painters, based on a variety of graphics
     capabilities. The details of their implementation do not
     matter. Any procedure can serve as a painter, provided that it
     takes a frame as argument and draws something scaled to fit the
     frame.

     - Exercise 2.48. A directed line segment in the plane can be
       represented as a pair of vectors -- the vector running from the
       origin to the start-point of the segment, and the vector
       running from the origin to the end-point of the segment. Use
       your vector representation from exercise 2.46 to define a
       representation for segments with a constructor make-segment and
       selectors start-segment and end-segment.

       #+BEGIN_SRC scheme
       (define (make-segment start-seg end-seg)
         (cons start-seg end-seg))
       (define (start-segment seg)
        (car seg))
       (define (end-segment seg)
        (cdr seg))
       #+END_SRC

     - Exercise 2.49. Use segments->painter to define the following
       primitive painters:

       a. The painter that draws the outline of the designated frame

       #+BEGIN_SRC scheme
       (define outline (segments->painter 
                        (list (make-segment (make-vect 0 0) (make-vect 1 0))
                              (make-segment (make-vect 1 0) (make-vect 1 1))
                              (make-segment (make-vect 1 1) (make-vect 0 1))
                              (make-segment (make-vect 0 1) (make-vect 0 0)))))
       #+END_SRC

       b. The painter that draws an "X" by connecting opposite corners
       of the frame.

       #+BEGIN_SRC scheme
       (define x (segments->painter
                  (list (make-segment (make-vect 0 0) (make-vect 1 1))
                        (make-segment (make-vect 1 0) (make-vect 0 1)))))
       #+END_SRC

       c. The painter that draws a diamond shape by connecting the
       midpoints of the sides of the frame.

       #+BEGIN_SRC scheme
       (define diamond-painter (segments->painter
                                (list (make-segment (make-vect 0 0.5) (make-vect 0.5 1))
                                      (make-segment (make-vect 0.5 1) (make-vect 1 0.5))
                                      (make-segment (make-vect 1 0.5) (make-vect 0.5 0))
                                      (make-segment (make-vect 0.5 0) (make-vect 0 0.5)))))
       #+END_SRC

       d. The wave painter.
       NO.



**** Transforming and combining painters

     An operation on painters (such as flip-vert or beside) works by
     creating a painter that invokes the original painters with
     respect to frames derived from the argument frame. Thus, for
     example, flip-vert doesn't have to know how a painter works in
     order to flip it -- it just has to know how to turn a frame
     upside down: The flipped painter just uses the original painter,
     but in the inverted frame.
     
     Painter operations are based on the procedure transform-painter,
     which takes as arguments a painter and information on how to
     transform a frame and produces a new painter. The transformed
     painter, when called on a frame, transforms the frame and calls
     the original painter on the transformed frame. The arguments to
     transform-painter are points (represented as vectors) that
     specify the corners of the new frame: When mapped into the frame,
     the first point specifies the new frame's origin and the other
     two specify the ends of its edge vectors. Thus, arguments within
     the unit square specify a frame contained within the original
     frame.
     
     #+BEGIN_SRC scheme
     (define (transform-painter painter origin corner1 corner2)
      (lambda (frame)
       (let ((m (frame-coord-map frame)))
        (let ((new-origin (m origin)))
         (painter
          (make-frame new-origin
                      (sub-vect (m corner1) new-origin)
                      (sub-vect (m corner2) new-origin)))))))
     #+END_SRC

     Here's how to flip painter images vertically:

     #+BEGIN_SRC scheme
     (define (flip-vert painter)
      (transform-painter painter
                         (make-vect 0.0 1.0)
                         (make-vect 1.0 1.0)
                         (make-vect 0.0 0.0)))
     #+END_SRC


     Using transform-painter, we can easily define new
     transformations. For example, we can define a painter that
     shrinks its image to the upper-right quarter of the frame it is
     given:

     #+BEGIN_SRC scheme
     (define (shrink-to-upper-right painter)
      (transform-painter painter
                         (make-vect 0.5 0.5)
                         (make-vect 1.0 0.5)
                         (make-vect 0.5 1.0)))
     #+END_SRC

     Other transformations rotate images counterclockwise by 90
     degrees

     #+BEGIN_SRC scheme
     (define (roatete90 painter)
      (transform-painter painter
                         (make-vect 1.0 0.0)
                         (make-vect 1.0 1.0)
                         (make-vect 0.0 0.0)))
                         
     #+END_SRC

     or squash images towards the center of the frame:

     #+BEGIN_SRC scheme
     (define (squash-inwards painter)
      (transform-painter painter
                         (make-vect 0.0 0.0)
                         (make-vect 0.65 0.35)
                         (make-vect 0.35 0.65)))
     #+END_SRC

     Frame transformation is also the key to defining means of
     combining two or more painters. The beside procedure, for
     example, takes two painters, transforms them to paint in the left
     and right halves of an argument frame respectively, and produces
     a new, compound painter. When the compound painter is given a
     frame, it calls the first transformed painter to paint in the
     left half of the frame and calls the second transformed painter
     to paint in the right half of the frame:

     #+BEGIN_SRC scheme
     (define (beside painter1 painter2)
      (let ((split-point (make-vect 0.5 0.0)))
       (let ((paint-left
              (transform-painter painter1
                                 (make-vect 0.0 0.0)
                                 split-point
                                 (make-vect 0.0 1.0)))
             (paint-right
              (transform-painter painter2
                                 split-point
                                 (make-vect 1.0 0.0)
                                 (make-vect 0.5 1.0))))
        (lambda (frame)
         (paint-left frame)
         (paint-right frame)))))
     #+END_SRC

     Observe how the painter data abstraction, and in particular the
     representation of painters as procedures, makes beside easy to
     implement. The beside procedure need not know anything about the
     details of the component painters other than that each painter
     will draw something in its designated frame.

     - Exercise 2.50. Define the transformation flip-horiz, which
       flips painters horizontally, and transformations that rotate
       painters counterclockwise by 180 degrees and 270 degrees. 

       #+BEGIN_SRC scheme
       (define (flip-horiz painter)
        (transform-painter painter
                           (make-vect 1.0 0.0)
                           (make-vect 0.0 0.0)
                           (make-vect 1.0 1.0)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (rotate180 painter)
        (transform-painter
         painter
         (make-vect 1.0 1.0)
         (make-vect 0.0 1.0)
         (make-vect 1.0 0.0)))
       #+END_SRC
       
       #+BEGIN_SRC scheme
       (define (rotate270 painter)
        (transform-painter
         painter
         (make-vect 0.0 1.0)
         (make-vect 0.0 0.0)
         (make-vect 1.0 1.0)))
       #+END_SRC

     - Exercise 2.51. Define the below operation for painters. Below
       takes two painters as arguments. The resulting painter, given a
       frame, draws with the first painter in the bottom of the frame
       and with the second painter in the top. Define below in two
       different ways -- first by writing a procedure that is
       analogous to the beside procedure given above, and again in
       terms of beside and suitable rotation operations.

       #+BEGIN_SRC scheme
       (define (below painter1 painter2)
        (let ((mid (make-vect 0.0 0.5)))
         (let ((transformed-painter1
                (transform-painter painter1
                                   (make-vect 0.0 0.0)
                                   (make-vect 1.0 0.0)
                                   mid))
               (transformed-painter2
                (transform-painter painter2
                                   mid
                                   (make-vect 1.0 0.5)
                                   (make-vect 0.0 1.0))))
         (lambda (frame)
          (transformed-painter1 frame)
          (transformed-painter2 frame)))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (below2 painter1 painter2)
        (let ((beside-painters (beside (rotate270 painter1) (rotate270 painter2))))
         (lambda (frame)
          ((rotate90 beside-painters) frame))))
       #+END_SRC


**** Levels of language for robust design

     The picture language exercises some of the critical ideas we've
     introduced about abstraction with procedures and data. The
     fundamental data abstractions, painters, are implemented using
     procedural representations, which enables the language to handle
     different drawing capabilities in a uniform way. The means of
     combination satisfy the closure property, which permits us to
     easily build up complex designs. Finally, all the tools for
     abstracting procedures are available to us for abstracting means
     of combination for painters.

     We have also obtained a glimpse of another crucial idea about
     languages and program design. This is the approach of _stratified
     design_, the notion that a complex system should be structured as
     a sequence of levels that are described using a sequence of
     languages. Each level is constructed by combining parts that are
     regarded as primitive at that level, and the parts constructed at
     each level are used as primitives on the next level. The language
     used at each level of a stratified design has primitives, means
     of combination, and means of abstraction appropriate to that
     level of detail. 

     Stratified design pervades the engineering of complex
     systems. For example, in computer engineering, resistors and
     transistors are combined (and described using a language of
     analog circuits) to produce parts such as and-gates and or-gates,
     which form the primitives of a language for digital-circuit
     design. These parts are combined to build processors, bus
     structures, and memory systems, which are in turn combined to
     form computers, using languages appropriate to computer
     architecture. Computers are combined to form distributed systems,
     using languages appropriate for describing network
     interconnections, and so on.

     As a tiny example of stratification, our picture language uses
     primitive elements (primitive painters) that are created using a
     language that specifies points and lines to provide the lists of
     line segments for segments->painter, or the shading details for a
     painter like rogers. The bulk of our description of the picture
     language focused on combining these primitives, using geometric
     combiners such as beside and below. We also worked at a higher
     level, regarding beside and below as primitives to be manipulated
     in a language whose operations, such as square-of-four, capture
     common patterns of combining geometric combiners.

     Stratified design helps make programs _robust_, that is, it makes
     it likely that small changes in a specification will require
     correspondingly small changes in the program. For instance,
     suppose we wanted to change the image based on wave shown in
     figure 2.9. We could work at the lowest level to change the
     detailed appearance of the wave element; we could work at the
     middle level to change the way corner-split replicates the wave;
     we could work at the highest level to change how square-limit
     arranges the four copies of the corner. In general, each level of
     a stratified design provides a different vocabulary for
     expressing the characteristics of the system, and a different
     kind of ability to change it.

     - Exercise 2.52. Make changes to the square limit of wave shown
       in figure 2.9 by working at each of the levels described
       above. In particular:

       a. Add some segments to the primitive wave painter of exercise
       2.49 (to add a smile, for example).

       I didn't originally define the figure but here is a partial
       definition:
       
       #+BEGIN_SRC scheme
       (define wave
        (segments->painter
         (list (make-segment (make-vect 0.25 0.6)
                             (make-vect 0.20 0.7))
               (make-segment (make-vect 0.20 0.7)
                             (make-vect 0.15 0.55))
               (make-segment (make-vect 0.15 0.55)
                             (make-vect 0.0 0.8))
               (make-segment (make-vect 0.20 0.72)
                             (make-vect 0.15 0.71))
               (make-segment (make-vect 0.15 0.71)
                             (make-vect 0.0 0.83))
               (make-segment (make-vect 0.20 0.72)
                             (make-vect 0.30 0.72))
               (make-segment (make-vect 0.30 0.72)
                             (make-vect 0.25 0.9))
               (make-segment (make-vect 0.25 0.9)
                             (make-vect 0.30 1.0))
               (make-segment (make-vect 0.60 1.0)
                             (make-vect 0.65 0.9))
               (make-segment (make-vect 0.65 0.9)
                             (make-vect 0.30 0.72)))))
       #+END_SRC
       
       The SICP segments->painter method doesn't work in drracket so
       I'm leaving it at that.

       b. Change the pattern constructed by corner-split (for example,
       by using only one copy of the up-split and right-split images
       instead of two)

       #+BEGIN_SRC scheme
       (define (corner-split2 painter n)
        (if (= n 0)
            painter
            (let ((up (up-split painter (- n 1)))
                  (right (right-split painter (- n 1))))
             (beside (below painter up)
                     (below right (corner-split2 painter (- n 1)))))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (corner-split painter n)
        (if (= n 0)
            painter
            (let ((up (up-split painter (- n 1)))
                  (right (right-split painter (- n 1)))
                  (corner (corner-split painter (- n 1))))
             (beside (below painter (beside up up))
                     (below (below right right) corner)))))
       #+END_SRC

       c. Modify the version of square-limit that uses square-of-four
       so as to assemble the corners in a different pattern. (For
       example, you might make a big Mr. Rogers look outward from each
       corner of the square).

       original:
       #+BEGIN_SRC scheme
       (define (square-limit painter n)
        (let ((combine4 (square-of-four flip-horiz identity
                                        rotate180 flip-vert)))
         (combine4 (corner-split painter n))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (square-limit2 painter n)
        (let ((combine4 (square-of-four flip-horiz identity
                                        rotate180 flip-vert)))
         (combine4 (corner-split (flip-horiz painter) n))))
       #+END_SRC
     

     
** 2.3 Symbolic Data
   All the compound data objects we have used so far were constructed
   ultimately from numbers. In this section we extend the
   representational capability of our language by introducing the
   ability to work with arbitrary symbols as data.

*** 2.3.1 Quotation

    If we can form compound data using symbols, we can have lists such
    as

    #+BEGIN_SRC scheme
    (a b c d)
    (23 45 17)
    ((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
    #+END_SRC

    Lists containing symbols can look just like the expressions of our
    language:

    #+BEGIN_SRC scheme
    (* (+ 23 45) (+ x 9))
    (define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))
    #+END_SRC

    In order to manipulate symbols we need a new element in our
    language: the ability to _quote_ a data object. Suppose we want to
    construct the list (a b). We can't accomplish this with (list a
    b), because this expression constructs a list of the _values_ of a
    and b rather than the symbols themselves. This issue is well known
    in the context of natural languages, where words and sentences may
    be regarded either as semantic entities or as character strings
    (syntactic entities). The common practice in natural languages is
    to use quotation marks to indicate that a word or a sentence is to
    be treated literally as a string of characters. For instance, the
    first letter of "John" is clearly "J." If we tell somebody to "say
    your name aloud," we expect to hear that person's name. However,
    if we tell somebody to "say 'your name' aloud," we expect to hear
    the words "your name." Note that we are forced to nest quotation
    marks to describe what somebody else might say.

    We can follow this same practice to identify lists and symbols
    that are to be treated as data objects rather than as expressions
    to be evaluated. However, our format for quoting differs from that
    of natural languages in that we place a quotation mark
    (traditionally, the single quote symbol ') only at the beginning
    of the object to be quoted. We can get away with this in Scheme
    syntax because we rely on blanks and parentheses to delimit
    objects. Thus, the meaning of a single quote character is to quote
    the next object.

    Now we can distinguish between symbols and their values:

    #+BEGIN_SRC scheme
    (define a 1)
    (define b 2)
    (list a b)
    => (1 2)
    (list 'a 'b)
    => (a b)
    (list 'a b)
    => (a 2)
    #+END_SRC

    Quotation also allows us to type in compound objects, using the
    conventional printed representation for lists:

    #+BEGIN_SRC scheme
    (car '(a b c))
    a
    (cdr '(a b c))
    (b c)
    #+END_SRC

    In keeping with this, we can obtain the empty list by evaluating
    '(), and thus dispense with the variable nil.

    One additional primitive used in manipulating symbols is eq?,
    which takes two symbols as arguments and tests whether they are
    the same. Using eq?, we can implement a useful procedure called
    memq. This takes two arguments, a symbol and a list. If the symbol
    is not contained in the list (i.e. is not eq? to any item in the
    list), then memq returns false. Otherwise, it returns the sublist
    of the list beginning with the first occurrence of the symbol:

    #+BEGIN_SRC scheme
    (define (memq item x)
     (cond ((null? x) false)
           ((eq? item (car x)) x)
           (else (memq item (cdr x)))))
    #+END_SRC

    For example, the value of

    #+BEGIN_SRC scheme
    (memq 'apple '(pear banana prune))
    #+END_SRC

    is false, whereas the value of

    #+BEGIN_SRC scheme
    (memq 'apple '(x (apple sauce) y apple pear))
    #+END_SRC

    is (apple pear)

    - Exercise 2.53. What would the interpreter print in response to
      evaluating each of the following expressions?

      #+BEGIN_SRC scheme
      (list 'a 'b 'c)
      (list (list 'george))
      (cdr '((x1 x2) (y1 y2)))
      (cadr '((x1 x2) (y1 y2)))
      (pair? (car '(a short list)))
      (memq 'red '((red shoes) (blue socks)))
      (memq 'red '(red shoes blue socks))
      #+END_SRC

      #+BEGIN_SRC scheme
      (list 'a 'b 'c)
      => (a b c)
      (list (list 'george))
      => ((george))
      (cdr '((x1 x2) (y1 y2)))
      => ((y1 y2))
      (cadr '((x1 x2) (y1 y2)))
      (y1 y2)
      (pair? (car '(a short list)))
      false
      (memq 'red '((red shoes) (blue socks)))
      false
      (memq 'red '(red shoes blue socks))
      (red shoes blue socks)
      #+END_SRC

    - Exercise 2.54. Two lists are said to be equal? if they contain
      equal elements arranged in the same order. For example,

      #+BEGIN_SRC scheme
      (equal? '(this is a list) '(this is a list))
      #+END_SRC

      is true, but
      
      #+BEGIN_SRC scheme 
      (equal? '(this is a list) '(this (is a) list))
      #+END_SRC

      is false. To be more precise, we can define equal? recursively
      in terms of the basic eq? equality of symbols by saying that a
      and b are equal? if they are both symbols and the symbols
      are eq?, or if they are both lists such that (car a) is equal?
      to (car b) and (cdr a) is equal? to (cdr b). Using this idea,
      implement equal? as a procedure.

      #+BEGIN_SRC scheme
      (define (equal? a b)
       (cond
        ((and (null? a) (null? b)) true)
        ((or (and (null? a) (not (null? b)))
             (and (null? b) (not (null? a)))) false)
        ((and (pair? (car a)) (pair? (car b)))
         (and (equal? (car a) (car b))
              (equal? (cdr a) (cdr b))))
        ((eq? (car a) (car b)) (equal? (cdr a) (cdr b)))
        (else false)))
      #+END_SRC

    - Eva Lu Ator types to the interpreter the expression

      #+BEGIN_SRC scheme
      (car ''abracadabra)
      #+END_SRC scheme
      
      To her surprise, the interpreter prints back quote. Explain.

      Not that the book has given enough information for anyone to
      actually be able to know this, but ' is syntactic sugar for the
      syntactic symbol quote, which is like if in that it is specially
      looked for by the interpreter and is not an ordinary variable
      and cannot be defined as such. So ''abracadabra is the same as
      typing in (quote (quote abracadabra)), and the first quote
      symbol when seen by the interpreter 'quotes', e.g. does not
      interpret semantically, the entire expression inside it. Which
      is the list (quote abracadabra). So the return value of
      ''abracadabra is the list (quote abracadabra).


*** 2.3.2 Example: Symbolic Differentiation

    As an illustration of symbol manipulation and a further
    illustration of data abstraction, consider the design of a
    procedure that performs symbolic differentiation of algebraic
    expressions. We would like the procedure to take as arguments an
    algebraic expression and a variable and to return the derivative
    of the expression with respect to the variable. For example, if
    the arguments to the procedure are ax^2 + bx + c and x, the
    procedure should return 2ax + b. Symbolic differentiation is of
    special historical significance in Lisp. It was one of the
    motivating examples behind the development of a computer language
    for symbol manipulation. Furthermore, it marked the beginning of
    the line of research that led to the development of powerful
    systems for symbolic mathematical work, which are currently being
    used by a growing number of applied mathematicians and physicists.

    In developing the symbolic-differentiation program, we will follow
    the same strategy of data abstraction that we followed in
    developing the rational-number system of section 2.1.1. That is,
    we will first define a differentiation algorithm that operates on
    abstract objects such as "sums," "products," and "variables"
    without worrying about how these are to be represented.  Only
    afterward will we address the representation problem.

**** The differentiation program with abstract data

     In order to keep things simple, we will consider a very simple
     symbolic-differentiation program that handles expressions that
     are built up using only the operations of addition and
     multiplication with two arguments. Differentiation of any such
     expression can be carried out by applying the following reduction
     rules:

     \begin{fragment}
     \frac{dc}{dx} = 0 for c  a constant or a variable different from x
     \frac{dx}{dx} = 1
     \frac{d(u + v)}{dx} = \frac{du}{dx} + \frac{dv}{dx}
     \frac{d(uv)}{dx} = u(\frac{du}{dx}) + v(\frac{du}{dx})
     \end{fragment}

     Observe that the latter two rules are recursive in nature. That
     is, to obtain the derivative of a sum we first find the
     derivatives of the terms and add them. Each of the terms may in
     turn be an expression that needs to be decomposed. Decomposing
     into smaller and smaller pieces will eventually produce pieces
     that are either constants or variables, whose derivatives will be
     either 0 or 1.

     To embody these rules in a procedure we indulge in a little
     wishful thinking, as we did in designing the rational-number
     implementation. If we had a means for representing algebraic
     expressions, we should be able to tell whether an expression is a
     sum, a product, a constant, or a variable. We should be able to
     extract the parts of an expression. For a sum, for example we
     want to be able to extract the addend (first term) and the augend
     (second term). We should also be able to construct expressions
     from parts. Let us assume that we already have procedures to
     implement the following selectors, constructors, and predicates:

     #+BEGIN_SRC scheme
     (variable? e)              Is e a variable?
     (same-variable? v1 v2)     Are v1 and v2 the same variable?
     (sum? e)                   Is e a sum?
     (addend e)                 Addend of the sum e.
     (augend e)                 Augend of the sum e.
     (make-sum a1 a2)           Construct the sum of a1 and a2.
     (product? e)               Is e a product?
     (multiplier e)             Multiplier of the product e
     (multiplicand e)           Multiplicand of the product e.
     (make-product m1 m2)       Construct the product of m1 and m2.
     #+END_SRC

     Using these, and the primitive predicate number?, which
     identifies numbers, we can express the differentiation rules as
     the following procedure:

     #+BEGIN_SRC scheme
     (define (deriv exp var)
      (cond ((number? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                       (deriv (augend exp) var)))
            ((product? exp)
             (make-sum
              (make-product (multiplier exp)
                            (deriv (multiplicand exp) var))
              (make-product (deriv (multiplier exp) var)
                            (multiplicand exp))))
            (else
             (error "unknown expression type -- DERIV" exp))))
     #+END_SRC

     This deriv procedure incorporates the complete differentiation
     algorithm. Since it is expressed in terms of abstract data, it
     will work no matter how we choose to represent algebraic
     expressions, as long as we design a proper set of selectors and
     constructors. This is the issue we must address next.

**** Representing algebraic expressions.

     We can imagine many ways to use list structure to represent
     algebraic expressions. For example, we could use lists of symbols
     that mirror the usual algebraic notation, representing ax + b as
     the list (a * x + b). However, one especially straightforward
     choice is to use the same parenthesized prefix notation that Lisp
     uses for combinations; that is, to represent ax + b as (+ (* a x)
     b). Then our data representation for the differentiation problem
     is as follows:

     - The variables are symbols. They are identified by the primitive
       predicate symbol?.

       #+BEGIN_SRC scheme
       (define (variable? x) (symbol? x))
       #+END_SRC

     - Two variables are the same if the symbols representing them are
       eq?:

       #+BEGIN_SRC scheme
       (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2)))
       #+END_SRC

     - Sums and products are constructed as lists:

       #+BEGIN_SRC scheme
       (define (make-sum a1 a2) (list '+ a1 a2))
       (define (make-product m1 m2) (list '* m1 m2))
       #+END_SRC

     - A sum is a list whose first element is the symbol +:

       #+BEGIN_SRC scheme
       (define (sum? x)
        (and (pair? x) (eq? (car x) '+)))
       #+END_SRC

     - The addend is the second item of the sum list:

       #+BEGIN_SRC scheme
       (define (addend s) (cadr s))
       #+END_SRC

     - The augend is the third item of the sum list:

       #+BEGIN_SRC scheme
       (define (augend s) (caddr s))
       #+END_SRC

     - A product is a list whose first element is the symbol *:

       #+BEGIN_SRC scheme
       (define (product? x)
        (and (pair? x) (eq? (car x) '*)))
       #+END_SRC

     - The multiplier is the second item of the product list:

       #+BEGIN_SRC scheme
       (define (multiplier p) (cadr p))
       #+END_SRC

     - The multiplicand is the third item of the product list:

       #+BEGIN_SRC scheme
       (define (multiplicand p) (caddr p))
       #+END_SRC


     Thus, we only need to combine these with the algorithm as
     enbodied by deriv to have a working symbolic-differentiation
     program. Let us look at some examples of its behavior:

     #+BEGIN_SRC scheme
     (deriv '(+ x 3) 'x)
     => (+ 1 0)
     (deriv '(* x y) 'x)
     => (+ (* x 0) (* 1 y))
     (deriv '(* (* x y) (+ x 3)) 'x)
     => (+ (* (* x y) (+ 1 0))
           (* (+ (* x 0) (* 1 y))
              (+ x 3)))
     #+END_SRC

     The program produces answers that are correct; however, they are
     unsimplified. It is true that 


     d(xy)/dx = x * 0 + 1* y

     but we would like the program to know that x * 0 = 0, 1 * y = y,
     and 0 + y = y. The answer for the second example should have been
     simply y. As the third example shows, this becomes a serious
     issue when the expressions are complex.

     Our difficulty is much like the one we encountered with the
     rational-number implementation: we haven't reduced answers to
     simplest form. To accomplish the rational-number reduction, we
     need to change only the constructors and the selectors of the
     implementation. We can adopt a similar strategy here. We won't
     change deriv at all. Instead, we will change make-sum so that if
     both summands are numbers, make-sum will add them and return
     their sum. Also, if one of the summands is 0, then make-sum will
     return the other summand.

     #+BEGIN_SRC scheme
     (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2)))
     #+END_SRC

     This uses the procedure =number?, which checks whether an
     expression is equal to a given number:

     #+BEGIN_SRC scheme
     (define (=number? exp num)
      (and (number? exp) (= exp num)))
     #+END_SRC

     Similarly, we will change make-product to build in the rules that
     0 times anything is 0 and 1 times anything is the thing itself:

     #+BEGIN_SRC scheme
     (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))
     #+END_SRC

     Here is how this version works on our three examples:

     #+BEGIN_SRC scheme
     (deriv '(+ x 3) 'x)
     1
     (deriv '(* x y) 'x)
     y
     (deriv '(* (* x y) (+ x 3)) 'x)
     (+ (* x y) (* y (+ x 3)))
     #+END_SRC

     Although this is quite an improvement, the third example shows
     that there is still a long way to go before we get a program that
     puts expressions into a form that we might agree is "simplest."
     The problem of algebraic simplification is complex because, among
     other reasons, a form that may be simplest for one purpose may
     not be for another.

     - Exercise 2.56. Show how to extend the basic differentiator to
       handle more kinds of expressions. For instance, implement the
       differentiation rule

       d(u^n)/dx = n * u^(n-1)(du/dx)

       by adding a new clause to the deriv program and defining
       appropriate procedures exponentiation?, base, exponent, and
       make-exponentiation. (You may use the symbol ** to denote
       exponentiation.) Build in the rules that anything raised to the
       power 0 is 1 and anything raised to the power 1 is the thing
       itself.

       #+BEGIN_SRC scheme
       (define (deriv exp var)
        (cond
         ((number? exp) 0)
         ((variable? exp)
          (if (same-variable? exp var) 1 0))
         ((sum? exp)
          (make-sum
           (deriv (addend exp) var)
           (deriv (augend exp) var)))
         ((product? exp)
          (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
         ((and (exponentiation? exp)
               (number? (exponent exp)))
          (make-product
           (make-product
            (exponent exp)
            (make-exponent
             (base exp)
             (- (exponent exp) 1)))
           (deriv (base exp) var)))
         (else
          (error "unknown expression type -- DERIV" exp))))
 
       (define (make-exponent base exponent)
        (cond 
         ((=number? base 0) 0)
         ((=number? exponent 0) 1)
         ((=number? exponent 1) base)
         (else
          (list '** base exponent))))
       (define (base exponent)
        (cadr exponent))
       (define (exponent exponent)
        (caddr exponent))
       (define (exponentiation? exp)
        (and (symbol? (car exp))
             (eq? (car exp) '**)))
       #+END_SRC

     - Exercise 2.57. Extend the differentiation program to handle
       sums and products of arbitrary numbers of (two or more)
       terms. Then the last example above could be expressed as

       #+BEGIN_SRC scheme
       (deriv '(* x y (+ x 3)) 'x)
       #+END_SRC

       Try to do this by changing only the representation for sums and
       products, without changing the deriv procedure at all. For
       example, the addend of a sum would be the first term, and the
       augend would be the sum of the rest of the terms.

       #+BEGIN_SRC scheme
       (define (addend exp)
        (cadr exp))
       (define (augend exp)
        (cond
         ((= (length exp) 3)
          (caddr exp))
         (else
         (cons '+ (cddr exp)))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (multiplicand exp)
        (cadr exp))
       (define (multiplier exp)
        (cond
         ((= (length exp) 3)
          (caddr exp))
         (else (cons '* (cddr exp)))))
       #+END_SRC

     - Exercise 2.58. Suppose we want to modify the differentiation
       program so that it works with ordinary mathematical notation,
       in which + and * are infix rather than prefix operators. Since
       the differentiation program is defined in terms of abstract
       data, we can modify it to work with different representations
       of expressions solely by changing the predicates, selectors,
       and constructors that define the representation of the
       algebraic expressions on which the differentiator is to
       operate.

       a. Show how to do this in order to differentiate algebraic
       expressions presented in infix form, such as (x + (3 * (x +
       (y + 2)))). To simplify the task, assume that + and * always
       take two arguments and that expressions are fully
       parenthesized.

       If each only takes two arguments, it's pretty easy.
       
       #+BEGIN_SRC scheme
       (define (triple-symbol-predicate insym)
        (lambda (expr)
         (and
          (pair? expr)
          (= (length expr) 3)
          (symbol? (cadr expr))
          (eq? (cadr expr) insym))))

       (define (make-sum x y)
        (cond
         ((=number? x 0) y)
         ((=number? y 0) x)
         ((and (number? x) (number? y)) (+ x y))
         (else
         (list x '+ y))))
       (define sum? (triple-symbol-predicate '+))
       (define (addend expr)
        (car expr))
       (define (augend expr)
        (caddr expr))

       (define (make-product x y)
        (cond 
         ((or (=number? x 0) (=number? y 0)) 0)
         ((=number? x 1) y)
         ((=number? y 1) x)
         ((and (number? x) (number? y)) (* x y))
         (else
          (list x '* y))))
       (define product? (triple-symbol-predicate '*))
       (define (multiplier expr)
        (car expr))
       (define (multiplicand expr)
        (caddr expr))

       (define (make-exponent base power)
        (cond
         ((=number? power 1) base)
         ((=number? power 0) 1)
         ((=number? base 1) 1)
         ((=number? base 0) 0)
         (else
          (list base '** power))))

       (define exponentiation? (triple-symbol-predicate '**))
       (define (base expr)
        (car expr))
       (define (exponent expr)
        (caddr expr))
       #+END_SRC

       The problem becomes substantially harder if we allow standard
       algebraic notation, such as (x + 3 * (x + y + 2)), which drops
       unnecessary parentheses and assumes that multiplication is done
       before addition. Can you assign appropriate predicates,
       selectors, and constructors for this notation such that our
       derivative program still works?

       When we take an expression, we need to search for the
       lowest-precedence operator in the top-level list, take the
       entire left-hand side as the first part of the
       expression/operation, and the right hand side as the other
       part. So it will require some searching. The predicates will be
       difficult because of this but the rest isn't anything we've
       seen before. At first we'll just leave the make-sum &c as the same.
       
       #+BEGIN_SRC scheme
       (define (get-left-arg-of-oper oper)
        (define (compile-all-left-of-expr expr)
         (cond
          ((and (pair? expr)
                (symbol? (car expr))
                (eq? (car expr) oper))
           '())
          ((pair? expr)
           (cons (car expr)
                 (compile-all-left-of-expr (cdr expr))))
          (else 
           (error 
            "Cannot take the left hand of this expr -- COMPILLE-ALL-LEFT-OF-EXPR"
            expr))))
          (define (get-left-hand-expression expr)
           (let ((left-of (compile-all-left-of-expr expr)))
            (cond
             ((= (length left-of) 1) (car left-of))
             (else left-of))))
          get-left-hand-expression)


       (define (get-right-arg-of-oper oper)
        (lambda (expr) 
         (let ((right-of (cdr (memq oper expr))))
          (if (= (length right-of) 1) (car right-of) right-of))))

       (define (sum? expr)
        (and (pair? expr) (pair? (memq '+ expr))))

       (define addend (get-left-arg-of-oper '+))

       (define augend (get-right-arg-of-oper '+))

       (define (product? expr)
        (and (pair? expr)
             (not (sum? expr))
             (pair? (memq '* expr))))
       (define multiplicand (get-left-arg-of-oper '*))
       (define multiplier (get-right-arg-of-oper '*))

       (define (exponentiation? expr)
        (and (pair? expr)
             (not (sum? expr))
             (not (product? expr))
             (pair? (memq '** expr))))
       (define base (get-left-arg-of-oper '**))
       (define exponent (get-right-arg-of-oper '**))
       #+END_SRC

       This solution appears to work for the operations we've
       defined. Basically you just have to take an expression list and
       use the lowest-precedence operator as the operator that we are
       applying a derivation rule to. Next we have to redefine
       constructors to eliminate unecessary parens. Because we can
       parse out the differences between * and +, we don't need to
       discriminate these. When should we keep parens, when creating a
       sum or multiplication?

       When creating a multiplication from two sums, we need to
       parenthesize the two sums, so

       #+BEGIN_SRC scheme
       (make-product '(1 + 2 + 3) '(x + y))
       => '((1 + 2 + 3) * (x + y))
       #+END_SRC
       
       When making a sum, we don't need to bother because it has the
       lowest operator precedence. It doesn't matter the order you add
       things in. But for exponentiation we again need to check:

       #+BEGIN_SRC scheme
       (make-exponentiation '(1 + 3 + x) 5)
       => '((1 + 3 + x) ** 5)
       (make-exponentiation 'x '(x + 5))
       => '(x ** '(x + 5))
       (make-exponentiaton '(5 * x) '(6 * x))
       => '((5 * x) ** (6 * x))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (make-sum x y)
        (cond
         ((=number? x 0) y)
         ((=number? y 0) x)
         ((and (number? x) (number? y)) (+ x y))
         ((and (pair? x) (pair? y))
          (append x '(+) y))
         (else (list x '+ y))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (make-product x y)
        (cond 
         ((or (=number? x 0) (=number? y 0)) 0)
         ((=number? x 1) y)
         ((=number? y 1) x)
         ((and (number? x) (number? y)) (* x y))
         ((and (pair? x) 
               (pair? y)
               (not (sum? x))
               (not (sum? y)))
          (append x '(*) y))
         ((and (pair? x)
               (not (pair? y))
               (not (sum? x)))
          (append x '(*) (list y)))
         ((and (pair? x)
               (pair? y)
               (not (sum? x))
               (sum? y))
          (append x '(*) (list y)))
         (else
          (list x '* y))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (make-exponent base power)
        (cond
         ((=number? power 1) base)
         ((=number? power 0) 1)
         ((=number? base 1) 1)
         ((=number? base 0) 0)
         ((and (exponentiation? base)
               (exponentiation? power))
          (append base '(**) power))
         ((exponentiation? base)
          (append base '(**) (list power)))
         ((exponentiation? power)
          (append (list base) '(**) power))
         (else
          (list base '** power))))
       #+END_SRC
     
*** 2.3.3 Example: Representing sets

    In the previous examples we built representations for two kinds of
    compound data objects: rational numbers and algebraic
    expressions. In one of these examples we had the choice of
    simplifying (reducing) the expressions at either construction time
    or selection time, but other than that the choice of a
    representation for these structures in terms of lists was
    straightforward. When we turn to the representation of sets, the
    choice of a representation is not so obvious. Indeed, there are a
    number of possible representations and they differ significantly
    from one another in several ways.

    Informally, a set is simply a collection of distinct objects. To
    give a more precise definition we can employ the method of data
    abstraction. That is, we define "set" by specifying the operations
    that are to be used on sets. These are union-set,
    intersection-set, element-of-set?, and adjoin-set. Element-of-set?
    is a predicate that determines whether a given element is a member
    of a set. Adjoin-set takes an object and a set as arguments and
    returns a set that contains the elements of the original set and
    also the adjoined element. Union-set computes the union of two
    sets, which is the set containing each element that appears in
    either argument. Intersection-set computes the intersection of two
    sets, which is teh set containing only elements that appear in
    both arguments. From the viewpoint of data abstraction, we are
    free to design any representation that implements these operations
    in a way consistent with the interpretations given above.

**** Sets as unordered lists

     One way to represent a set is as a list of its elements in which
     no element appears more than once. The empty set is represented
     by the empty list. In this representation, element-of-set? is
     similar to the procedure memq of section 2.3.1. It uses equal?
     instead of eq? so that the set elements need not be symbols:

     #+BEGIN_SRC scheme
     (define (element-of-set? x set)
      (cond ((null? set) false)
            ((equal? x (car set)) true)
            (else (element-of-set? x (cdr set)))))
     #+END_SRC

     Using this, we can werite adjoin-set. If the object to be
     adjoined is already in the set, we just return the
     set. Otherwise, we use cons to add the object to the list that
     represents the set:

     #+BEGIN_SRC scheme
     (define (adjoin-set x set)
      (if (element-of-set? x set)
          set
          (cons x set)))
     #+END_SRC

     For intersection-set we can use a recursive strategy. If we know
     how to form the intersection of set2 and the cdr of set1, we only
     need to decide whether to include the car of set1 in this. But
     this depends on whether (car set1) is also in set2. Here is the
     resulting procedure:

     #+BEGIN_SRC scheme
     (define (intersection-set set1 set2)
      (cond ((or (null? set1) (null? set2)) '())
            ((element-of-set? (car set1) set2)
             (cons (car set1) (intersection-set (cdr set1) set2)))
            (else (intersection-set (cdr set1) set2))))
     #+END_SRC

     In designing a representation, one of the issues we should bec
     concerned with is efficiency. Consider the number of steps
     required by our set operations. Since they all use
     element-of-set?, the speed of this operation has a major impact
     on the efficiency of the set implementation as a whole. Now, in
     order to check whether an object is a member of a set,
     element-of-set? may have to scan the entire set. (In the worst
     case, the object turns out not to be in the set.) Hence, if the
     set has n elements, element-of-set? might take up to n
     steps. Thus, the number of steps required grows as O(n). The
     number of steps required by adjoin-set, which uses this
     operation, also grows as O(n). For intersection-set, which does
     an element-of-set? check for each element of set1, the number of
     steps required grows as the product of sizes of the sets
     involved, or O(n^2) for two sets of size n. The same will be true
     of union-set.

     - Exercise 2.59. Implement the union-set operation for the
       unordered-list representation of sets.

       #+BEGIN_SRC scheme
       (define (union-set set1 set2)
        (cond 
         ((null? set1) set2)
         (else 
          (let ((rest-of-union (union-set (cdr set1) set2)))
           (if (not (element-of-set? (car set1) rest-of-union))
               (cons (car set1) rest-of-union)
               rest-of-union)))))
       #+END_SRC

     - Exercise 2.60. We specified that a set would be represented as
       a list with no duplicates. Now suppose we allow duplicates. For
       instance, the set {1, 2, 3} could be represented as the list (2
       3 2 1 3 2 2). Design procedures element-of-set?, adjoin-set,
       union-set, and intersection-set that operate on this
       representation. How does the efficiency of each compare with
       the corresponding procedure for teh non-duplicate
       representation? Are there applications for which you would use
       this representation in preference to the non-duplicate one?

       elment-of-set? doesn't have to be changed. adjoin-set doesn't
       _have_ to be changed but _can_ become:

       #+BEGIN_SRC scheme
       (define (adjoin-set x set)
        (cons x set))
       #+END_SRC

       union-set can literally be an alias of append
       #+BEGIN_SRC scheme
       (define union-set append)
       #+END_SRC

       intersection-set doesn't have to be changed at all. If there
       was some application that was mostly adjoin-set and union-set
       with relatively few calls to elelment-of-set? then this
       duplicate version would be faster.

**** Sets as ordered lists

     One way to speed up our set operations is to change the
     representation so that the set elements are listed in increasing
     order. To do this, we need some way to compare two objects so
     that we can say which is bigger. For example, we could compare
     symbols lexicographically, or we could agree on some method for
     assigning a unique number to an object and then compare the
     elements by comparing the corresponding numbers. To keep our
     discussion simple, we will consider only the case where the set
     elements are numbers, so that we can compare elements using > and
     <. We will represent a set of numbers by listing its elements in
     increasing order. Whereas our first representation above allowed
     us to represent the set {1, 3, 6, 10} by listing the elements in
     any order, our new representation allows only the list (1 3 6
     10). 

     One advantage of ordering shows up in element-of-set?: In
     checking for the presence of an item, we no longer have to scan
     the entire set. If we reach a set element that is larger than the
     item we are looking for, then we know that the item is not in the
     set:

     #+BEGIN_SRC scheme
     (define (element-of-set? x set)
      (cond ((null? set) false)
            ((= x (car set)) true)
            ((< x (car set)) false)
            (else (element-of-set? x (cdr set)))))
     #+END_SRC

     How many steps does this save? In the worst case, the item we are
     looking for may be the largest one in the set, so the number of
     steps is the same as for the unordered representation. On the
     other hand, if we search for items of many different sizes we can
     expect that sometimes we will be able to stop searching at a
     point near the beginning of the list and that other times we will
     still need to examine most of the list. On the average we should
     expect to have to examine about half of the items in the
     set. Thus, the average number of steps required will be about
     n/2. This is still O(n) growth, but it does save us, on the
     average, a factor off 2 in number of steps over the previous
     implementation.

     We obtain a more impressive speedup with intersection-set. In the
     unordered representation this operation required O(n^2) steps,
     because we performed a complete scan of set2 for each element of
     set1. But with the ordered representation, we can use a more
     clever method. Begin by comparing the initial elements, x1 and
     x2, of the two sets. If x1 equals x2, then that gives an element
     of the intersection, and the rest of the intersection is the
     intersection of the cdrs of the two sets. Suppose, however, that
     x1 is less than x2. Since x2 is the smallest element in set2, we
     can immediately conclude that x1 cannot appear anywhere in set2
     and hence is not in the intersection. Hence, the intersection is
     equal to the intersection of set2 with the cdr of
     set1. Similarly, if x2 is less than x1, then the intersection is
     given by teh intersection of set1 with the cdr of set2. Here is
     the procedure:

     #+BEGIN_SRC scheme
     (define (intersection-set set1 set2)
      (cond
       ((or (null? set1) (null? set2)) '())
       (else (let ((x1 (car set1)) (x2 (car set2)))
              (cond
               ((= x1 x2)
                (cons x1 (intersection-set (cdr set1) (cdr set2))))
               ((< x1 x2) 
                (intersection-set (cdr set1) set2))
               ((< x2 x1) 
                (intersection-set set1 (cdr set2))))))))
     #+END_SRC

     To estimate the number of steps required by this process, observe
     that at each step we reduce the intersection problem to computing
     intersections of smaller sets -- removing the first element from
     set1 or set2 or both. Thus, the number of steps required is at
     most the sum of the sizes of set1 and set2, rather than the
     product of the sizes as with the unordered representation. This
     is O(n) growth rather than O(n^2) -- a considerable speedup, even
     for sets of moderate size.

     - Exercise 2.61. Given an implementation of adjoin-set using the
       ordered representation. By analogy with element-of-set? show
       how to take advantage of the ordering to produce a procedure
       that requires on average about half as many steps as with the
       unordered representation.

       #+BEGIN_SRC scheme
       (define (adjoin-set x set)
        (cond
         ((null? set) (list x))
         ((< x (car set)) (cons x set))
         (else (cons (car set) (adjoin-set x (cdr set))))))
       #+END_SRC

       Similar to element-of-set?, we look at each element on the list
       and see if the element to be inserted, x, is less than the
       first element of the set. If so, then the new set is a list
       starting with x and having the original input set as the rest
       of the set, (cons x set). Otherwise, we have a way to go and
       insert x into the subset of the rest of the list, adding on the
       first element. Because we can expect that when inserting
       elements into the list, some are going to be near the
       beginning, although in the worst case we traverse the whole
       set, (O(n))we can expect that on average some are near the
       beginning and we get O(n/2).

     - Exercise 2.62. Give a O(n) implementation of union-set for sets
       represented as ordered lists.

       #+BEGIN_SRC scheme
       (define (union-set set1 set2)
        (cond
         ((null? set1) set2)
         ((null? set2) set1)
         (else (let ((x1 (car set1)) 
                     (x2 (car set2)))
                (cond
                  ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                  ((< x1 x2)
                   (let ((rest-of-union (union-set (cdr set1) set2)))
                    (if (= x1 (car rest-of-union)) 
                        rest-of-union
                        (cons x1 rest-of-union))))
                  ((< x2 x1)
                   (let ((rest-of-union (union-set set1 (cdr set2))))
                    (if (= x2 (car rest-of-union))
                        rest-of-union
                        (cons x2 rest-of-union)))))))))  
       #+END_SRC

**** Sets as binary trees
     We can do better than the ordered-list representation by
     arranging the set elements in the form of a tree. Each node of
     the tree holds one element of the set, called the "entry" at that
     onde, and a link to each of the two other (possibly empty)
     nodes. The "left" link points to elements smaller than the node,
     and the "right" link to elements greater than the one at the
     node. Figure 2.16 shows some trees that represent teh set {1, 3,
     5, 7, 9, 11}. The same set may be represented by a tree in a
     number of different ways. The only thing we require for a valid
     representation is that all elements in the left subtree be
     smaller than the node entry and that all elements in the right
     subtree be larger.

     The advantage of the tree representation is this: Suppose we want
     to check whether a number _x_ is contained in a set. We begin by
     comparing x with the entry in the top node. If x is less than
     this, we know that we need only search the left subtree; if x is
     greater, we need only search the right subtree. Now, if the tree
     is "balanced", each of these subtrees will be about half the size
     of the original. Thus, in one step we have reduced the problem of
     searching a tree of size n to searching a tree of size n/2. Since
     the size of the tree is halved at each step, we should expect
     that the number of steps needed to search a tree of size n grows
     as O(log n). For large sets, this will be a significant speedup
     over the previous representations.

     We can represent trees by using lists. Each node will be a list
     of three items: the entry at the node, the left subtree, and the
     right subtree. A left or right subtree of the empty list will
     indicate that there is no subtree connected there. We can
     describe this representation with the following procedures:

     #+BEGIN_SRC scheme
     (define (entry tree) (car tree))
     (define (left-branch tree) (cadr tree))
     (define (right-branch tree) (caddr tree))
     (define (make-tree entry left right)
      (list entry left right))
     #+END_SRC

     Now we can write the element-of-set? procedure using the strategy
     described above:

     #+BEGIN_SRC scheme
     (define (element-of-set? x set)
      (cond ((null? set) false)
            ((= x (entry set)) true)
            ((< x (entry set))
             (element-of-set? x (left-branch set)))
            ((> x (entry set))
             (element-of-set? x (right-branch set)))))
     #+END_SRC

     Adjoining an item to a set is implemented similarly and also
     requires O(log n) steps. To adjoin an item x, we compare x with
     the node entry to determine whether x should be added to the
     right or to the left branch, and having adjoined x to the
     appropriate branch we piece this newly constructed branch
     together with the original entry and the other branch. If x is
     equal to the entry, we just return the node. If we are asked to
     adjoin x to an empty tree, we generate a tree that has x as the
     entry and empty left and right branches. Here is the procedure:
     
     #+BEGIN_SRC scheme
     (define (adjoin-set x set)
      (cond ((null? set) (make-tree x '() '()))
            ((= x (entry set)) set)
            ((< x (entry set))
             (make-tree (entry set)
                        (adjoin-set x (left-branch set))
                        (right-branch set)))
            ((> x (entry set))
             (make-tree (entry set)
                        (left-branch set)
                        (adjoin-set x (right-branch set))))))
     #+END_SRC

     The above claim that searching the tree can be performed in a
     logarithmic number of steps rets on the assumption that the tree
     is "balanced," i.e. that the left and right subtree of every tree
     have approximately the same number of elements, so that each
     subtree contains about half the elements of its parent. But how
     can we be certain that ther trees we construct will be balanced?
     Even if we start with a balanced tree, adding elements with
     adjoin-set may produce an unbalanced result. Since the position
     of a newly adjoined element depends on how the element compares
     with the items already in the set, we can expect that if we add
     elements "randomly" the tree will tend to be balanced on the
     average. But this is not a guarantee. For example, if we start
     with an empty set and adjoin the numbers 1 through 7 in sequence
     we end up with the highly unbalanced tree shown in figure
     2.17. In this tree all the left subtrees are empty, so it has no
     advantage over a simple ordered list. One way to solve this
     problem is to define an operation that transforms an arbitrary
     tree into a balanced tree with the same elements. Then we can
     perform this transformation after every few adjoin-set operations
     to keep our set in balance. There are also other ways to solve
     this problem, most of which involve designing new data structures
     for which searching and insertion both can be done in O(log n)
     steps.

     - Exercise 2.63. Each of the following two procedures converts a
       binary tree to a list.

       #+BEGIN_SRC scheme
       (define (tree->list-1 tree)
        (if (null? tree)
            '()
            (append (tree->list-1 (left-branch tree))
                    (cons (entry tree)
                          (tree->list-1 (right-branch tree))))))
       (define (tree->list-2 tree)
        (define (copy-to-list tree result-list)
         (if (null? tree)
             result-list
             (copy-to-list (left-branch tree)
                           (cons (entry tree)
                                 (copy-to-list (right-branch tree)
                                               result-list)))))
        (copy-to-list tree '()))
       #+END_SRC

       a. Do the two procedures produce the same result for every
       tree? If not, how do the results differ? What lists do the two
       procedures produce for the trees in figure 2.16?
       
       Yes, they produce the same result, the tree elements, then the
       element, then the leftmost tree, recursively. This results in a
       sorted list. The figures in 2.16 become:

       (1 3 5 7 9 11)

       each time for all invocations.

       b. Do the two procedures have the same order of growth in the
       number of steps required to convert a balanced tree with _n_
       elements to a list? If not, which one grows more slowly?

       No, the first one grows more quickly. append is an O(n)
       procedure. For very large sets you end up with something that
       is roughly O(n log n), because you are appending on each recursive
       call, but appending a data set that halves. The second is only
       O(n).

     - Exercise 2.64. The following procedure list->tree converts an
       ordered list to a balanced binary tree. The helper procedure
       partial-tree takes as arguments an integer _n_ and a list of at
       least _n_ elements and constructs a balanced tree containing
       the first n elements of the list. The result returned by
       partial-tree is a pair (formed with cons) whose car is the
       constructed tree and whose cdr is the list of elements not
       included in the tree.

       #+BEGIN_SRC scheme
       (define (list->tree elements)
        (car (partial-tree elements (length elements))))
       (define (partial-tree elts n)
        (if (= n 0)
            (cons '() elts)
            (let ((left-size (quotient (- n 1) 2)))
             (let ((left-result (partial-tree elts left-size)))
              (let ((left-tree (car left-result))
                    (non-left-elts (cdr left-result))
                    (right-size (- n (+ left-size 1))))
               (let ((this-entry (car non-left-elts))
                     (right-result (partial-tree 
                                    (cdr non-left-elts) right-size)))
                (let ((right-tree (car right-result))
                      (remaining-elts (cdr right-result)))
                 (cons (make-tree this-entry left-tree right-tree)
                       remaining-elts))))))))
       #+END_SRC

       This is an O(n) algorithm. You recursively calculate sizes of
       subtrees and get the left subtree from the algorithm first. It
       will return a subtree and a list of elements you haven't
       consumed yet. You then take that extra list, the first element
       is taken to be your root, and the rest of these will form the
       right subtree. Recursively call the same algorithm on the right
       subtree and make a tree out of those three elements.

     - Exercise 2.65 Use the results of exercises 2.63 and 2.64 to
       give O(n) implementations of union-set and intersection-set for
       sets implemented as (balanced) binary trees.
     
       #+BEGIN_SRC scheme
       (define (union-set set1 set2)
         (define (merge-lists list1 list2)
           (cond
            ((null? list1) list2)
            ((null? list2) list1)
            (else
             (let ((x1 (car list1))
                   (x2 (car list2)))
              (cond
               ((= x1 x2)
                (cons x1 (merge-lists (cdr list1) (cdr list2))))
               ((< x1 x2)
                (cons x1 (merge-lists (cdr list1) list2)))
               ((< x2 x1)
                (cons x2 (merge-lists list1 (cdr list2)))))))))
         (let ((list1 (tree->list set1))
               (list2 (tree->list set2)))
          (list->tree (merge-lists list1 list2))))

       (define (intersection-set set1 set2)
        (define (intersection-sorted-list l1 l2)
         (cond
          ((or (null? l1) (null? l2)) '())
          (else
           (let ((x1 (car l1))
                 (x2 (car l2)))
            (cond
             ((= x1 x2) (cons x1 (intersection-sorted-list (cdr l1) (cdr l2))))
             ((< x1 x2) (intersection-sorted-list (cdr l1) l2))
             ((< x2 x1) (intersection-sorted-list l1 (cdr l2))))))))
        (let ((list1 (tree->list set1))
              (list2 (tree->list set2)))
         (list->tree (intersection-sorted-list list1 list2))))
       #+END_SRC

       Intersection-set has O(n) steps. The first is to convert the
       two trees to lists, the second is to merge the lists, the third
       is to convert back to a tree. Each step is O(n) so the whole
       thing is O(n). Union-set works in almost exactly the same way,
       except we always cons back onto a list; using an un-modified
       merge-list algorithm, which is O(n). There are again a total of
       four O(n) operations, one for each list, one for amerge, and
       another for converting back into a tree.
     
**** Sets and information retrieval

     We have examined options for using lists to represent sets and
     have seen how the choice of representation for a data object can
     have a large impact on the performance of the programs that use
     the data. Another reason for concentrating on sets is that the
     techniques discussed here appear again and again in applications
     involving information retrieval.

     Consider a data base containing a large number of individual
     records, such as the personnel files for a company or the
     transactions in an accounting system. A typical data-management
     system spends a large amount of time accessing or modifying the
     data in the records and therefore requires an efficient method
     for accessing records. This is done by identifying a part of each
     record to serve as an identifying _key_. A key can be anything
     that uniquely identifies the record. For a personnel file, it
     might be an employee's ID number. For an accounting system, it
     might be a transaction number. Whatever the key is, when we
     define the record as a data structure we should include a key
     selector procedure that retrieves the key associated with a given
     record.

     Now we represent the data base as a set of records. To locate a
     record with a given key we use a procedure lookup, which takes as
     arguments a key and a data base and which returns the record that
     has that key, or false if there is no such record. Lookup is
     implemented in almost the same way as element-of-set?. For
     example, if the set of records is implemented as an unordered
     list, we could use

     #+BEGIN_SRC scheme
     (define (lookup given-key set-of-records)
      (cond ((null? set-of-records) false)
            ((equal? given-key (key (car set-of-records)))
             (car set-of-records))
            (else (lookup given-key (cdr set-of-records)))))
     #+END_SRC

     Or course, there are better ways to represent large sets than as
     unordered lists. Information-retrieval systems in which records
     have to be "randomly accessed" are typically implemented by a
     tree-based method, such as a binary-tree representation discussed
     previously. In designing such a system the methodology of data
     abstraction can be a great help. The designer can create an
     initial implementation using a simple, straightforward
     representation such as unordered lists. This will be unsuitable
     for the eventual system, but it can be useful in providing a
     "quick and dirty" data base with which to test the rest of the
     system. Later on, the data representation can be modified to be
     more sophisticated. If the data base is accessed in terms of
     abstract selectors and constructors, this change in
     representation will not require any changes to the rest of the
     system.

     - Exercise 2.66. Implement the lookup procedure for the case
       where the set of records is structured as a binary tree,
       ordered by the numerical values of the keys.
       
       #+BEGIN_SRC scheme
       (define (lookup given-key tree-of-records)
        (cond ((null? tree-of-records) false)
              ((equal? given-key (key (entry tree-of-records)))
               (entry tree-of-records))
              ((< given-key (key (entry tree-of-records)))
               (lookup given-key (left-branch tree-of-records)))
              (else (lookup given-key (right-branch tree-of-records)))))
       #+END_SRC

*** 2.3.4 Example: Huffman Encoding Trees

    This section provides practice in the use of list structure and
    data abstraction to manipulate sets and trees. The application is
    to methods for representing data as sequences of ones and zeros
    (bits). For example, the ASCII standard code used to represent
    text in computers encodes each character as a sequence of seven
    bits. Using seven bits allows us to distinguish 2^7, or 128,
    possible different characters. In general, if we want to
    distinguish n different symbols, we will use log2(n) bits per
    symbol. If all our messages are made up of eight symbols A, B, C,
    D, E, F, G, and H, we can choose a code with three bits per
    character, for example

    A 000 C 010 E 100 G 110
    B 001 D 011 F 101 H 111
      
    With this code, the message

    BACADAEAFABBAAAGAH

    is encoded as the string of 54 bits

    001000010000011000100000100000001001000000000110000111

    Codes such as ASCII and the A-through-H code above are known as
    _fixed-length_ codes, because they represent each symbol in the
    message with the same number of bits. It is sometimes advantageous
    to use _variable-length_ codes, in which different symbols may be
    represented by different numbers of bits. For example, morse code
    does not use the same number of dots and dashes for each letter of
    the alphabet. In particular, E, the most frequent letter, is
    represented by a single dot. In general, if our messages are such
    that some symbols appear very frequently and some very rarely, we
    can encode data more efficiently (i.e. using fewer bits per
    message) if we assign shorter codes to the frequent
    symbols. Consider the following alternative code for the letters A
    through H:

    A 0    C 1010 E 1100 G 1110
    B 100  D 1011 F 1101 H 1111

    With this code, the same message as above is encoded as the string

    1000101001011 ...

    This string contains 42 bits, so its saves more than 20% in space
    in comparison with the fixed-length code shown above.

    One of the difficulties of using a variable-length code is knowing
    when you have reached the end of a symbol in reading a sequence of
    zeros and oens. Morse code solves this problem by using a special
    _separator code_ (in this case, a pause) after the sequence of
    dots and dashes for each letter. Another solution is to design the
    code in such a way that no complete code for any symbol is the
    beginning (or _prefix_) of the code for another symbol. Such a
    code is called a _prefix code_. In the example above, A is encoded
    by 0 and B is encoded by 100, so no other symbol can have a code
    that begins with 0 or with 100.

    In general, we can attain significant savings if we use
    variable-length prefix codes that take advantage of the relative
    frequencies of the symbols in the messages to be encoded. One
    particular scheme for doing this is called the Huffman encoding
    method, after its discoverer, David Huffman. A Huffman code can be
    represented as a binary tree whose leaves are the symbols that are
    encoded. At each non-leaf node of the tree there is a set
    containing all the symbols in the leaves that lie below the
    node. In addition, each symbol at a leaf is assigned a weight
    (which is its relative frequency), and each non-leaf node contains
    a weight that is the sum of all the weights of the leaves lying
    below it. The weights are not used in the encoding or the decoding
    process. We will see below how they are used to help construct the
    tree.

    Figure 2.18 shows the Huffman tree for the A-through-H code given
    above. The weights at the leaves indicate that the tree was
    designed for messages in which A appears with relative frequency
    8, B with relative frequency 3, and the other letters each with
    relative frequency 1. 

    Given a Huffman tree, we can find the encoding of any symbol by
    starting at the root and moving down until we reach the leaf that
    holds the symbol. Each time we move down a left branch we add a 0
    to the code, and each time we move down a right branch we add
    a 1. (We decide which branch to follow by testing to see which
    branch either is the leaf node for the symbol or contains the
    symbol in its set.) For eample, starting from the root of the tree
    in figure 2.18, we arrive at the leaf for D by following a right
    branch, then a left branch, then a right branch, then a right
    branch; hence, the code for D is 1011. 

    To decode a bit sequence using a Huffman tree, we begin at the
    root and use successive zeros and ones of the bit sequence to
    determine whether to move down to the left or the right
    branch. Each time we come to a leaf, we have generated a new
    symbol in the message, at which point we start over from the root
    of teh tree to find the next symbol. For example, suppose we are
    given the tree above and the sequence 10001010. Starting at the
    root, we move down from the right branch, (since the first bit of
    the string is 1), then down to the left branch (since the second
    bit is 0), then down the left branch (since the third bit is also
    0). This brings us to the leaf for B, so the first symbol of the
    decoded message is B. Now we start again at the root, and we make
    a left move because the next bit in the string is 0. This brings
    us to the leaf for A. Then we start again at the root with the
    rest of the strign 1010, so we move right, left, right, left and
    reach C. Thus, the entire message is BAC.

**** Generating Huffman trees

     Given an "alphabet" of symbols and their relative frequencies,
     how do we construct the "best" code? (In other words, which tree
     will encode messages with the fewest bits?) Huffman gave an
     algorithm for doing this and showed that the resulting code is
     indeed the best variable-length code for messages where the
     relative frequency of the symbols matches teh frequencies with
     which the code was constructed. We will not prove this optimality
     of Huffman codes here, but we will show how Huffman trees are
     constructed.

     The algorithm for generating a Huffman tree is very simple. The
     idea is to arrange the tree so that the symbols with the lowest
     frequency appear farthest away from the root. Begin with the set
     of leaf nodes, containing symbols and their frequencies, as
     determined by the initial data from which the code is to be
     constructed. 

     The algorithm for generating a Huffman tree is very simple. The
     idea is to arrange the tree so that the symbols with the lowest
     frequency appear farthest away from the root. Begin with the set
     of leaf nodes, containing symbols and their frequencies, as
     determined by the initial data from which the code is to be
     constructed. Now find two leaves with the lowest weights and
     merge them to produce a node that has these two nodes as its left
     and right branches. The weight of the new node is the sum of the
     two weights. Remove the two leaves from the original set and
     replace them by this new node. Now continue this process. At each
     step, merge two nodes with the smallest weights, removing them
     from the set and replacing them with a node that has these two as
     its left and right branches. The process stops when there is only
     one node left, which is the root of the entire tree. Here is how
     the Huffman tree of figure 2.18 was generated:

     #+BEGIN_EXAMPLE
     Initial leaves {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}
     Merge          {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}
     Merge          {(A 8) (B 3) ({C D} 2) ({E F} 2)(G 1)(H 1)}
     Merge          {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}
     Merge          {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}
     Merge          {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}
     Merge          {(A 8) ({B C D} 5) ({E F G H} 4)}
     Merge          {(A 8) ({B C D E F G H} 9)}
     Merge          {({A B C D E F G H} 17)}  
     #+END_EXAMPLE

     This algorithm does not always specify a unique tree, because
     there may not be unique smallest-weight nodes at each step. Also,
     the choice of the order in which the two nodes are merged
     (i.e. which will be the right branch and which will be the left
     branch) is arbitrary.

**** Representing Huffman trees

     In the exercises below we will work with a system that uses
     Huffman trees to encode and decode messages and generates Huffman
     trees according to the algorithm outlined above. We will begin by
     discussing how trees are represented.

     Leaves of the tree are represented by a list consisting of the
     symbol leaf, the symbol at the leaf, and the weight:

     #+BEGIN_SRC scheme
     (define (make-leaf symbol weight)
      (list 'leaf symbol weight))
     (define (leaf? object)
      (eq? (car object) 'leaf))
     (define (symbol-leaf x) (cadr x))
     (define (weight-leaf x) (caddr x))
     #+END_SRC

     A general tree will be a list of a left branch, a right branch, a
     set of symbols, and a weight. The set of symbols will simply be a
     list of the symbols, rather than some more sophisticated set
     representation. When we make a tree by merging two nodes, we
     obtain the weight of the tree as the sum of the weights of the
     nodes, and the set of symbols as the union of the sets of symbols
     for the nodes. Since our symbol sets are represented as lists, we
     can form the union by using the append procedure we defined in
     section 2.2.1:

     #+BEGIN_SRC scheme
     (define (make-code-tree left right)
      (list left
            right
            (append (symbols left) (symbols right))
            (+ (weight left) (weight right))))
     #+END_SRC

     If we make a tree in this way, we have the following selectors:

     #+BEGIN_SRC scheme
     (define (left-branch tree) (car tree))
     (define (right-branch tree) (cadr tree))
     (define (symbols tree)
      (if (leaf? tree)
          (list (symbol-leaf tree))
          (caddr tree)))
     (define (weight tree)
      (if (leaf? tree)
          (weight-leaf tree)
          (cadddr tree)))
     #+END_SRC
     
     The procedures symbols and weight must do something slightly
     different depending on whether they are called with a leaf or a
     general tree. These are simple examples of _generic procedures_
     (procedures that can handle more than one kind of data), which we
     will have much more to say about in sections 2.4 and 2.5.

***** The decoding procedure
      The following procedure implements the decoding algorithm. It
      takes as arguments a list of zeros and ones, together with a
      Huffman tree:

      #+BEGIN_SRC scheme
      (define (decode bits tree)
       (define (decode-1 bits current-branch)
        (if (null? bits)
            '()
            (let ((next-branch
                   (choose-branch (car bits) current-branch)))
             (if (leaf? next-branch)
                 (cons (symbol-leaf next-branch)
                       (decode-1 (cdr bits) tree))
                 (decode-1 (cdr bits) next-branch)))))
        (decode-1 bits tree))
      (define (choose-branch bit branch)
       (cond ((= bit 0) (left-branch branch))
             ((= bit 1) (right-branch branch))
             (else (error "bad bit -- CHOOSE-BRANCH" bit))))
      #+END_SRC

      The procedure decode-1 takes two arguments: the list of
      remaining bits and the current position in the tree. It keeps
      moving "down" the tree, choosing a left or right branch
      according to whether the next bit in the list is a zero or a
      one. (This is done with the procedure choose-branch.) When it
      reaches a leaf, it returns the symbol at that leaf as the next
      symbol in the message by consing it onto the result of decoding
      the rest of the message, starting at the root of the tree. Note
      the error check in the final clause of choose-branch, which
      complains if the procedure finds something other than a zero or
      a one in the input data.

***** Sets of weighted elements

      In our representation of trees, each non-leaf node contains a
      set of symbols, which we have represented as a simple
      list. However, the tree-generating algorithm discussed above
      requires that we also work with sets of leaves and trees,
      successively merging the two smallest items. Since we will be
      required to repreatedly find the smallest item in a set, it is
      convenient to sue an ordered representation of this kind of
      set. 

      We will represent a set of leaves and trees as a list of
      elements, arranged in increasing order of weight. The following
      adjoin-set procedure for constructing sets is similar to teh one
      described in exercise 2.61; however, items are compared by their
      weights, and the element being added to the set is never already
      in it.

      #+BEGIN_SRC scheme
      (define (adjoin-set x set)
       (cond ((null? set) (list x))
             ((< (weight x) (weight (car set))) (cons x set))
             (else (cons (car set)
                         (adjoin-set x (cdr set)))))) 
      #+END_SRC

      The following procedure takes a list of symbol-frequency pairs
      such as ((A 4) (B 2) (C 1) (D 1)) and constructs an initial
      ordered set of leaves, ready to be merged according to the
      Huffman algorithm:

      #+BEGIN_SRC scheme
      (define (make-leaf-set pairs)
       (if (null? pairs)
           '()
           (let ((pair (car pairs)))
            (adjoin-set (make-leaf (car pair) ; symbol
                                   (cadr pair)) ;frequency
                        (make-leaf-set (cdr pairs))))))
      #+END_SRC

      - Exercise 2.67. Define an encoding tree and a sample message:

	#+BEGIN_SRC scheme
        (define sample-tree
         (make-code-tree (make-leaf 'A 4)
                         (make-code-tree
                          (make-leaf 'B 2)
                          (make-code-tree (make-leaf 'D 1)
                                          (make-leaf 'C 1)))))
        (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

	#+END_SRC

	Use the decode procedure to decode the message, and give the
        result.

	#+BEGIN_SRC scheme
        (decode sample-message sample-tree)
        => (a d a b b c a)
	#+END_SRC

      - Exercise 2.68. The encode procedure takes as arguments a
        message and a tree and produces the list of bits that gives
        the encoded message.

	#+BEGIN_SRC scheme
        (define (encode message tree)
         (if (null? message)
             '()
             (append (encode-symbol (car message) tree)
                     (encode (cdr message) tree))))
	#+END_SRC

	encode-symbol is a procedure, which you must write, that
        returns the list of bits that encodes a given symbol according
        to a given tree. You should design encode-symbol so that it
        signals an error if the symbol is not in the tree at all. Test
        your procedure by encoding the result you obtained in exercise
        2.67 with the sample tree and seeing whether it is the same as
        the original sample message.

	#+BEGIN_SRC scheme
        (define (encode-symbol sym tree)
         (define (contains? x listofx)
          (cond
           ((null? listofx) false)
           ((eq? x (car listofx)) true)
           (else (contains? x (cdr listofx)))))

         (cond
          ((leaf? tree) '())
          (else 
           (let
            ((left-node (left-branch tree))
             (right-node (right-branch tree)))
            (cond
             ((contains? sym (symbols left-node))
              (cons 0 (encode-symbol sym left-node)))
             ((contains? sym (symbols right-node))
              (cons 1 (encode-symbol sym right-node))))))))
	#+END_SRC

	Second write:

 	#+BEGIN_SRC scheme
        (define (encode-symbol sym tree)
         (define (contains? x listofx)
          (cond
           ((null? listofx) false)
           (else (or (eq? x (car listofx))
                     (contains? x (cdr listofx))))))
         (cond
          ((leaf? tree) '())
          ((contains? sym (symbols (left-branch tree)))
           (cons 0 (encode-symbol sym (left-branch tree))))
          ((contains? sym (symbols (right-branch tree)))
           (cons 1 (encode-symbol sym (right-branch tree))))
          (else
           (error "unknown symbol -- ENCODE-SYMBOL" symbol))))
	#+END_SRC

      - Exercise 2.69. The following procedure takes as its argument a
        list of symbol-frequency pairs (where no symbol appears in
        more than one pair) and generates a Huffman encoding tree
        according to the Huffman algorithm.

	#+BEGIN_SRC scheme
        (define (generate-huffman-tree pairs)
         (successive-merge (make-leaf-set pairs)))
	#+END_SRC

	Make-leaf-set is the procedure given above that transforms the
        list of pairs into an ordered set of leaves. Successive-merge
        is the procedure you must write, using make-code-tree to
        successively merge the smallest-weight elements of the set
        until there is only one element left, which is the desired
        Huffman tree. (This procedure is slightly tricky, but not
        really complicated. If you find yourself designing a complex
        procedure, then you are almost certainly doing something
        wrong. You can take significant advantage of the fact that we
        are using an ordered set representation.)

	#+BEGIN_SRC scheme
        (define (successive-merge set-of-leaves)
         (define (merge-iter theset)
          (cond
           ((null? (cdr theset)) (car theset))
           (else 
              (merge-iter (adjoin-set (make-code-tree
                            (car theset)
                            (cadr theset))
                           (cddr theset))))))
         (merge-iter set-of-leaves))

	#+END_SRC

      - Exercise 2.70. The following eight-symbol alphabet with
        associated relative frequencies was designed to efficiently
        encode the lyrics of 1950s rock songs. (Note that the "symbol"
        of an "alphabet" need not be individual letters.)

	A     2  NA      16
        BOOM  1  SHA      3
        GET   2  YIP      9
        JOB   2  WAH      1

	Use generate-huffman-tree (exercise 2.69) to generate a
        corresponding Huffman tree, and use encode (exercise 2.68) to
        encode the following message:

	Get a job

	Sha na na na na na na na na

	Get a job

	Sha na na na na na na na na

	Wah yip yip yip yip yip yip yip yip yip

	Sha boom

	How many bits are required for the encoding? What is the
        smallest number of bits that would be needed to encode this
        song if we used a fixed-length code for the eight-symbol
        alphabet?
	
	#+BEGIN_SRC scheme
        (define fifties-song-tree (generate-huffman-tree
         '((a 2)
           (boom 1)
           (get 2)
           (job 2)
           (na 16)
           (sha 3)
           (yip 9)
           (wah 1))))
        (define message
         '(get a job
           sha na na na na na na na na
           get a job
           sha na na na na na na na na
           wah yip yip yip yip yip yip yip yip yip
           sha boom))
        (encode message fifties-song-tree)
        => (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1)
        (length (encode message fifties-song-tree))
        84
	#+END_SRC

	If we used a fixed-length code we'd need three bits for eight
        different symbol values, three times the message length, 36,
        is 108. So we saved a fair amount of space, on the order of 20%.

      - Exercise 2.71 Suppose we have a Huffman tree for an alphabet
        of _n_ symbols, and that the relative frequencies of the
        symbols are 1, 2, 4, ..., 2^n-1. Sketch a tree for n = 5, n
        = 10. IN such a tree (for general n) how many bits are
        required to encode the most frequent symbol? the least
        frequent symbol?

	For the most frequent symbol, always 1 bit. For the least
        frequent, n - 1 bits are required.

      - Exercise 2.72 Consider the encoding of the procedure that you
        designed in exercise 2.68. What is the order of growth in the
        number of steps needed to encode a symbol? Be sure to include
        the number of steps needed to search the symbol list at each
        node encountered. To answer this question in general is
        difficult. Consider the special case where the relative
        frequencies of the _n_ symbols are as described in exercise
        2.71, and give the order of growth (as a function of n) of the
        number of steps needed to encode the most frequent and least
        frequent symbols in the alphabet.  

	In the worst case, we're accessing one of the least frequent
        two symbols and searching every node set and going all the way
        down. You'd have something like

	((n - 1) + (n - 2) + (n - 3) + ... 1) with _n_ terms.

	This is

	(n / 2) * (n + 1)
        n ^2 / 2 + n /2, or n^2.

	However, in the best case it's O(n) since all symbols are in
        the set, we search the set, go left, and have the
        symbol. Actually, since we know the set is sorted from least
        to greatest we always know it's going to take n. It is much
        more likely that we are going to do a quick lookup than a
        small one. The first three or four symbols take up the
        majority of the symbols and if we do three or four O(n)
        lookups that's O(4 * n),  or O(n). So average runtime is O(n)
        and worse case is O(n^2).

** 2.4. Multiple Representations for Abstract Data

   We have introduced data abstraction, a methodology for structuring
   systems in such a way that much of a program can be specified
   independent of the choices involved in implementing the data
   objects that the program manipulates. For example, we saw in
   section 2.1.1 how to separate the task of designing a program that
   uses rational numbers from the task of implementing rational
   numbers (make-rat,numer,denom) -- that isolates the way rational
   numbers are used from their underlying representation in terms of
   list structure. A similar abstraction barrier isolates the details
   of the procedures that perform rational arithmetic (add-rat,
   sub-rat, mul-rat, and div-rat) from the "higher level" procedures
   that use rational numbers. The resulting program has the structure
   shown in figure 2.1.

   These data-abstraction barriers are powerful tools for controlling
   complexity. By isolating the underlying representations of data
   objects, we can divide the task of designing a large program into
   smaller tasks that can be performed separately. But this kind of
   data abstraction is not yet powerful enough, because it may not
   always make sense to speak of "the underlying representation" for a
   data object.

   For one thing, there might be more than one useful representation
   for a data object, and we might like to design systems that can
   deal with multiple representations. To take a simple example,
   complex numbers may be represented in two almost equivalent ways:
   in rectangular form (real and imaginary parts) and in polar form
   (magnitude and angle). Sometimes rectangular form is more
   appropriate and sometimes polar form is more appropriate. Indeed,
   it is perfectly plausible to imagine a system in which complex
   numbers are represented in both ways, and in which the procedures
   for manipulating complex numbers work with either representation.

   More importantly, programming systems are often designed by many
   people working over extended periods of time, subject to
   requirements that change over time. In such an environment, it is
   simply not possible for everyone to agree in advance on choices of
   data representation. So in addition to the data-abstraction
   barriers that isolate representation from use, we need abstraction
   barriers that isolate different design choices from each other and
   permit different choices to coexist in a single
   program. Furthermore, since large programs are often created by
   combining pre-existing modules that were designed in isolation, we
   need conventions that permit programmers to incorporate modules
   into larger systems _additively_, that is, without having to
   redesign or reimplement these modules.

   In this section, we will learn how to cope with data that may be
   represented in different ways by different parts of a program. That
   requires constructing _generic procedures_ -- procedures that can
   operate on data that may be represented in more than one way. Our
   main technique for building generic procedures will be to work in
   terms of data objects that have _type tags_, that is, data objects
   that include explicit information about how they are to be
   processed. We will also discuss _data-directed_ programming, a
   powerful and convenient implementation strategy for additively
   assembling systems with generic operations.

   We begin with the simple complex-number example. We will see how
   type tags and data-directed style enable us to design separate
   rectangular and polar representations for complex numbers while
   maintaining the notion of an abstract "complex-number" data
   object. We will accomplish this by defining arithmetic procedures
   for complex numbers (add-complex, sub-complex, mul-complex, and
   div-complex) in terms of generic selectors that access parts of a
   complex number independent of how the number is represented. The
   resulting complex-number system, as shown in figure 2.19, contains
   two different kinds of abstraction barriers. The "horizontal"
   abstraction barriers play the same role as the ones in figure
   2.1. They isolate "higher-level" operations from "lower-level"
   representations. 

   In section 2.5 we will show how to use type tags and data-directed
   style to develop a generic arithmetic package. This provides
   procedures (add, mul, and so on) that can be used to manipulate all
   sorts of "numbers" and can easily extend when a new kind of number
   is needed. IN section 2.5.3, we will show how to use generic
   arithmetic in a system that performs symbolic algebra.

*** 2.5.1 Representations for Complex Numbers

    We will develop a system that performs arithmetic operations on
    complex numbers as a simple but unrealistic example of a program
    that uses generic operations. We begin by discussing two plausible
    representations for complex numbers as ordered pairs: rectangular
    form (real part and imaginary part) and polar form (magnitude and
    angle). Section 2.4.2 will show how both representations can be
    made to coexist in a single system through the use of type tags
    and generic operations.

    Like rational numbers, complex numbers are naturally represented
    as ordered pairs. The set of complex numbers can be thought of as
    a two-dimensional space with two orthogonal axes, the "real" axis
    and the "imaginary" axis. (See figure 2.20.) From this point of
    view, the complex number z = x + iy (where i^2 = -1) can be
    thought of as the point in the plane whose real coordinate is x
    and whose imaginary coordinate is y. Addition of complex numbers
    reduces in this representation to addition of coordinates:

    Real-part(z1 + z2) = Real-part(z1) + Real-part(z2)
    Imaginary-part(z1 + z2) = Imaginary-part(z1) + Imaginary-part(z2)

    When multiplying complex numbers, it is more natural to think in
    terms of representing a complex number in polar form, as a
    magnitude and an angle (r and A in figure 2.20). The product of
    two complex numbers is the vector obtained by stretching one
    complex number by the length of the other and then rotating it
    through the angle of the other:

    Magnitude(z1 * z2) = Magnitude(z1) * Magnitude(z2)
    Angle(z1 * z2) = Angle(z1) + Angle(z2)

    Thus, there are two different representations for complex numbers,
    which are appropriate for different operations. Yet, from the
    viewpoint of someone writing a program that uses complex numbers,
    the principle of data abstraction suggests that all the operations
    for manipulating complex numbers should be available regardless of
    which representation is used by the computer. For example, it is
    often useful to be able to find the magnitude of a complex number
    that is specified by rectangular coordinates. Similarly, it is
    often useful to be able to determine the real part of a complex
    number that is specified by polar coordinates.

    To design such a system, we can follow the same data-based
    abstraction strategy we followed in designing the rational-number
    package in section 2.1.1. Assume that the operations on complex
    numbers are implemented in terms of four selectors: real-part,
    imag-part, magnitude, and angle. Also assume that we have two
    procedures for constructing complex numbers: make-from-real-imag
    returns a complex number with specified real and imaginary parts,
    and make-from-mag-ang returns a complex number with specified
    magnitude and angle. These procedures have the property that, for
    any complex number z, both

    #+BEGIN_SRC scheme
    (make-from-real-imag (real-part z) (imag-part z))
    #+END_SRC

    and 

    #+BEGIN_SRC scheme
    (make-from-mag-ang (magnitude z) (angle z))
    #+END_SRC

    produce complex numbers that are equal to z.

    Using these constructors and selectors, we can implement
    arithmetic on complex numbers using the "abstract data" specified
    by the constructors and selectors, just as we did for rational
    numbers in section 2.1.1. As shown in the formulas above, we can
    add and subtract complex numbers in terms of real and imaginary
    parts while multiplying and dividing complex numbers in terms of
    magnitudes and angles:

    #+BEGIN_SRC scheme
    (define (add-complex z1 z2)
     (make-from-real-imag (+ (real-part z1) (real-part z2))
                          (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
     (make-from-real-imag (- (real-part z1) (real-part z2))
                          (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
     (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                        (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
     (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                        (- (angle z1) (angle z2))))
    #+END_SRC

    To complete the complex-number package, we must choose a
    representation and we must implement the constructors and
    selectors in terms of primitive numbers and primitive list
    structure. There are two obvious ways to do this: We can represent
    a complex number in "rectangular form" as a pair (real part,
    imaginary part) or in "polar form" as a pair (magnitude,
    angle). Which shall we choose?

    In order to make the different choices concrete, imagine that
    there are two programmers, Ben Bitdiddle and Alyssa P. Hacker, who
    are independently designing representations for the complex-number
    system. Ben chooses to represent complex numbers in rectangular
    form. With this choice, selecting the real and imaginary parts of
    a complex number is straightforward, as is constructing a complex
    number with given real and imaginary parts. To find the magnitude
    and the angle, or to construct a complex number with a given
    magnitude and angle, he uses the trigonometric relations

    x = r cos A   r = sqrt(x^2 + y^2)
    y = r sin A   A = arctan(y, x)

    which relate the real and imaginary parts (x, y) to the magnitude
    and the angle (r, A). Ben's representation is therefore given by
    the following selectors and constructors:

    #+BEGIN_SRC scheme
    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (magnitude z)
      (sqrt (+ (square (real-part z)) (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-real-imag x y) (cons x y))
    (define (make-from-mag-ang r a)
     (cons (* r (cos a)) (* r (sin a))))
    #+END_SRC

    Alyssa, in contrast, chooses to represent complex numbers in polar
    form. For her, selecting the magnitude and angle is
    straightforward, but she has to use trigonometric relations to
    obtain the real and imaginary parts. Alyssa's representation is:

    #+BEGIN_SRC scheme
    (define (real-part z)
     (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
     (* (magnitude z) (sin (angle z))))
    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-real-imag x y)
     (cons (sqrt (+ (square x) (square y)))
           (atan y x)))
    (define (make-from-mag-ang r a) (cons r a))
    #+END_SRC

    The discipline of data abstraction ensures that the same
    implementation of add-complex, sub-complex, mul-complex and
    div-complex will work with either Ben's representation or Alyssa's
    representation.

*** 2.4.2 Tagged data

    One way to view data abstraction is as an application of the
    "principle of least commitment." In implementing the
    complex-number system in section 2.4.1, we can use either Ben's
    rectangular representation or Alyssa's polar representation. The
    abstraction barrier formed by the selectors and constructors
    permits us to defer to the last possible moment the choice of a
    concrete representation for our data objects and thus retain
    maximum flexibility in our system design.

    The principle of least commitment can be carried to even further
    extremes. If we desire, we can maintain the ambiguity of
    representation even _after_ we have designed the selectors and
    constructors, and elect to use both Ben's representation _and_
    Alyssa's representation. If both representations are included in a
    single system, however, we will need some way to distinguish data
    in polar form from data in rectangular form. Otherwise, if we were
    asked, for instance, to find the magnitude of the pair (3,4), we
    wouldn't know whether to answer 5 (interpreting the number in
    rectangular form) or 3 (interpreting the number in polar form). A
    straightforward way to accomplish this distinction is to include a
    _type tag_ -- the symbol rectangular or polar -- as part of each
    complex number. Then when we need to manipulate a complex number
    we can use the tag to decide which selector to apply. 

    In order to manipulate tagged data, we will assume that we have
    the procedures type-tag and contents that extract from a data
    object the tag and the actual contents (the polar or rectangular
    coordinates, in the case of a complex number). We will also
    postulate a procedure attach-tag that takes a tag and contents and
    produces a tagged data object. A straightforward way to implement
    this is to use ordinary list structure:

    #+BEGIN_SRC scheme
    (define (attach-tag type-tag contents)
     (cons type-tag contents))
    (define (type-tag datum)
     (if (pair? datum)
         (car datum)
         (error "Bad tagged datum -- TYPE-TAG" datum)))
    (define (contents datum)
     (if (pair? datum)
         (cdr datum)
         (error "Bad tagged datum -- CONTENTS" datum)))
    #+END_SRC
    
    Using these procedures, we can define predicates rectangular? and
    polar?, which recognize polar and rectangular numbers,
    respectively:

    #+BEGIN_SRC scheme
    (define (rectangular? z)
     (eq? (type-tag z) 'rectangular))
    (define (polar? z)
     (eq? (type-tag z) 'polar))
    #+END_SRC
    
    With type tags, Ben and Alyssa can now modify their code so that
    their two different representations can coexist in the same
    system. Whenever Ben constructs a complex number, he tags it as
    rectangular. Whenever Alyssa constructs a complex number, she tags
    it as polar. In addition, Ben and Alyssa must make sure that the
    names of their procedures do not conflict. One way to do this is
    for Ben to append the suffix rectangular to the name of each of
    his representation procedures and for Alyssa to append polar to
    the names of hers. Here is Ben's revised rectangular
    representation from section 2.4.1:

    #+BEGIN_SRC scheme
    (define (real-part-rectangular z) (car z))
    (define (imag-part-rectangular z) (cdr z))
    (define (magnitude-rectangular z)
     (sqrt (+ (square (real-part-rectangular z))
              (square (imag-part-rectangular z)))))
    (define (angle-rectangular z)
     (atan (imag-part rectangular z)
           (real-part-rectangular z)))
    (define (make-from-real-imag-rectangular x y)
     (attach-tag 'rectangular (cons x y)))
    (define (make-from-mag-ang-rectangular r a)
     (attach-tag 'rectangular
                 (cons (* r (cos a)) (* r (sin a)))))
    #+END_SRC

    and here is Alyssa's revised polar representation:

    #+BEGIN_SRC scheme
    (define (real-part-polar z)
     (* (magnitude-polar z) (cos (angle-polar z))))
    (define (imag-part-polar z)
     (* (magnitude-polar z) (sin (angle-polar z))))
    (define (magnitude-polar z) (car z))
    (define (angle-polar z) (cdr z))
    (define (make-from-real-imag-polar x y)
     (attach-tag 'polar
                 (cons (sqrt (+ (square x) (square y)))
                       (atan x y))))
    (define (make-from-mag-ang-polar r a)
     (attach-tag 'polar (cons r a)))
    #+END_SRC
    
    Each generic selector is implemented as a procedure that checks
    the tag of its argument and calls the appropriate procedure for
    handling data of that type. For example, to obtain the real part
    of a complex number, real-part examines the tag to determine
    whether to use Ben's real-part-rectangular or Alyssa's
    real-part-polar. In either case, we use contents to extract the
    bare, untagged datum and send this to the rectangular or polar
    procedure as required:

    #+BEGIN_SRC scheme
    (define (real-part z)
     (cond ((rectangular? z)
            (real-part-rectangular (contents z)))
           ((polar? z)
            (real-part-polar (contents z)))
           (else (error "Unknown type -- REAL-PART" z))))

    (define (imag-part z)
     (cond ((rectangular? z)
            (imag-part-rectangular (contents z)))
           ((polar? z)
            (imag-part-polar (contents z)))
           (else (error "Unknown type -- IMAG-PART" z))))
     
    (define (magnitude z)
     (cond ((rectangular? z) 
            (magnitude-rectangular (contents z)))
           ((polar? z)
            (magnitude-polar (contents z)))
           (else (error "Unknown type -- MAGNITUDE" z))))
            
    (define (angle z)
     (cond ((rectangular? z)
            (angle-rectangular (contents z)))
           ((polar? z)
            (angle-polar (contents z)))
           (else (error "Unknown type -- ANGLE" z))))
    #+END_SRC

    To implement the complex-number arithmetic operations, we can use
    the same procedures add-complex, sub-complex, mul-complex, and
    div-complex from section 2.4.1, because the selectors they call
    are generic, and so will work with either representation. For
    example, the procedure add-complex is still

    #+BEGIN_SRC scheme
    (define (add-complex z1 z2)
     (make-from-real-imag (+ (real-part z1) (real-part z2))
                          (+ (imag-part z1) (imag-part z2))))
    #+END_SRC

    Finally, we must choose whether to construct complex numbers using
    Ben's representation or Alyssa's representation. One reasonable
    choice is to construct rectangular numbers whenever we have real
    and imaginary parts and to construct polar numbers whenever we
    have magnitudes and angles:

    #+BEGIN_SRC scheme
    (define (make-from-real-imag x y)
     (make-from-real-imag-rectangular x y))
    (define (make-from-mag-ang r a)
     (make-from-mag-ang-polar r a))
    #+END_SRC
    
    The resulting complex-number system has the structure shown in
    figure 2.21. The system has been decomposed into three relatively
    independent parts: the complex-number-arithmetic operations,
    Alyssa's polar implementation, and Ben's rectangular
    implementation. The polar and rectangular implementations could
    have been written by Ben and Alyssa working separately, and both
    of these can be used as underlying representations by a third
    programmer implementing the complex-arithmetic procedures in terms
    of the abstract constructor/selector interface.

    Since each data object is tagged with its type, the selectors
    operate on the data in a generic manner. That is, each selector is
    defined to have a behavior that depends on the particular type of
    data it is applied to. Notice that the general mechanism for
    interfacing the separate representations: Within a given
    representation implementation (say, Alyssa's polar package) a
    complex number is an untyped pair (magnitude, angle). When a
    generic selector operates on a number of polar type, it strips off
    the tag and passes the contents on to Alyssa's code. Conversely,
    when Alyssa constructs a number for general use, she tags it with
    a type so that it can be appropriately recognized by the
    higher-level procedures. This discipline of stripping off and
    attaching tags as data objects are passed from level to level can
    be an important organizational strategy, as we shall see in
    section 2.5.

*** 2.4.3 Data-Directed Programming and Additivity

    The general strategy of checking the type of a datum and calling
    an appropriate procedure is called _dispatching on type_. This is
    a powerful strategy for obtaining modularity in system design. On
    the other hand, implementing the dispatch as in section 2.4.2 has
    two significant weaknesses. One weakness is that the generic
    interface procedures (real-part, imag-part, magnitude, and angle)
    must know about all the different representations. For instance,
    suppose we wanted to incorporate a new representation for complex
    numbers into our complex-number system. We would need to identify
    this new representation with a type, and then add a clause to each
    of the generic interface procedures to check for the new type and
    apply the appropriate selector for that representation.

    Another weakness of the technique is that even though the
    individual representations can be designed separately, we must
    guarantee that no two procedures in the entire system have the
    same name. This is why Ben and Alyssa had to change the names of
    their original procedures from section 2.4.1.

    The issue underlying both of these weaknesses is that the
    technique for implementing generic interfaces is not
    _additive_. The person implementing the generic selector
    procedures must modify those procedures each time a new
    representation is installed, and the people interfacing the
    individual representations must modify their code to avoid name
    conflicts. In each of these cases, the changes that must be made
    to the code are straightforward, but they must be made
    nonetheless, and this is a source of inconvenience and error. This
    is not much of a problem for the complex-number system as it
    stands, but suppose there were not two but hundreds of different
    representations for complex numbers. And suppose that there were
    many generic selectors to be maintained in the abstract-data
    interface. Suppose, in fact, that no one programmer knew all
    the interface procedures or all the representations. The problem
    is real and must be addressed in such programs as large-scale
    data-base-management systems.

    What we need is a means for modularizing the system design even
    further. This is provided by the programming technique known as
    _data-directed programming_. To understand how data-directed
    programming works, begin with the observation that whenever we
    deal with a set of generic operations that are common to a set of
    different types we are, in effect, dealing with a two-dimensional
    table that contains the possible operations on one axis and the
    possible types on another axis. The entries in the table are the
    procedures that implement each operation for each type of argument
    presented. In the complex-number system developed in the previous
    section, the correspondence between operation name, data type, and
    actual procedure was spread out among the various conditional
    clauses in the generic interface procedures. But the same
    information could have been organized in a table, as shown in
    figure 2.22.

    Data-directed programming is the technique of designing programs
    to work with such a table directly. Previously, we implemented the
    mechanism that interfaces the complex-arithmetic code with the two
    representation packages as a set of procedures that each perform
    an explicit dispatch on type. Here we will implement the interface
    as a single procedure that looks up the combination of the
    operation name and the argument type in the table to find the
    correct procedure to apply, and then applies it to the contents of
    the argument. If we do this, then to add a new representation
    package to the system we need not change any existing procedures;
    we need only  add new entries to the table. 

    To implement this plan, assume that we have two procedures, put
    and get, for manipulating the operation-and-type table:

    - (put <op> <type> <item>)
      installs the <item> into the table, indexed by <op> and the <type>.
    - (get <op> <type>)
      looks up the <op>, <type> entry in the table and returns the
      item found there. If no item is found, get returns false.

      
    For now, we can assume that put and get are included in our
    language. In chapter 3 (section 3.3.3, exercise 3.24) we will see
    how to implement these and other operations for manipulating
    tables.

    Here is how data-directed programming can be used in the
    complex-number system. Ben, who developed the rectangular
    representation, implements his code just as he did originally. He
    defines a collection of procedures, or a _package_, and interfaces
    these to the rest of the system by adding entries to the table
    that tell the system how to operate on rectangular numbers. This
    is accomplished by calling the following procedure:

    #+BEGIN_SRC scheme
    (define (install-rectangular-package)
     ;; internal procedures
     (define (real-part z) (car z))
     (define (imag-part z) (cdr z))
     (define (make-from-real-imag x y) (cons x y))
     (define (magnitude z)
      (sqrt (+ (square (real-part z))
               (square (imag-part z)))))
     (define (angle z)
      (atan (imag-part z) (real-part z)))
     (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))
     (define (tag x) (attach-tag 'rectangular x))
     (put 'real-part '(rectangular) real-part)
     (put 'imag-part '(rectangular) imag-part)
     (put 'magnitude '(rectangular) magnitude)
     (put 'angle '(rectangular) magnitude)
     (put 'make-from-real-imag 'rectangular
          (lambda (x y) (tag (make-from-real-imag x y))))
     (put 'make-from-mag-ang 'rectangular
          (lambda (r a) (tag (make-from-mag-ang r a))))
      'done) 
    #+END_SRC

    Alyssa's polar package is analogous:

    #+BEGIN_SRC scheme
    (define (install-polar-package)
     ;; internal procedures
     (define (magnitude z) (car z))
     (define (angle z) (cdr z))
     (define (make-from-mag-ang r a) (cons r a))
     (define (real-part z)
      (* (magnitude z) (cos (angle z))))
     (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
     (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
            (atan y x)))
     ;; interface to rest of system.
     (define (tag x) (attach-tag 'polar x))
     (put 'real-part '(polar) real-part)
     (put 'imag-part '(polar) imag-part)
     (put 'magnitude '(polar) magnitude)
     (put 'angle '(polar) angle)
     (put 'make-from-real-imag 'polar
          (lambda (x y) (tag (make-from-real-imag x y))))
     (put 'make-from-mag-ang 'polar
          (lambda (r a) (tag (make-from-mag-ang r a))))
     'done)
    #+END_SRC

    Even though Ben and Alyssa both still use their original
    procedures defined with the same names as each other's
    (e.g. real-part), these definitions are now internal to different
    procedures (see section 1.1.8), so there is no name conflict. 

    The complex-arithmetic selectors access the table by means of a
    general "operation" procedure called apply-generic, which applies
    a generic operation to some arguments. Apply-generic looks in the
    table under the name of the operation and the types of the
    arguments and applies the resulting procedure if one is present:

    #+BEGIN_SRC scheme
    (define (apply-generic op . args)
     (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
       (if proc
           (apply proc (map contents args))
           (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))
    #+END_SRC

    Using apply-generic, we can define our generic selectors as
    follows:

    #+BEGIN_SRC scheme
    (define (real-part z) (apply-generic 'real-part z))
    (define (imag-part z) (apply-generic 'imag-part z))
    (define (magnitude z) (apply-generic 'magnitude z))
    (define (angle z) (apply-generic 'angle z))
    #+END_SRC

    Observe that these do not change at all if a new representation is
    added to the system.

    We can also extract from the table the constructors to be used by
    the programs external to the packages in making complex numbers
    from real and imaginary parts and from magnitudes and angles. As
    in section 2.4.2, we construct rectangular numbers whenever we
    have real and imaginary parts, and polar numbers whenever we have
    magnitudes and angles:

    #+BEGIN_SRC scheme
    (define (make-from-real-imag x y)
     ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
     ((get 'make-from-mag-ang 'polar) r a))
    #+END_SRC

    - Exercise 2.73. Section 2.3.2 described a program that performs
      symbolic differentiation:

      #+BEGIN_SRC scheme
      (define (deriv exp var)
       (cond ((number? exp) 0)
             ((variable? exp) (if (same-variable? exp var) 1 0))
             (else ((get 'deriv (operator exp)) (operands exp) var))))
      (define (operator exp) (car exp))
      (define (operands exp) (cdr exp))
      #+END_SRC
      
      a. Explain what was done above. Why can't we assimilate the
      predicates number? and same-variable? into the data-directed
      dispatch? 

      For every operation, you put the procedure to derive that
      operation in the table. So if you want to get the derivative for
      (* 3 x), you find in the table 'deriv '* and apply the procedure
      in there to 'x. So deriv is an operation and '* is a type, you
      apply deriv to that type. So deriv can now be added to by anyone
      that has a new operator they want to add. number? can't be put
      into the dispatch because it has no operator. Technically you
      could probably make the operator procedure return the symbol
      'number for numbers and make operands return '(), and the
      procedure in the table return 0. variable? is similar, it isn't
      as cleanly integrated into the operator/operands procedures but
      technically you could force it into the table. 

      b. Write the procedures for derivatives of sums and products,
      and the auxiliary code required to install them in the table
      used by the program above.

      #+BEGIN_SRC scheme
      (define (install-deriv)
       (define (addend var)
         (car var))
       (define (augend var)
         (cadr var))
       (define (make-sum exp1 exp2)
        (cond
         ((=number? exp1 0) exp2)
         ((=number? exp2 0) exp1)
         ((and (number? exp1) (number? exp2))
          (+ exp1 exp2))
         (else (list '+ exp1 exp2))))

       (define (multiplier var) (cadr var))
       (define (multiplicand var) (car var))
       (define (make-product x1 x2)
        (cond
         ((or (=number? x1 0) (=number? x2 0)) 0)
         ((=number? x1 1) x2)
         ((=number? x2 1) x1)
         ((and (number? x1) (number? x2)) (* x1 x2))
         (else (list '* x1 x2))))

       (define (deriv-sum ops var)
        (make-sum
         (deriv (addend ops) var)
         (deriv (augend ops) var)))

       (define (deriv-mul ops var)
        (make-sum
         (make-product (multiplier ops)
                       (deriv (multiplicand ops) var))
         (make-product (deriv (multiplier ops) var)
                       (multiplicand ops))))
                       
       (put 'deriv '+ deriv-sum)
       (put 'deriv '* deriv-mul)
       (put 'deriv '** deriv-exp)
       'done)
      #+END_SRC

      c. Choose any additional differentiation rule that you like,
      such as the one for exponents (exercise 2.56), and install it in
      this data-directed system.

      #+BEGIN_SRC scheme
      (define (install-deriv)
       (define (addend var)
         (car var))
       (define (augend var)
         (cadr var))
       (define (make-sum exp1 exp2)
        (cond
         ((=number? exp1 0) exp2)
         ((=number? exp2 0) exp1)
         ((and (number? exp1) (number? exp2))
          (+ exp1 exp2))
         (else (list '+ exp1 exp2))))

       (define (multiplier var) (cadr var))
       (define (multiplicand var) (car var))
       (define (make-product x1 x2)
        (cond
         ((or (=number? x1 0) (=number? x2 0)) 0)
         ((=number? x1 1) x2)
         ((=number? x2 1) x1)
         ((and (number? x1) (number? x2)) (* x1 x2))
         (else (list '* x1 x2))))

       (define (deriv-sum ops var)
        (make-sum
         (deriv (addend ops) var)
         (deriv (augend ops) var)))

       (define (deriv-mul ops var)
        (make-sum
         (make-product (multiplier ops)
                       (deriv (multiplicand ops) var))
         (make-product (deriv (multiplier ops) var)
                       (multiplicand ops))))
                       
       (put 'deriv '+ deriv-sum)
       (put 'deriv '* deriv-mul)

       (define (base exp)
        (car exp))
       (define (power exp)
        (cadr exp))
       (define (make-exponent base power)
        (cond
         ((=number? base 0) 0)
         ((=number? power 0) 1)
         ((=number? base 1) 1)
         ((=number? power 1) base)
         (else
          (list '** base power))))
 
       (define (deriv-exp ops var)
        (make-product
         (make-exponent
          (make-product 
           (power ops)
           (base ops))
          (make-sum (power ops) -1))
         (deriv (base ops) var)))
       (put 'deriv '** deriv-exp)
       'done)
      #+END_SRC

      d. In this simple algebraic manipulator the type of an
      expression is the algebraic operator that binds it
      together. Suppose, however, we indexed the procedures in the
      opposite way, so that the dispatch line in deriv looked like

      #+BEGIN_SRC scheme
      ((get (operator exp) 'deriv) (operands exp) var)
      #+END_SRC

      What corresponding changes to the derivative system are
      required?

      You really only need to change the order of the arguments to put
      and get.

      #+BEGIN_SRC scheme
      (define (deriv exp var)
       (cond ((number? exp) 0)
             ((variable? exp) (if (same-variable? exp var) 1 0))
             (else ((get (operator exp) 'deriv) (operands exp) var))))
      (define (operator exp) (car exp))
      (define (operands exp) (cdr exp))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (install-deriv)
       (define (addend var)
         (car var))
       (define (augend var)
         (cadr var))
       (define (make-sum exp1 exp2)
        (cond
         ((=number? exp1 0) exp2)
         ((=number? exp2 0) exp1)
         ((and (number? exp1) (number? exp2))
          (+ exp1 exp2))
         (else (list '+ exp1 exp2))))

       (define (multiplier var) (cadr var))
       (define (multiplicand var) (car var))
       (define (make-product x1 x2)
        (cond
         ((or (=number? x1 0) (=number? x2 0)) 0)
         ((=number? x1 1) x2)
         ((=number? x2 1) x1)
         ((and (number? x1) (number? x2)) (* x1 x2))
         (else (list '* x1 x2))))

       (define (deriv-sum ops var)
        (make-sum
         (deriv (addend ops) var)
         (deriv (augend ops) var)))

       (define (deriv-mul ops var)
        (make-sum
         (make-product (multiplier ops)
                       (deriv (multiplicand ops) var))
         (make-product (deriv (multiplier ops) var)
                       (multiplicand ops))))
                       
       (put '+ 'deriv deriv-sum)
       (put '* 'deriv deriv-mul)

       (define (base exp)
        (car exp))
       (define (power exp)
        (cadr exp))
       (define (make-exponent base power)
        (cond
         ((=number? base 0) 0)
         ((=number? power 0) 1)
         ((=number? base 1) 1)
         ((=number? power 1) base)
         (else
          (list '** base power))))
 
       (define (deriv-exp ops var)
        (make-product
         (make-exponent
          (make-product 
           (power ops)
           (base ops))
          (make-sum (power ops) -1))
         (deriv (base ops) var)))
       (put '** 'deriv deriv-exp)
       'done)
      #+END_SRC

      I installed this package and it worked. All I did was change the
      put and get argument order. 'type' and 'op' are really just how
      we decide in our minds to do the lookup.

    - Exercise 2.74. Insatiable Enterprises, Inc., is a highly
      decentralized conglomerate company consisting of a large number
      of independent divisions located all over the world. The
      company's computer facilities have just been interconnected by
      means of a clever network-interfacing scheme that makes the
      entire network appear to any user to be a single
      computer. Insatiable's president, in her first attempt to
      exploit the ability of the network to extract administrative
      information from division files, is dismayed to discover that,
      although all the division files have been implemented as data
      structures in Scheme, the particular data structure used varies
      from division to division. A meeting of division managers is
      hastily called to search for a strategy to integrate the files
      that will satisfy headquarters' needs while preserving the
      existing autonomy of the divisions. 

      Show how such a strategy can be implemented with data-directed
      programming. As an example, suppose that each deivision's
      personnel records consist of a single file, which contains a set
      of records keyed on employees' names. The structure of the set
      varies from division to division. Furthermore, each employee's
      record is itself a set (structured differently from division to
      division) that contains information keyed under identifiers such
      as address and salary. In particular:

      a. Implement for headquarters a get-record procedure that
      retrieves a specified employee's record from a specified
      personnel file. The procedure should be applicable to any
      division's file. Explain how the individual divisions' files
      should be structured. In particular, what type information must
      be supplied?

      Every headquarters has some kind of get-employee-record
      procedure that takes an employee name. Each record also has a
      set with information keyed under identifiers that are basically
      the same. So you need to collect all these procedures and put
      them into the table.

      #+BEGIN_SRC scheme
      ;; in the boston package...
      (put 'get-record '(boston-file) get-employee-boston-file)
      ;; in the dnever package...
      (put 'get-record '(denver-file) get-employee-denver-file)
      ;; in the boston package...
      (put 'record-employee-name '(boston-record) get-employee-name-from-record-boston)
      ;; in the denver package...
      (put 'record-employee-name '(denver-record) get-employee-name-from-record-denver)
      #+END_SRC

      It does not matter how each divisions' file is structured except
      that we do need to add type-tags in order to identify them. So,
      if you want to use this new system with your file, you need to
      tag it:

      #+BEGIN_SRC scheme
      (define boston-file (tag 'boston-file my-employee-records)) ;; this file can be used with our system.
      #+END_SRC
      
      And, when our file searchers return employee records, we must also
      tag these so that we can use the appropriate methods to select
      data from each individual record.

      So, although we don't care about the divison's file structure
      deeply as long as each division has appropriate methods to get
      what we want, we do need to tag each one with a type tag no
      matter what to use in our system.

      #+BEGIN_SRC scheme
      (define (get-record a-record)
       (apply-generic 'get-record a-record))
      #+END_SRC

      So supposing we have division files loaded in whatever structure
      they're in as boston-file, denver-file, and new-york-file. These
      are three divisions. Each division needs to install itself as a
      package like this:

      #+BEGIN_SRC scheme
      (define (install-boston)
        (define (get-record-address-boston raw-record)
          ;; does what the boston record-address procedure already does
         )
        (define (get-record-name-boston raw-record)
         ;; does what the boston record-name procedure that takes
         ;; a division-specific set already does
         )
        (define (get-boston-record raw-file)
         ;; 
         )
        (define (get-boston-record file)
            (let ((employee-record (boston-get-record file)))
             (tag 'boston-employee-record employee-record)))
        (put 'get-record '(boston-file) get-boston-record)
        (put 'record-address '(boston-employee-record) get-record-address-boston)
        (put 'record-name '(boston-employee-record) get-record-name-boston)
       'done)

      (define (install-new-york)
        ;; ...
       'done)
      (define (install-denver)
        ;; ...
       'done)
      (define (get-record a-record)
        (apply-generic 'get-record a-record))
      (define (record-address a-record)
        (apply-generic 'record-address a-record))
      (install-boston)
      (install-new-york)
      (install-denver)
      #+END_SRC

      Each package defines a set of procedures: a lookup procedure to
      get an employee record out of a file, and a set of procedures to
      get the information from that employee record based on
      keys. The employee-record getting procedure _must_ tag the data
      it retrieves with the division's type,
      e.g. 'boston-employee-record, so that we can dispatch the
      selectors appropriately. Then, each selector is installed into
      the table so we can dispatch based on the selector.

      This installs into our table all the operations specific to the
      individual divisions' files and allows us to use one procedure
      to get the same data from all of them.

      b. Implement for headquarters a get-salary procedure that
      returns the salary information from a given employee's record
      from any division's personnel file. How should the record be
      structured in order to make this operation work?

      The get-salary procedure will just be a generic
      application. Each division must define their own set-specific
      get-salary-<division> procedure and install it into our table
      using (put 'get-salary '<division-file-type-tag>
      <get-salary-op>). The record must be tagged in order for this to
      work, nothing else is of importance to this procedure.

      #+BEGIN_SRC scheme
      (define (get-boston-employee-record record)
         ;; data-structure specific actions...
       )
      (put 'get-salary '(boston-employee-record) get-boston-employee-record)
      #+END_SRC

      c. Implement for headquarters a find-employee-record
      procedure. This should search all the divisions' files for the
      record of a given employee and return the record. Assume that
      this procedure takes as arguments an employee's name and a list
      of all the divisons' files.

      The division files MUST be tagged.
      #+BEGIN_SRC scheme
      (define (find-employee-record listof-division-files name)
       (cond
        ((null? listof-division-files)
          false)
        (else
         (let ((found-employee (get-record name)))
          (if found-employee
              found-employee
              (find-employee-record (cdr listof-division-files) name))))))
      #+END_SRC

      d. When Insatiable takes over a new company, what changes must
      be made in order to incorporate the new personnel information
      into the central system?

      You need to write a new install-<division-name> package that
      ties into the table using put and get all the record finding and
      record data element selection procedures that that division has
      already defined for their files and records.

**** Message passing

     The key idea of data-directed programming is to handle generic
     operations in programs by dealing explicitly with
     operation-and-type tables, such as the table in figure 2.22. The
     style of programming we used in section 2.4.2 organized the
     required dispatching on type by having each operation take care
     of its own dispatching. In effect, this decomposes the
     operation-and-type table into rows, with each generic operation
     procedure representing a row of the table.

     An alternative implementation strategy is to decompose the table
     into columns and, instead of using "intelligent operations" that
     dispatch on data types, to work with "intelligent data objects"
     that dispatch on operation names. We can do this by arranging
     things so that a data object, such as a rectangular number, is
     represented as a procedure that takes as input the required
     operation name and performs the operation indicated. In such a
     discipline, make-from-real-imag could be written as

     #+BEGIN_SRC scheme
     (define (make-from-real-imag x y)
      (define (dispatch op)
       (cond ((eq? op 'real-part) x)
             ((eq? op 'imag-part) y)
             ((eq? op 'magnitude)
              (sqrt (+ (square x) (square y))))
             ((eq? op 'angle) (atan y x))
             (else
              (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
      dispatch)
     #+END_SRC

     The corresponding apply-generic procedure, which applies a
     generic operation to an argument, now simply feeds the
     operation's name to the data object and lets the object do the
     work:

     #+BEGIN_SRC scheme
     (define (apply-generic op arg) (arg op))
     #+END_SRC

     Note that the value returned by make-from-real-imag is a
     procedure -- the internal dispatch procedure. This is the
     procedure that is invoked when apply-generic requests an
     operation to be performed.

     This style of programming is called _message passing_. The name
     comes from the image that a data object is an entity that
     receives the requested operation name as a "message." We have
     already seen an example of message passing in section 2.1.3,
     where we saw how cons, car, and cdr could be defined with no data
     objects but only procedures. Here we see that message passing is
     not a mathematical trick but a useful technique for organizing
     systems with generic operations. In the remainder of this chapter
     we will continue to use data-directed programming, rather than
     message passing, to discuss generic arithmetic operations. In
     chapter 3 we will return to message passing, and we will see that
     it can be a powerful tool for structuring simulation programs.

     - Exercise 2.75. Implement the constructor make-from-mag-ang in
       message-passing style. This procedure should be analogous to
       the make-from-real-imag procedure given above.

       #+BEGIN_SRC scheme
       (define (make-from-mag-ang mag ang)
        (define (dispatch op)
         (cond ((eq? op 'magnitude) mag)
               ((eq? op 'angle) ang)
               ((eq? op 'real) (* mag (cos ang)))
               ((eq? op 'imag) (* mag (sin ang)))
               (else
                (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
        dispatch)
       #+END_SRC

     - Exercise 2.76. As a large system with generic operations
       evolves, new types of data objects or new operations may be
       needed. For each of the three strategies -- generic operations
       with explicit dispatch, data-directed style, and
       message-passing style -- describe the changes that must be made
       to a system in order to add new types or new operations. Which
       organization would be most appropriate for a system in which
       new types must often be added? Which would be most appropriate
       for a system in which new operations must often be added?

       If you add a lot of new operations continually, you need to go
       and modify each dispatch function to add new operations. It
       would probably be easier for a programmer to add new operations
       in a data-directed-dispatch style. But when you're adding lots
       of new types, message-passing requires less code.

** 2.5 Systems with Generic Operations

   In the previous section, we saw how to design systems in which data
   objects can be represented in more than one way. The key idea is to
   link the code that specifies the data operations to the several
   representations by means of generic interface procedures. Now we
   will see how to sue this same idea not only to define operations
   that are generic over different representations but also to define
   operations that are generic over different kinds of arguments. We
   have already seen several different packages of arithmetic
   operations: the primitive arithmetic (+,-, *, /) built into our
   language, the rational-number arithmetic (add-rat, sub-rat,
   mul-rat, div-rat) of section 2.1.1, and the complex-number
   arithmetic that we implemented in section 2.4.3. We will now use
   data-directed techniques to construct a package of arithmetic
   operations that incorporates all the arithmetic packages we have
   already constructed. 

   Figure 2.23 shows the structure of the system we shall
   build. Notice the abstraction barriers. From the perspective of
   someone using "numbers," there is a single procedure add that
   operates on whatever numbers are supplied. Add is part of a generic
   interface that allows the separate ordinary-arithmetic,
   rational-arithmetic, and complex-arithmetic packages to be accessed
   uniformly by programs that use numbers. Any individual arithmetic
   package (such as the complex package) may itself be accessed
   through generic procedures (such as add-complex) that combine
   packages designed for different representations (such as
   rectangular and polar). Moreover, the structure of the system is
   additive, so that one can design the individual arithmetic packages
   separately and combine them to produce a generic arithmetic system.

   
*** 2.5.1 Generic Arithmetic Operations

    The task of designing generic arithmetic operations is analogous
    to that of designing the generic complex-number operations. We
    would like, for instance, to have a generic addition procedure add
    that acts like ordinary primitive addition + on ordinary numbers,
    like add-rat on rational numbers, and like add-complex on complex
    numbers. We can implement add, and the other generic arithmetic
    operations, by following the same strategy we used in section
    2.4.3 to implement the generic selectors for complex numbers. We
    will attach a type tag to each kind of number and cause the
    generic procedure to dispatch to an appropriate package according
    to the data type of its arguments.

    The generic arithmetic procedures are defined as follows:

    #+BEGIN_SRC scheme
    (define (add x y) (apply-generic 'add x y))
    (define (sub x y) (apply-generic 'sub x y))
    (define (mul x y) (apply-generic 'mul x y))
    (define (div x y) (apply-generic 'div x y))
    #+END_SRC

    We begin by installing a package for handling _ordinary_ numbers,
    that is, the primitive numbers of our language. We will tag these
    with the symbol scheme-number. The arithmetic operations in this
    package are primitive arithmetic procedures (so there is no need
    to define extra procedures to handle the untagged numbers). Since
    these operations each take two arguments, they are installed in
    the table keyed by the list (scheme-number scheme-number):

    #+BEGIN_SRC scheme
    (define (install-scheme-number-package)
     (define (tag x)
      (attach-tag 'scheme-number x))
     (put 'add '(scheme-number scheme-number)
          (lambda (x y) (tag (+ x y))))
     (put 'sub '(scheme-number scheme-number)
          (lambda (x y) (tag (- x y))))
     (put 'mul '(scheme-number scheme-number)
          (lambda (x y) (tag (* x y))))
     (put 'div '(scheme-number scheme-number)
          (lambda (x y) (tag (/ x y))))
     (put 'make 'scheme-number
          (lambda (x) (tag x)))
     'done)
    #+END_SRC

    Users of the Scheme-number package will create (tagged) ordinary
    numbers by means of the procedure:

    #+BEGIN_SRC scheme
    (define (make-scheme-number n)
     ((get 'make 'scheme-number) n))
    #+END_SRC

    Now that the framework of the generic arithmetic system is in
    place, we can readily include new kinds of numbers. Here is a
    package that performs rational arithmetic. Notice that, as a
    benefit of additivity, we can use without modification the
    rational-number code from section 2.1.1 as the internal procedures
    in the package:

    #+BEGIN_SRC scheme
    (define (install-rational-package)
     ;; internal procedures
     (define (numer x) (car x))
     (define (denom x) (cdr x))
     (define (make-rat n d)
      (let ((g (gcd n d)))
       (cons (/ n g) (/ d g))))
     (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
     (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
     (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
                (* (denom x) (denom y))))
     (define (div-rat x y)
      (make-rat (* (numer x) (denom x))
                (* (denom x) (numer y))))
     ;; interface to rest of the system
     (define (tag x) (attach-tag 'rational x))
     (put 'add '(rational rational)
          (lambda (x y) (tag (add-rat x y))))
     (put 'sub '(rational rational)
          (lambda (x y) (tag (sub-rat x y))))
     (put 'mul '(rational rational)
          (lambda (x y)(tag (mul-rat x y))))
     (put 'div '(rational rational)
          (lambda (x y) (tag (div-rat x y))))
     (put 'make 'rational
          (lambda (n d) (tag (make-rat n d))))
     'done)
    (define (make-rational n d)
     ((get 'make 'rational) n d))
    #+END_SRC

    We can install a similar package to handle complex numbers, using
    the tag complex. In creating the package, we extract from the
    table the operations make-from-real-imag and make-from-mag-ang
    that were defined by the rectangular and polar
    packages. Additivity permits us to use, as the internal
    operations, the same add-complex, sub-complex, mul-complex, and
    div-complex procedures from section 2.4.1.

    #+BEGIN_SRC scheme
    (define (install-complex-package)
     ;; imported procedures from rectangular and polar packages
     (define (make-from-real-imag x y) 
      ((get 'make-from-real-imag 'rectangular) x y))
     (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
     ;; internal procedures
     (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
                           (+ (imag-part z1) (imag-part z2))))
     (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
                           (- (imag-part z1) (imag-part z2))))
     (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                         (+ (angle z1) (angle z2))))
     (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                         (- (angle z1) (angle z2))))
     ;; interface to the rest of the system 
     (define (tag z) (attach-tag 'complex z))
     (put 'add '(complex complex)
          (lambda (z1 z2) (tag (add-complex z1 z2))))
     (put 'sub '(complex complex)
          (lambda (z1 z2) (tag (sub-complex z1 z2))))
     (put 'mul '(complex complex)
          (lambda (z1 z2) (tag (mul-complex z1 z2))))
     (put 'div '(complex complex)
          (lambda (z1 z2) (tag (div-complex z1 z2))))
     (put 'make-from-real-imag 'complex
          (lambda (x y) (tag (make-from-real-imag x y))))
     (put 'make-from-mag-ang 'complex
          (lambda (r a) (tag (make-from-mag-ang r a))))
     'done)
    #+END_SRC

    Programs outside the complex-number package can construct complex
    numbers either from real and imaginary parts or from magnitudes
    and angles. Notice how the underlying procedures, originally
    defined in the rectangular and polar packages, are exported to the
    complex package, and exported from there to the outside world.

    #+BEGIN_SRC scheme
    (define (make-complex-from-real-imag x y)
     ((get 'make-from-real-imag 'complex) x y))
    (define (make-complex-from-mag-ang r a)
     ((get 'make-from-mag-ang 'complex) r a))
    #+END_SRC

    What we have here is a two-level tag system. A typical complex
    number, such as 3 + 4i in rectangular form, would be represented
    as shown in figure 2.34. The outer tag (complex) is used to direct
    the number to the complex package. Once within the complex
    package, the next tag (rectangular) is used to direct the number
    to the rectangular package. In a large and complicated system
    there might be many levels, each interfaced with the next by means
    of generic operations. As a data object is passed "downward," the
    outer tag that is used to direct it to the appropriate package is
    stripped off (by applying contents) and the next level of tag (if
    any) becomes visible to be used for further dispatching. 

    In the above packages, we used add-rat, add-complex, and the other
    arithmetic procedures exactly as originally written. Once these
    definitions are internal to different installation procedures,
    however, they no longer need names that are distinct from each
    other: we could simply name them add, sub, mul and div in both
    packages.

    - Exercise 2.77. Louis Reasoner tries to evaluate the expression
      (magnitude z) where z is the object shown in figure 2.24. To his
      surprise, instead of the answer 5 he getse an error message from
      apply-generic, saying there is no method for the operation
      magnitude on the types (complex). He shows this interaction to
      Alyssa P. Hacker, who says "The problem is that the
      complex-number selectors were never defined for complex numbers,
      just for polar and rectangular numbers. All you have to do to
      make this work is add the following to the complex package:"

      #+BEGIN_SRC scheme
      (put 'real-part '(complex) real-part)
      (put 'imag-part '(complex) imag-part)
      (put 'magnitude '(complex) magnitude)
      (put 'angle '(complex) angle)
      #+END_SRC

      Describe in detail why this works. As an example, trace through
      all the procedures called in evaluating the expression
      (magnitude z) where z is the object shown in figure 2.24. In
      particular, how many times is apply-generic invoked? What
      procedure is dispatched to in each case?

      This works because if z is the object shown in figure 2.24, it
      has two type tags, 'complex and 'polar. The first tag pulled off
      is 'complex, so the apply-generic procedure looks in the
      operations table for an entry in {'(complex), 'magnitude}, and
      there is not one. There is only one in {'(polar) 'magnitude}
      because that's the only one we install in the complex
      package. By adding another entry under {'(complex), 'magnitude}
      we tell the table to use our already defined procedure
      magnitude. What then happens is that apply-generic is actually
      applied twice. 

      #+BEGIN_SRC scheme
      (magnitude (complex polar 3 . 4))
      (apply-generic 'magnitude (complex polar 3. 4))
      (let ((type-tags (map type-tag ((complex polar 3 . 4)))))

       (let ((proc (get op type-tags)))
        (apply proc (map contents args))))

      (let ((type-tags (complex)))
       (let ((proc (get 'magnitude type-tags)))
        (apply proc (map contents ((complex polar 3 . 4))))))
       
    
      (let ((proc magnitude))  ;; this magnitude is the one we installed earlier which actually is a recursive call to apply-generic.
                               ;; this time the call is different though because we will take the contents
                               ;; of z and return (polar 3 . 4) which is still tagged. This is why we
                               ;; are calling apply-generic a second time.
       (apply proc (map contents ((complex polar 3 . 4)))))
    
      (apply magnitude (map contents ((complex polar 3 . 4))))
   
      (apply magnitude ((polar 3 . 4)))
      (magnitude (polar 3. 4))
      (apply-generic 'magnitude (polar 3 . 4))
      
      (let ((type-tags (map type-tag ((polar 3 . 4)))))
       (let ((proc (get 'magnitude type-tags)))
        (apply proc (map contents ((polar 3 . 4))))))

      (let ((type-tags (polar)))
       (let ((proc (get 'magnitude type-tags)))
        (apply proc (map contents ((polar 3 . 4))))))

       (let ((proc (get 'magnitude (polar))))
        (apply proc (map contents ((polar 3 . 4))))))

       (let ((proc magnitude)) ;; from the internal definitions of the install-complex package procedure.
        (apply proc (map contents ((polar 3 . 4)))))

      (apply magnitude (map contents ((polar 3 . 4))))
      (apply magnitude ((3 . 4)))
      (magnitude (3 . 4))
      (car (3 . 4))
      3
      #+END_SRC

      apply-generic strips of the complex tag and looks in the table
      for (complex), and finds it. It so happens that the procedure is
      the same one we're calling, so we have a kind of indirect
      recursion; the reduction step is that we stripped off the
      (compelx) tag and now only have a (polar) tag. When we look in
      the table again for the (polar) tag we find the actual procedure
      that operates on the data.

    - Exercise 2.78. The internal procedures in the scheme-number
      package are essentially nothing more than calls to the primitive
      procedures +, -, etc. It was not possible to use the primitives
      of the language directly because our type-tag system requires
      that each data object have a type attached to it. In fact,
      however, all Lisp implementations do have a type system, which
      they use internally. Primitive predicates such as symbol? and
      number? determine whether data objects have particular
      types. Modify the definitions of type-tag, contents, and
      attach-tag from section 2.4.2 so that our generic system takes
      advantage of Scheme's internal type system. That is to say, the
      system should work as before except that ordinary numbers should
      be represented simply as Scheme numbers rather than as pairs
      whose car is the symbol scheme-number.

      #+BEGIN_SRC scheme
      (define (attach-tag tag datum)
       (cond
        ((eq? 'scheme-number tag) datum)
        (else (cons tag datum))))

      (define (type-tag datum)
       (cond
        ((number? datum) 'scheme-number)
        (else (car datum))))

      (define (contents datum)
       (cond
        ((number? datum) datum)
        (else (cdr datum))))
      #+END_SRC

    - Exercise 2.79. Define a generic equality predicate equ? that
      tests the equality of two numbers, and install it in the generic
      arithmetic package. This operation should work for ordinary
      numbers, rational numbers, and complex numbers.

      #+BEGIN_SRC scheme
      (define (install-equ)
       (define (complex-equ? x y)
        (and (= (real-part x) (real-part y))
             (= (imag-part x) (imag-part y))))
       (put 'equ? '(complex complex) complex-equ?)

       (define (rational-equ? x y)
        (and (= (numer x) (numer y))
             (= (denom x) (denom y))))
       (put 'equ? '(rational rational) rational-equ?)

       (define (scheme-number-equ? x y)
        (= x y))
       (put 'equ? '(scheme-number scheme-number) scheme-number-equ?)
       'done)
      (define (equ? x y)
       (apply-generic 'equ? x y))
      #+END_SRC

      This was my original attempt but you run into a problem. numer
      and denom are not defined. If you define them by putting them
      into the table -- (put 'numer '(rational) numer) -- inside the
      install-rational package, you have problems because the tag gets
      stripped in apply-generic. So, if you have a separate package
      using the numer defined outside of the installrational package
      procedure referencing the table, this numer expects there to be
      a tag to strip. There will not be, it's a number. It looks in
      the table for a number and can't find it. SO you have an
      error. You need to use the internally-defined numer or retag the
      data. I went with splitting up the equ? procedure into the
      separate packages.

      #+BEGIN_SRC scheme
      (define (install-rational-package)
        ;; ...
        (define (rational-equ? x y)
         (and (= (numer x) (numer y))
              (= (denom x) (denom y))))
        (put 'equ? '(rational rational) rational-equ?)
        ;; ...)
      (define (install-scheme-number-package)
        ;; ...
       (define (scheme-number-equ? x y)
        (= x y))
       (put 'equ? '(scheme-number scheme-number) scheme-number-equ?)
        ;; ....)
      (define (install-complex-package)
         ;; ...
       (define (complex-equ? x y)
        (and (= (real-part x) (real-part y))
             (= (imag-part x) (imag-part y))))
       (put 'equ? '(complex complex) complex-equ?)
         ;; ...
        ) 
      (define (equ? x y)
       (apply-generic 'equ? x y))
      #+END_SRC
      
      This is somewhat inconvenient because if we want to add a new
      generic operation, we have to go and edit all types
      separately. There is no way for a developer to add equ? to the
      system additively.

    - Exercise 2.80. Define a generic predicate =zero? that tests if
      its argument is zero, and install it in the generic arithmetic
      package. This operation should work for ordinary numbers,
      rational numbers, and complex numbers.

      #+BEGIN_SRC scheme
      (define (install-scheme-number-package)
       (put '=zero? '(scheme-number) (lambda (x) (= x 0)))
      )

      (define (install-complex-package)
       (define (=zero-complex? x)
        (and (= 0 (real-part x)) (= 0 (imag-part x))))
       (put '=zero? '(complex) =zero-complex?)
       )

      (define (install-rational-package)
       (define (=zero-rational? x)
        (= 0 (numer x)))
       (put '=zero? '(rational) =zero-rational?)
       )
      #+END_SRC

*** 2.5.2 Combining Data of Different Types

    We have seen how to define a unified arithmetic system that
    encompasses ordinary numbers, complex numbers, rational numbers,
    and any other type of number we might decide to invent, but we
    have ignored an important issue. The operations we have defined so
    far treat the different data types as being completely
    independent. Thus, there are separate packages for adding, say,
    two ordinary numbers, or two complex numbers. What we have not yet
    considered is the fact that it is meaningful to define operations
    that cross type boundaries, such as the addition of a complex
    number to an ordinary number. We have gone to great pains to
    introduce barriers between parts of our programs so that they can
    be developed and understood separately. We would like to introduce
    the cross-type operations in some carefully controlled way, so
    that we can support them without seriously violating our module
    boundaries.

    One way to handle cross-type operations is to design a different
    procedure for each possible combination of types for which the
    operation is valid. For example, we could extend the
    complex-number package sot hat it provides a procedure for adding
    complex numbers to ordinary numbers and installs this in the table
    using the tag (complex scheme-number):

    #+BEGIN_SRC scheme
    (define (add-complex-to-schemenum z x)
     (make-from-real-imag (+ (real-part z) x)
                          (imag-part z))
     (put 'add '(complex scheme-number)
          (lambda (z x) (tag (add-complex-to-schemenum z x)))))
    #+END_SRC

    This technique works, but it is cumbersome. With such a system,
    the cost of introducing a new type is not just the construction of
    the package of procedures for that type but also the construction
    and installation of the procedures that implement the cross-type
    operations. This can easily be much more code than is needed to
    define the operations on the type itself. The method also
    undermines our ability to combine separate packages additively, or
    at least to limit the extend to which the implementors of the
    individual packages need to take account of other packages. For
    instance, in the example above, it seems reasonable that handling
    mixed operations on complex numbers and ordinary numbers should be
    the responsibility of the complex-number package. Combining
    rational numbers and complex numbers, however, might be done by
    the complex package, by the rational package, or by some third
    package that uses operations extracted from these two
    packages. Formulating coherent policies on the division of
    responsibility among packages can be an overwhelming task in
    designing systems with many packages and many cross-type
    operations.

**** Coercion
     In the general situation of completely unrelated operations
     acting on completely unrelated types, implementing explicit
     cross-type operations, cumbersome though it may be, is the best
     that one can hope for. Fortunately, we can usually do better by
     taking advantage of additional structure that may be latent in
     our type system. Often the different data types are not
     completely independent, and there may be ways by which objects of
     one type may be viewed as being another type. This process is
     called _coercion_. For example, if we are asked to arithmetically
     combine an ordinary number with a complex number, we can view the
     ordinary number as a complex number whose imaginary part is
     zero. This transforms the problem to that of combining two
     complex numbers, which can be handled in the ordinary way by the
     complex-arithmetic package. 

     In general, we can implement this idea by designing coercion
     procedure that transform an object of one type into an equivalent
     object of another type. Here is a typical coercion procedure,
     which transforms a given ordinary number to a complex number with
     that real part and zero imaginary part:

     #+BEGIN_SRC scheme
     (define (scheme-number->complex n)
      (make-complex-from-real-imag (contents n) 0))
     #+END_SRC

     We install these coercion procedures in a special coercion table,
     indexed under the names of the two types:

     #+BEGIN_SRC scheme
     (put-coercion 'scheme-number 'complex scheme-number->complex)
     #+END_SRC
     
     (We assume that there are put-coercion and get-coercion
     procedures available for manipulating this table.) Generally some
     of the slots in the table will be empty, because it is not
     generally possible to coerce an arbitrary data object of each
     type into all other types. For example, there is no way to coerce
     an arbitrary complex number to an ordinary number, so there will
     be no general complex->scheme-number procedure included in the
     table. 

     Once the coercion table has been set up, we can handle coercion
     in a uniform manner by modifying the apply-generic procedure for
     section 2.4.3. When asked to apply an operation, we first check
     whether the operation is defined for the arguments' types, just
     as before. If so, we dispatch to the procedure found in the
     operation-and-type table. Otherwise, we try coercion. For
     simplicity, we consider only the case where there are two
     arguments. We check the coercion table to see if objects of the
     first type can be coerced to the second type. If so, we coerce
     the first argument and try the operation again. If objects of the
     first type cannot in general be coerced to the second type, we
     try the coercion the other way around to see if there is a way to
     coerce the second argument to the type of the first
     argument. Finally, if there is no known way to coerce either type
     to the other type, we give up. Here is the procedure:

     #+BEGIN_SRC scheme
     (define (apply-generic op . args)
      (let ((type-tags (map type-tag args)))
       (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                 (let ((t1->t2 (get-coercion type1 type2))
                       (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else 
                         (error "No method for these types"
                                (list op type-tags))))))
                 (else "No method for these types"
                       (list op type-tags)))))))
     #+END_SRC

     This coercion scheme has many advantages over the method of
     defining explicit cross-type operations, as outlined
     above. Although we still need to write coercion procedures to
     relate the types (possible n^2 procedures for a system with n
     types), we need to write only one procedure for each pair of
     types rather than a different procedure for each collection of
     types and each generic operation.  What we are counting on here
     is the fact that the appropriate transformation between types
     depends only on the types themselves, not on the operation to be
     applied.

     On the other hand, there may be applications for which our
     coercion scheme is not general enough. Even when neither of the
     objects to be combined can be converted to the type of the other
     it may still be possible to perform the operation by converting
     both objects to a third type. In order to deal with such
     complexity and still preserve modularity in our programs, it is
     usually necessary to build systems that take advantage of still
     further structure in the relations among types, as we discuss
     next.

**** Hierarchies of types

     The coercion scheme presented above relied on the existence of
     natural relations between pairs of types. Often there is more
     "global" structure in how the different types relate to each
     other. For instance, suppose we are building a generic arithmetic
     system to handle integers, rational numbers,real numbers, and
     complex numbers. In such a system, it is quite natural to regard
     an integer as a special kind of rational number, which is in turn
     a special kind of real number, which is in turn a special kind of
     complex number. What we actually have is a so-called _hierarchy
     of types_, in which, for example, integers are a _subtype_ of
     rational numbers (i.e., any operation that can be applied to a
     rational number can be automatically be applied to an
     integer). Conversely, we say that rational numbers form a
     _supertype_ of integer. The particular hierarchy we have here is
     of a very simple kind, in which each type has at most one
     supertype and at most one subtype. Such a structure, called a
     _tower_, is illustrated in figure 2.25.

     complex 
       ^
     real
       ^
     rational
       ^
     integer

     If we have a tower structure, then we can greatly simplify the
     problem of adding a new type to the hierarchy, for we need only
     specify how the new type is embedded in the next supertype above
     it and how it is the supertype of the type below it. For example,
     if we want to add an integer to a complex number, we need not
     explicitly define a special coercion procedure
     integer->complex. Instead, we define how an integer can be
     transformed into a rational number, how a rational number is
     transformed into a real number, and how a real number is
     transformed into a complex number. We then allow the system to
     transform the integer into a complex number through these steps
     and then add the two complex numbers. 

     We can redesign our apply-generic procedure in the following way:
     For each type, we need to supply a raise procedure, which
     "raises" objects of that type one level in the tower. Then when
     the system is required to operate on objects of different types
     it can successively raise the lower types until all the objects
     are at the same level in the tower. Then when the system is
     required to operate on objects of different types it can
     successively raise the lower types until all the objects are at
     teh same level in the tower. 

     Another advantage of a tower is that we can easily implement the
     notion that every type "inherits" all operations defined on a
     supertype. For instance, if we do not supply a special procedure
     for finding the real part of an integer, we should nevertheless
     expect that real-part will be defined for integers by virtue of
     the fact that integers are a subtype of complex numbers. In a
     tower, we can arrange for this to happen in a uniform way by
     modifying apply-generic. If the required operation is not
     directly defined for the type of the object given, we raise the
     object to its supertype and try again. We thus crawl up the
     tower, transforming our argument as we go, until we either find a
     level at which the desired operation can be performed or hit the
     top (in which case we give up). Yet another advantage of a tower
     over a more general hierarchy is that it gives us a simple way to
     "lower" a data object to the simplest representation. For
     example, if we add 2 + 3i to 4 - 3i, it would be nice to obtain
     the answer as the integer 6 rather than as the complex number 6 +
     0i. Exercise 2.85 discusses a way to implement such a lowering
     operation. (The trick is that we need a general way to
     distinguish those objects that can be lowered, such as 6 + 0i,
     from those that cannot, such as 6 + 2i.)

**** Inadequacies of hierarchies

     If the data types in our system can be naturally arranged in a
     tower, this greatly simplifies the problems of dealing with
     generic operations on different types, as we have
     seen. Unfortunately, this is usually not the case. Figure 2.26
     illustrates a more complex arrangement of mixed types, this one
     showing relations among different types of geometric figures. We
     see that, ingeneral, a type may have more than one supertype. For
     example, an isosceles right triangle may be regarded either as an
     isoceles triangle or as a right triangle. This
     multiple-supertypes issue is particularly thorny, since it means
     that there is no unique way to "raise" a type in the
     hierarchy. Finding teh "correct" supertype in which to apply an
     operation to an object may involve considerable searching through
     the entire type network on the part of a procedure such as
     apply-generic. Since there generally are multiple subtypes for a
     type, there is a similar problem in coercing a value "down" the
     type hierarchy. Dealing with large numbers of interrelated types
     while still preserving modularity in the design of large systems
     is very difficult, and is an area of much current research.

     - Exercise 2.81 Louis Reasoner has noticed that apply-generic may
       try to coerce the arguments to each other's type even if they
       already have the same type. Therefore, he reasons, we need to
       put procedures in the coercion table to _coerce_ arguments of
       each type to their own type. For example, in addition to the
       scheme-number->complex coercion shown above, he would do:

       #+BEGIN_SRC scheme
       (define (scheme-number->scheme-number n) n)
       (define (complex->complex z) z)
       (put-coercion 'scheme-number
                     'scheme-number
                     scheme-number->scheme-number)
       (put-coercion 'complex 'complex complex->complex)
       #+END_SRC

       a. With Louis' coercion procedures installed, what happens if
       apply-generic is called with two arguments of type
       scheme-number or two arguments of type complex for an operation
       that is not found in the table for those types? For example,
       assume that we've defined a generic exponentiation operation:

       #+BEGIN_SRC scheme
       (define (exp x y) (apply-generic 'exp x y))
       #+END_SRC

       and have put a procedure for exponentiation in the
       scheme-number package but not in any other package:

       #+BEGIN_SRC scheme
       ;; following added to scheme-number package
       (put 'exp '(scheme-number scheme-number)
            (lambda (x y) (tag (expt x y))))
            ; using primitive expt
       #+END_SRC

       What happens if we call exp with two complex numbers as
       arguments?

       If you call exp with two complex numbers, apply-generic will
       not find a procedure with a matching signature. So it will then
       try to coerce the types to each others' type. Because Louis
       installed coercion procedures for complex->complex, it finds
       these and applies them. Because complex->complex is the
       identity function, apply-generic ends up calling itself with
       the exact same arguments and loops forever. So Louis Reasoner
       broke the system for undefined operations between objects of
       the same type.

       b. Is Louis correct that something had to be done about
       coercion with arguments of the same type, or does apply-generic
       work correctly as is?

       apply-generic works correctly. It's true that it will try to
       coerce a type to itself. But if no coercions are installed that
       coerce a type to itself, it will give an error message -- the
       exact same error message it gives if it can't look up a
       procedure in the table.

       c. Modify apply-generic so that it doesn't try coercion if the
       two arguments have the same type.

       #+BEGIN_SRC scheme
       (define (apply-generic op . args)
        (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
          (if proc
              (apply proc (map contents args))
              (cond
               ((and (= (length args) 2)
                     (not (eq? (car type-tags) (cadr type-tags))))
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                 (let ((t1->t2 (get-coercion type1 type2))
                       (t2->t1 (get-coercion type2 type1)))
                  (cond
                   (t1->t2
                    (apply-generic op (t1->t2 a1) a2))
                   (t2->t1
                    (apply-generic op a1 (t2->t1 a2)))
                   (else
                    (error "No method for these types"
                           (list op type-tags)))))))
               (else
                (error "No method for these types"
                       (list op type-tags))))))))
       #+END_SRC

     - Exercise 2.82. Show how to generalize apply-generic to handle
       coercion in the general case of multiple arguments. One
       strategy is to attepmt to coerce all the arguments to the type
       of the first argument, then to the type of the second argument,
       and so on. Give an example of a situation where this strategy
       (and likewise the two-argument version given above) is not
       sufficiently general. (Hint: Consider the case where there are
       some suitable mixed-type operations present in the table that
       will not be tried.)

       If you try to just coerce all arguments to the types of one of
       the arguments, you miss a mixed-type operation. Say we have
       arguments of types (complex real rational) and we have an operation
       defined for (complex real real), and say we only have the
       coercion rational->real in the table. If we only try to coerce
       each type so that all types are the same, we miss this in the
       lookup table. So we need to use a recursive procedure.

       #+BEGIN_SRC scheme
       (define (apply-generic op . args)
        (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
          (if proc
              (apply-proc (map contents args))
              (find-matching-coercion op args)))))

       ;; find-matching-coercion -- find a coercion that can be used on the arguments
       ;; to get a procedure using get, and apply it to the coerced arguments.
       (define (find-matching-coercion op args)
        (let ((coercion-typetag-list (get-listof-possible-coercions (map type-tag args))))
         (let ((found-types-and-proc (find-working-typetag-list op coercion-typetag-list args)))
          (if found-types-and-proc
           (apply-proc (car found-types-and-proc) (map contents (cdr found-types-and-proc)))
           (error "Unable to find coercion -- FIND-MATCHING-COERCION" op args)))))

       (define (get-listof-possible-coercions listof-typetags)
        (cond
         ((null? listof-typetags) '())
         (else
          (append
           (map (lambda (x) (cons (car listof-typetags) x))
                (get-listof-possible-coercions (cdr listof-typetags)))
           (map (lambda (x) (cons x (cdr listof-typetags)))
                (get-listof-coerced-types (car listof-typetags)))))))

       (define (get-listof-coerced-types a-type)
        (let ((coercions (get-coercions-list)))
         (map (lambda (coercion) (cadr coercion)) 
              (filter (lambda (coercion) (eq? (car coercion) a-type)) coercions))))

       (define (find-working-typetag-list op listof-possible-typetags original-args-list)
        (cond
         ((null? listof-typetags) false)
         (else
          (let ((coercions (map (lambda (sym1 sym2) 
                                 (if (eq? sym1 sym2)
                                     false
                                     (get-coercion sym1 sym2)))
                                (map type-tag original-args-list)
                                (car listof-possible-typetags))))
           (let ((coerced (map (lambda (proc arg) (if proc (proc arg) arg))
                               coercions
                               original-args-list)))
            (let ((proc (get op (car listof-possible-typetags))))
             (if proc
                 (cons proc coerced)
                 (find-working-typetag-list (cdr listof-possible-typetags)
                                            original-args-list))))))))
       #+END_SRC

       This procedure assumes the exisence of get-coercions which
       returns a list of triples, the input symbol, the output symbol,
       and a procedure. It returns all possible coercions of
       anything. It's an exhaustive search of all possible coercions,
       and is not efficient. But it allows us to apply a procedure
       where, for example, perhaps all three arguments are of a
       different type but they all three have a way to coerce to a
       fourth type. This procedure will find that type and apply
       it. The above is a first draft, and doesn't work. The final
       draft:

       #+BEGIN_SRC scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
       	  (apply proc (map contents args))
       	  (find-matching-coercion op args)))))
       
       ;; find-matching-coercion -- find a coercion that can be used on the arguments
       ;; to get a procedure using get, and apply it to the coerced arguments.
       (define (find-matching-coercion op args)
         (let ((coercion-typetag-list (get-listof-possible-coercions (map type-tag args))))
           (let ((found-types-and-proc (find-working-typetag-list op coercion-typetag-list args)))
             (if found-types-and-proc
       	  (apply (car found-types-and-proc) (map contents (cdr found-types-and-proc)))
       	  (error "Unable to find coercion -- FIND-MATCHING-COERCION" op args)))))
       
       (define (flatmap proc elems)
         (cond
          ((null? elems) '())
          (else
           (append (proc (car elems))
       	    (flatmap proc (cdr elems))))))
       
       (define (get-listof-possible-coercions listof-typetags)
         (cond
          ((null? listof-typetags) '(()))
          (else
           (let ((rest-possible-coercions
       	   (get-listof-possible-coercions (cdr listof-typetags)))
       	  (coercion-destinations-for-this-type
       	   (get-listof-coerced-types (car listof-typetags))))
             (flatmap
              (lambda (first)
       	 (map
       	  (lambda (rest) (cons first rest))
       	  rest-possible-coercions))
              (cons (car listof-typetags) coercion-destinations-for-this-type))))))
       
       (define (get-listof-coerced-types a-type)
         (let ((coercions (get-coercions-list)))
           (map (lambda (coercion) (cadr coercion)) 
       	 (filter (lambda (coercion) (eq? (car coercion) a-type)) coercions))))
       
       (define (find-working-typetag-list op listof-possible-typetags original-args-list)
         (cond
          ((null? listof-possible-typetags) false)
          (else
           (let ((coercions (map (lambda (sym1 sym2) 
       			    (if (eq? sym1 sym2)
       				false
       				(get-coercion sym1 sym2)))
       			  (map type-tag original-args-list)
       			  (car listof-possible-typetags))))
             (let ((coerced (map (lambda (proc arg) (if proc (proc arg) arg))
       			  coercions
       			  original-args-list)))
       	(let ((proc (get op (car listof-possible-typetags))))
       	  (if proc
       	      (cons proc coerced)
       	      (find-working-typetag-list
       	       op
       	       (cdr listof-possible-typetags)
       	       original-args-list))))))))
       #+END_SRC
       
       The indenting doesn't work but polymorph.scm has the
       results. This is an exhuastive solution. A potentially more
       resource-sparing solution would be to only look for coercions
       that involve at least some types that exist in the original
       argument list. Finally, we could try to chain coercions
       somehow. If we have an argument list (a b) and we have a
       coercion a->c and c->b, we could try to apply it that way.

     - Exercise 2.83. Suppose you are designing a generic arithmetic
       system for dealing with the tower of types shown in figure
       2.25: integer, rational, real, complex. For each type (except
       complex), design a procedure that raises objects of that type
       one level in the tower. Show how to install a generic raise
       operation that will work for each type (except complex).

       #+BEGIN_SRC scheme
       (define (install-real)
        ;; package-specific
        (define (raise x)
         (make-complex-from-real-imag x 0))
        ;; interface to system
        (put 'raise '(real) raise)
        ;; .. other stuff
        )

       (define (install-rational)
        ;; package-specific procedures
        (define (raise x)
         (/ (* 1.0 (numer x)) (denom x)))
        ;; interfacing to the system
        (put 'raise '(rational) raise)
        ;; other stuff
        )

       (define (install-integer)
        ;; package-specific procedures
        (define (raise x)
         (make-rational x 1))
        ;; interfacing to the system
        (put 'raise '(integer) raise))
       (define (raise x) (apply-generic 'raise x))
       #+END_SRC

       here, raise is not a special procedure. It is sort of like a
       coercion.

     - Exercise 2.84. Using the raise operation of Exercise 2.83,
       modify the apply-generic procedure so that it coerces its
       arguments to have the same type by the method of successive
       raising, as discussed in this section. You will need to devise
       a way to test which of the two types is higher in the tower. Do
       this in a manner that is "compatible" with the rest of the
       system and will not lead to problems in adding new levels to
       the tower.

       #+BEGIN_SRC scheme
       (define (apply-generic op . args)
        (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
          (if proc 
              (apply-proc (map contents args))
              (let ((raised-list (raise-args op args)))
               (apply apply-generic (cons op raised-list)))))))

       (define (raise-args op args)
        (let ((highest-type-tag (get-highest-type args)))
         (map (lambda (arg) (raise-to highest-type-tag arg)))))

       (define (get-highest-type objects)
        (define (iter-highest highest objs)
         (cond
          ((null? objs) highest)
          ((higher? highest (car objs))
           (iter-highest highest (cdr objs)))
          ((higher? (car objs) highest)
           (iter-highest (car objs) (cdr objs)))
          (else (error "No matching procedure for types" objects))))
        (iter-highest (car objs) (cdr objs)))
 
       (define (raise-to a-type-tag object)
        (cond
         ((eq? (type-tag object) a-type-tag)
          object)
         (else (raise-to a-type-tag (raise object)))))

        (define (higher? type1 type2)
         (let ((type-map (get-type-tower)))
          (let ((type1-in-list (memq type1 type-map))
                (type2-in-list (memq type2 type-map)))
           (if (and type1-in-list type2-in-list)
            (not (memq type1 type2-in-list))
            false))))

        (define (unsorted-pairs-to-chain listof-pairs)
         (define (insertable? element resultlist)
          (cond
           ((null? resultlist) false)
           ((eq? (cadr element) (caar resultlist))
            true)
           ((eq? (car element) (cadar resultlist))
            true)
           (else (insertable? element (cdr resultlist)))))

         (define (insert-one-element elem listof-pairs)
          (cond
           ((null? listof-pairs) (list elem))
           ((eq? (cadr elem) (caar listof-pairs))
            (cons elem listof-pairs))
           ((eq? (car elem) (cadar listof-pairs))
            (cons (car listof-pairs) (cons elem (cdr listof-pairs))))
           (else (cons (car listof-pairs) (insert-one-element elem (cdr listof-pairs))))))

         (define (find-insertable listof-pairs result)
          (cond
           ((null? result) listof-pairs)
           ((null? listof-pairs) 
            (error "Can't insert any element from this into that -- FIND-INSERTABLE"
                   listof-pairs result))
           (else
            (let ((first (car listof-pairs)))
             (if (insertable? first result)
                 listof-pairs
                 (let ((insertable-list (find-insertable (cdr listof-pairs) result)))
                  (cons (car insertable-list) 
                   (cons first (cdr insertable-list)))))))))

         (define (iter-pairs result listof-pairs)
          (cond 
           ((null? listof-pairs) result)
           (else
            (let ((insertable-first (find-insertable listof-pairs result)))
             (iter-pairs (insert-one-element (car insertable-first) result)
                         (cdr insertable-first))))))
          (iter-pairs '() listof-pairs))

        (define (sorted-pairs->list sorted-pairs)
         (cond
          ((null? sorted-pairs)
           (error "Must have a list of at least length one -- SORTED-PAIRS"))
          ((null? (cdr sorted-pairs))
           (list (caar sorted-pairs) (cadar sorted-pairs)))
          (else
           (cons (caar sorted-pairs) (sorted-pairs->list (cdr sorted-pairs))))))

        (define (make-table-into-tower listof-pairs)
         (sorted-pairs->list (unsorted-pairs-to-chain listof-pairs)))

        (define (get-type-tower)
         (let ((raise-table 
                (hash-table->alist (hash-table->ref *op-table* 'raise))))
          (make-table-into-tower (map car raise-table)))
       #+END_SRC
       
       This actually doesn't work, given the way we defined raise
       earlier. I assume that the lists returned by getting raise
       entries out of the procedure table are pairs, but they are only
       lists of a single element, because we only define the type it
       takes. So, in order for the apply procedure to work, we need to
       treat raise procedures like coercions. In fact we could do
       something like tie the coercion and raise table together. But
       we do need for our program to be informed about the type tower
       some way or another, and it should be informed by how people
       define the raise procedures. If we just naively define a raise
       procedure, that will not allow the 'interpreter' we've built to
       raise things intelligently. A potential application is to 'test
       raise' things, but this would be extremely inefficient.

       I will define a procedure used like this:

       #+BEGIN_SRC scheme
       (put-raise '(x y) (lambda (x) ...))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define *inheritance-table* '())
       (define (put-raise t1 t2 proc)
         (put 'raise (list t1) proc)
         (put-coercion t1 t2 proc)
         (put-inheritance t1 t2))
       (define (put-inheritance t1 t2)
        (set! *inheritance-table* (cons (list t1 t2) *inheritance-table*)))
       #+END_SRC

       put-inheritance defines the start of a new system designed just
       to keep track of who inherits from whom. We are only required
       to redefine get-type-tower in this case.

       The finished system (which doesn't have all the errors this
       does) is in polymorph-inheritance.scm and
       number-system-inheritance.scm. It has some limitations. It
       doesn't raise types to the right type if a procedure is defined
       that has a list of types where we could satisfy the signature
       by raising some and not others, it only coerces to the first
       common type, and then keeps coercing up in case there is a
       procedure defined further up the heirarchy. It doesn't disturb
       any extra additions to the tower.

     - Exercise 2.85. This section mentioned a method for
       "simplifying" a data object by lowering it in the tower of
       types as far as possible. Design a procedure drop that
       accomplishes this for the tower described in exercise 2.83. The
       key is to decide, in some general way, whether an object can be
       lowered. For example, the complex number 1.5 + 0i can be
       lowered as far as real, the complex number 1 + 0i can be
       lowered as far as integer, and the complex number 2 + 3i cannot
       be lowered at all. Here is a plan for determining whether an
       object can be lowered: Begin by defining a generic operation
       project that "pushes" an object down in the tower. For example,
       projecting a complex number would involve throwing away the
       imaginary part. Then a number can be dropped if, when we
       project it and raise the result back to the type we started
       with, we end up with something equal to what we started
       with. Show how to implement this idea in detail, by writing a
       drop procedure that drops an object as far as possible. You
       will need to design the various projection operations and
       install project as a generic operation in the system. You will
       also need to make use of a generic equality predicate, such as
       described in exercise 2.79. Finally, use drop to rewrite
       apply-generic from exercise 2.84 so it "simplifies" its
       answers.

       We must define a project operation for each type, that is,
       inside the type-specific package is the best place for us to
       define projections, although we could put them
       elsewhere. Projections should not use apply-generic and should
       not be applied with apply-generic, because we don't want tags
       to be stripped. We want to be able to deal with both types as
       abstract. So technically we could put projections outside the
       package definition, but it makes less sense outside.

       We define two more procedures, put-projection and
       get-projection, that behave the same as type coercions. project
       is then a procedure that gets a projection and applies it. We
       already have the equ? procedure defined. drop will then simply
       drop things, raise them back, and compare if the two are
       equal. If so, keep dropping.

       #+BEGIN_SRC scheme
       (define (install-real-package)
        ; ...
        (put-projection 'complex 'real (lambda (x) (real-part x))))

       (define (install-rational-package)
        ; ...
        (define MAX-DIGITS 15)
        (define (coerce-to-rational areal)
         (define (coerce-to-rational-inner num denom digit-counter)
          (cond
           ((or (= digit-counter 0)
                (= (floor num) num))
            (make-rational (floor num) (floor denom)))
           (else
            (coerce-to-rational-inner (* num 10)  (* 10 denom) (- digit-counter 1)))))
         (coerce-to-rational-inner areal 1 MAX-DIGITS))
                
            
         
        (put-projection 'real 'rational coerce-to-rational)

       (define (install-integer-package)
        ; ...
        (put-projection 'rational 'integer
          (lambda (x) (floor (/ (numer x) (denom x))))))

       (define (project x)
        ((get-projection (type-tag x)) x))
       (define (drop x)
        (cond
         ((and (projectable? (type-tag x)) (equ? x (raise (project x))))
          (drop (project x)))
         (else x)))


       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc 
     	          (drop (apply proc (map contents args)))
         	  (let ((raised-list (raise-args op args)))
        	        (apply apply-generic (cons op raised-list)))))))
       #+END_SRC
       
       The implementations of all these had to be changed
       considerably. This is now drop:

       #+BEGIN_SRC scheme
       (define (drop x)
         (let ((x-tag (type-tag x)))
           (cond
            ((and (projectable? (type-tag x)) ((get 'equ? (list x-tag x-tag))
       					(contents x) (contents (raise (project x)))))
             (drop (project x)))
            (else x))))
       #+END_SRC

       It was changed because equ? is defined as an apply-generic
       alias. drop would work fine if I didn't put it in
       apply-generic, but because I did, any call to equ? results in
       infinite recursion, because the beginning of the drop procedure
       calls itself transitively without ever actually evaluating a
       condition. In general, the entire inheritance system, the more
       integrated it became with the system, had to very carefully
       avoid apply-generic procedures for this reason. 

       This makes it so that apply-generic can really only be used
       strictly by higher-level clients, and that it's layer in the
       stratified design becomes pretty clearly higher than any
       inheritance procedure, which wasn't at first apparent, at least
       to me. 
       
       The next problem with our apply-generic procedure as modified
       is that any procedure that returns values outside the type
       hierarchy -- like equ? must not be dropped. This led to a
       modification:

       #+BEGIN_SRC scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc 
       	         (let ((val (apply proc (map contents args))))
       	          (if (type-in-system? val)
       		      (drop val)
       		      val))
       	         (let ((raised-list (raise-args op args)))
       	          (apply apply-generic (cons op raised-list)))))))       
       (define (type-in-system? datum)
         (cond
          ((or
            (number? datum)
            (and (pair? datum)
       	         (not (false? (memq (car datum) (get-type-tower))))))
           true)
          (else
           false)))
       #+END_SRC

       which only drops values that are in the type system. Finally, I
       also had to change the definition of raise, which had been an
       apply-generic procedure. Finally, I had to change raise, which
       had been defined as a apply-generic procedure. It had more or
       less gotten away with being defined as apply-generic since it
       only asked for raises that were in the system. However, if it
       asks for a raise not in the system, it will recursively call
       itself.

       #+BEGIN_SRC scheme
       (define (raise x)
        ((get-coercion (type-tag x) (get-parent (type-tag x))) x))
       #+END_SRC

       With the previous definition, if you asked for a nonexistent
       procedure to apply, apply-generic would hang and blow the
       recursion limit. The final draft works.


     - Exercise 2.86: Suppose we want to handle complex numbers whose
       real parts, imaginary parts, magnitudes, and angles can be
       either ordinary numbers, rational numbers, or other numbers we
       might wish to add to the system. Describe and implement the
       changes to the system needed to accomodate this. You will have
       to define operations such as sine and cosine that are generic
       over ordinary numbers and rational numbers.

       You need to replace all the operations on the numbers like
       +, -, /, with add, sub, and div. Then define cosine, sine, atan
       on those numbers. This has interesting implications for the
       'layering' of our design. complex becomes a number that is made
       up of the other numbers. On the other hand, it doesn't _know_
       what numbers it's made up of. But earlier I was thinking of
       this as a normal object hierarchy in an OO language. However,
       you rarely have a concrete supertype made up of descended
       subtypes. That doesn't actually mean you can't. 

       But we also have to modify the entire complex package and all
       representations of complex numbers. Rather than tyep the thing
       out here I just modified complex.scm,
       number-system-inheritance.scm, and polymorph-inheritance.scm to
       work with the new system.

       Basically, what was needed was to create these functions:

       - cosine -- cos function, integer and rational packages are
         just aliases to the cos builtin. In the rational package we
         convert to real numbers before taking the cosine. 

       - sine -- sine function, same basic idea as cosine.

       - arctan -- Again, alias to atan in real and integer, but atan
         with the (/ (numer y) (denom y)) conversion applied to the
         arguments first.

       - sqr -- squaring function, defined as (mul x x).

       - square-root -- square-root function, In the real and integer
         packages just (put 'square-root '<symbol> sqrt) and in the
         rational package we convert it first.

*** 2.5.3. Example: Symbolic Algebra
    The manipulation of symbolic algebraic expressions is a complex
    process that illustrates many of the hardest problems that occur
    in the design of large-scale systems. An algebraic expression, in
    general, can be viewed as a hierarchical structure, a tree of
    operators applied to operands. We can construct algebraic
    expressions by starting with a set of primitive objects, such as
    constants and variables, and combining these by means of algebraic
    operators, such as addition and multiplication. As in other
    languages, we form abstractions that enable us to refer to
    compound objects in simple terms. Typical abstractions in symbolic
    algebra are ideas such as linear combination, polynomial, rational
    function, or trigononmetric function. We can regard these as
    compound "types," which are often useful for directing the
    processing of expressions. For example, we could describe the
    expression

    \begin{frag}
    x^2sin(y^2 + 1) + x cos 2y + cos(y^3 - 2y^2)
    \end{frag}

    as a polynomial in x with coefficients that are trigonometric
    functions of polynomials in y whose coefficients are integers.

    We will not attempt to develop a complete algebraic-manipulation
    system here. Such systems are exceedingly complex programs,
    embodying deep algebraic knowledge and elegant algorithms. What we
    will do is look at a simple but important part of algebraic
    manipulation: the arithmetic of polynomials. We will illustrate
    the kinds of decisions the designer of such a system faces, and
    how to apply the ideas of abstract data and generic operations to
    helpl organize this effort.

**** Arithmetic on polynomials

     Our first task in designing a system for performing arithmetic on
     polynomials is to decide just what a polynomial is. Polynomials
     are normally defined relative to certain variables (the
     _indeterminates_ of the polynomial). For simplicity, we will
     restrict ourselves to polynomials having just one indeterminate
     (_univariate polynomials_). We will define a polynomial to be a
     sum of terms, each of which is either a coefficient, a power of
     the indeterminate, or a product of a coefficient and a power of
     the indeterminate. A coefficient is defined as an algebraic
     expression that is not dependent upon the indeterminate of the
     polynomial. For example

     \begin{example}
     5x^2 + 3x +  7
     \end{example}

     is a simple polynomial in x and

     \begin{example}
     (y^2 + 1)x^3 + (2y)x + 1
     \end{example}

     is a polynomial in x whose coefficients are polynomials in y.

     Already we are skirting some thorny issues. Is the first of these
     polynomials the same as the polynomial 5y^2 + 3y + 7, or not? A
     reasonable answer might be "yes, if we are considering a
     polynomial purely as a mathematical function, but no, if we are
     considering a polynomial to be a syntactic form." The second
     polynomial is algebraically equivalent to a polynomial in y whose
     coefficients are polynomials in x. Should our system recognize
     this, or not? Furthermore, there are other ways to represent a
     polynomial -- for example, as a product of factors, or (for a
     univariate polynomial) as the set of roots, or as a listing of
     the values of the polynomial at a specified set of points. We can
     finesse these questions by deciding that in our
     algebraic-manipulation system a "polynomial" will be a particular
     syntactic form, not its underlying mathematical meaning.

     Now we must consider how to go about doing arithmetic on
     polynomials. In this simple system, we  will consider only
     addition and multiplication. Moreover, we will insist that two
     polynomials to be combined must have the same indeterminate.

     We will approach the design of our system by following the
     familiar discipline of data abstraction. We will represent
     polynomials using a data structure called a _poly_, which
     consists of a variable and a collection of terms. We assume that
     we have selectors variable and term-list and extract those parts
     from a poly and a constructor make-poly that assemples a poly
     from a given variable and term list. A variable will be just a
     symbol, so we can use the same-variable? procedure of Section
     2.32 to compare variables. The following procedures define
     addition and multiplication of polys:

     #+BEGIN_SRC scheme
     (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (add-terms (term-list p1) (term-list p2)))
          (error "Polys not in same var: ADD-POLY" (list p1 p2))))
     (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1) (term-list p2)))
          (error "Polys not in same var: MUL-POLY" (list p1 p2))))
     #+END_SRC
    
     To incorporate polynomials into our generic arithmetic system, we
     need to supply them with type tags. We'll use the tag polynomial,
     and install appropriate operations on tagged polynomials in the
     operation table. We'll embed all our code in an installation
     procedure for the polynomial package, similar to the ones in
     section 2.5.1:

     #+BEGIN_SRC scheme
     (define (install-polynomial-package)
      ;; internal procedures
      ;; representation of poly
      (define (make-poly variable term-list) (cons variable term-list))
      (define (variable p) (car p))
      (define (term-list p) (cdr p))
      (define (add-poly p1 p2) ...)
      (define (mul-poly p1 p2) ...)

      ;; interface to rest of system
      (define (tag p) (attach-tag 'polynomial p))
      (put 'add '(polynomial polynomial)
           (lambda (p1 p2) (tag (add-poly p1 p2))))
      (put 'mul '(polynomial polynomial)
           (lambda (p1 p2) (tag (mul-poly p1 p2))))
      (put 'make 'polynomial
           (lambda (var terms) (tag (make-poly var terms))))
      'done)
     #+END_SRC

     Polynomial addition is performed termwise. Terms of the same
     order (i.e., with the same power of the indeterminate) must be
     combined. This is done by forming a new term of the same order
     whose coefficient is the sum of the coefficients of the
     addends. Terms in one addend for which there are no terms of the
     same order in the other addend are simply accumulated into the
     sum polynomial being constructed. 

     In order to manipulate term lists, we will assume that we have a
     constructor the-empty-termlist that returns an empty term list
     and a constructor adjoin-term that adjoins a new term to a term
     list. We will also assume that we have a predicate
     empty-termlist? that tells if a given term list is empty, a
     selector first-term that extracts the highest-order term from a
     term list, and a selector rest-terms that returns all but the
     highest-order term. To manipulate terms, we will suppose that we
     have a constructor make-term that constructs a term with given
     order and coefficient, and selectors order and coeff that return,
     respectively, the order and the coefficient of the term. These
     operations allow us to consider both terms and term lists as data
     abstractions, whose concrete representations we can worry about
     separately.

     Here is the procedure that constructs the term list for the sum
     of two polynomials:

     #+BEGIN_SRC scheme
     (define (add-terms L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1))
                   (t2 (first-term L2)))
              (cond ((> (order t1) (order t2))
                     (adjoin-term
                      t1
                      (add-terms (rest-terms L1) L2)))
                    ((< (order t1) (order t2))
                     (adjoin-term
                      t2
                      (add-terms L1 (rest-terms L2))))
                    (else
                     (adjoin-term
                      (make-term (order t1)
                                 (add (coeff t1) (coeff t2)))
                      (add-terms (rest-terms L1)
                                 (rest-terms L2)))))))))
     #+END_SRC
     
     The most important point to note here is that we used the generic
     addition procedure add to add together the coefficients of the
     terms being combined. This has powerful consequences, as we will
     see below.

     In order to multiply two term lists, we multiply each term of the
     first list by all the terms of the other list, repeatedly using
     mul-term-by-all-terms, which multiplies a given term by all terms
     in a given term list. The resulting term lists (one for each term
     of the first list) are accumulated into a sum. Multiplying two
     terms forms a term whose order is the sum of the orders of the
     factors and whose coefficient is the product of the coefficients
     of the factors:

     #+BEGIN_SRC scheme
     (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
          (the-empty-termlist)
          (add-terms (mul-term-by-all-terms (first-term L1) L2)
                     (mul-terms (rest-terms L1) L2))))
     (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
          (the-empty-termlist)
          (let ((t2 (first-term L)))
           (adjoin-term
            (make-term (+ (order t1) (order t2))
                       (mul (coeff t1) (coeff t2)))
            (mull-term-by-all-terms t1 (rest-terms L))))))

     #+END_SRC

     This is really all there is to polynomial addition and
     multiplication. Notice that, since we operate on terms using the
     generic procedures add and mul, our polynomial package is
     automatically able to handle any type of coefficient that is
     known about by the genric arithmetic package. If we include a
     coercion mechanism such as the one discussed in Section 2.5.2,
     then we also are automatically able to handle operations on
     polynomials of different coefficient types, such as

     \begin{mul}
     [3x^2 + (2 + 3i)x + 7] * [x^4 + \frac{2}{3}x^2 (5 + 3i)]
     \end{mul}
     
     Because we installed the polynomial addition and multiplication
     procedures add-poly and mul-poly in the generic arithmetic system
     as the add and mul operations for type and polynomial, our system
     is also automaticlaly able to handle polynomial operations such
     as

     \begin{mul}
     [(y + 1)x^2 + (y^2 + 1)x + (y - 1)] * [(y - 2)x + (y^3 + 7)]
     \end{mul}

     The reason is that when the system tries to combine coefficients,
     it will dispatch through add and mul. Since the coefficients are
     themselves polynomials (in y), these will be combined using
     add-poly and mul-poly. The result is a kind of "data-directed
     recursion" in which, for example, a call to mul-poly will result
     in recursive calls to mul-poly in order to multiply the
     coefficients. If the coefficients of the coefficients were
     themselves polynomials (in y), these will be combined using
     add-poly and mul-poly. The result is a kind of "data-directed
     recursion" in which, for example, a call to mul-poly will result
     in recursive calls to mul-poly in order to multiply the
     coefficients. If the coefficients of the coefficients were
     themselves polynomials (as might be used to represent polynomials
     in three variables), the data direction would ensure that the
     system would follow through another level of recursive calls, and
     so on through as many levels as the structure of the data
     dictates.

**** Representing term lists
     
     Finally, we must confront the job of implementing a good
     representation for the term lists. A term list is, in effect, a
     set of coefficients keyed by the order of the term. Hence, any of
     the methods for representing sets, as discussed in section 2.3.3,
     can be applied to this task. On the other hand, our procedures
     add-terms and mul-terms always access term lists sequentially
     from highest to lowest order. Thus, we will use some kind of
     ordered list representation.

     How should we structure the list that represents a term list? One
     consideration is the "density" of the polynomials we intend to
     manipulate. A polynomial is said to be _dense_ if it has nonzero
     coefficents in terms of most orders. If it has many zero terms it
     is said to be _sparse_. For example:

     \begin{dense}
     A: x^5 + 2x^4 + 3x^2 - 2x - 5
     \end{dense}

     is a dense polynomial, whereas

     \begin{sparse}
     B: x^100 + 2x^2 + 1
     \end{sparse}

     is sparse.

     The term lists of dense polynomials are most efficiently
     represented as lists of the coefficients. For example, A above
     would be nicely represented as (1 2 0 3 -2 -5) The order of a
     term in this representation is the length of the sublist
     beginning with that term's coefficient, decremented by 1. This
     would be a terrible representation for a sparse polynomial such
     as B: There would be a giant list of zeros punctuated by a few
     lonely nonzero terms. A more reasonable representation of the
     term list of a sparse polynomial is as a list of nonzero terms,
     where each term is a list containing the order of the term and
     the coefficient for that order. In such a scheme, polynomial B is
     efficiently represented as ((100 1) (2 2) (0 1)). As most
     polynomial manipulations are performed on sparse polynomials, we
     will use this method. We will assume that term lists are
     represented as lists of terms, arranged from highest-order to
     lowest-order term. Once we have made this decision, implementing
     the selectors and constructors for terms and term lists is
     straightforward:

     #+BEGIN_SRC scheme
     (define (adjoin-term term term-list)
      (if (=zero? (coeff term))
          term-list
          (cons term term-list)))
     (define (the-empty-termlist) '())
     (define (first-term term-list) (car term-list))
     (define (rest-terms term-list) (cdr term-list))
     (define (empty-termlist? term-list) (null? term-list))
     (define (make-term order coeff) (list order coeff))
     (define (order term) (car term))
     (define (coeff term) (cadr term))
     #+END_SRC

     where =zero? is as defined in exercise 2.80. 

     Users of the polynomial package will create (tagged) polynomials
     by means of the procedure:

     #+BEGIN_SRC scheme
     (define (make-polynomial var terms)
      ((get 'make 'polynomial) var terms))
     #+END_SRC

     - Exercise 2.87: Install =zero? for polynomials in the generic
       arithmetic package. This will allow adjoin-term to work for
       polynomials with coefficients that are themselves polynomials.

       #+BEGIN_SRC scheme
      (define (=poly-zero? poly)
       (or (empty-termlist? (term-list poly))
    	   (all-coeffs-zero? poly)))
      (define (all-coeffs-zero? poly)
       (fold-right (lambda (term result) 
 		    (and result (=zero? (coeff term))))
		   true
		   (term-list poly)))
       (put '=zero? '(polynomial) =poly-zero?)
       #+END_SRC

     - Exercise 2.88: Extend the polynomial system to include
       subtraction of polynomials (Hint: You may find it helpful to
       define a generic negation operation).

       #+BEGIN_SRC scheme
       (define (sub x y) (add x (negate y)))
       (define (negate x) (apply-generic 'negate x))
       (define (install-integer)
        ;; ...
        (define (negate-int x) -)
        (put 'negate '(integer) negate-int)
        ;; ...)
        
       (define (install-rational-package)
        ;; ...
        (define (negate-rat x) (make-rational (- (numer x)) (denom x)))
        (put 'negate '(rational) negate-rat)
        ;; ...)

       (define (install-real)
        ;; ...
        (define (negate-real x) -)
        (put 'negate '(real) negate-real)
        ;;
        )
       (define (install-complex)
        ;; ...
        (define (negate-complex x)
         (mul (make-complex-from-real-imag -1 0) x))
        (put 'negate '(complex) negate-complex)
        ;; ...
        )
       (define (install-polynomial)
        ;; ...
        (define (negate-poly p)
         (make-poly (variable p)
                    (negate-coefficients (term-list p))))
        (define (negate-coefficients terms)
         (if (empty-term-list? terms)
             (empty-term-list)
             (let ((first (first-term terms))
                   (rest (rest-terms terms)))
              (adjoin-term
               (make-term (order first)
                          (negate (coeff first)))
               (negate-coefficients rest)))))
       (put 'negate '(polynomial) negate-poly)
       ;; ...
       )

       #+END_SRC

     - Exercise 2.89 Define procedures that implement the term-list
       representation described above as appropriate for dense
       polynomials.

       #+BEGIN_SRC scheme
       (define (adjoin-term term term-list)
        (define (insert-term order coeff list listlen)
         (cond
          ((null? list) (error 
                         "There is a mistake in the insert-term coding -- ADJOIN-TERM"))
          ((= order (- listlen 1)) 
           (cons (add coeff (car list)) (cdr list)))
          (else (cons (car list) (insert-term order coeff (cdr list) (- listlen 1))))))
        (define (repeat-zero n)
         (cond ((= n 0) '())
               (else (cons 0 (repeat-zero (- n 1))))))
        (let ((term-order (order term))
              (term-coeff (coeff term)))
         (cond
          ((< term-order (length term-list))
           (insert-term term-order term-coeff term-list (length term-list)))
          (else
           (append (cons term-coeff (repeat-zero (- term-order (length term-list))))
                    term-list)))))

       (define (the-empty-termlist) '())
       (define (first-term term-list) term-list)
       (define (rest-terms term-list) (cdr term-list))
       (define (empty-termlist? term-list) (null? term-list))
       (define (make-term order coeff)
        (define (make-term-inner terms nleft)
         (if (= nleft 0)
             (cons coeff terms)
             (make-term-inner (cons 0 terms) (- nleft 1))))
        (make-term-inner '() order))
       (define (order term) (- (length term) 1))
       (define (coeff term) (car term))
       #+END_SRC

       This is what I started with. However, given this
       representation, other things make sense to redefine, especially
       add-terms. adjoin-term basically does the work of add-terms;
       joining two term lists is the same as add-terms. In fact, we
       can alias add-terms with adjoin-term and get the same
       answers. All of the implementations of the functions we have so
       far that operate on polynomials will still work given these
       modifications. However, we can speed them up considerably by
       redefining most other functions. I won't do that now since I
       know I'll have to for 2.90.

     - Exercise 2.90: Suppose we want to have a polynomial system that
       is efficient for both sparse and dense polynomials. One way to
       do this is to allow both kinds of term-list representations in
       our system. The situation is analogous to the complex-number
       example of section 2.4, where we allowed both rectangular and
       polar representations. To do this we must distinguish different
       types of term lists and make the operations on term lists
       generic. Redesign the polynomial system to implement this
       generalization. This is a major effort, not a local change.

       We need to create two packages, sparse-term-list-package and
       dense-term-list-package, and insert their operations into the table.

       You must define a term as separate from the lists, a termlist
       is a strictly separate concept from its atom. Otherwise, you
       can't have generic applications of add-to-list, cons,
       etc. Because you have to design a particular atom for a
       particular list and then know a-priori the list type.

       Then there is another problem which is that we have to define
       adjoin-list for two items, a term and a list. We need the list
       to differ but we already know what the term is, and don't need
       it tagged. But our type system doesn't allow this, to satisfy
       the put requirement we have to tag each argument.  It only
       makes sense to have one representaiton of a term list right
       now. So we do not need it tagged. Furthermore, because
       apply-generic applies the contents function to each argument,
       we get the _internal_ representation of the term when we do not
       really want it. My solution was to make make-term tag its
       returned term object but to not define order or coeff as
       generic procedures, but to just use the ones directly
       manipulating the list everywhere.  This required one change to
       the add-terms procedure, I couldn't just use adjoin-list with a
       term from a list but re-make a term so it was tagged.

       There were just generally some strange consequences to the fact
       that we wanted to manipulate term objects in two different
       layers and between three different types. It required that all
       three types manipulate terms assuming they aren't tagged, and
       that they tag them when they pass them back out, for the most
       part. Or at least tag them when passing them to procedures they
       don't own. The result is in polynomials.scm.

     - Exercise 2.91: A univariate polynomial can be divided by
       another one to produce a polynomial quotient and a polynomial
       remainder. For example,

       \begin{polydiv}
       \frac{x^5 - 1}{x^2 - 1} = x^3 + x, remainder x - 1.
       \end{poly}

       Division can be performed via long division. That is, divide
       the highest-order term of the dividend by the highest-order
       term of the divisor. The result is the first term of the
       quotient. Next, multiply the result by the divisor, subtract
       that from the dividend, and produce the rest of the answer by
       recursively dividing the difference by the divisor. Stop when
       the order of the divisor exceeds the order of the dividend and
       declare the dividend to be the remainder. Also, if the dividend
       ever becomes zero, return zero as both quotient and remainder.

       We can design a div-poly procedure on the model of add-poly and
       mul-poly. The procedure checks to see if the two polys have the
       same variable. If so, div-poly strips off the variable and
       passes the problem to div-terms, which performs the division
       operation on term lists. div-poly finally reattaches the
       variable to the result supplied by div-terms. It is convenient
       to design div-terms to compute both the quotient and the
       remainder of a division. div-terms can take two term lists as
       arguments and return a list of the quotient term list and the
       remainder term list.

       Complete the following definition of div-terms by filling in
       the missing expressions. Use this to implement div-poly, which
       takes two polys as arguments and returns a list of the quotient
       and remainder polys.

       #+BEGIN_SRC scheme
       (define (div-terms L1 L2)
        (if (empty-termlist? L1)
            (list (the-empty-termlist) (the-empty-termlist))
            (let ((t1 (first-term L1)))
                 ((t2 (first-term L2)))
             (if (> (order t2) (order t1))
                 (list (the-empty-termlist) L1)
                 (let ((new-c (div (coeff t1) (coeff t2)))
                       (new-o (- (order t1) (order t2))))
                  (let ((rest-of-result
                         <compute rest of result recursively> ))
                   <form complete result> ))))))
       #+END_SRC
       #+BEGIN_SRC scheme
       (define (div-terms L1 L2)
        (if (empty-termlist? L1)
            (list (the-empty-termlist) (the-empty-termlist))
            (let ((t1 (first-term L1))
                  (t2 (first-term L2)))
             (if (> (order t2) (order t1))
                 (list (the-empty-termlist) L1)
                 (let ((new-c (div (coeff t1) (coeff t2)))
                       (new-o (- (order t1) (order t2))))
                  (let ((rest-of-result
                         (div-terms 
                          (add-terms 
                           L1
                           (negate-coefficients 
                            (mul-term-by-all-terms 
                             (make-untagged-term new-o new-c)
                             L2)))
                           L2)))
                    (let ((remainder (cadr rest-of-result))
                          (div-result (car rest-of-result)))
                     (list
                      (adjoin-term
                       (make-term new-o new-c)
                        div-result)
                      remainder))))))))
       #+END_SRC 
       
       Here is div-terms. I didn't add this to the 'div tag since it
       doesn't return anything that is recognized by the number
       system. I instead created a div-poly function visible outside
       the polynomial package.

       I modified it as below to work in the multiple-list system:

       #+BEGIN_SRC scheme
       (define (div-terms L1 L2)
        (if (empty-termlist? L1)
  	;; (list (the-empty-termlist) (the-empty-termlist))
	    (list L1 L1)
	   (let ((t1 (first-term L1))
	         (t2 (first-term L2)))
	     (if (> (order t2) (order t1))
	         (list (the-empty-sparse-termlist) L1)
	         (let ((new-c (div (coeff t1) (coeff t2)))
	   	    (new-o (- (order t1) (order t2))))
	   	(let ((rest-of-result
	   	       (div-terms 
	   		(add-terms 
	   		 L1
	   		 (negate-coefficients 
	   		  (mul-term-by-all-terms 
	   		   (make-untagged-term new-o new-c)
	   		   L2)))
	   		L2)))
	   	  (let ((remainder (cadr rest-of-result))
	   		(div-result (car rest-of-result)))
	   	    (list
	   	     (adjoin-term
	   	      (make-term new-o new-c)
	   	      div-result)
	   	     remainder))))))))
       #+END_SRC

**** Hierarchies of types in symbolic algebra

     Our polynomial system illustrates how objects of one type
     (polynomials) may in fact be complex objects that have objects of
     many different types as parts. This poses no real difficulty in
     defining generic operations. We need only install appropriate
     generic operations for performing the necessary manipulations of
     the parts of the compound types. In fact, we saw that polynomials
     form a kind of "recursive data abstraction," in that parts of a
     polynomial may themselves be polynomials. Our generic operations
     and our data-directed programming style can handle this
     complication without much trouble.

     On the other hand, polynomial algebra is a system for which the
     data types cannot be naturally arranged in a tower. For instance,
     it is possible to have polynomials in _x_ whose coefficients are
     polynomials in _y_. It is also possible to have polynomials in
     _y_ whose coefficients are polynomials in _x_. Neither of these
     types is "above" the other in any natural way, yet it is often
     necessary to add together elements from each set. There are
     several ways to do this. One possibility is to convert one
     polynomial to the type of the other by expanding and rearranging
     terms so that both polynomials have the same principal
     variable. One can impose a towerlike structure on this by
     ordering the variables and thus always converting any polynomial
     to a "canonical form" with the highest-priority variable dominant
     and the lower-priority variables buried in the coefficients. This
     strategy works fairly well, except that the conversion may expand
     a polynomial unnecessarily, making it hard to read and perhaps
     less efficient to work with. The tower strategy is certainly not
     natural for this domain or any domain where the user can invent
     new types dynamically using old types in various combining forms,
     such as trigonometric functions, power series, and integrals. 

     It should not be surprising that controlling coercion is a
     serious problem in the design of large-scale
     algebraic-manipulation systems. Much of the complexity of such
     systems is concerned with relationships among diverse
     types. Indeed, it is fair to say that we do not yet completely
     understand coercion. In fact, we do not yet completely understand
     the concept of a data type.

     - Exercise 2.92: By imposing an ordering on variables, extend the
       polynomial package so that addition and multiplication of
       polynomials works for polynomials in different variables. (This
       is not easy!)

       I suppose what this means is that the polynomial x^3 + 2y + x
       should be converted to a polynomial in x with coefficients in y
       all the time, even though we could look at it as a polynomial
       in y with coefficients in x. So

       #+BEGIN_SRC scheme
       (make-polynomial 'x (list 'dense-term-list 
                                 1
                                 0
                                 1
                                 (make-polynomial 'y '(dense-term-list 2 0))))
       #+END_SRC

       Should be the same as

       #+BEGIN_SRC scheme
       (make-polynomial 'y (list 'dense-term-list
                            2
                            (make-polynomial 'x
                             '(dense-term-list 1 0 1 0))))
       #+END_SRC

       That way, we can always add two polynomials. The simplest way
       to do this is in the make-polynomial procedure itself. We can
       define an ordering with a list:
       
       #+BEGIN_SRC scheme
       (define VARIABLE-ORDER '(x y z a b c))
       #+END_SRC

       Let's look at some examples:

       (y^2 + 2y)x^3 + x^2 + 2y*x + 1 -- 
       (x^3)y^2 + (2 * x^3 + 2 *x) * y + (x^2 + 1)
       #+BEGIN_SRC scheme
       ;; canonical representation
       (make-polynomial 'x (list 'dense-term-list
                                  (make-polynomial 'y '(dense-term-list 1 2 0))
                                  2
                                  (make-polynomial 'y '(dense-term-list 2 0))
                                  1))
       (make-polynomial 'y (list 'dense-term-list
                                 (make-polynomial 'x '(dense-term-list 1 0 0 0))
                                 (make-polynomial 'x '(dense-term-list 2 0 2 0))
                                 (make-polynomial 'x '(dense-term-list 1 0 1))))
       #+END_SRC

       We need a procedure to transform the second to the first. We do
       this by looking at the polynomial lists and building terms in X
       for that. For example, we take all the highest-degree terms
       from the x polynomials and combine them, we'd look thorugh the
       list and see x^3 with coefficients of 1 for y^2 and 2 for y. So
       that means we have a term (y^2 + 2*y) * x^3

       #+BEGIN_SRC scheme
       (define (add-to-coefficient-from-poly
                new-var
                new-term
                poly-term)
         (let ((term-order (order new-term))
               (new-term-coeff-poly (coeff new-term)))
          (define (iter poly-termlist new-coeff-termlist)
           (if (empty-termlist? poly-termlist)
               new-coeff-termlist
               (cond
                ((= (order (first-term poly-termlist)) term-order)
                 (adjoin-term (make-term 
                               (order poly-term) 
                               (coeff (first-term poly-termlist)))
                              new-coeff-termlist))
                (else (iter (rest-terms poly-termlist) new-coeff-termlist)))))
          (make-term term-order 
                     (make-poly 
                       (variable new-term-coeff-poly) 
                       (iter (term-list (coeff poly-term))
                             (term-list new-term-coeff-poly))))))

       (define (add-to-coefficient-from-constant
                new-variable
                term
                first-term)
        (if (= 0 (order term)) 
            (make-term
             (order term)
              (make-poly
               (variable (coeff term))
               (adjoin-term
                (make-term (order first-term)
                           (coeff first-term))
                (term-list (coeff term)))))
             term))

       ;; transform poly to be in terms of new-variable.
       (define (make-term-of-order-in new-variable order poly)
        (define (iter termlist term)
         (if (empty-termlist? termlist)
             term
         (let ((first-term (first-term termlist))
               (rest-terms (rest-terms termlist)))
          (if (polynomial-in? new-variable (coeff first-term))
              (iter rest-terms (add-to-coefficient-from-poly
                                new-variable
                                term
                                first-term))
              (iter rest-terms (add-to-coefficient-from-constant
                                new-variable
                                term
                                first-term))))))
         (iter (term-list poly) 
                (make-term 
                 order 
                 (make-poly (variable poly) (the-empty-termlist)))))

       (define (polynomial-in? var poly)
        (same-variable? var (variable poly)))

     

       (define (transform-terms new-variable poly)
        (define (iter termlist order)
         (if (< order 0)
             termlist
             (let ((new-term (make-term-of-order-in new-variable order poly)))
                  (iter (adjoin-term new-term
                                     termlist)
                        (- order 1)))))
         (make-poly new-variable (iter (the-empty-termlist) 
                                       (highest-order-of new-variable poly))))

       (define (highest-order-of var poly)
        (define (highest-term-of-list term-list)
         (cond
          ((empty-termlist? (rest-terms term-list)) (order (first-term term-list)))
          (else
           (highest-term-of-list (rest-terms term-list)))))

        (define (highest-order-term var poly)
         (if (same-variable? (variable poly) var)
             (highest-term-of-list (term-list poly))
             false))
        

        (define (iter-poly-list highest termlist)
         (if (empty-termlist? termlist) 
             highest
            (let ((this-order (highest-order-term var (coeff (first-term termlist)))))
             (if (and this-order (> this-order highest))
                 (iter-poly-list this-order (rest-terms termlist))
                 (iter-poly-list highest (rest-terms termlist))))))
        (iter-poly-list -1 (term-list poly)))
       #+END_SRC

       This basic algorithm is hacky but it does work. What's left is
       to refine it, and then add a layer to work recursively for
       large lists of variables. Also, it needs to be refined not to
       just count down in order but to obtain a list of orders, to not
       make polynomial coefficients in terms of another variable when
       it doesn't need to be.

       After many trials and tribulations, I got this code refined and
       working in the package structure in polynomials.scm. Right now
       I redefined add to coerce polynomials of a lower variable to
       polynomials of a higher variable. It works for 

       #+BEGIN_SRC
       (add (make-polynomial 'y (list 'sparse-term-list '(3 2) '(2 1) (list 1 (make-polynomial 'x '(sparse-term-list (2 2) (1 3)))))) (make-polynomial 'x '(sparse-term-list (2 2) (1 1))))

       ;Value 80: (polynomial x sparse-term-list (2 (polynomial y sparse-term-list (0 2) (1 2))) (1 (polynomial y sparse-term-list (0 1) (1 3))) (0 (polynomial y sparse-term-list (2 1) (3 2))))
       #+END_SRC

       Which is a correct result; both polynomials have been coerced
       to be in terms of x and then added. There are some problems,
       however.

       1. What happpens when we have deep polys in terms of three
          variables?

       2. The package structure is hacky. Because the polys being
          passed in to the coercion procedure are tagged, we have to
          apply the contents procedure all over the place. It also
          means we have to keep track of which parts of a procedure
          are expected to produce tagged polynomials and which
          not. Using the contents procedure inside a package is
          odd. In order to be understood by the rest of the packaging
          system we should probably keep the polynomials tagged
          though, so it makes sense that when destructuring one and
          restructuring it we keep everything tagged and use
          make-polynomial, the external make function, rather than
          make-poly. In general tag management is a complex
          task. Other languages manage tagging transparently or at
          least seem to -- then again, we don't normally manage
          interactions between this many types. This is a fairly
          complicated scenario; although there aren't a lot of lines
          of code the logic is dense. Typically objects are not made
          of so many densely nested, composite structures as this. 

	  We can mitigate some of these problems by writing procedures
          whose purpose is to handle this, like writing a procedure
          designed to take the contents of polys and assert that they
          are, indeed, polys. Another thing that makes sense is simply
          designing a set of procedures called poly-termlist and so
          on that use apply-generic. Probably that should be a next step.

**** Extended exercise: Rational functions
     We can extend our generic arithmetic system to include _rational
     functions_. These are "fractions" whose numerator and denominator
     are polynomials, such as

     \begin{ratfunc}
     \frac{x + 1}{x^3 - 1}
     \end{ratfunc}

     The system should be able to add, subtract, multiply, and divide
     rational functions, and to perform such computations as

     \begin{ratfunc}
     \frac{x + 1}{x^3 - 1} + \frac{x}{x^2 - 1} = \frac{x^3 + 2x^2 + 3x + 1}{x^4 + x^3 - x - 1}
     \end{ratfunc}

     (Here the sum has been simplified by removing common
     factors. Ordinary "cross multiplication" would have produced a
     fourth-degree polynomial over a fifth-degree polynomial.)

     If we modify our rational-arithmetic package so that it uses
     generic operations, then it will do what we want, except for the
     problem of reducing fractions to lowest terms.

     - Exercise 2.93. Modify the rational-arithmetic package to use
       generic operations, but change make-rat so that it does not
       attempt to reduce fractions to lowest terms. Test your systems
       by calling make-rational on two polynomials to produce a
       rational function

       #+BEGIN_SRC scheme
       (define p1 (make-polynomial 'x '((2 1) (0 1))))
       (define p2 (make-polynomial 'x '((3 1) (0 1))))
       (define rf (make-rational p2 p1))
       #+END_SRC

       Now add rf to itself, using add. You will observe that this
       addition procedure does not reduce fractions to lowest terms.

       We can reduce polynomial fractions to lowest terms using the
       same idea we used with integers: modifying make-rat to divide
       both the numerator and the denominator by their greatest common
       divisor. The notion of "greatest common divisor" makes sense
       for polynomials. In fact, we can compute the GCD of two
       polynomials using essentially the same Euclid's Algorithm that
       works for integers. 


       


       

       
