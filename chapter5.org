* Chapter 5 Computing with Register Machines
We began this book by studying processes and by describing processes
in terms of procedures written in Lisp. To explain the meanings of
these procedures, we used a succession of models of evaluation: the
substitution model of Chapter 1, the environment model of Chapter 3,
and the metacircular evaluator of Chapter 4. Our examination of the
metacircular evaluator, in particular, dispelled much of the mystery
of how Lisp-like languages are interpreted. But even the metacircular
evaluator leaves important questions unanswered, because it fails to
elucidate the mechanisms of control in a Lisp system. For instance,
the evaluator does not explain how the evaluation of a subexpression
manages to return a value to the expression that uses this value, nor
does the evaluator explain how some recursive procedures generate
iterative processes (that is, are evaluated using constant space)
whereas other recursive procedures generate recursive processes. These
questions remain unanswered because the metacircular evaluator is
itself a Lisp program and hence inherits the control structure of the
underlying Lisp system. In order to provide a more complete
description of the control structure of the Lisp evaluator, we must
work at a more primitive level than Lisp itself.

In this chapter we will describe processes in terms of the
step-by-step operatio of a traditional computer. Such a computer, or
_register machine_, sequentially executes _instructions_ that
manipulate the contents of a fixed set of storage elements called
_registers_. A typical register-machine instruction applies a
primitive operation to the contents of some registers and assigns the
result to another register. Our descriptions of processes executed by
register machines will look very much like "machine-language" programs
for traditional computers. However, instead of focusing on the machine
languag of any particular computer, we will examine several Lisp
procedures and design a specific register machine to execute each
procedure. Thus, we will approach our task from the perspective of a
hardware architect rather than that of a machine-language computer
programmer. In designing register machines, we will develop mechanisms
for implementing important programming constructs such as
recursion. We will also present a language for describing designs for
register machines. In Section 5.2 we will implement a Lisp program
that uses these descriptions to simulate the machines we design. 

Most of the primitive operations of our register machines are very
simple. For example, an operation might add the numbers fetched from
two registers, producing a result to be stored into a third
register. Such an operation can be performed by easily described
hardware. In order to deal with list structure, however, we will also
use the memory operations car, cdr, and cons, which require an
elaborate storage-allocation mechanism. In Section 5.3 we study their
implementation in terms of more elementary operations.

In Section 5.4, after we have accumulated experience formulating
simple procedures as register machines, we will design a machine that
carries out the algorithm described by the metacircular evaluator of
Section 4.1. This will fill in the gap in our understanding of how
Scheme expressions are interpreted, by providing an explicit model for
the mechanisms of control in the evaluator. In Section 5.5 we will
study a simple compiler that translates Scheme programs into sequences
of instructions that can be executed directly with the registers and
operations of the evaluator register machine.

** 5.1 Designing Register Machines
   To design a register machine, we must design its _data paths_
   (registers and operations) and the _controller_ that sequences these
   operations. To illustrate the design of a simple register machine, let
   us examine Euclid's Algorithm, which is used to compute the greates
   common divisor (GCD) of two integers. As we saw in Section 1.2.5,
   Euclid's Algorithm can be carried out by an iterative process, as
   specified by the following procedure:

   #+BEGIN_SRC scheme
   (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
   #+END_SRC

   A machine to carry out this algorithm must keep track of two
   numbers, a and b, so let us assume that these numbers are stored in
   two registers with those names. The basic operations required are
   testing whether the contents of register b is zero and computing
   the remainder of the contents of register a divided by the contents
   of register b. The remainder operation is a complex process, but
   assume for the moment that we have a primitive device that computes
   remainders. On each cycle of the GCD algorithm, the contents of
   register a must be replaced by the contents of register b, and the
   contents of b must be replaced by the remainder of the old contents
   of a divided by the old contents of b. It would be convenient if
   these replacements could be done simultaneously, but in our model
   of register machines we will assume that only one register can be
   assigned a new value at each step. To accomplish the replacements,
   our machine will use a third "temporary" register, which we call
   t. (First the remainder will be placed in t, then the contents of b
   will be placed in a, and finally the remainder stored in t will be
   blaced in b.)

   We can illustrate the registers and operations required for this
   machine by using the data-path diagram shown in Figure 5.1. In this
   diagram, the registers (a, b, and t) are represented by
   rectangles. Each way to assign a value to a register is indicated
   by an arrow with an X behind the head, pointing from the source of
   data to the register. We can think of X as a button that, when
   pushed, allows the value at the source to "flow" into the
   designated register. The label next ot each button is the name we
   will use to refer to the button. The names are arbitrary, and can
   be chosen to have a mnemonic value (for example, a<-b denotes
   pushing the button that assigns the contents of register b to
   register a). The source of data for a register can be another
   register (as in the a<-b assignemnt), an operation result (as in
   the t<-r assignment), or a constant (a built-in value that cannot
   be changed, represented in a data-path diagram by a triangle
   containing the constant). 

   An operation that computes a value from constants and the contents
   of registers is represented in a data-path diagram by a trapezoid
   containing a name for the operation. For example, the box marked
   rem in Figure 5.1 represents an operation that computes the
   remainder of the contents of registers a and b to which it is
   attached. Arrows (without buttons) point from the input registers
   and constants to the box, and arrows connect the operation's output
   value to registers. A test is represented by a circle containing a
   name for the test. For example, our GCD machine has an operation
   that tests whether the contents of register b is zero. A test also
   has arrows from its input registers and constants, but it has no
   output arrows; its value is used by the controller rather than by
   the data paths. Overall, the data-path diagram shows the registers
   and operations that are required for the machine and how they must
   be connected. If we view the arrows as wires and the X buttons as
   switches, the data-path diagram is very like the wiring diagram for
   a machine that could be constructed from electrical components.

   In order for the data paths to actually compute GCDs, the buttons
   must be pushed in the correct sequence. We will describe this
   sequence in terms of a controller diagram, as illustrated in Figure
   5.2. The elements of the controller diagram indicate how the
   data-path components should be operated. The rectangular boxes in
   the controler diagram identify data-path buttons to be pushed, and
   the arrows describe the sequencing from one step to the next. The
   diamond in the diagram represents a decision. One of the two
   sequencing arrows will be followed, depending on the value of the
   data-path test identified in the diamond. We can interpret the
   controller in terms of a physical analogy: Think of the diagram as
   a maze in which a marble is rolling. When the marble rolls into a
   box, it pushes the data-path button that is named by the box. When
   the marble rolls into a decision node (such as the test for b = 0),
   it leaves the node on the path determined by the result of the
   indicated test. Taken together, the data paths and the controller
   completely describe a machine for computing GCDs. We start the
   controller (the rolling marble) at the place marked start, after
   placing numbers in registers a and b. When the controller reaches
   done, we will find the value of the GCD in register a.

   - Exercise 5.1 Design a register machine to compute factorials
     using the iterative algorithm specified by the following
     procedure. Draw data-path and controller diagrams for this
     machine.

     #+BEGIN_SRC scheme
     (define (factorial n)
      (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product)
                 (+ counter 1))))
      (iter 1 1)) 
    #+END_SRC
*** 5.1.1 A Language for Describing Register Machines
    Data-path and controller diagrams are adequate for representing
    simple machines such as GCD, but they are unwieldly for describing
    large machines such as a Lisp interpreter. To make it possible to
    deal with complex machines, we will create a language that
    presents, in textual form, all the information given by the
    data-path and controller diagrams. We will start with a notation
    that directly mirrors the diagrams.

    We define the data paths of a machine by describing the registers
    and the operations. To describe a register, we give it a name and
    specify the buttons that control assignment to it. We give each of
    these buttons a name and specify the source of the data that
    enters the register under the button's control. (The source is a
    register, a constant, or an operation.) To describe an operation,
    we give it a name and specify its inputs (registers or
    constants). We define the controller of a machine as a sequence of
    _instructions_ together with _labels_  that identify _entry
    points_ in a sequence. An instruction is one of the following:

    - The name of a data-path button to push to assign a value to a
      register. (This corresponds to a box in the controller diagram.)
    - A test instruction, that performs a specified test.
    - A conditional branch (branch instruction) to a location
      indicated by a controller label, based on the result of the
      previous test. (The test and branch together correspond to a
      diamond in the controller diagram.) If the test is false, the
      controller should continue with tne next instruction in the
      sequence. Otherwise, the controller should continue with the
      instruction after the label.
    - An unconditional branch (goto instruction) naming a controller
      label at which to cintinue execution.

      
    The machine starts at th ebeginning of the controller instruction
    sequence and stops when execution reaches the end of the
    sequence. Except when a branch chanes the flow of contol,
    instructions are executed in the order in which they are listed.

    - Figure 5.3: A specification of the GCD machine.
      #+BEGIN_SRC scheme
      (data-paths
       (registers
        ((name a)
         (buttons ((name a<-b) (source (register b)))))
        ((name b)
         (buttons ((name b<-t) (source (register t)))))
        ((name t)
         (buttons ((name t<-r) (source (operation rem))))))
       (operations
        ((name rem) (inputs (register a) (register b)))
        ((name =) (inputs (register b) (constant 0)))))
       (controller
        test-b
        (test =)
        (branch (label gcd-done))
        (t<-r)
        (a<-b)
        (b<-t)
        (goto (label test-b))
      gcd-done)
    #+END_SRC

    Figure 5.3 shows the GCD machine described this way. This example
    only hints at the generality of these descriptions, since the GCD
    machine is a very simple case: Each register has only one button,
    and each button and test is used only once in the controller.

    Unfortunately, it is difficult to read such a description. In
    order to understand the controller instructions we must constantly
    refer back to the definitions of the button names and the
    operation names, and to understand what the buttons do we may have
    to refer to the definitions of the operation names. We will thus
    transform our notation to combine the information from the
    data-path and controller descriptions so that we see it all
    together. To obtain this form of description, we will replace the
    arbitrary button and operation names by the definitions of their
    behavior. That is, instead of saying (in the controller) "Push
    button t<-r" and separately saying (in the data paths) "Button
    t<-r assigns the value of the rem operation to register t" and
    "the rem operation's inputs are the contents of registers a and
    b," we will say (in the controller) "Push the button that assigns
    to register t the value of the rem operation on the contents of
    register a and b." Similarly, instead of saying (in the
    controller) "Perform the = test" and separately saying (in the
    data paths) "The = test operates on the contents of register b and
    the constant 0," we will say "Perform the = test on the contents
    of register b and the constant 0." We will omit the data-path
    description, leaving only the controller sequence. Thus, the GCD
    machine is described as follows:

    #+BEGIN_SRC scheme
    (controller
     test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
    gcd-done)
    #+END_SRC

    This form of description is easier to read than the kind
    illustrated in Figure 5.3, but it also has disadvantages:

    - It is more verbose for large machines, because complete
      descriptions of the data-path elements are repeated whenever the
      elements are mentioned in the controller instruction
      sequence. (This is not a problem in the GCD example, because
      each operation and button is used only once.) Moreover,
      repeating the data-path descriptions obscures the actual
      data-path structure of the machine; it is not obvious for a
      large machine how many registers, operations, and buttons there
      are and how they are interconnected.

    - Because the controller instructions in a machine definition look
      like Lisp expressions, it is easy to forget that they are not
      arbitrary Lisp expressions. They can notate only legal machine
      operations. For example, operations can operate directly only on
      constants and the contents of registers, not on the results of
      other operations.

      
    In spite of these disadvantages, we will use this register-machine
    language throughout this chapter, because we will be more
    concerned with understanding controllers than with understanding
    the elements and connections in data paths. We should keep in
    mind, however, that data-path design is crucial in designing real
    machines. 

    - Exercise 5.2: Use the register-machine language to describe the
      iterative factorial machine of Exercise 5.1.

      #+BEGIN_SRC scheme 
      (controller
       test-c-n
       (test (op >) (reg c) (reg n))
       (branch (label done-fac))
       (assign tc (op +) (reg c) (const 1))
       (assign tp (op *) (reg c) (reg p))
       (assign p (reg tp))
       (assign c (reg tc))
       (goto (label test-c-n))
      done-fac)
      #+END_SRC

**** Actions
     Let us modify the GCD machine so that we can type in the numbers
     whose GCD we want and get the answer printed at our terminal. We
     will not discuss how to make a machine that can read and print,
     but will assume (as we do when we use read and display in Scheme)
     that they are available as primitive operations.

     read is like the operations we have been using in that it
     produces a value that can be stored in a register. But read does
     not take inputs from any registers; its value depends on
     something that happens outside the parts of the machine we are
     designing. We will allow our machine's operations to have such
     behavior, and will thus draw and notate the use of read just as
     we do any other operation that computes a value.

     print, on the other hand, differs from the operations we have
     been using in a fundamental way: It does not produce an output
     value to be stored in a register. Though it has an effect, this
     effect is not on a part of the machine we are designing. We will
     refer to this kind of operation as an _action_. We will represent
     an action in a data-path diagram just as we represent an
     operation that computes a value -- as a trapezoid that contains
     the name of the action. Arrows point to the action box from any
     inputs (registers or constants). We also associate a button with
     the action. Pushing the button makes the action happen. To make a
     controller push an action button we will use a new kind of
     instruction called perform. Thus, the action of printing the
     contents of register a is represented in a controller sequence by
     the instruction

     #+BEGIN_SRC scheme
     (perform (op print) (reg a))
     #+END_SRC

     Figure 5.4 shows the data paths and controller for the new GCD
     machine. Instead of having a machine stop after printing the
     answer, we have made it start over, so that it repeatedly reads a
     pair of numbers, computes their GCD, and prints the result. This
     structure is like the driver loops we used in the interpreters of
     Chapter 4.

     #+BEGIN_SRC scheme
     (controller
      gcd-loop
      (assign a (op read))
      (assign b (op read))
      test-b
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t
              (op rem)
              (reg a)
              (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label test-b))
      gcd-done
      (perform (op print) (reg a))
      (goto (label gcd-loop)))
     #+END_SRC

*** 5.1.2 Abstraction in Machine Design      
    We will often define a machine to include "primitive " operations
    that are actually very complex. For example, in Section 5.4 and
    Section 5.5 we will treat Scheme's environment manipulations as
    primitive. Such abstraction is valuable because it allows us to
    ignore the details of parts of a machine so that we can
    concentrate on other aspects of the design. The fact that we have
    swept a lot of complexity under the rug, however, does not mean
    that a machine design is unrealistic. We can always replace the
    complex "primitives" by simpler primitive operations.

    Consider the GCD machine. The machine has an instruction that
    computes the remainder of the contents of registers a and b and
    assigns the result to register t. If we want to construct the GCD
    machine without using a primitive remainder operation, we must
    specify how to compute remainders in terms of simpler operations,
    such as subtraction. Indeed, we can write a Scheme procedure that
    finds remainders in this way:

    #+BEGIN_SRC scheme
    (define (remainder n d)
     (if (< n d)
         n
         (remainder (- n d) d)))
    #+END_SRC

    We can thus replace the remainder operation in the GCD machine's
    data paths with a subtraction operation and a comparison
    test. Figure 5.5 shows the data paths and controller for the
    elaborated machine. The instruction 

    #+BEGIN_SRC scheme
    (assign t (op rem) (reg a) (reg b))
    #+END_SRC

    in the GCD controller definition is replaced by a sequence of
    instructions that contains a loop, as shown in Figure 5.6.

    - Figure 5.6: Controller instructin sequence for the GCD machine
      in Figure 5.5.

      #+BEGIN_SRC scheme
      (controller test-b
                  (test (op =) (reg b) (const 0))
                  (branch (label gcd-done))
                  (assign t (reg a))
                  rem-loop
                  (test (op <) (reg t) (reg b))
                  (branch (label rem-done))
                  (assign t (op -) (reg t) (reg b))
                  (goto (label rem-loop))
                  rem-done
                  (assign a (reg b))
                  (assign b (reg t))
                  (goto (label test-b))
                  gcd-done)
      #+END_SRC

    - Exercise 5.3: Design a machine to compute square roots using
      Newton's method, as described in Section 1.1.7:

      #+BEGIN_SRC scheme
      (define (sqrt x)
       (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
       (define (improve guess)
        (average guess (/ x guess)))
       (define (sqrt-iter guess)
        (if (good-enough? guess)
             guess
            (sqrt-iter (improve guess))))
       (sqrt-iter 1.0))
      #+END_SRC

      Begin by assuming that good-enough? and improve operations are
      available as primitives. Then show how to expand these in terms
      of arithmetic operations. Describe each version of the sqrt
      machine design by drawing a data-path diagram and writing a
      controller definition in the register-machine language.

      I will first assume good-enough? and improve-guess are
      primitives, so we need a guess register and, I'm assuming, a
      temporary register to hold the improved result before assigning
      it to guess. I'm assuming that if we assign the result of
      improve directly to guess, the machine will get into an
      inconsistent or undesirable state. We can try it with just a
      guess register.

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign t (op improve) (reg g) (reg x))
       (assign g (reg t))
       (test (op good-enough?) (reg g) (reg x))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done) 
      #+END_SRC

      Next, we put improve and good-enough? inline. improve is an
      average of the guess with x divided by the guess. I will inline
      the entire thing.

      Registers: p1, p2, g, x.

      We need extra registers to hold the answers of operations and
      parameters for those operations in improve. Our data paths so
      far have assumed that you can't assign to something that is also
      being used as an operand. The definition of improve is:

      #+BEGIN_SRC scheme
      (define (improve guess x)
       (average guess (/ x guess))
      #+END_SRC

      So I need to do the work of two functions: improve and
      average. I already have a register for guess and x. I need
      another register to hold the result of (/ x guess) -- p1. Then I
      need to compute the average of guess and p1. This is
      accomplished by first adding these two registers and dividing
      them. If I want to add then divide, I need another register to
      hold the result of this operation. Becaues I assume I cannot use
      the register p1 (or g) for an assign operation that it is being used as
      an operand in -- like (assign p1 (op +) (reg g) (reg p1)) -- I
      need another register, p2. That way I can write (assign p2 (op
      +) (reg g) (reg p1)). Now p2 holds the sum of guess and (/x
      guess), so I need to divide it by 2. Since I don't need g
      anymore, I can use g directly to hold the result of dividing the sum
      by the constant 2, which is then the result.


      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (test (op good-enough?) (reg g) (reg x))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC

      Now, with no outside procedures (except abs, *, <, -, +, /), I have
      a new guess in g and don't need p1 and p2. I need to see if g is
      good. To do this, I first need to square guess. I assume that we
      can use a register parameter twice (not assign to it though),
      and assign p1, which is newly free, (* g g). Then, I subtract
      that result from x and assign the result to p2. Finally, I
      assign p1 the result of (abs p2), which holds the result of (-
      (* g g) x). Now p2 holds the number representing how close we
      are to the actual square root. All I need to do now is test
      whether it's < 0.001, by using a test instruction. The rest of
      the code is the same. 

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (assign p1 (op *) (reg g) (reg g))
       (assign p2 (op -) (reg p1) (reg x))
       (assign p1 (op abs) (reg p2))
       (test (op <) (reg p1) (const 0.001))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC   

      Next, we remove abs by adding a branch.

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (assign p1 (op *) (reg g) (reg g))
       (assign p2 (op -) (reg p1) (reg x))
       abs
       (test (op >) (reg p2) (const 0))
       (branch (label abs-greater-than0))
       (assign p1 (op -) (const 0) (reg p2))
       (goto (label done-with-abs))
       abs-greater-than0
       (assign p1 (reg p2))
       done-with-abs
       (test (op <) (reg p1) (const 0.001))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC

*** 5.1.3 Subroutines
    
    When designing a machine to perform a computation, we would often
    prefer to arrange for components to be shared by different parts
    of the computation rather than duplicate the components. Consider
    a machine that includes two GCD computations -- one that finds the
    GCD of the contents of registers a and b and one that finds the
    GCD of the contents of registers c and d. We might start by
    assuming we have a primitive gcd operation, then expand the two
    instances of gcd in terms of more primitive operations. Figure 5.7
    shows just the GCD portions of the resulting machine's dat paths,
    without showing how they connect to the rest of the machine. The
    figure also shows the corresponding portions of the machine's
    controller sequence.

    This machine has two remainder operation boxes and two boxes for
    testing equality. If the duplicated components are complicated, as
    is the remainder box, this will not be an economical way to build
    the machine. We can avoid duplicating the data-path components by
    using the same components for both GCD computations, provided that
    doing so will not affect the rest of the larger machine's
    computation. If the values in registers a and b are not needed by
    the time the controller gets to gcd-2 (or if these values can be
    moved to other registers for safekeeping), we can change the
    machine so that it uses registers a and b, rather than registers c
    and d, in computing the second GCD as well as the first. If we do
    this, we obtain the controller sequence shown in Figure 5.8.

    - Figure 5.8: Portions of the controller sequence for a machine
      that uses the same data-path components for two different GCD
      computations.

      #+BEGIN_SRC scheme
      gcd-1 
      (test (op =) (reg b) (const 0))
      (branch (label after-gcd-1))
      (assign t (op rem))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd-1))
      after-gcd-1
      ...
      gcd-2
      (test (op =) (reg b) (const 0))
      (branch (label after-gcd-2))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd-2))
      after-gcd-2
      #+END_SRC

      
    We have removed the duplicated data-path components (so that the
    data paths are again as in Figure 5.1), but the controller now has
    two GCD sequences that differ only in their entry-point labels. It
    would be better to replace these two sequences by branches to a
    single sequence -- a gcd _subroutine_ -- at the end of which we
    branch back to the correct place in the main instruction
    sequence. We can accomplish this as follows: Before branching to
    gcd, we place a distinguishing value (such as 0 or 1) into a
    special register, continue. At the end of the gcd subroutine we return
    either after-gcd-1 or after-gcd-2, depending on the value of the
    continue register. Figure 5.9 shows the relevant portion of the
    resulting controller sequence, which includes only a single copy
    of the gcd instructions.

    - Figure 5.9: Using a continue register to avoid the duplicate
      controller sequence in Figure 5.8

      #+BEGIN_SRC scheme
      gcd
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assing b (reg t))
      (goto (label gcd))
      gcd-done
      (test (op =) (reg continue) (const 0))
      (branch (label after-gcd-1))
      (goto (label after-gcd-2))
      ...
      ;; Before branching to gcd from the first place where
      ;; it is needed, we place 0 in the continue register.
      (assign continue (const 0))
      (goto (label gcd))
      after-gcd-1
      ...
      ;; Before the second use of gcd, we place 1 in the 
      ;; continue register.
      (assign continue (const 1))
      (goto (label gcd))
      after-gcd-2
      #+END_SRC

      
    This is a reasonable approach for handling small problems, but it
    would be awkward if there were many instances of GCD computations
    in the controller sequence. To decide where to continue executing
    after the gcd subroutine, we would need tests in the data paths
    and branch instructions in the controller for all the places that
    use gcd. A more powerful method for implementing subroutines is to
    have the continue register hold the label of the entry point in
    the controller sequence at which execution should continue when
    the subroutine is finished. Implementing this strategy requires a
    new kind of connection between the data paths and the controller
    of a register machine: There must be a way to assign a register a
    label in the controller sequence in such a way that this value can
    be fetched from the register and used to continue execution at the
    designated entry point.

    To reflect this ability, we will extend the assign instruction of
    the register-machine language to allow a register to be assigned
    as value a label from the controller sequence (as a special kind
    of constant). We will also extend the goto instruction to allow
    execution to continue at the entry point described by the contents
    of a register rather than only at the entry point described by a
    constant label. Using these new constructs we can terminate the
    gcd subroutine with a branch to the location stored in the
    continue register. This leads to the controller sequence shown in
    Figure 5.10.

    - Figure 5.10: Assigning labels to the continue register
      simplifies and generalizes the strategy shown in Figure 5.9.

      #+BEGIN_SRC scheme
      gcd
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd))
      gcd-done
      (goto (reg continue))

       ...
      ;; Before calling gcd, we assign to continue
      ;; the label to which gcd should return.
      (assign continue (label after-gcd-1))
      (goto (label gcd))
      after-gcd-1
      ...
      ;; Here is the second call to gcd,
      ;; with a different continuation.
      (assign continue (label after-gcd-2))
      (goto (label gcd))
      after-gcd-2
      #+END_SRC

      A machine with more than one subroutine could use multiple
      continuation registers (e.g., gcd-continue, factorial-continue)
      or we could have all subroutines share a single continue
      register. Sharing is more economical, but we must be careful if
      we have a subroutine (sub1) that calls another subroutine
      (sub2). Unless sub1 saves the contents of continue in some other
      register before setting up continue for the call to sub2, sub1
      will not know where to go when it is finished. The mechanism
      developed in the next section to handle recursion also provides
      a better solution to this problem of nested subroutine calls.

*** 5.1.4. Using a Stack to Implement Recursion      

    With the ideas illustrated so far, we can implement any iterative
    process by specifying a register machine that has a register
    corresponding to each state variable of the process. The machine
    repeatedly executes a controller loop, changing the contents of
    the registers, until some termination condition is satisfied. At
    each point in the controller sequence, the state of the machine
    (representing the state of the iterative process) is completely
    determined by the contents of the registers (the values of the
    state variables). 

    Implementing recursive processes, however, requires an additional
    mechanism. Consider the following recursive method for computing
    factorials, which we first examined in Section 1.2.1:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1)) n)))
    #+END_SRC

    As we see from the procedure, computing n! requires computing
    (n-1)!. Our GCD machine, modeled on the procedure

    #+BEGIN_SRC scheme
    (define (gcd a b)
     (if (= b 0) a (gcd b (remainder a b))))
    #+END_SRC

    similarly had to compute another GCD. But there is an important
    difference between the gcd procedure, which reduces the original
    computation to a new GCD computation, and factorial, which
    requires computing another factorial as a subproblem. In GCD, the
    answer to the new GCD computation is the answer to the original
    problem. To compute the next GCD, we simply place the new
    arguments in the input registers of the GCD machine and reuse the
    machine's data paths by executing the same controller
    sequence. When the machine is finished solving the final GCD
    problem, it has completed the entire computation. 

    In the case of factorial (or any recursive process) the answer to
    the new factorial subproblem is not the answer to the original
    problem. The value obtained for (n-1)! must be multiplied by n to
    get the final answer. If we try to imitate the GCD design, and
    solve the factorial subproblem by decrementing the n register and
    rerunning the factorial machine, we will no longer have available
    the old value of n by which to multiply the result. We thus need a
    second factorial machine to work on the subproblem. This second
    factorial computation itself has a factorial subproblem, which
    requires a third factorial machine, and so on. Since each
    factorial machine contains another factorial machine within it,
    the total machine contains an infinite nest of similar machines
    and hence cannot be constructed from a fixed, finite number of
    parts.

    Nevertheless, we can implement the factorial process as a register
    machine if we can arrange to use the same components for each
    nested instance of the machine. Specifically, the machine that
    computes n! should use the same components to work on the
    subproblem of computing (n-1)!, on the subproblem for (n-2)!, and
    so on. This is plausible because, although the factorial process
    dictates that an unbounded number of copies of the same machine
    are needed to perform a computation, only one of these copies
    needs to be active at any given time. When the machine encounters
    a recursive subproblem, it can suspend work on the main problem,
    reuse the same physical parts to work on the subproblem, then
    continue the suspended computation. 

    In the subproblem, the contents of the registers will be different
    than they were in the main problem. (In this case the n register
    is decremented.) In order to be able to continue the suspended
    computation, the machine must save the contents of any registers
    that will be needed after the subproblem is solved so that these
    can be restored to continue the suspended computation. In the case
    of factorial, we will save the old value of n, to be restored when
    we are finishing computing the factorial of the decremented n
    register.

    Since there is no _a priori_ limit on the depth of nested
    recursive calls, we may need to save an arbitrary number of
    register values. These values must be restored in the reverse
    order in which they were saved, since in a test of recursions the
    last subproblem to be entered is the first to be finished. This
    dictates the use of a _stack_, or "last in, first out" data
    structure, to save register values. We can extend the
    register-machine language to include a stack by adding two kinds
    of instructions: Values are placed on the stack using a save
    instruction and restored from the stack using a restore
    instruction. After a sequence of values has been saved on the
    stack, a sequence of restores will retrieve these values in
    reverse order.

    With the aid of the stack, we can reuse a single copy of the
    factorial machine's data paths for each factorial
    subproblem. There is a similar design issue in reusing the
    controller sequence that operates the data paths. To reexecute the
    factorial computation, the controller cannot simply loop back to
    the beginning, as with an iterative process, because after solving
    the (n - 1)! subproblem the machine must still multiply the result
    by n. THe controller must suspend its computation of n!, solve the
    (n-1)! subproblem, then continue its computation of n!. This view
    of the factorial computation suggests the use of the subroutine
    mechanism described in Section 5.1.3, which has the controller use
    a continue register to transfer to the part of the sequence that
    solves a subproblem and then continue where it left off on the
    main problem. We can thus make a factorial subroutine that returns
    to the entry point stored in the continue register. Around each
    subroutine call, we save and restore continue just as we do the n
    register, since each "level" of the factorial computation will use
    the same continue register. That is, the factorial subroutine must
    put a new value in continue when it calls itself for a subproblem,
    but it will need the old value in order to return to the place
    that called it to solve a subproblem. 

    Figure 5.11 shows the data paths and controller for a machine that
    implements the recursive factorial procedure. The machine has a
    stack and three registers, called n, val, and continue. To
    simplify the data-path diagram, we have not named the
    register-assignment buttons, only the stack-operation buttons (sc
    and sn to save registers, rc and rn to restore registers). To
    operate the machine, we put in register n the number whose
    factorial we wish to compute and start the machine. When the
    machine reaches fact-done, the computation is finished and the
    answer will be found in the val register. In the controller
    sequence, n and continue are saved before each recursive call and
    restored upon return from the call. Returning from a call is
    accomplished by branching to the location stored in
    continue. continue is initialized when the machine starts so that
    the last return will go to fact-done. The val register, which
    holds the result of the factorial computation, is not saved before
    the recursive call, because the old contents of val is not useful
    after the subroutine returns. Only the new value, which is the
    value produced by the subcomputation, is needed.

    Although in principle the factorial computation requires an
    infinite machine, the machine in Figure 5.11 is actually finite
    except for the stack, which is potentially unbounded. Any
    particular physical implementation of a stack, however, will be of
    finite size, and this will limit the depth of recursive calls that
    can be handled by the machine. This implementation of factorial
    illustrates the general strategy for realizing recursive
    algorithms as ordinary register machines augmented by
    stacks. When a recursive subproblem is encountered, we save on the
    stack the registers whose current values will be required after
    the subproblem is solved, solve the recursive subproblem, then
    restore the saved registers and continue execution on the main
    problem. The continue register must always be saved. Whether there
    are other registers that need to be saved depends on the
    particular machine, since not all recursive computations need the
    original values of registers that are modified during solution of
    the subproblem. 

    - Figure 5.11: A recursive factorial machine.

      #+BEGIN_SRC scheme
      (controller
       (assign continue (label fact-done))
       fact-loop
       (test (op =) (reg n) (const 1))
       (branch (label base-case))
       ;; Set up for the recursive call by saving n and continue.
       ;; Set up continue so that the computation will continue
       ;; at after-fact when the subroutine returns.
       (save continue)
       (save n)
       (assign n (op -) (reg n) (const 1))
       (assign continue (label after-fact))
       (goto (label fact-loop))
       after-fact
       (restore n)
       (restore continue)
       (assign val (op *) (reg n) (reg val))
       (goto (reg continue))
       base-case
       (assign val (const 1))
       (goto (reg continue))
       fact-done)
      #+END_SRC

      
**** A double recursion    

     Let us examine a more complex recursive process, the
     tree-recursive computaiton of the Fibonacci numbers, which we
     introduced in Section 1.2.2:

     #+BEGIN_SRC scheme
     (define (fib n)
      (if (< n 2)
          n
          (+ (fib (- n 1)) (fib (- n 2)))))
     #+END_SRC

     Just as with factorial, we can implement the recursive Fibonacci
     computation as a register machine with registers n, val, and
     continue. The machine is more complex than the one for factorial,
     because there are two places in the controller sequence where we
     need to perform recursive calls -- once to compute Fib(n-1) and
     once to compute Fib(n-2). To set up for each of these calls, we
     save the registers whose values will be needed later, set the n
     register to the number whose Fib we need to compute recursively
     (n - 1 or n -2), and assign to continue the entry point in the
     main sequence to which to return (afterfib-n-1 or afterfib-n-2,
     respectively). We then go to fib-loop. When we return from the
     recursive call, the answer is in val. Figure 5.12 shows the
     controller sequence for this  machine.


     - Figure 5.12: Controller for a machine to compute Fibonacci
       numbers.

       #+BEGIN_SRC scheme
       (controller
        (assign continue (label fib-done))
        fib-loop
        (test (op <) (reg n) (const 2))
        (branch (label immediate-answer))
        ;; set up to compute Fib(n-1)
        (save continue)
        (assign continue (label afterfib-n-1))
        (save n)
        (assign n (op -) (reg n) (const 1))
        (goto (label fib-loop))
	afterfib-n-1
        (restore n)
        (restore continue)
        ;; set up to compute Fib(n-2)
	(assign n (op -) (reg n) (const 2))
        (save continue)
        (assign continue (label afterfib-n-2))
        (save val)
        (goto (label fib-loop))
        afterfib-n-2
        (assign n (reg val))
        (restore val)
        (restore continue)
        (assign val (op +) (reg val) (reg n))
        (goto (reg continue))
        immediate-answer
        (assign val (reg n))
        (goto (reg continue))
        fib-done)
       #+END_SRC

       - Exercise 5.4: Specify register machines that implement each
         of the following procedures. For each machine, write a
         controller instruction sequence and draw a diagram showing
         the data paths.

	 a. Recursive exponentiation:
	 #+BEGIN_SRC scheme
         (define (expt b n)
          (if (= n 0)
              1
              (* b (expt b (- n 1)))))
	 #+END_SRC

	 I will initially need a b, n, and val register. I 
	 #+BEGIN_SRC scheme
         (controller
          (assign continue (label end-expt))
          expt-loop
          (test (op =) (reg n) (const 0))
          (branch (label base-case))
          (save continue)
          (assign continue (label expt-loop-done))
          (assign n (op -) (reg n) (const 1))
          (goto (label expt-loop))
          expt-loop-done
          (restore continue)
          (assign val (op *) (reg val) (reg b))
          (goto (reg continue))
          base-case
          (assign val (const 1))
          (goto (reg continue))
          end-expt)
	 #+END_SRC

	 b. Iterative exponentiation:
	 #+BEGIN_SRC scheme
	 (define (expt b n)
          (define (expt-iter counter product)
           (if (= counter 0)
               product
               (expt-iter (- counter 1)
                          (* b product))))
          (expt-iter n 1))
	 #+END_SRC

	 #+BEGIN_SRC scheme
         (controller
          (assign p (const 1)) ;; set product to 1.
          (assign c (reg n))   ;; set counter to n.
          expt-iter
          (test (op =) (reg c) (const 0)) ;; if counter is 0, exit.
          (branch (label expt-done))
          (assign p (op *) (reg b) (reg p)) ;; otherwise, multiply b and p.
          (assign c (op -) (reg c) (const 1))
          (goto (label expt-iter))
          expt-done)
	 #+END_SRC

       - Exercise 5.5: Hand-simulate the factorial and Fibonacci
         machines, using some nontrivial input (require execution of
         at least one recursive call). Show the contents of the stack
         at each significant point in the execution.

       - Exercise 5.6: Ben Bitdiddle observes that the Fibonacci
         machine's controller sequence has an extra save and an extra
         restore, which can be removed to make a faster. Where are
         these instructions?

         #+BEGIN_SRC scheme
	   (controller
	    (assign continue (label fib-done))
	    fib-loop
	    (test (op <) (reg n) (const 2))
	    (branch (label immediate-answer))
	    ;; set up to compute Fib(n-1)
	    (save continue)
	    (assign continue (label afterfib-n-1))
	    (save n)
	    (assign n (op -) (reg n) (const 1))
	    (goto (label fib-loop))
	    afterfib-n-1
	    (restore n)
	    ;; The lines marked 'redundant:' were unnecessary.
	    ;; redundant: (restore continue)
	    ;; set up to compute Fib(n-2)
	    (assign n (op -) (reg n) (const 2))
	    ;; redundant: (save continue)
	    (assign continue (label afterfib-n-2))
	    (save val)
	    (goto (label fib-loop))
	    afterfib-n-2
	    (assign n (reg val))
	    (restore val)
	    (restore continue)
	    (assign val (op +) (reg val) (reg n))
	    (goto (reg continue))
	    immediate-answer
	    (assign val (reg n))
	    (goto (reg continue))
	    fib-done)
       #+END_SRC

*** 5.1.5 Instruction Summary	 
    A controller instruction in our register-machine language has one
    of the following forms, where each <input_i> is either (reg
    <register-name>) or (const <constant-value>). These instructions
    were introduced in Section 5.1.1:

    #+BEGIN_SRC scheme
    (assign <register-name>  (reg <register-name>))
    (assign <register-name> (const <constant-value>))
    (assign <register-name>
            (op <operation-name>)
            <input1> ... <inputn>)
    (perform (op <operation-name>) <input1> ... <inputn>)
    (test (op <operation-name>) <input1> ... <inputn>)
    (branch (label <label-name>))
    (goto (label <label-name>))
    #+END_SRC

    The use of registers to hold labels was introduced in Section
    5.1.3:

    #+BEGIN_SRC scheme
    (assign <register-name> (label <label-name>))
    (goto (reg <register-name>))
    #+END_SRC

    Instructions to use the stack were introduced in Section 5.1.4:

    #+BEGIN_SRC scheme
    (save <register-name>)
    (restore <register-name>)
    #+END_SRC

    The only kind of <constant-value> we have seen so far is a number,
    but later we will use strings, symbols, and lists. For example,

    #+BEGIN_SRC scheme
    (const "abc") is the string "abc",
    (const abc) is the symbol abc,
    (const (a b c)) is the list (a b c),
    and (const ()) is the empty list.
    #+END_SRC

** 5.2 A Register-Machine Simulator
   In order to gain a good understanding of the design of register
   machines, we must test the machines we design to see if they
   perform as expected. One way to test a design is to hand-simulate
   the operation of the controller, as in Exercise 5.5. But this is
   extremely tedious for all but the simplest machines. In this
   section we construct a simulator for machines described in the
   register-machine language. The simulator is a Scheme program with
   four interface procedures. The first uses a description of a
   register machine to construct a model of the machine (a data
   structure whose parts correspond to the parts of the machine to be
   simulated), and the other three allow us to simulate the machine by
   manipulating the model:

- Specification   
    #+BEGIN_SRC scheme
    (make-machine <register-names> <operations> <controller>)
    #+END_SRC

    constructs and returns a model of the machine with the given
    registers, operations, and controller.

    #+BEGIN_SRC scheme
    (set-register-contents! <machine-model>
                            <register-name>
                            <value>)
    #+END_SRC

    stores a value in a simulated register in the given machine.

    #+BEGIN_SRC scheme
    (get-register-contents <machine-model> <register-name>)
    #+END_SRC

    returns the contents of a simulated register in the given machine.

    #+BEGIN_SRC scheme
    (start <machine-model>)
    #+END_SRC

    simulates the execution of the given machine, starting from the
    beginning of the controller sequence and stopping when it reaches
    the end of the sequence.

   As an example of how these procedures are used, we can define
   gcd-machine to be a model of the GCD machine of Section 5.1.1 as
   follows:

   #+BEGIN_SRC scheme
     (define gcd-machine
       (make-machine
	'(a b t)
	(list (list 'rem remainder) (list '= =))
	'(test-b (test (op =) (reg b) (const 0))
		 (branch (label gcd-done))
		 (assign t (op rem) (reg a) (reg b))
		 (assign a (reg b))
		 (assign b (reg t))
		 (goto (label test-b))
		 gcd-done)))
   #+END_SRC


   The first argument to make-machine is a list of register names. The
   next argument is a table (a list of two-element lists) that pairs
   each operation name with a Scheme procedure that implements the
   operation (that is, produces the same output value given the same
   input values). The last argument specifies the controller as a list
   of labels and machine instructions, as in Section 5.1.

   To compute GCDs with this machine, we set the input registers,
   start the machine, and examine the result when the simulation
   terminates:

   #+BEGIN_SRC scheme
   (set-register-contents! gcd-machine 'a 206)
   ;; => done
   (set-register-contents! gcd-machine 'b 40)
   ;; => done
   (start gcd-machine)
   ;; => done
   (get-register-contents gcd-machine 'a)
   ;; => 2
   #+END_SRC

   This computation will run much more slowly than a gcd procedure
   written in Scheme, becase we will simulate low-level machine
   instructions, such as assign, by much more complex operations.

   - Exercise 5.7: Use the simulator to test the machines you designed
     in Exercise 5.4.

*** 5.2.1 The Machine Model     
    The machine model generated by make-machine is represented as a
    procedure with local state using the message-passing techniques
    developed in Chapter 3. To build this model, make-machine begins
    by calling the procedure make-new-machine to construct the parts
    of the machine model that are common to all register
    machines. This basic machine model constructed by make-new-machine
    is essentially a container for some registers and a stack,
    together with an execution mechanism that processes controller
    instructions one by one. 

    make-mahine then extends this basic model (by sending it messages)
    to include the registers, operations, and controller of the
    particular machine being defined. First it allocates a register in
    the new machine for each of the supplied register names and
    installs the designated operations in the machine. Then it uses an
    _assembler_ (described below in Section 5.2.2) to transform the
    controller list into instructions for the new machine and installs
    these as the machine's instruction sequence. make-machine returns
    as its value the modified machine model.

    #+BEGIN_SRC scheme
    (define (make-machine register-names ops controller-text)
     (let ((machine (make-new-machine)))
      (for-each (lambda (register-name)
                 ((machine 'allocate-register) register-name))
       register-names)
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))
    #+END_SRC

**** Registers    
     We will represent a register as a procedure with local state, as
     in Chapter 3. The procedure make-register creates a register that
     holds a value that can be accessed or changed:

     #+BEGIN_SRC scheme
     (define (make-register name)
      (let ((contents '*unassigned*))
       (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              (else
               (error "Unknown request: REGISTER" message))))
       dispatch))
     #+END_SRC

     The following procedures are used to access registers:

     #+BEGIN_SRC scheme
     (define (get-contents register) (register 'get))
     (define (set-contents! register value) ((register 'set) value))
     #+END_SRC

**** The stack     
     We can also represent a stack as a procedure with local
     state. The procedure make-stack creates a stack whose local state
     consists of a list of the items on the stack. A stack accepts
     requests to push an item onto the stack, to pop the top item off
     the stack and return it, and to initialize the stack to empty.

     #+BEGIN_SRC scheme
     (define (make-stack)
      (let ((s '()))
       (define (push x) (set! s (cons x s)))
       (define (pop)
        (if (null? s)
            (error "Empty stack: POP")
            (let ((top (car s)))
             (set! s (cdr s))
             top)))
       (define (initialize)
        (set! s '())
        'done)
       (define (dispatch message)
        (cond ((eq? message 'push) push)
              ((eq? message 'pop) (pop))
              ((eq? message 'initialize) (initialize))
              (else (error "Unknown request: STACK" message))))
       dispatch))
     #+END_SRC

     The following procedures are used to access stacks:

     #+BEGIN_SRC scheme
     (define (pop stack) (stack 'pop))
     (define (push stack value) ((stack 'push) value))
     #+END_SRC

**** The basic machine     
     
     The make-new-machine procedure, shown in Figure 5.13, constructs
     an object whose local state consists of a stack, an initially
     empty instruction sequence, a list of operations that initially
     contains an operation to initialize the stack, and a _register
     table_ that initially contains two registers, named flag and pc
     (for "program counter"). The internal procedure allocate-register
     adds new entries to the register table, and the internal
     procedure lookup-register looks up registers in the table.

     The flag register is used to control branching in the simulated
     machine. test instructions set the contents of flag to the result
     of the test (true or false). branch instructions decide whether
     or not to branch by examining the contents of flag.

     The pc register determines the sequencing of instructions as the
     machine runs. This sequencing is implemented by the internal
     procedure execute. In the simulation model, each machine
     instruction is a data structure that includes a procedure of no
     arguments, called the _instruction execution procedure_, such
     that calling this procedure simulates executing the
     instruction. As the simulation runs, pc points to the place in
     the instruction sequence beginning with the next instruction to
     be executed. execute gets that instruction, executes it by
     calling the instruction execution procedure, and repeats this
     cycle until there are no more instructions to execute (i.e.,
     until pc points to the end of the instruction sequence). 

     - Figure 5.13: The make-new-machine procedure, which implements
       the basic machine model.

       #+BEGIN_SRC scheme
	 (define (make-new-machine)
	  (let ((pc (make-register 'pc))
		(flag (make-register 'flag))
		(stack (make-stack))
		(the-instruction-sequence '()))
	   (let ((the-ops
		  (list (list 'initialize-stack
			      (lambda () (stack 'initialize)))))
		 (register-table
		  (list (list 'pc pc) (list 'flag flag))))
	    (define (allocate-register name)
	     (if (assoc name register-table)
		 (error "Multiply defined register: " name)
		 (set! register-table
		       (cons (list name (make-register name))
			      register-table)))
	     'register-allocated)
	    (define (lookup-register name)
	     (let ((val (assoc name register-table)))
	      (if val
		  (cadr val)
		  (error "Unknown register:" name))))
	    (define (execute)
	     (let ((insts (get-contents pc)))
	      (if (null? insts)
		  'done
		  (begin
		   ((instruction-execution-proc (car insts)))
		   (execute)))))
	    (define (dispatch message)
	     (cond ((eq? message 'start)
		    (set-contents! pc the-instruction-sequence)
		    (execute))
		   ((eq? message 'install-instruction-sequence)
		    (lambda (seq)
		     (set! the-instruction-sequence seq)))
		   ((eq? message 'allocate-register)
		    allocate-register)
		   ((eq? message 'get-register)
		    lookup-register)
		   ((eq? message 'install-operations)
		    (lambda (ops)
		      (set! the-ops (append the-ops ops))))
		   ((eq? message 'stack) stack)
		   ((eq? message 'operations) the-ops)
		   (else (error "Unknown request: MACHINE"
				message))))
	    dispatch)))
       #+END_SRC

       As part of its operation, each instruction execution procedure
       modifies pc to indicate the next instruction to be
       executed. branch and goto instructions change pc to point to
       the new destination. All other instructions simply advance pc,
       making it point to the next instruction in the
       sequence. Observe that each call to execute calls execute
       again, but this does not produce an infinite loop because
       running the instruction execution procedure changes the
       contents of pc.

       make-new-machine returns a dispatch procedure that implements
       message-passing access to the internal state. Notice that
       starting the machine is accomplished by setting pc to the
       beginning of the instruction sequence and calling execute.

       For convenience, we provide an alternate procedural interface
       to a machine's start operation, as well as procedures to set
       and examine register contents, as specified at the beginning of
       Section 5.2:

       #+BEGIN_SRC scheme
       (define (start machine) (machine 'start))
       (define (get-register-contents machine register-name)
        (get-contents (get-register machine register-name)))
       (define (set-register-contents! machine register-name value)
        (set-contents! (get-register machine register-name)
                       value)
        'done)
       #+END_SRC

       These procedures (and many procedures in Section 5.2.2 and
       Section 5.2.3) use the following to look up the register with a
       given name in a given machine:

       #+BEGIN_SRC scheme
       (define (get-register machine reg-name)
        ((machine 'get-register) reg-name))
       #+END_SRC

*** 5.2.2 The Assembler       

    The assembler transforms the sequence of controller expressions
    for a machine into a corresponding list of machine instructions,
    each with its execution procedure. Overall, the assembler is much
    like the evaluators we studied in Chapter 4 -- there is an input
    language (in this case, the register-machine language) and we must
    perform an appropriate action for each type of expression in the
    language.

    The technique of producing an execution procedure for each
    instruction is just what we used in Section 4.1.7 to speed up the
    evaluator by separating analysis from runtme exection. As we saw
    in Chapter 4, much useful analysis of Scheme expressions could be
    performed without knowing the actual values of variables. Here,
    analogously, much useful analysis of register-machine-language
    expressions can be performed without knowing the actual contents
    of machine registers. For example, we can replace references to
    registers by pointers to the register objects, and we can replace
    references to labels by pointers to the place in the instruction
    sequence that the label designates. 

    Before it can generate the instruction execution procedures, the
    assembler must know what all the labels refer to, so it begins by
    scanning the controller text to separate the labels from the
    instructions. As it scans the text, it constructs both a list of
    instructions and a table that associates each label with a pointer
    into that list. Then the assembler augments the instruction list
    by inserting the execution procedure for each instruction.

    The assemble procedure is the main entry to the assembler. it
    takes the controller text and the machine model as arguments and
    returns the instruction sequence to be stored in the
    model. assemble calls extract-labels to build the initial
    instruction list and label table from the supplied controller
    text. The second argument to extract-labels is a procedure to be
    called to process these results: This procedure uses update-insts!
    to generate the instruction execution procedures and insert them
    into the instruction list, and returns the modified list.

    #+BEGIN_SRC scheme
    (define (assemble controller-text machine)
     (extract-labels
      controller-text
      (lambda (insts labels)
       (update-insts! insts labels machine)
       insts)))
    #+END_SRC

    extract-labels takes as arguments a list text (the sequence of
    controller instruction expressions) and a receive
    procedure. receive will be called with two values: (1) a list of
    insts of instruction data structures, each containing an
    instruction from text; and (2) a table called labels, which
    associates each label from text with the position in the list
    insts that the label designates.

    #+BEGIN_SRC scheme
      (define (extract-labels text receive)
       (if (null? text)
	   (receive '() '())
	   (extract-labels
	    (cdr text)
	    (lambda (insts labels)
	      (let ((next-inst (car text)))
		(if (symbol? next-inst)
		    (receive
			insts
			(cons (make-label-entry next-inst
						insts)
			      labels))
		    (receive
			(cons
			 (make-instruction next-inst)
			 insts)
			labels)))))))
    #+END_SRC

    extract-labels works by sequentially scanning the elements of the
    text and accumulating the insts and the labels. If an element is a
    symbol (and thus a label) an appropriate entry is added to the
    labels table. Otherwise the element is accumulated onto the insts
    list. 

    update-insts! modifies the instruction list, which initially
    contains only the text of the instructions, to include the
    corresponding execution procedures:

    #+BEGIN_SRC scheme
    (define (update-insts! insts labels machine)
     (let ((pc (get-register machine 'pc))
           (flag (get-register machine 'flag))
           (stack (machine 'stack))
           (ops (machine 'operations)))
       (for-each
        (lambda (inst)
         (set-instruction-execution-proc!
          inst
          (make-execution-procedure
           (instruction-text inst)
           labels machine pc flag stack ops)))
         insts)))
    #+END_SRC

    The machine instruction data structure simply pairs the
    instruction text with the corresponding execution procedure. The
    execution procedure is not yet available wihen extract-labels
    constructs the instruction, and is inserted later by
    update-insts!.

    #+BEGIN_SRC scheme
    (define (make-instruction text) (cons text '()))
    (define (instruction-text inst) (car inst))
    (define (instruction-execution-proc inst) (cdr inst))
    (define (set-instruction-execution-proc! inst proc)
     (set-cdr! inst proc))
    #+END_SRC

    The instruction text is not used by our simulator, but is handy to
    keep around for debugging (see Exercise 5.16).

    Elements of the label table are pairs:

    #+BEGIN_SRC scheme
    (define (make-label-entry label-name insts)
     (cons label-name insts))
    #+END_SRC

    Entries will be looked up in the table with

    #+BEGIN_SRC scheme
    (define (lookup-label labels label-name)
     (let ((val (assoc label-name labels)))
      (if val
          (cdr val)
          (error "Undefined label: ASSEMBLE"
                 label-name))))
    #+END_SRC

    - Exercise 5.8: The following register-machine code is abiguous,
      because the label here is defined more than once:

      #+BEGIN_SRC scheme
      start
       (goto (label here))
      here
       (assign a (const 3))
       (goto (label there))
      here
       (assign a (const 4))
       (goto (label there))
      there
      #+END_SRC

      With the simulator as written, what will the contents of
      register a be when control reaches the label 'there'? Modify the
      extract-labels procedure procedure so that the assembler will
      signal an error if the same label name is used to indicate two
      different locations.

      Register a will hold 3, since we cons onto the assoc list from
      the top down, the first here will be closer to the front of the list.

      #+BEGIN_SRC scheme
      (define (extract-labels text receive)
       (if (null? text)
           (receive '() '())
           (extract-labels
            (cdr text)
            (lambda (insts labels)
             (let ((next-inst (car text)))
              (cond 
               ((and (symbol? next-inst)
                    (assoc next-inst labels))
                (error "Multiply defined label -- ASSEMBLE"))
               ((symbol? next-inst)
                  (receive insts
                           (cons (make-label-entry next-inst
                                                   insts)
                                 labels)))
               (else
                (receive (cons (make-instruction next-inst)
                               insts)
                         labels))))))))
                  
      #+END_SRC


*** 5.2.3 Generating Execution Procedures for Instructions     
   
    The assembler calls make-execution-procedure to generate the
    execution procedure for an instruction. Like the analyze procedure
    in the evaluator of Section 4.1.7, this dispatches on the type of
    instruction to generate the appropriate execution procedure.

    #+BEGIN_SRC scheme
    (define (make-execution-procedure
             inst labels machine pc flag stack ops)
     (cond ((eq? (car inst) 'assign)
            (make-assign inst machine labels ops pc))
           ((eq? (car inst) 'test)
            (make-test inst machine labels ops flag pc))
           ((eq? (car inst) 'branch)
            (make-branch inst machine labels flag pc))
           ((eq? (car inst) 'goto)
            (make-goto inst machine labels pc))
           ((eq? (car inst) 'save)
            (make-save inst machine stack pc))
           ((eq? (car inst) 'restore)
            (make-restore inst machine stack pc))
           ((eq? (car inst) 'perform)
            (make-perform inst machine labels ops pc))
           (else
            (error "Unknown instruction type: ASSEMBLE"
                   inst))))
    #+END_SRC

    For each type of instruction in the register-machine language,
    there is a generator that builds an appropriate execution
    procedure. The details of these procedures determine both the
    syntax and meaning of the individual instructions in the
    register-machine language. We use data abstraction to isolate the
    detailed syntax of register-machine expressions from the general
    execution mechanism, as we did for evaluators in Section 4.1.2, by
    using syntax procedures to extract and classify the parts of an
    instruction.

**** assign instructions.

     The make-assign procedure handles assign instructions:

     #+BEGIN_SRC scheme
     (define (make-assign inst machine labels operations pc)
      (let ((target
             (get-register machine (assign-reg-name inst)))
            (value-exp (assign-value-exp inst)))
       (let ((value-proc
              (if (operation-exp? value-exp)
                  (make-operation-exp
                   value-exp machine labels operations)
                  (make-primitive-exp
                   (car value-exp) machine labels))))
        (lambda ()
         (set-contents! target (value-proc))
         (advance-pc pc)))))
     #+END_SRC

     make-assign extracts the target register name (the second element
     of the instruction) and the value expression (the rest of the
     list that forms the instruction) from the assign instruction
     using the selectors

     #+BEGIN_SRC scheme
     (define (assign-reg-name assign-instruction)
      (cadr assign-instruction))
     (define (assign-value-exp assign-instruction)
      (cddr assign-instruction))
     #+END_SRC

     The register name is looked up with get-register to produce the
     target register object. The value expression is passed to
     make-operation-exp if the value is the result of an operation,
     and to make-primitive-exp otherwise. These procedures (shown
     below) parse the value expression and produce an execution
     procedure for the value. This is a procedure of no arguments,
     called value-proc, which will be evaluated during the simulation
     to produce the actual value to be assigned to the
     register. Notice that the work of looking up the register name
     and parsing the value expression is performed just once, at
     assembly time, not every time the instruction is simulated. This
     saving of work is the reason we use execution procedures, and
     corresponds directly to the saving in work we obtained by
     separating program analysis from execution in the evaluator of
     Section 4.1.7. 

     The result returned by make-assign is the execution procedure for
     the assign instruction. When this procedure is called (by the
     machine model's execute procedure), it sets the contents of the
     target register to the result obtained by executing
     value-proc. Then it advances the pc to the next instruction by
     running the procedure

     #+BEGIN_SRC scheme
     (define (advance-pc pc)
      (set-contents! pc (cdr (get-contents pc))))
     #+END_SRC

     advance-pc is the normal termination for all instructions except
     branch and goto.

**** test, branch, and goto instructions

     make-test handles test instructions in a similar way. It extracts
     the expression that specifies the condition to be tested and
     generates an execution procedure for it. At simulation time, the
     procedure for the condition is called, the result is assigned to
     the flag register, and the pc is advanced:

     #+BEGIN_SRC scheme
       (define (make-test inst machine labels operations flag pc)
	(let ((condition (test-condition inst)))
	 (if (operation-exp? condition)
	  (let ((condition-proc
		 (make-operation-exp
		  condition machine labels operations)))
	   (lambda ()
	    (set-contents! flag (condition-proc))
	    (advance-pc pc)))
	  (error "Bad TEST instruction: ASSEMBLE" inst))))
       (define (test-condition test-instruction)
	 (cdr test-instruction))
     #+END_SRC

     The execution procedure for a branch instruction checks the
     contents of the flag register and either sets the contents of the
     pc to the branch destination (if the branch is taken) or else
     just advances the pc (if the branch is not taken). Notice that
     the indicated destination in a branch instruction must be a
     label, and the make-branch procedure enforces this. Notice also
     that the label is looked up at assembly time, not each time the
     branch instruction is simulated.

     #+BEGIN_SRC scheme
     (define (make-branch inst macchine labels flag pc)
      (let ((dest (branch-dest inst)))
        (if (label-exp? dest)
            (let ((insts
                   (lookup-label
                    labels
                    (label-exp-label dest))))
             (lambda ()
              (if (get-contents flag)
                  (set-contents! pc insts)
                  (advance-pc pc)))
             (error "Bad BRANCH instruction: ASSEMBLE" inst)))))
     (define (branch-dest branch-instruction)
      (cadr branch-instruction))
     #+END_SRC

     A goto instruction is similar to a branch, except that the
     destination may be specified either as a label or as a register,
     and there is no condition to check -- the pc is always set to the
     new destination.

     #+BEGIN_SRC scheme
       (define (make-goto inst machine labels pc)
	(let ((dest (goto-dest inst)))
	 (cond ((label-exp? dest)
		(let ((insts (lookup-label
			      labels
			      (label-exp-label dest))))
		  (lambda ()
		    (set-contents! pc insts))))
	       ((register-exp? dest)
		(let ((reg (get-register
			    machine
			    (register-exp-reg dest))))
		  (lambda ()
		    (set-contents! pc (get-contents reg)))))
	       (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))
       (define (goto-dest goto-instruction)
	 (cadr goto-instruction))
     #+END_SRC

**** Other instructions     
     The stack instructions save and restore simply use the stack with
     the designated register and advance the pc:

     #+BEGIN_SRC scheme
     (define (make-save inst machine stack pc)
      (let ((reg (get-register machine
                               (stack-inst-reg-name inst))))
       (lambda ()
        (push stack (get-contents reg))
        (advance-pc pc))))
     (define (make-restore inst machine stack pc)
      (let ((reg (get-register machine
                               (stack-inst-reg-name inst))))
       (lambda ()
        (set-contents! reg (pop stack))
        (advance-pc pc))))
     (define (stack-inst-reg-name stack-instruction)
      (cadr stack-instruction))
     #+END_SRC

     The final instruction type, handled by make-perform, generates an
     execution procedure for the action to be performed. At simulation
     time, the action procedure is executed and the pc advanced.

     #+BEGIN_SRC scheme
     (define (make-perform inst machine labels operations pc)
       (let ((action (perform-action inst)))
        (if (operation-exp? action)
         (let ((action-proc
                (make-operation-exp
                 action machine labels operations)))
          (lambda () (action-proc) (advance-pc pc)))
         (error "Bad PERFORM instruction: ASSEMBLE" inst))))
     (define (perform-action inst) (cdr inst))
     #+END_SRC

**** Execution procedures for subexpressions     
     The value of a reg, label, or const expression may be needed for
     assignment to a register (make-assign) or for input to an
     operation (make-operation-exp, below). The following procedure
     generates execution procedures to produce values for these
     expressions during the simulation:

     #+BEGIN_SRC scheme
     (define (make-primitive-exp exp machine labels)
      (cond ((constant-exp? exp)
             (let ((c (constant-exp-value exp)))
              (lambda () c)))
            ((label-exp? exp)
             (let ((insts (lookup-label
                           labels
                           (label-exp-label exp))))
              (lambda () insts)))
            ((register-exp? exp)
             (let ((r (get-register machine (register-exp reg exp))))
              (lambda () (get-contents r))))
            (else (error "Unknown expression type: ASSEMBLE" exp))))
     #+END_SRC

     The syntax of reg, label, and const expressions is determined by

     #+BEGIN_SRC scheme
     (define (register-exp? exp) (tagged-list? exp 'reg))
     (define (register-exp-reg exp) (cadr exp))
     (define (constant-exp? exp) (tagged-list? exp 'const))
     (define (constant-exp-value exp) (cadr exp))
     (define (label-exp? exp) (tagged-list? exp 'label))
     (define (label-exp-label exp) (cadr exp))
     #+END_SRC

     assign, perform, and test instructions may include the
     application of a machine operation (specified by an op
     expression) to some operands (specified by reg and const
     expressions). The following procedure produces an execution
     procedure for an "operation expression" -- a list containing the
     operation and operand expression from the instruction:

     #+BEGIN_SRC scheme
     (define (make-operation-exp exp machine labels operations)
      (let ((op (lookup-prim (operation-exp-op exp) 
                             operations))
           (aprocs
            (map (lambda (e)
                  (make-primitive-exp e machine labels))
                 (operation-exp-operands exp))))
       (lambda ()
        (apply op (map (lambda (p) (p)) aprocs))))) 
     #+END_SRC

     The syntax of operation expressions is determined by

     #+BEGIN_SRC scheme
     (define (operation-exp? exp)
      (and (pair? exp) (tagged-list? (car exp) 'op)))
     (define (operation-exp-op operation-exp)
      (cadr (car operation-exp)))
     (define (operation-exp-operands operation-exp)
      (cdr operation-exp))
     #+END_SRC

     Observe that the treatment of operation expressions is very much
     like the treatment of procedure applications by the
     analyze-application procedure in the evaluator of Section 4.1.7
     in that we generate an execution procedure for each operand. At
     simulation time, we call the operand procedures and apply the
     Scheme procedure that simulates the operation to the resulting
     values. The simulation procedure is found by looking up the
     operation name in the operation table for the machine:

     #+BEGIN_SRC scheme
     (define (lookup-prim symbol operations)
      (let ((val (assoc symbol operations)))
       (if val
           (cadr val)
           (error "Unknown operation: ASSEMBLE" symbol))))
     #+END_SRC

     - Exercise 5.9: The treatment of machine operations above
       permits them to operate on labels as well as on constants and
       the contents of registers. Modify the expression-processing
       procedures to enforce the condition that operations can be used
       only with registers and constants. (done in assembler.scm)

     - Exercise 5.10: Design a new syntax for register-machine
       instructions and modify the simulator to use your new
       syntax. Can you implement your new syntax without changing any
       part of the simulator except the syntax procedures in this
       section?

       I will make it look more like a traditional assembly language.

       #+BEGIN_SRC scheme
       (assign (op -) (reg v) (reg a) (reg b)) 
       ->
       (sub v a b)
       
       ;; basically (<op> <reg1> ...<reg n>)

       (push v)
       ->
       (push v)
   
       (save v)
       ->
       (save v)

       #+END_SRC

       labels will be the same. We can't do this changing only the
       accessor/syntax procedures, we can only make trivial changes in
       syntax ordering with those. We need to change
       make-execution-procedure. I will leave test and branch the
       same. 

       We wouldn't need to change anything if the
       make-execution-procedure had proper predicates instead of eq?
       clauses in the cond clause.
       
       An interesting note is that it is hard to change the syntax
       much besides re-ordering the list order or just changing the
       symbol values (reg->register for example), because we give
       ourselves lots of critical information upfront that would
       normally require information about the parsed text. For example

       #+BEGIN_SRC scheme
       (register-exp? exp)
       #+END_SRC

       Can be a simple one-argument function because we annotated it
       in the actual syntax as

       #+BEGIN_SRC scheme
       (reg x)
       #+END_SRC

       So the function is just

       #+BEGIN_SRC scheme
       (define (register-exp? exp) (tagged-list? exp 'reg))
       #+END_SRC

       Otherwise, if we want anything that isn't basically a tagged
       list, we have to do:

       #+BEGIN_SRC scheme
       (define (register-exp? exp machine) 
        (and (symbol? exp)
             (register-defined? machine exp)))
       #+END_SRC

       Otherwise, we would need to pass the machine into each
       predicate, so it could see if the machine had that as a
       register. Otherwise we would confuse registers and labels,
       because alternative syntaxes can confuse them easily. 

       I ended up with the following syntax for gcd:

       #+BEGIN_SRC scheme
	 (test-b
	  (test = b 0)
	  (branch gcd-done)
	  (rem t a b)
	  (mov a b)
	  (mov b t)
	  (goto test-b)
	  gcd-done)
       #+END_SRC

     - Exercise 5.11: When we introduced save and restore in Section
       5.1.4, we didn't specify what would happen if you tried to
       restore in Section 5.1.4, we didn't specify what would happen
       if you tried to restore a register that was not the last one
       saved, as in the sequence

       #+BEGIN_SRC scheme
       (save y) (save x) (restore y)
       #+END_SRC

       There are several reasonable possibilities for the meaning of
       restore:

       a. (restore y) puts into y the last value saved on the stack,
       regardless of what register that value came from. This is the
       way our simulator behaves. Show how to take advantage of this
       behavior to eliminate one instruction from the Fibonacci
       machine of Section 5.1.4 (Figure 5.12).

       We already did this in Exercise 5.6.
         #+BEGIN_SRC scheme
	   (controller
	    (assign continue (label fib-done))
	    fib-loop
	    (test (op <) (reg n) (const 2))
	    (branch (label immediate-answer))
	    ;; set up to compute Fib(n-1)
	    (save continue)
	    (assign continue (label afterfib-n-1))
	    (save n)
	    (assign n (op -) (reg n) (const 1))
	    (goto (label fib-loop))
	    afterfib-n-1
	    (restore n)
	    ;; The lines marked 'redundant:' were unnecessary.
	    ;; redundant: (restore continue)
	    ;; set up to compute Fib(n-2)
	    (assign n (op -) (reg n) (const 2))
	    ;; redundant: (save continue)
	    (assign continue (label afterfib-n-2))
	    (save val)
	    (goto (label fib-loop))
	    afterfib-n-2
            ;; ** REMOVED **
	    ;; (assign n (reg val))
	    ;; (restore val)
            (restore n) ;; << Added. Restore old val directly to n.
	    (restore continue)
	    (assign val (op +) (reg val) (reg n))
	    (goto (reg continue))
	    immediate-answer
	    (assign val (reg n))
	    (goto (reg continue))
	    fib-done)
       #+END_SRC

       b. (restore y) puts into y the last value saved on the stack,
       but only if that value was saved from y; otherwise, it signals
       an error. Modify the simulator to behave this way. You will
       have to change save to put the register name on the stack along
       with the value.
       (In directory register-sim-5.10-b)

       c. (restore y) puts into y the last value saves from y
       regardless of what other registers were saved after y and not
       restored. Modify the simulator to behave this way. You will
       have to associate a separate stack with each register. You
       should make the initialize-stack operation initialize the all
       register stacks.

       (In directory register-sim-5.10-c)

     - Exercise 5.12: The simulator can be used to help determine the
       data paths required for implementing a machine with a given
       controller. Extend the assembler to store the following
       information in the machine model:

       * A list of all instructions, with duplicates removed, sorted
         by instruction type (assign, goto, and so on).

       * A list (without duplicates) of the registers used to hold
         entry points (these are teh registers referenced by goto
         instructions);

       * for each register, a list (without duplicates) of the sources
         from which it is assigned (for example, the sources for
         register val in the factorial machine of Figure 5.11 are
         (const 1) and ((op *) (reg n) (reg val))).

	 #+BEGIN_SRC scheme
	   1 ]=> (fibom 'print-control-data)
	   Table assignment-values
	   ((val (reg n) ((op +) (reg val) (reg n)))
	    (n (reg val) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
	    (continue (label afterfib-n-2) (label afterfib-n-1) (label fib-done)))

	   Table saved-regs
	   (val n continue)

	   Table instructions
	   ((assign val (reg n)) (assign val (op +) (reg val) (reg n))
				 (assign n (reg val))
				 (assign continue (label afterfib-n-2))
				 (assign n (op -) (reg n) (const 2))
				 (assign n (op -) (reg n) (const 1))
				 (assign continue (label afterfib-n-1))
				 (assign continue (label fib-done))
				 (test (op <) (reg n) (const 2))
				 (branch (label immediate-answer))
				 (save val)
				 (save n)
				 (save continue)
				 (goto (reg continue))
				 (goto (label fib-loop))
				 (restore val)
				 (restore continue)
				 (restore n))

	   Table restored-regs
	   (val continue n)
	 #+END_SRC

     - Exercise 5.13: Modify the simulator so that it uses the
       controller sequence ot determine what registers the machine has
       rather than requiring a list of registers as an argument to
       make-machine. Instead of pre-allocating the registers in
       make-machine, you can allocate them one at a time when they are
       first seen during assembly of the instructions. (Done in the
       5-12 folder).

*** 5.2.4 Monitoring Machine Performance 

    Simulation is useful not only for verifying the correctness of a
    proposed machine design but also for measuring the machine's
    performance. For example, we can install in our simulation program
    a "meter" that measures the number of stack operations used in a
    computation. To do this, we modify our simulated stack to keep
    track of the number of times registers are saved on the stack and
    the maximum depth reached by the stack, and add a message to the
    stack's interface that prints the statistics, as shown below. We
    also add an operation to the basic machine model to print the
    stack statistics, by initializing the-ops in make-new-machine to

    #+BEGIN_SRC scheme
    (list (list 'initialize-stack
                (lambda () (stack 'initialize)))
          (list 'print-statistics 
                (lambda () (stack 'print-statistics))))
    #+END_SRC

    Here is the new version of make-stack:

    #+BEGIN_SRC scheme
      (define (make-stack)
       (let ((s '())
	     (number-pushes 0)
	     (max-depth 0)
	     (current-depth 0))
	 (define (push x)
	   (set! s (cons x s))
	   (set! number-pushes (+ 1 number-pushes))
	   (set! current-depth (+ 1 current-depth))
	   (set! max-depth (max current-depth max-depth)))
	 (define (pop)
	   (if (null? s)
	       (error "Empty stack: POP")
	       (let ((top (car s)))
		 (set! s (cdr s))
		 (set! current-depth (- current-depth 1))
		 top)))
	 (define (initialize)
	   (set! s '())
	   (set! number-pushes 0)
	   (set! max-depth 0)
	   (set! current-depth 0)
	   'done)
	 (define (print-statistics)
	   (newline)
	   (display (list 'total-pushes '= number-pushes
			  'maximum-depth '= max-depth)))
	 (define (dispatch message)
	   (cond ((eq? message 'push) push)
		 ((eq? message 'pop) (pop))
		 ((eq? message 'initialize) (initialize))
		 ((eq? message 'print-statistics)
		  (print-statistics))
		 (else (error "Unknown request: STACK" message))))
	 dispatch))
    #+END_SRC

    Exercise 5.15 through Exercise 5.19 describe other useful
    monitoring and debugging features that can be added to the
    register-machine simulator.

    - Exercise 5.14: Measure the number of pushes and the maximum
      stack depth required to compute n! for various small values of
      _n_ using the factorial machine shown in Figure 5.11. From your
      data determine formulas in terms of _n_ for the total number of
      push operations and the maximum stack depth used in computing n!
      for any n > 1. Note that each of these is a linear function of n
      and is thus determined by two constants. In order to get the
      statistics printed, you will have to augment the factorial
      machine with instructions to initialize the stack and print the
      statistics. You may want to also modify the machine so that it
      repeatedly reads a value for n, computes the factorial, and
      prints the result (as we did for the GCD machine in Figure 5.4),
      so that you will not have to repeatedly invoke
      get-register-contents, set-register-contents!, and start.

      #+BEGIN_SRC scheme
	(start-fact-readwrite-loop
	 (assign c (op read))
	 (assign p (const 1))
	 (perform (op initialize-stack))
	 (assign continue (label fact-done))
	 fact-loop
	 (test (op <) (reg c) (const 1))
	 (branch (label fact-done))
	 (assign p (op *) (reg p) (reg c))
	 (assign c (op -) (reg c) (const 1))
	 (goto (label fact-loop))
	 fact-done
	 (perform (op print-statistics))
	 (perform (op display) (reg p))
	 (perform (op newline))
	 (goto (label start-fact-readwrite-loop)))
      #+END_SRC
      
      The above function is zero for both. It doesn't use the stack.

      #+BEGIN_SRC scheme
	(start-fact-readwrite-loop
	 (assign n (op read))
	 (assign val (const 0))
	 (perform (op initialize-stack))
	 (assign continue (label fact-done))
	 fact-loop
	 (test (op <) (reg n) (const 1))
	 (branch (label immediate-answer))
	 (save continue)
	 (save n)
	 (assign n (op -) (reg n) (const 1))
	 (assign continue (label after-fact-loop))
	 (goto (label fact-loop))
	 after-fact-loop
	 (restore n)
	 (assign val (op *) (reg n) (reg val))
	 (restore continue)
	 (goto (reg continue))
	 immediate-answer
	 (assign val (const 1))
	 (goto (reg continue))
	 fact-done
	 (perform (op print-statistics))
	 (perform (op newline))
	 (perform (op display) (reg val))
	 (perform (op newline))
	 (goto (label start-fact-readwrite-loop)))

      #+END_SRC
      For this function/program, the total pushes and depth are equal,
      and the equation is 2*n. So computing 1! results in 2 stack
      pushes and a max depth of 2, 7! in 14 pushes and a max depth
      of 14.

    - Exercise 5.15: Add _instruction counting_ to the register
      machine simulation. That is, have the machine model keep track
      of the number of instructions executed. Extend the machine
      model's interface to accept a new message that prints the value
      of the instruction count and resets the count to zero.

    - Exercise 5.16: Augment the simulator to provide for _instruction
      tracing_. That is, before each instruction is executed, the
      simulator should print the text of the instruction. Make the
      machine model accept trace-on and trace-off messages to turn
      tracing on and off (Did this in the register-simulator folder).

    - Exercise 5.17: Extend the instruction tracing of Exercise 5.16 so
      that before printing an instruction, the simulator prints any
      labels that immediately precede that instruction in the
      controller sequence. Be careful to do this in a way that does
      not interfere with instruction counting (Exercise 5.15). You
      will have to make the simulator retain the necessary label
      information. (Also done in register-simulator folder).

    - Exercise 5.18: Modify the make-register procedure of Section
      5.2.1 so that registers can be traced. Registers should accept
      messages that turn tracing on and off. When a register is
      traced, assigning a value to the register should print the name
      of the register, the old contents of the register, and the new
      contents being assigned. Extend the interface to the machine
      model to permit you to turn tracing on and off for designated
      machine registers.

    - Exercise 5.19: Alyssa P. Hacker wants a _breakpoint_ freature in
      the simulator to help her debug her machine designs. You have
      been hired to install this feature for her. She wants to be able
      to specify a place in the controller sequence where the
      simulator will stop and allow her to examine the state of the
      machine. You are to implement a procedure

      #+BEGIN_SRC scheme
      (set-breakpoint <machine> <label> <n>)
      #+END_SRC

      that sets a breakpoint just before the nth instruction after the
      given label. For example:

      #+BEGIN_SRC scheme
      (set-breakpoint gcd-machine 'test-b 4)
      #+END_SRC

      installs a breakpoint in gcd-machine just before the assignment
      to register a. When the simulator reaches the breakpoint it
      should print the label and the offset of the breakpoint and stop
      executing instructions. Alyssa can then use
      get-register-contents and set-register-contents! to manipulate
      the state of the simulated machine. She should then be able to
      continue execution by saying

      #+BEGIN_SRC scheme
      (procceed-machine <machine>)
      #+END_SRC

      She should also be able to remove a specific breakpoint by means
      of

      #+BEGIN_SRC scheme
      (cancel-breakpoint <machine> <label> <n>)
      #+END_SRC

      or to remove all breakpoints by means of 

      #+BEGIN_SRC scheme
      (cancel-all-breakpoints <machine>)
      #+END_SRC

      All these are in the register-simulator/ folder.

** 5.3 Storage Allocation and Garbage Collection
   In Section 5.4, we will show how ot implement a Scheme evaluator as
   a register machine. In order to simplify the discussion, we will
   assume that our register machines can be equipped with a
   _list-structured memory_, in which the basic operations for
   manipulating list-structured data are primitive. Postulating the
   existence of such a memory is a useful abstraction when one is
   focusing on the mechanisms of control in a Scheme interpreter, but
   this does not reflect a realistic view of hte actual primitive data
   operations of contemporary computers. To obtain a more complete
   picture of how a Lisp system operates, we must investigate how list
   structure can be represented in a way that is compatible with
   conventional computer memories. 

   There are two considerations in implementing list structure. The
   first is purely an issue of representation: how to represent the
   "box-and-pointer" structure of Lisp pairs, using only the storage
   and addressing capabilities of typical computer memories. The
   second issue concerns the management of memory as a computation
   proceeds. The operation of a Lisp system depends crucially on the
   ability to continually create new data objects. These include
   objects that are explicitly created by the interpreter itself, such
   as environments and argument lists. Although the constant creation
   of new data objects would pose no problem on a computer with an
   infinite amount of rapidly addressable memory, computer memories
   are available only in finite sizes (more's the pity). Lisp systems
   thus provide an _automatic storage allocation_ facility to support
   the illusion of an infinite memory. When a data object is no longer
   needed, the memory allocated to it is automatically recycled and
   used to construct new data objects. There are various techniques
   for providing such automatic storage allocation. The method we
   shall discuss in this section is called _garbage collection_. 

*** 5.3.1 Memory as Vectors

    A conventional computer memory can be thought of as an array of
    cubbyholes, each of which can contain a piece of information: Each
    cubbyhole has a unique name, called its _address_ or
    _location_. Typical memory sytems provide two primitive
    operations: one that fetches the data stored in a specified
    location and one that assigns new data to a specified
    location. Memory addresses can be incremented to support
    sequential access to some set of the cubbyholes. More generally,
    many important data operations require that memory addresses be
    treated as data, which can be stored in memory locations and
    manipulated in machine registers. The representation of list
    structure is one application of such _address arithmetic_. 

    To model computer memory, we use a new kind of data structure
    called a _vector_. Abstractly, a vector is a compound data object
    whose individual elements can be accessed by means of an integer
    index in an amount of time that is independent of the index. In
    order to describe memory operations, we use two primitive Scheme
    procedures for manipulating vectors:

    - (vector-ref <VECTOR> <N>) returns the _n_th element of the vector.
    - (vector-set! <VECTOR> <N> <VALUE>) sets the _n_th element of the
      vector to the designated value.

      
    For example, if v is a vector, then (vector-ref v 5) gets the
    fifth entry of the vector v and (vector-set! v 5 7) changes the
    value of the fifth entry of the vector v to 7. For computer
    memory, this access can be implemented through the use of address
    arithmetic to combine a _base address_ that specifies the
    beginning location of a vector in memory with an _index_ that
    specifies the offset of a particular element of the vector.

**** Representing Lisp data.

     We can use vectors to implement the basic pair structures
     required for a list-structured memory. Let us imagine that
     computer memory is divided into two vectors: the-cars and
     the-cdrs. We will represent list structure as follows: A pointer
     to a pair is an index into the two vectors. The car of the pair
     is the entry in the-cars with the designated index, and the cdr
     of the pair is the entry in the-cdrs with the designated
     index. We also need a representation for objects other than pairs
     (such as numbers and symbols) and a way to distinguish one kind
     of data from another. There are many methods of accomplishing
     this, but they all reduce to using _typed pointers_, that is, to
     extending the notion of "pointer" to include information on data
     type. The data type enables the system to distinguish a pointer
     to a pair (which consists of the "pair" data type and an index
     into the memory vectors) from pointers to other kinds of data
     (which consist of some other data type and whatever is being used
     to represent data of that type). Two data objects are considered
     to be the same (eq?) if their pointers are  identical. Figure
     5.14 illustrates the use of this method to represent the list ((1
     2) 3 4), whose box-and-pointer diagram is also shown. We use
     letter prefixes to denote the data-type information. Thus, a
     pointer to the pair with index 5 is denoted p5, the empty list is
     denoted by the pointer e0, and a pointer to the number 4 is
     denoted n4. In the box-and-pointer diagram, we have indicated
     at the lower left of each pair the vector index that specifies
     where the car and cdr of the pair are stored. The blank locations
     in the-cars and the-cdrs may contain parts of other list
     structures (not of interest here0. 

     A pointer to a number, such as n4, might consist of a type
     indicating numeric data together with the actual representation
     of the number 4. To deal with numbers that are too large to be
     represented in the fixed amount of space allocated for a single
     pointer, we could use a distinct _bignum_ data type, for which
     the pointer designates a list in which the parts of the number
     are stored.

     A symbol might be represented as a typed pointer that designates
     a sequence of the characters that form the symbol's printed
     representation. This sequence is constructed by the Lisp reader
     when the character string is initially encountered in
     input. SInce we want two instances of a symbol to be recognized
     as the "same" symbol by eq? and we want eq? to be a simple test
     for equality of pointers, we must ensure that if the reader sees
     the same character string twice, it will use the same pointer (to
     the same sequence of characters) to represent both
     occurrences. To accomplish this, the reader maintains a table,
     traditionally called the _obarray_, of all the symbols it has
     ever encountered. When the reader encounters a character string
     and is about to construct a symbol, it checks the obarray to see
     if it has ever before seen the same character string. If it has
     not, it uses the characters to construct a new symbol (a typed
     pointer to a new character sequence) and enters this pointer in
     the obarray. If the reader has seen the string before, it returns
     the symbol pointer stored in the obarray. This process of
     replacing character strings by unique pointers is called
     _interning_ symbols.

**** Implementing the primitive list operations     

     Given the above representation scheme, we can replace each
     "primitive" list operation of a register machine with one or more
     primitive vector operations. We will use two registers, the-cars
     and the-cdrs, to identify the memory vectors, and will assume
     that vector-ref and vector-set! are available as primitive
     operations. We also assume that numeric operations on pointers
     (such as incrementing a pointer, using a pair pointer to index a
     vector, or adding two numbers) use only the index portion of the
     typed pointer.

     For example, we can make a register machine support the
     instructions

     #+BEGIN_SRC scheme
     (assign <reg1> (op car) (reg <reg2>))
     (assign <reg1> (op cdr) (reg <reg2>))
     #+END_SRC

     if we implement these, respectively, as

     #+BEGIN_SRC scheme
     (assign <reg1> (op vector-ref) (reg the-cars) (reg <reg2>))
     (assign <reg1> (op vector-ref) (reg the-cdrs) (reg <reg2>))
     #+END_SRC

     The instructions

     #+BEGIN_SRC scheme
     (perform (op set-car!) (reg <reg1>) (reg <reg2>))
     (perform (op set-cdr!) (reg <reg1>) (reg <reg2>))
     #+END_SRC

     are implemented as

     #+BEGIN_SRC scheme
     (perform
      (op vector-set!) (reg the-cars) (reg <reg1>) (reg <reg2>))
     (perform
      (op vector-set!) (reg the-cdrs) (reg <reg1>) (reg <reg2>))
     #+END_SRC

     cons is performed by allocating an unused index and storing the
     arguments to cons in the-cars and the-cdrs at that indexed vector
     position. We presume that there is a special register, free, that
     always holds a pair pointer containing the next available index,
     and that we can increment the index part of that pointer to find
     the next free location. For example, the instruction

     #+BEGIN_SRC scheme
     (assign <reg1> (op cons) (reg <reg2>) (reg <reg3>))
     #+END_SRC

     is implemented as the following sequence of vector operations:

     #+BEGIN_SRC scheme
     (perform (op vector-set!) (reg the-cars) (reg free) (reg <reg2>))
     (perform (op vector-set!) (reg the-cdrs) (reg free) (reg <reg3>))
     (assign <reg1> (reg free))
     (assign free (op +) (reg free) (const 1))
     #+END_SRC

     the eq? operation

     #+BEGIN_SRC scheme
     (op eq?) (reg <reg1>) (reg <reg2>)
     #+END_SRC

     simply tests the equality of all fields in the registers, and
     predicates such as pair?, null?, symbol?, and number? need only
     check the type field.

**** Implementing stacks     
     Although our register machines use stacks, we need do nothing
     special here, since stacks can be modeled in terms of lists. The
     stack can be a list of the saved values, pointed to by a special
     register the-stack. Thus, (save <reg>) can be implemented as

     #+BEGIN_SRC scheme
     (assign the-stack (op cons) (reg <reg>) (reg the-stack))
     #+END_SRC

     Similarly, (restore <reg>) can be implemented as 

     #+BEGIN_SRC scheme
     (assign <reg> (op car) (reg the-stack))
     (assign the-stack (op cdr) (reg the-stack))
     #+END_SRC

     #+BEGIN_SRC scheme
     (assign the-stack (op cons) (reg <reg>) (reg the-stack))
     #+END_SRC

     Similarly, (restore <reg>) can be implemented as

     #+BEGIN_SRC scheme
     (assign <reg> (op car) (reg the-stack))
     (assign the-stack (op cdr) (reg the-stack))
     #+END_SRC

     and (perform (op initialize-stack)) can be implemented as

     #+BEGIN_SRC scheme
     (assign the-stack (const ()))
     #+END_SRC

     These operations can be further expanded in terms of the vector
     operations given above. In conventional computer architectures,
     however, it is usually advantageous to allocate the stack as a
     separate vector. Then pushing and popping the stack can be
     accomplished by incrementing or decrementing an index into that
     vector.

     - Exercise 5.20: Draw the box-and-pointer representation and the
       memory-vector representation (as in Figure 5.14) of the list
       structure produced by

       #+BEGIN_SRC scheme
       (define x (cons 1 2))
       (define y (list x x))
       #+END_SRC

       with free pointer initially p1. What is the final value of
       free? What pointers represent the values of x and y?

       In the end, free is p4. x is represented by the pointer p1, the
       car of p1 is n1 and the cdr is n2. Y is represented by the
       pointer p2, which points to the first cons cell of the list.

     - Exercise 5.21: Implement register machines for the following
       procedures. Assume that the list-structured memory operations
       are available as machine primitives.

       a. Recursive count-leaves:
       #+BEGIN_SRC scheme
       (define (count-leaves tree)
        (cond ((null? tree) 0)
              ((not (pair? tree)) 1)
              (else (+ (count-leaves (car tree))
                       (count-leaves (cdr tree))))))
       #+END_SRC

       #+BEGIN_SRC scheme
       ;; val: count value.
       ;; t: current tree.
       ;; tval: temporary value.
       ((perform (op initialize-stack))
        (assign continue (label end-count-leaves))
        count-leaves-loop
        (test (op null?) (reg t))
        (branch (label zero-count))
        (assign  tval (op pair?) (reg t))
        (test (op not) (reg tval))
        (branch (label one-count))
        (save t)
        (assign t (op car) (reg t))
        (save continue)
        (assign continue (label after-count-car))
        (goto (label count-leaves-loop))
        after-count-car
        (restore continue)
        (restore t)
        (save t)
        (save val)
        (save continue)
        (assign t (op cdr) (reg t))
        (assign continue (label after-count-cdr))
        (goto (label count-leaves-loop))
        after-count-cdr
        (restore continue)
        (restore tval)
        (restore t)
        (assign val (op +) (reg tval) (reg val))
        (goto (reg continue))
        zero-count
        (assign val (const 0))
        (goto (reg continue))
        one-count
        (assign val (const 1))
        (goto (reg continue))
        end-count-leaves)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (count-leaves tree)
        (define (count-iter tree n)
         (cond ((null? three) n)
               ((not (pair? tree)) (+ n 1))
               (else
                (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
         (count-iter tree 0))
       #+END_SRC

       #+BEGIN_SRC scheme
       ;; n: current count value
       ;; t: tree
       ((assign continue (label end-count))
        (assign n (const 0))
        count-leaves
        (test (op null?) (reg t))
        (branch (reg continue))
        (assign tval (op pair?) (reg t))
        (test (op not) (reg tval))
        (branch (label add-one-and-continue))
        (save t)
        (save continue)
        (assign t (op car) (reg t))
        (assign continue (label after-car))
        (goto (label count-leaves))
        after-car
        (restore continue)
        (restore t)
        (assign t (op cdr) (reg t))
        (save continue)
        (assign continue (label after-cdr))
        (goto (label count-leaves))
        after-cdr
        (restore continue)
        (goto (reg continue))
        add-one-and-continue
        (assign n (op +) (reg n) (const 1))
        (goto (reg continue))
        end-count)
       #+END_SRC

     - Exercise 5.22: Exercise 3.12 of Section 3.3.1 presented an
       append procedure that appends two lists to form a new list and
       an append! procedure that splices two lists together. Design a
       register machine to implement each of these procedures. Assume
       that the list-structure memory operations are available as
       primitive operations.

       
     

