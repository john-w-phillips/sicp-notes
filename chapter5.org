* Chapter 5 Computing with Register Machines
We began this book by studying processes and by describing processes
in terms of procedures written in Lisp. To explain the meanings of
these procedures, we used a succession of models of evaluation: the
substitution model of Chapter 1, the environment model of Chapter 3,
and the metacircular evaluator of Chapter 4. Our examination of the
metacircular evaluator, in particular, dispelled much of the mystery
of how Lisp-like languages are interpreted. But even the metacircular
evaluator leaves important questions unanswered, because it fails to
elucidate the mechanisms of control in a Lisp system. For instance,
the evaluator does not explain how the evaluation of a subexpression
manages to return a value to the expression that uses this value, nor
does the evaluator explain how some recursive procedures generate
iterative processes (that is, are evaluated using constant space)
whereas other recursive procedures generate recursive processes. These
questions remain unanswered because the metacircular evaluator is
itself a Lisp program and hence inherits the control structure of the
underlying Lisp system. In order to provide a more complete
description of the control structure of the Lisp evaluator, we must
work at a more primitive level than Lisp itself.

In this chapter we will describe processes in terms of the
step-by-step operatio of a traditional computer. Such a computer, or
_register machine_, sequentially executes _instructions_ that
manipulate the contents of a fixed set of storage elements called
_registers_. A typical register-machine instruction applies a
primitive operation to the contents of some registers and assigns the
result to another register. Our descriptions of processes executed by
register machines will look very much like "machine-language" programs
for traditional computers. However, instead of focusing on the machine
languag of any particular computer, we will examine several Lisp
procedures and design a specific register machine to execute each
procedure. Thus, we will approach our task from the perspective of a
hardware architect rather than that of a machine-language computer
programmer. In designing register machines, we will develop mechanisms
for implementing important programming constructs such as
recursion. We will also present a language for describing designs for
register machines. In Section 5.2 we will implement a Lisp program
that uses these descriptions to simulate the machines we design. 

Most of the primitive operations of our register machines are very
simple. For example, an operation might add the numbers fetched from
two registers, producing a result to be stored into a third
register. Such an operation can be performed by easily described
hardware. In order to deal with list structure, however, we will also
use the memory operations car, cdr, and cons, which require an
elaborate storage-allocation mechanism. In Section 5.3 we study their
implementation in terms of more elementary operations.

In Section 5.4, after we have accumulated experience formulating
simple procedures as register machines, we will design a machine that
carries out the algorithm described by the metacircular evaluator of
Section 4.1. This will fill in the gap in our understanding of how
Scheme expressions are interpreted, by providing an explicit model for
the mechanisms of control in the evaluator. In Section 5.5 we will
study a simple compiler that translates Scheme programs into sequences
of instructions that can be executed directly with the registers and
operations of the evaluator register machine.

** 5.1 Designing Register Machines
   To design a register machine, we must design its _data paths_
   (registers and operations) and the _controller_ that sequences these
   operations. To illustrate the design of a simple register machine, let
   us examine Euclid's Algorithm, which is used to compute the greates
   common divisor (GCD) of two integers. As we saw in Section 1.2.5,
   Euclid's Algorithm can be carried out by an iterative process, as
   specified by the following procedure:

   #+BEGIN_SRC scheme
   (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
   #+END_SRC

   A machine to carry out this algorithm must keep track of two
   numbers, a and b, so let us assume that these numbers are stored in
   two registers with those names. The basic operations required are
   testing whether the contents of register b is zero and computing
   the remainder of the contents of register a divided by the contents
   of register b. The remainder operation is a complex process, but
   assume for the moment that we have a primitive device that computes
   remainders. On each cycle of the GCD algorithm, the contents of
   register a must be replaced by the contents of register b, and the
   contents of b must be replaced by the remainder of the old contents
   of a divided by the old contents of b. It would be convenient if
   these replacements could be done simultaneously, but in our model
   of register machines we will assume that only one register can be
   assigned a new value at each step. To accomplish the replacements,
   our machine will use a third "temporary" register, which we call
   t. (First the remainder will be placed in t, then the contents of b
   will be placed in a, and finally the remainder stored in t will be
   blaced in b.)

   We can illustrate the registers and operations required for this
   machine by using the data-path diagram shown in Figure 5.1. In this
   diagram, the registers (a, b, and t) are represented by
   rectangles. Each way to assign a value to a register is indicated
   by an arrow with an X behind the head, pointing from the source of
   data to the register. We can think of X as a button that, when
   pushed, allows the value at the source to "flow" into the
   designated register. The label next ot each button is the name we
   will use to refer to the button. The names are arbitrary, and can
   be chosen to have a mnemonic value (for example, a<-b denotes
   pushing the button that assigns the contents of register b to
   register a). The source of data for a register can be another
   register (as in the a<-b assignemnt), an operation result (as in
   the t<-r assignment), or a constant (a built-in value that cannot
   be changed, represented in a data-path diagram by a triangle
   containing the constant). 

   An operation that computes a value from constants and the contents
   of registers is represented in a data-path diagram by a trapezoid
   containing a name for the operation. For example, the box marked
   rem in Figure 5.1 represents an operation that computes the
   remainder of the contents of registers a and b to which it is
   attached. Arrows (without buttons) point from the input registers
   and constants to the box, and arrows connect the operation's output
   value to registers. A test is represented by a circle containing a
   name for the test. For example, our GCD machine has an operation
   that tests whether the contents of register b is zero. A test also
   has arrows from its input registers and constants, but it has no
   output arrows; its value is used by the controller rather than by
   the data paths. Overall, the data-path diagram shows the registers
   and operations that are required for the machine and how they must
   be connected. If we view the arrows as wires and the X buttons as
   switches, the data-path diagram is very like the wiring diagram for
   a machine that could be constructed from electrical components.

   In order for the data paths to actually compute GCDs, the buttons
   must be pushed in the correct sequence. We will describe this
   sequence in terms of a controller diagram, as illustrated in Figure
   5.2. The elements of the controller diagram indicate how the
   data-path components should be operated. The rectangular boxes in
   the controler diagram identify data-path buttons to be pushed, and
   the arrows describe the sequencing from one step to the next. The
   diamond in the diagram represents a decision. One of the two
   sequencing arrows will be followed, depending on the value of the
   data-path test identified in the diamond. We can interpret the
   controller in terms of a physical analogy: Think of the diagram as
   a maze in which a marble is rolling. When the marble rolls into a
   box, it pushes the data-path button that is named by the box. When
   the marble rolls into a decision node (such as the test for b = 0),
   it leaves the node on the path determined by the result of the
   indicated test. Taken together, the data paths and the controller
   completely describe a machine for computing GCDs. We start the
   controller (the rolling marble) at the place marked start, after
   placing numbers in registers a and b. When the controller reaches
   done, we will find the value of the GCD in register a.

   - Exercise 5.1 Design a register machine to compute factorials
     using the iterative algorithm specified by the following
     procedure. Draw data-path and controller diagrams for this
     machine.

     #+BEGIN_SRC scheme
     (define (factorial n)
      (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product)
                 (+ counter 1))))
      (iter 1 1)) 
    #+END_SRC
*** 5.1.1 A Language for Describing Register Machines
    Data-path and controller diagrams are adequate for representing
    simple machines such as GCD, but they are unwieldly for describing
    large machines such as a Lisp interpreter. To make it possible to
    deal with complex machines, we will create a language that
    presents, in textual form, all the information given by the
    data-path and controller diagrams. We will start with a notation
    that directly mirrors the diagrams.

    We define the data paths of a machine by describing the registers
    and the operations. To describe a register, we give it a name and
    specify the buttons that control assignment to it. We give each of
    these buttons a name and specify the source of the data that
    enters the register under the button's control. (The source is a
    register, a constant, or an operation.) To describe an operation,
    we give it a name and specify its inputs (registers or
    constants). We define the controller of a machine as a sequence of
    _instructions_ together with _labels_  that identify _entry
    points_ in a sequence. An instruction is one of the following:

    - The name of a data-path button to push to assign a value to a
      register. (This corresponds to a box in the controller diagram.)
    - A test instruction, that performs a specified test.
    - A conditional branch (branch instruction) to a location
      indicated by a controller label, based on the result of the
      previous test. (The test and branch together correspond to a
      diamond in the controller diagram.) If the test is false, the
      controller should continue with tne next instruction in the
      sequence. Otherwise, the controller should continue with the
      instruction after the label.
    - An unconditional branch (goto instruction) naming a controller
      label at which to cintinue execution.

      
    The machine starts at th ebeginning of the controller instruction
    sequence and stops when execution reaches the end of the
    sequence. Except when a branch chanes the flow of contol,
    instructions are executed in the order in which they are listed.

    - Figure 5.3: A specification of the GCD machine.
      #+BEGIN_SRC scheme
      (data-paths
       (registers
        ((name a)
         (buttons ((name a<-b) (source (register b)))))
        ((name b)
         (buttons ((name b<-t) (source (register t)))))
        ((name t)
         (buttons ((name t<-r) (source (operation rem))))))
       (operations
        ((name rem) (inputs (register a) (register b)))
        ((name =) (inputs (register b) (constant 0)))))
       (controller
        test-b
        (test =)
        (branch (label gcd-done))
        (t<-r)
        (a<-b)
        (b<-t)
        (goto (label test-b))
      gcd-done)
    #+END_SRC

    Figure 5.3 shows the GCD machine described this way. This example
    only hints at the generality of these descriptions, since the GCD
    machine is a very simple case: Each register has only one button,
    and each button and test is used only once in the controller.

    Unfortunately, it is difficult to read such a description. In
    order to understand the controller instructions we must constantly
    refer back to the definitions of the button names and the
    operation names, and to understand what the buttons do we may have
    to refer to the definitions of the operation names. We will thus
    transform our notation to combine the information from the
    data-path and controller descriptions so that we see it all
    together. To obtain this form of description, we will replace the
    arbitrary button and operation names by the definitions of their
    behavior. That is, instead of saying (in the controller) "Push
    button t<-r" and separately saying (in the data paths) "Button
    t<-r assigns the value of the rem operation to register t" and
    "the rem operation's inputs are the contents of registers a and
    b," we will say (in the controller) "Push the button that assigns
    to register t the value of the rem operation on the contents of
    register a and b." Similarly, instead of saying (in the
    controller) "Perform the = test" and separately saying (in the
    data paths) "The = test operates on the contents of register b and
    the constant 0," we will say "Perform the = test on the contents
    of register b and the constant 0." We will omit the data-path
    description, leaving only the controller sequence. Thus, the GCD
    machine is described as follows:

    #+BEGIN_SRC scheme
    (controller
     test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
    gcd-done)
    #+END_SRC

    This form of description is easier to read than the kind
    illustrated in Figure 5.3, but it also has disadvantages:

    - It is more verbose for large machines, because complete
      descriptions of the data-path elements are repeated whenever the
      elements are mentioned in the controller instruction
      sequence. (This is not a problem in the GCD example, because
      each operation and button is used only once.) Moreover,
      repeating the data-path descriptions obscures the actual
      data-path structure of the machine; it is not obvious for a
      large machine how many registers, operations, and buttons there
      are and how they are interconnected.

    - Because the controller instructions in a machine definition look
      like Lisp expressions, it is easy to forget that they are not
      arbitrary Lisp expressions. They can notate only legal machine
      operations. For example, operations can operate directly only on
      constants and the contents of registers, not on the results of
      other operations.

      
    In spite of these disadvantages, we will use this register-machine
    language throughout this chapter, because we will be more
    concerned with understanding controllers than with understanding
    the elements and connections in data paths. We should keep in
    mind, however, that data-path design is crucial in designing real
    machines. 

    - Exercise 5.2: Use the register-machine language to describe the
      iterative factorial machine of Exercise 5.1.

      #+BEGIN_SRC scheme 
      (controller
       test-c-n
       (test (op >) (reg c) (reg n))
       (branch (label done-fac))
       (assign tc (op +) (reg c) (const 1))
       (assign tp (op *) (reg c) (reg p))
       (assign p (reg tp))
       (assign c (reg tc))
       (goto (label test-c-n))
      done-fac)
      #+END_SRC

**** Actions
     Let us modify the GCD machine so that we can type in the numbers
     whose GCD we want and get the answer printed at our terminal. We
     will not discuss how to make a machine that can read and print,
     but will assume (as we do when we use read and display in Scheme)
     that they are available as primitive operations.

     read is like the operations we have been using in that it
     produces a value that can be stored in a register. But read does
     not take inputs from any registers; its value depends on
     something that happens outside the parts of the machine we are
     designing. We will allow our machine's operations to have such
     behavior, and will thus draw and notate the use of read just as
     we do any other operation that computes a value.

     print, on the other hand, differs from the operations we have
     been using in a fundamental way: It does not produce an output
     value to be stored in a register. Though it has an effect, this
     effect is not on a part of the machine we are designing. We will
     refer to this kind of operation as an _action_. We will represent
     an action in a data-path diagram just as we represent an
     operation that computes a value -- as a trapezoid that contains
     the name of the action. Arrows point to the action box from any
     inputs (registers or constants). We also associate a button with
     the action. Pushing the button makes the action happen. To make a
     controller push an action button we will use a new kind of
     instruction called perform. Thus, the action of printing the
     contents of register a is represented in a controller sequence by
     the instruction

     #+BEGIN_SRC scheme
     (perform (op print) (reg a))
     #+END_SRC

     Figure 5.4 shows the data paths and controller for the new GCD
     machine. Instead of having a machine stop after printing the
     answer, we have made it start over, so that it repeatedly reads a
     pair of numbers, computes their GCD, and prints the result. This
     structure is like the driver loops we used in the interpreters of
     Chapter 4.

     #+BEGIN_SRC scheme
     (controller
      gcd-loop
      (assign a (op read))
      (assign b (op read))
      test-b
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t
              (op rem)
              (reg a)
              (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label test-b))
      gcd-done
      (perform (op print) (reg a))
      (goto (label gcd-loop)))
     #+END_SRC

*** 5.1.2 Abstraction in Machine Design      
    We will often define a machine to include "primitive " operations
    that are actually very complex. For example, in Section 5.4 and
    Section 5.5 we will treat Scheme's environment manipulations as
    primitive. Such abstraction is valuable because it allows us to
    ignore the details of parts of a machine so that we can
    concentrate on other aspects of the design. The fact that we have
    swept a lot of complexity under the rug, however, does not mean
    that a machine design is unrealistic. We can always replace the
    complex "primitives" by simpler primitive operations.

    Consider the GCD machine. The machine has an instruction that
    computes the remainder of the contents of registers a and b and
    assigns the result to register t. If we want to construct the GCD
    machine without using a primitive remainder operation, we must
    specify how to compute remainders in terms of simpler operations,
    such as subtraction. Indeed, we can write a Scheme procedure that
    finds remainders in this way:

    #+BEGIN_SRC scheme
    (define (remainder n d)
     (if (< n d)
         n
         (remainder (- n d) d)))
    #+END_SRC

    We can thus replace the remainder operation in the GCD machine's
    data paths with a subtraction operation and a comparison
    test. Figure 5.5 shows the data paths and controller for the
    elaborated machine. The instruction 

    #+BEGIN_SRC scheme
    (assign t (op rem) (reg a) (reg b))
    #+END_SRC

    in the GCD controller definition is replaced by a sequence of
    instructions that contains a loop, as shown in Figure 5.6.

    - Figure 5.6: Controller instructin sequence for the GCD machine
      in Figure 5.5.

      #+BEGIN_SRC scheme
      (controller test-b
                  (test (op =) (reg b) (const 0))
                  (branch (label gcd-done))
                  (assign t (reg a))
                  rem-loop
                  (test (op <) (reg t) (reg b))
                  (branch (label rem-done))
                  (assign t (op -) (reg t) (reg b))
                  (goto (label rem-loop))
                  rem-done
                  (assign a (reg b))
                  (assign b (reg t))
                  (goto (label test-b))
                  gcd-done)
      #+END_SRC

    - Exercise 5.3: Design a machine to compute square roots using
      Newton's method, as described in Section 1.1.7:

      #+BEGIN_SRC scheme
      (define (sqrt x)
       (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
       (define (improve guess)
        (average guess (/ x guess)))
       (define (sqrt-iter guess)
        (if (good-enough? guess)
             guess
            (sqrt-iter (improve guess))))
       (sqrt-iter 1.0))
      #+END_SRC

      Begin by assuming that good-enough? and improve operations are
      available as primitives. Then show how to expand these in terms
      of arithmetic operations. Describe each version of the sqrt
      machine design by drawing a data-path diagram and writing a
      controller definition in the register-machine language.

      I will first assume good-enough? and improve-guess are
      primitives, so we need a guess register and, I'm assuming, a
      temporary register to hold the improved result before assigning
      it to guess. I'm assuming that if we assign the result of
      improve directly to guess, the machine will get into an
      inconsistent or undesirable state. We can try it with just a
      guess register.

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign t (op improve) (reg g) (reg x))
       (assign g (reg t))
       (test (op good-enough?) (reg g) (reg x))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done) 
      #+END_SRC

      Next, we put improve and good-enough? inline. improve is an
      average of the guess with x divided by the guess. I will inline
      the entire thing.

      Registers: p1, p2, g, x.

      We need extra registers to hold the answers of operations and
      parameters for those operations in improve. Our data paths so
      far have assumed that you can't assign to something that is also
      being used as an operand. The definition of improve is:

      #+BEGIN_SRC scheme
      (define (improve guess x)
       (average guess (/ x guess))
      #+END_SRC

      So I need to do the work of two functions: improve and
      average. I already have a register for guess and x. I need
      another register to hold the result of (/ x guess) -- p1. Then I
      need to compute the average of guess and p1. This is
      accomplished by first adding these two registers and dividing
      them. If I want to add then divide, I need another register to
      hold the result of this operation. Becaues I assume I cannot use
      the register p1 (or g) for an assign operation that it is being used as
      an operand in -- like (assign p1 (op +) (reg g) (reg p1)) -- I
      need another register, p2. That way I can write (assign p2 (op
      +) (reg g) (reg p1)). Now p2 holds the sum of guess and (/x
      guess), so I need to divide it by 2. Since I don't need g
      anymore, I can use g directly to hold the result of dividing the sum
      by the constant 2, which is then the result.


      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (test (op good-enough?) (reg g) (reg x))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC

      Now, with no outside procedures (except abs, *, <, -, +, /), I have
      a new guess in g and don't need p1 and p2. I need to see if g is
      good. To do this, I first need to square guess. I assume that we
      can use a register parameter twice (not assign to it though),
      and assign p1, which is newly free, (* g g). Then, I subtract
      that result from x and assign the result to p2. Finally, I
      assign p1 the result of (abs p2), which holds the result of (-
      (* g g) x). Now p2 holds the number representing how close we
      are to the actual square root. All I need to do now is test
      whether it's < 0.001, by using a test instruction. The rest of
      the code is the same. 

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (assign p1 (op *) (reg g) (reg g))
       (assign p2 (op -) (reg p1) (reg x))
       (assign p1 (op abs) (reg p2))
       (test (op <) (reg p1) (const 0.001))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC   

      Next, we remove abs by adding a branch.

      #+BEGIN_SRC scheme
      (controller
       newtons-method
       (assign g (reg x))
       newtons-method-loop
       (assign p1 (op /) (reg x) (reg g))
       (assign p2 (op +) (reg p1) (reg g))
       (assign g (op /) (reg p2) (const 2))
       (assign p1 (op *) (reg g) (reg g))
       (assign p2 (op -) (reg p1) (reg x))
       abs
       (test (op >) (reg p2) (const 0))
       (branch (label abs-greater-than0))
       (assign p1 (op -) (const 0) (reg p2))
       (goto (label done-with-abs))
       abs-greater-than0
       (assign p1 (reg p2))
       done-with-abs
       (test (op <) (reg p1) (const 0.001))
       (branch (label newtons-method-done))
       (goto (label newtons-method-loop))
       newtons-method-done)
      #+END_SRC

*** 5.1.3 Subroutines
    
    When designing a machine to perform a computation, we would often
    prefer to arrange for components to be shared by different parts
    of the computation rather than duplicate the components. Consider
    a machine that includes two GCD computations -- one that finds the
    GCD of the contents of registers a and b and one that finds the
    GCD of the contents of registers c and d. We might start by
    assuming we have a primitive gcd operation, then expand the two
    instances of gcd in terms of more primitive operations. Figure 5.7
    shows just the GCD portions of the resulting machine's dat paths,
    without showing how they connect to the rest of the machine. The
    figure also shows the corresponding portions of the machine's
    controller sequence.

    This machine has two remainder operation boxes and two boxes for
    testing equality. If the duplicated components are complicated, as
    is the remainder box, this will not be an economical way to build
    the machine. We can avoid duplicating the data-path components by
    using the same components for both GCD computations, provided that
    doing so will not affect the rest of the larger machine's
    computation. If the values in registers a and b are not needed by
    the time the controller gets to gcd-2 (or if these values can be
    moved to other registers for safekeeping), we can change the
    machine so that it uses registers a and b, rather than registers c
    and d, in computing the second GCD as well as the first. If we do
    this, we obtain the controller sequence shown in Figure 5.8.

    - Figure 5.8: Portions of the controller sequence for a machine
      that uses the same data-path components for two different GCD
      computations.

      #+BEGIN_SRC scheme
      gcd-1 
      (test (op =) (reg b) (const 0))
      (branch (label after-gcd-1))
      (assign t (op rem))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd-1))
      after-gcd-1
      ...
      gcd-2
      (test (op =) (reg b) (const 0))
      (branch (label after-gcd-2))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd-2))
      after-gcd-2
      #+END_SRC

      
    We have removed the duplicated data-path components (so that the
    data paths are again as in Figure 5.1), but the controller now has
    two GCD sequences that differ only in their entry-point labels. It
    would be better to replace these two sequences by branches to a
    single sequence -- a gcd _subroutine_ -- at the end of which we
    branch back to the correct place in the main instruction
    sequence. We can accomplish this as follows: Before branching to
    gcd, we place a distinguishing value (such as 0 or 1) into a
    special register, continue. At the end of the gcd subroutine we return
    either after-gcd-1 or after-gcd-2, depending on the value of the
    continue register. Figure 5.9 shows the relevant portion of the
    resulting controller sequence, which includes only a single copy
    of the gcd instructions.

    - Figure 5.9: Using a continue register to avoid the duplicate
      controller sequence in Figure 5.8

      #+BEGIN_SRC scheme
      gcd
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assing b (reg t))
      (goto (label gcd))
      gcd-done
      (test (op =) (reg continue) (const 0))
      (branch (label after-gcd-1))
      (goto (label after-gcd-2))
      ...
      ;; Before branching to gcd from the first place where
      ;; it is needed, we place 0 in the continue register.
      (assign continue (const 0))
      (goto (label gcd))
      after-gcd-1
      ...
      ;; Before the second use of gcd, we place 1 in the 
      ;; continue register.
      (assign continue (const 1))
      (goto (label gcd))
      after-gcd-2
      #+END_SRC

      
    This is a reasonable approach for handling small problems, but it
    would be awkward if there were many instances of GCD computations
    in the controller sequence. To decide where to continue executing
    after the gcd subroutine, we would need tests in the data paths
    and branch instructions in the controller for all the places that
    use gcd. A more powerful method for implementing subroutines is to
    have the continue register hold the label of the entry point in
    the controller sequence at which execution should continue when
    the subroutine is finished. Implementing this strategy requires a
    new kind of connection between the data paths and the controller
    of a register machine: There must be a way to assign a register a
    label in the controller sequence in such a way that this value can
    be fetched from the register and used to continue execution at the
    designated entry point.

    To reflect this ability, we will extend the assign instruction of
    the register-machine language to allow a register to be assigned
    as value a label from the controller sequence (as a special kind
    of constant). We will also extend the goto instruction to allow
    execution to continue at the entry point described by the contents
    of a register rather than only at the entry point described by a
    constant label. Using these new constructs we can terminate the
    gcd subroutine with a branch to the location stored in the
    continue register. This leads to the controller sequence shown in
    Figure 5.10.

    - Figure 5.10: Assigning labels to the continue register
      simplifies and generalizes the strategy shown in Figure 5.9.

      #+BEGIN_SRC scheme
      gcd
      (test (op =) (reg b) (const 0))
      (branch (label gcd-done))
      (assign t (op rem) (reg a) (reg b))
      (assign a (reg b))
      (assign b (reg t))
      (goto (label gcd))
      gcd-done
      (goto (reg continue))

       ...
      ;; Before calling gcd, we assign to continue
      ;; the label to which gcd should return.
      (assign continue (label after-gcd-1))
      (goto (label gcd))
      after-gcd-1
      ...
      ;; Here is the second call to gcd,
      ;; with a different continuation.
      (assign continue (label after-gcd-2))
      (goto (label gcd))
      after-gcd-2
      #+END_SRC

      A machine with more than one subroutine could use multiple
      continuation registers (e.g., gcd-continue, factorial-continue)
      or we could have all subroutines share a single continue
      register. Sharing is more economical, but we must be careful if
      we have a subroutine (sub1) that calls another subroutine
      (sub2). Unless sub1 saves the contents of continue in some other
      register before setting up continue for the call to sub2, sub1
      will not know where to go when it is finished. The mechanism
      developed in the next section to handle recursion also provides
      a better solution to this problem of nested subroutine calls.

*** 5.1.4. Using a Stack to Implement Recursion      

    With the ideas illustrated so far, we can implement any iterative
    process by specifying a register machine that has a register
    corresponding to each state variable of the process. The machine
    repeatedly executes a controller loop, changing the contents of
    the registers, until some termination condition is satisfied. At
    each point in the controller sequence, the state of the machine
    (representing the state of the iterative process) is completely
    determined by the contents of the registers (the values of the
    state variables). 

    Implementing recursive processes, however, requires an additional
    mechanism. Consider the following recursive method for computing
    factorials, which we first examined in Section 1.2.1:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1)) n)))
    #+END_SRC

    As we see from the procedure, computing n! requires computing
    (n-1)!. Our GCD machine, modeled on the procedure

    #+BEGIN_SRC scheme
    (define (gcd a b)
     (if (= b 0) a (gcd b (remainder a b))))
    #+END_SRC

    similarly had to compute another GCD. But there is an important
    difference between the gcd procedure, which reduces the original
    computation to a new GCD computation, and factorial, which
    requires computing another factorial as a subproblem. In GCD, the
    answer to the new GCD computation is the answer to the original
    problem. To compute the next GCD, we simply place the new
    arguments in the input registers of the GCD machine and reuse the
    machine's data paths by executing the same controller
    sequence. When the machine is finished solving the final GCD
    problem, it has completed the entire computation. 

    In the case of factorial (or any recursive process) the answer to
    the new factorial subproblem is not the answer to the original
    problem. The value obtained for (n-1)! must be multiplied by n to
    get the final answer. If we try to imitate the GCD design, and
    solve the factorial subproblem by decrementing the n register and
    rerunning the factorial machine, we will no longer have available
    the old value of n by which to multiply the result. We thus need a
    second factorial machine to work on the subproblem. This second
    factorial computation itself has a factorial subproblem, which
    requires a third factorial machine, and so on. Since each
    factorial machine contains another factorial machine within it,
    the total machine contains an infinite nest of similar machines
    and hence cannot be constructed from a fixed, finite number of
    parts.

    Nevertheless, we can implement the factorial process as a register
    machine if we can arrange to use the same components for each
    nested instance of the machine. Specifically, the machine that
    computes n! should use the same components to work on the
    subproblem of computing (n-1)!, on the subproblem for (n-2)!, and
    so on. This is plausible because, although the factorial process
    dictates that an unbounded number of copies of the same machine
    are needed to perform a computation, only one of these copies
    needs to be active at any given time. When the machine encounters
    a recursive subproblem, it can suspend work on the main problem,
    reuse the same physical parts to work on the subproblem, then
    continue the suspended computation. 

    In the subproblem, the contents of the registers will be different
    than they were in the main problem. (In this case the n register
    is decremented.) In order to be able to continue the suspended
    computation, the machine must save the contents of any registers
    that will be needed after the subproblem is solved so that these
    can be restored to continue the suspended computation. In the case
    of factorial, we will save the old value of n, to be restored when
    we are finishing computing the factorial of the decremented n
    register.

    Since there is no _a priori_ limit on the depth of nested
    recursive calls, we may need to save an arbitrary number of
    register values. These values must be restored in the reverse
    order in which they were saved, since in a test of recursions the
    last subproblem to be entered is the first to be finished. This
    dictates the use of a _stack_, or "last in, first out" data
    structure, to save register values. We can extend the
    register-machine language to include a stack by adding two kinds
    of instructions: Values are placed on the stack using a save
    instruction and restored from the stack using a restore
    instruction. After a sequence of values has been saved on the
    stack, a sequence of restores will retrieve these values in
    reverse order.

    With the aid of the stack, we can reuse a single copy of the
    factorial machine's data paths for each factorial
    subproblem. There is a similar design issue in reusing the
    controller sequence that operates the data paths. To reexecute the
    factorial computation, the controller cannot simply loop back to
    the beginning, as with an iterative process, because after solving
    the (n - 1)! subproblem the machine must still multiply the result
    by n. THe controller must suspend its computation of n!, solve the
    (n-1)! subproblem, then continue its computation of n!. This view
    of the factorial computation suggests the use of the subroutine
    mechanism described in Section 5.1.3, which has the controller use
    a continue register to transfer to the part of the sequence that
    solves a subproblem and then continue where it left off on the
    main problem. We can thus make a factorial subroutine that returns
    to the entry point stored in the continue register. Around each
    subroutine call, we save and restore continue just as we do the n
    register, since each "level" of the factorial computation will use
    the same continue register. That is, the factorial subroutine must
    put a new value in continue when it calls itself for a subproblem,
    but it will need the old value in order to return to the place
    that called it to solve a subproblem. 

    Figure 5.11 shows the data paths and controller for a machine that
    implements the recursive factorial procedure. The machine has a
    stack and three registers, called n, val, and continue. To
    simplify the data-path diagram, we have not named the
    register-assignment buttons, only the stack-operation buttons (sc
    and sn to save registers, rc and rn to restore registers). To
    operate the machine, we put in register n the number whose
    factorial we wish to compute and start the machine. When the
    machine reaches fact-done, the computation is finished and the
    answer will be found in the val register. In the controller
    sequence, n and continue are saved before each recursive call and
    restored upon return from the call. Returning from a call is
    accomplished by branching to the location stored in
    continue. continue is initialized when the machine starts so that
    the last return will go to fact-done. The val register, which
    holds the result of the factorial computation, is not saved before
    the recursive call, because the old contents of val is not useful
    after the subroutine returns. Only the new value, which is the
    value produced by the subcomputation, is needed.

    Although in principle the factorial computation requires an
    infinite machine, the machine in Figure 5.11 is actually finite
    except for the stack, which is potentially unbounded. Any
    particular physical implementation of a stack, however, will be of
    finite size, and this will limit the depth of recursive calls that
    can be handled by the machine. This implementation of factorial
    illustrates the general strategy for realizing recursive
    algorithms as ordinary register machines augmented by
    stacks. When a recursive subproblem is encountered, we save on the
    stack the registers whose current values will be required after
    the subproblem is solved, solve the recursive subproblem, then
    restore the saved registers and continue execution on the main
    problem. The continue register must always be saved. Whether there
    are other registers that need to be saved depends on the
    particular machine, since not all recursive computations need the
    original values of registers that are modified during solution of
    the subproblem. 

    - Figure 5.11: A recursive factorial machine.

      #+BEGIN_SRC scheme
      (controller
       (assign continue (label fact-done))
       fact-loop
       (test (op =) (reg n) (const 1))
       (branch (label base-case))
       ;; Set up for the recursive call by saving n and continue.
       ;; Set up continue so that the computation will continue
       ;; at after-fact when the subroutine returns.
       (save continue)
       (save n)
       (assign n (op -) (reg n) (const 1))
       (assign continue (label after-fact))
       (goto (label fact-loop))
       after-fact
       (restore n)
       (restore continue)
       (assign val (op *) (reg n) (reg val))
       (goto (reg continue))
       base-case
       (assign val (const 1))
       (goto (reg continue))
       fact-done)
      #+END_SRC

      
**** A double recursion    

     Let us examine a more complex recursive process, the
     tree-recursive computaiton of the Fibonacci numbers, which we
     introduced in Section 1.2.2:

     #+BEGIN_SRC scheme
     (define (fib n)
      (if (< n 2)
          n
          (+ (fib (- n 1)) (fib (- n 2)))))
     #+END_SRC

     Just as with factorial, we can implement the recursive Fibonacci
     computation as a register machine with registers n, val, and
     continue. The machine is more complex than the one for factorial,
     because there are two places in the controller sequence where we
     need to perform recursive calls -- once to compute Fib(n-1) and
     once to compute Fib(n-2). To set up for each of these calls, we
     save the registers whose values will be needed later, set the n
     register to the number whose Fib we need to compute recursively
     (n - 1 or n -2), and assign to continue the entry point in the
     main sequence to which to return (afterfib-n-1 or afterfib-n-2,
     respectively). We then go to fib-loop. When we return from the
     recursive call, the answer is in val. Figure 5.12 shows the
     controller sequence for this  machine.


     - Figure 5.12: Controller for a machine to compute Fibonacci
       numbers.

       #+BEGIN_SRC scheme
       (controller
        (assign continue (label fib-done))
        fib-loop
        (test (op <) (reg n) (const 2))
        (branch (label immediate-answer))
        ;; set up to compute Fib(n-1)
        (save continue)
        (assign continue (label afterfib-n-1))
        (save n)
        (assign n (op -) (reg n) (const 1))
        (goto (label fib-loop))
	afterfib-n-1
        (restore n)
        (restore continue)
        ;; set up to compute Fib(n-2)
	(assign n (op -) (reg n) (const 2))
        (save continue)
        (assign continue (label afterfib-n-2))
        (save val)
        (goto (label fib-loop))
        afterfib-n-2
        (assign n (reg val))
        (restore val)
        (restore continue)
        (assign val (op +) (reg val) (reg n))
        (goto (reg continue))
        immediate-answer
        (assign val (reg n))
        (goto (reg continue))
        fib-done)
       #+END_SRC

       - Exercise 5.4: Specify register machines that implement each
         of the following procedures. For each machine, write a
         controller instruction sequence and draw a diagram showing
         the data paths.

	 a. Recursive exponentiation:
	 #+BEGIN_SRC scheme
         (define (expt b n)
          (if (= n 0)
              1
              (* b (expt b (- n 1)))))
	 #+END_SRC

	 I will initially need a b, n, and val register. I 
	 #+BEGIN_SRC scheme
         (controller
          (assign continue (label end-expt))
          expt-loop
          (test (op =) (reg n) (const 0))
          (branch (label base-case))
          (save continue)
          (assign continue (label expt-loop-done))
          (assign n (op -) (reg n) (const 1))
          (goto (label expt-loop))
          expt-loop-done
          (restore continue)
          (assign val (op *) (reg val) (reg b))
          (goto (reg continue))
          base-case
          (assign val (const 1))
          (goto (reg continue))
          end-expt)
	 #+END_SRC

	 b. Iterative exponentiation:
	 #+BEGIN_SRC scheme
	 (define (expt b n)
          (define (expt-iter counter product)
           (if (= counter 0)
               product
               (expt-iter (- counter 1)
                          (* b product))))
          (expt-iter n 1))
	 #+END_SRC

	 #+BEGIN_SRC scheme
         (controller
          (assign p (const 1)) ;; set product to 1.
          (assign c (reg n))   ;; set counter to n.
          expt-iter
          (test (op =) (reg c) (const 0)) ;; if counter is 0, exit.
          (branch (label expt-done))
          (assign p (op *) (reg b) (reg p)) ;; otherwise, multiply b and p.
          (assign c (op -) (reg c) (const 1))
          (goto (label expt-iter))
          expt-done)
	 #+END_SRC

       - Exercise 5.5: Hand-simulate the factorial and Fibonacci
         machines, using some nontrivial input (require execution of
         at least one recursive call). Show the contents of the stack
         at each significant point in the execution.

       - Exercise 5.6: Ben Bitdiddle observes that the Fibonacci
         machine's controller sequence has an extra save and an extra
         restore, which can be removed to make a faster. Where are
         these instructions?

         #+BEGIN_SRC scheme
	   (controller
	    (assign continue (label fib-done))
	    fib-loop
	    (test (op <) (reg n) (const 2))
	    (branch (label immediate-answer))
	    ;; set up to compute Fib(n-1)
	    (save continue)
	    (assign continue (label afterfib-n-1))
	    (save n)
	    (assign n (op -) (reg n) (const 1))
	    (goto (label fib-loop))
	    afterfib-n-1
	    (restore n)
	    ;; The lines marked 'redundant:' were unnecessary.
	    ;; redundant: (restore continue)
	    ;; set up to compute Fib(n-2)
	    (assign n (op -) (reg n) (const 2))
	    ;; redundant: (save continue)
	    (assign continue (label afterfib-n-2))
	    (save val)
	    (goto (label fib-loop))
	    afterfib-n-2
	    (assign n (reg val))
	    (restore val)
	    (restore continue)
	    (assign val (op +) (reg val) (reg n))
	    (goto (reg continue))
	    immediate-answer
	    (assign val (reg n))
	    (goto (reg continue))
	    fib-done)
       #+END_SRC	 

*** 5.1.5 Instruction Summary	 
    A controller instruction in our register-machine language has one
    of the following forms, where each <input_i> is either (reg
    <register-name>) or (const <constant-value>). These instructions
    were introduced in Section 5.1.1:

    #+BEGIN_SRC scheme
    (assign <register-name>  (reg <register-name>))
    (assign <register-name> (const <constant-value>))
    (assign <register-name>
            (op <operation-name>)
            <input1> ... <inputn>)
    (perform (op <operation-name>) <input1> ... <inputn>)
    (test (op <operation-name>) <input1> ... <inputn>)
    (branch (label <label-name>))
    (goto (label <label-name>))
    #+END_SRC

    The use of registers to hold labels was introduced in Section
    5.1.3:

    #+BEGIN_SRC scheme
    (assign <register-name> (label <label-name>))
    (goto (reg <register-name>))
    #+END_SRC

    Instructions to use the stack were introduced in Section 5.1.4:

    #+BEGIN_SRC scheme
    (save <register-name>)
    (restore <register-name>)
    #+END_SRC

    The only kind of <constant-value> we have seen so far is a number,
    but later we will use strings, symbols, and lists. For example,

    #+BEGIN_SRC scheme
    (const "abc") is the string "abc",
    (const abc) is the symbol abc,
    (const (a b c)) is the list (a b c),
    and (const ()) is the empty list.
    #+END_SRC

** 5.2 A Register-Machine Simulator
   In order to gain a good understanding of the design of register
   machines, we must test the machines we design to see if they
   perform as expected. One way to test a design is to hand-simulate
   the operation of the controller, as in Exercise 5.5. But this is
   extremely tedious for all but the simplest machines. In this
   section we construct a simulator for machines described in the
   register-machine language. The simulator is a Scheme program with
   four interface procedures. The first uses a description of a
   register machine to construct a model of the machine (a data
   structure whose parts correspond to the parts of the machine to be
   simulated), and the other three allow us to simulate the machine by
   manipulating the model:

- Specification   
    #+BEGIN_SRC scheme
    (make-machine <register-names> <operations> <controller>)
    #+END_SRC

    constructs and returns a model of the machine with the given
    registers, operations, and controller.

    #+BEGIN_SRC scheme
    (set-register-contents! <machine-model>
                            <register-name>
                            <value>)
    #+END_SRC

    stores a value in a simulated register in the given machine.

    #+BEGIN_SRC scheme
    (get-register-contents <machine-model> <register-name>)
    #+END_SRC

    returns the contents of a simulated register in the given machine.

    #+BEGIN_SRC scheme
    (start <machine-model>)
    #+END_SRC

    simulates the execution of the given machine, starting from the
    beginning of the controller sequence and stopping when it reaches
    the end of the sequence.

   As an example of how these procedures are used, we can define
   gcd-machine to be a model of the GCD machine of Section 5.1.1 as
   follows:

   #+BEGIN_SRC scheme
     (define gcd-machine
       (make-machine
	'(a b t)
	(list (list 'rem remainder) (list '= =))
	'(test-b (test (op =) (reg b) (const 0))
		 (branch (label gcd-done))
		 (assign t (op rem) (reg a) (reg b))
		 (assign a (reg b))
		 (assign b (reg t))
		 (goto (label test-b))
		 gcd-done)))
   #+END_SRC


   The first argument to make-machine is a list of register names. The
   next argument is a table (a list of two-element lists) that pairs
   each operation name with a Scheme procedure that implements the
   operation (that is, produces the same output value given the same
   input values). The last argument specifies the controller as a list
   of labels and machine instructions, as in Section 5.1.

   To compute GCDs with this machine, we set the input registers,
   start the machine, and examine the result when the simulation
   terminates:

   #+BEGIN_SRC scheme
   (set-register-contents! gcd-machine 'a 206)
   ;; => done
   (set-register-contents! gcd-machine 'b 40)
   ;; => done
   (start gcd-machine)
   ;; => done
   (get-register-contents gcd-machine 'a)
   ;; => 2
   #+END_SRC

   This computation will run much more slowly than a gcd procedure
   written in Scheme, becase we will simulate low-level machine
   instructions, such as assign, by much more complex operations.

   - Exercise 5.7: Use the simulator to test the machines you designed
     in Exercise 5.4.

*** 5.2.1 The Machine Model     
    The machine model generated by make-machine is represented as a
    procedure with local state using the message-passing techniques
    developed in Chapter 3. To build this model, make-machine begins
    by calling the procedure make-new-machine to construct the parts
    of the machine model that are common to all register
    machines. This basic machine model constructed by make-new-machine
    is essentially a container for some registers and a stack,
    together with an execution mechanism that processes controller
    instructions one by one. 

    make-mahine then extends this basic model (by sending it messages)
    to include the registers, operations, and controller of the
    particular machine being defined. First it allocates a register in
    the new machine for each of the supplied register names and
    installs the designated operations in the machine. Then it uses an
    _assembler_ (described below in Section 5.2.2) to transform the
    controller list into instructions for the new machine and installs
    these as the machine's instruction sequence. make-machine returns
    as its value the modified machine model.

    #+BEGIN_SRC scheme
    (define (make-machine register-names ops controller-text)
     (let ((machine (make-new-machine)))
      (for-each (lambda (register-name)
                 ((machine 'allocate-register) register-name))
       register-names)
      ((machine 'install-operations) ops)
      ((machine 'install-instruction-sequence)
       (assemble controller-text machine))
      machine))
    #+END_SRC

**** Registers    
     We will represent a register as a procedure with local state, as
     in Chapter 3. The procedure make-register creates a register that
     holds a value that can be accessed or changed:

     #+BEGIN_SRC scheme
     (define (make-register name)
      (let ((contents '*unassigned*))
       (define (dispatch message)
        (cond ((eq? message 'get) contents)
              ((eq? message 'set)
               (lambda (value) (set! contents value)))
              (else
               (error "Unknown request: REGISTER" message))))
       dispatch))
     #+END_SRC

     The following procedures are used to access registers:

     #+BEGIN_SRC scheme
     (define (get-contents register) (register 'get))
     (define (set-contents! register value) ((register 'set) value))
     #+END_SRC

**** The stack     
     We can also represent a stack as a procedure with local
     state. The procedure make-stack creates a stack whose local state
     consists of a list of the items on the stack. A stack accepts
     requests to push an item onto the stack, to pop the top item off
     the stack and return it, and to initialize the stack to empty.

     #+BEGIN_SRC scheme
     (define (make-stack)
      (let ((s '()))
       (define (push x) (set! s (cons x s)))
       (define (pop)
        (if (null? s)
            (error "Empty stack: POP")
            (let ((top (car s)))
             (set! s (cdr s))
             top)))
       (define (initialize)
        (set! s '())
        'done)
       (define (dispatch message)
        (cond ((eq? message 'push) push)
              ((eq? message 'pop) (pop))
              ((eq? message 'initialize) (initialize))
              (else (error "Unknown request: STACK" message))))
       dispatch))
     #+END_SRC

     The following procedures are used to access stacks:

     #+BEGIN_SRC scheme
     (define (pop stack) (stack 'pop))
     (define (push stack value) ((stack 'push) value))
     #+END_SRC

**** The basic machine     
     
     The make-new-machine procedure, shown in Figure 5.13, constructs
     an object whose local state consists of a stack, an initially
     empty instruction sequence, a list of operations that initially
     contains an operation to initialize the stack, and a _register
     table_ that initially contains two registers, named flag and pc
     (for "program counter"). The internal procedure allocate-register
     adds new entries to the register table, and the internal
     procedure lookup-register looks up registers in the table.

     The flag register is used to control branching in the simulated
     machine. test instructions set the contents of flag to the result
     of the test (true or false). branch instructions decide whether
     or not to branch by examining the contents of flag.

     The pc register determines the sequencing of instructions as the
     machine runs. This sequencing is implemented by the internal
     procedure execute. In the simulation model, each machine
     instruction is a data structure that includes a procedure of no
     arguments, called the _instruction execution procedure_, such
     that calling this procedure simulates executing the
     instruction. As the simulation runs, pc points to the place in
     the instruction sequence beginning with the next instruction to
     be executed. execute gets that instruction, executes it by
     calling the instruction execution procedure, and repeats this
     cycle until there are no more instructions to execute (i.e.,
     until pc points to the end of the instruction sequence). 

     - Figure 5.13: The make-new-machine procedure, which implements
       the basic machine model.

       #+BEGIN_SRC scheme
	 (define (make-new-machine)
	  (let ((pc (make-register 'pc))
		(flag (make-register 'flag))
		(stack (make-stack))
		(the-instruction-sequence '()))
	   (let ((the-ops
		  (list (list 'initialize-stack
			      (lambda () (stack 'initialize)))))
		 (register-table
		  (list (list 'pc pc) (list 'flag flag))))
	    (define (allocate-register name)
	     (if (assoc name register-table)
		 (error "Multiply defined register: " name)
		 (set! register-table
		       (cons (list name (make-register name))
			      register-table)))
	     'register-allocated)
	    (define (lookup-register name)
	     (let ((val (assoc name register-table)))
	      (if val
		  (cadr val)
		  (error "Unknown register:" name))))
	    (define (execute)
	     (let ((insts (get-contents pc)))
	      (if (null? insts)
		  'done
		  (begin
		   ((instruction-execution-proc (car insts)))
		   (execute)))))
	    (define (dispatch message)
	     (cond ((eq? message 'start)
		    (set-contents! pc the-instruction-sequence)
		    (execute))
		   ((eq? message 'install-instruction-sequence)
		    (lambda (seq)
		     (set! the-instruction-sequence seq)))
		   ((eq? message 'allocate-register)
		    allocate-register)
		   ((eq? message 'get-register)
		    lookup-register)
		   ((eq? message 'install-operations)
		    (lambda (ops)
		      (set! the-ops (append the-ops ops))))
		   ((eq? message 'stack) stack)
		   ((eq? message 'operations) the-ops)
		   (else (error "Unknown request: MACHINE"
				message))))
	    dispatch)))
       #+END_SRC

       As part of its operation, each instruction execution procedure
       modifies pc to indicate the next instruction to be
       executed. branch and goto instructions change pc to point to
       the new destination. All other instructions simply advance pc,
       making it point to the next instruction in the
       sequence. Observe that each call to execute calls execute
       again, but this does not produce an infinite loop because
       running the instruction execution procedure changes the
       contents of pc.

       make-new-machine returns a dispatch procedure that implements
       message-passing access to the internal state. Notice that
       starting the machine is accomplished by setting pc to the
       beginning of the instruction sequence and calling execute.

       For convenience, we provide an alternate procedural interface
       to a machine's start operation, as well as procedures to set
       and examine register contents, as specified at the beginning of
       Section 5.2:

       #+BEGIN_SRC scheme
       (define (start machine) (machine 'start))
       (define (get-register-contents machine register-name)
        (get-contents (get-register machine register-name)))
       (define (set-register-contents! machine register-name value)
        (set-contents! (get-register machine register-name)
                       value)
        'done)
       #+END_SRC

       These procedures (and many procedures in Section 5.2.2 and
       Section 5.2.3) use the following to look up the register with a
       given name in a given machine:

       #+BEGIN_SRC scheme
       (define (get-register machine reg-name)
        ((machine 'get-register) reg-name))
       #+END_SRC

*** 5.2.2 The Assembler       

    The assembler transforms the sequence of controller expressions
    for a machine into a corresponding list of machine instructions,
    each with its execution procedure. Overall, the assembler is much
    like the evaluators we studied in Chapter 4 -- there is an input
    language (in this case, the register-machine language) and we must
    perform an appropriate action for each type of expression in the
    language.

    The technique of producing an execution procedure for each
    instruction is just what we used in Section 4.1.7 to speed up the
    evaluator by separating analysis from runtme exection. As we saw
    in Chapter 4, much useful analysis of Scheme expressions could be
    performed without knowing the actual values of variables. Here,
    analogously, much useful analysis of register-machine-language
    expressions can be performed without knowing the actual contents
    of machine registers. For example, we can replace references to
    registers by pointers to the register objects, and we can replace
    references to labels by pointers to the place in the instruction
    sequence that the label designates. 

    Before it can generate the instruction execution procedures, the
    assembler must know what all the labels refer to, so it begins by
    scanning the controller text to separate the labels from the
    instructions. As it scans the text, it constructs both a list of
    instructions and a table that associates each label with a pointer
    into that list. Then the assembler augments the instruction list
    by inserting the execution procedure for each instruction.

    The assemble procedure is the main entry to the assembler. it
    takes the controller text and the machine model as arguments and
    returns the instruction sequence to be stored in the
    model. assemble calls extract-labels to build the initial
    instruction list and label table from the supplied controller
    text. The second argument to extract-labels is a procedure to be
    called to process these results: This procedure uses update-insts!
    to generate the instruction execution procedures and insert them
    into the instruction list, and returns the modified list.

    #+BEGIN_SRC scheme
    (define (assemble controller-text machine)
     (extract-labels
      controller-text
      (lambda (insts labels)
       (update-insts! insts labels machine)
       insts)))
    #+END_SRC

    extract-labels takes as arguments a list text (the sequence of
    controller instruction expressions) and a receive
    procedure. receive will be called with two values: (1) a list of
    insts of instruction data structures, each containing an
    instruction from text; and (2) a table called labels, which
    associates each label from text with the position in the list
    insts that the label designates.

    #+BEGIN_SRC scheme
      (define (extract-labels text receive)
       (if (null? text)
	   (receive '() '())
	   (extract-labels
	    (cdr text)
	    (lambda (insts labels)
	      (let ((next-inst (car text)))
		(if (symbol? next-inst)
		    (receive
			insts
			(cons (make-label-entry next-inst
						insts)
			      labels))
		    (receive
			(cons
			 (make-instruction next-inst)
			 insts)
			labels)))))))
    #+END_SRC

    extract-labels works by sequentially scanning the elements of the
    text and accumulating the insts and the labels. If an element is a
    symbol (and thus a label) an appropriate entry is added to the
    labels table. Otherwise the element is accumulated onto the insts
    list. 

    update-insts! modifies the instruction list, which initially
    contains only the text of the instructions, to include the
    corresponding execution procedures:

    #+BEGIN_SRC scheme
    (define (update-insts! insts labels machine)
     (let ((pc (get-register machine 'pc))
           (flag (get-register machine 'flag))
           (stack (machine 'stack))
           (ops (machine 'operations)))
       (for-each
        (lambda (inst)
         (set-instruction-execution-proc!
          inst
          (make-execution-procedure
           (instruction-text inst)
           labels machine pc flag stack ops)))
         insts)))
    #+END_SRC

    The machine instruction data structure simply pairs the
    instruction text with the corresponding execution procedure. The
    execution procedure is not yet available wihen extract-labels
    constructs the instruction, and is inserted later by
    update-insts!.

    #+BEGIN_SRC scheme
    #+END_SRC
     
   
   

    

    

	 


