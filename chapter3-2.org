**** blah
     - Exercise 3.51 In order to take a closer look at delayed
       evaluation, we will use the following procedure, which simply
       returns its argument after printing it:

       #+BEGIN_SRC scheme
       (define (show x)
        (display-line x)
        x)
       #+END_SRC

       What does the interpreter print in response to evaluating each
       expression in the following sequence?

       #+BEGIN_SRC scheme
       (define (stream-ref s n)
        (if (= n 0) (stream-car s) (stream-ref (stream-cdr s) (- n 1))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-map fun s)
        (if (empty-stream? s)
            the-empty-stream
            (stream-cons (fun (stream-car s))
                         (stream-map fun (stream-cdr s)))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define x
               (stream-map show
                           (stream-enumerate-interval 0 10)))
       (stream-ref x 5)
       (stream-ref x 7)
       #+END_SRC

       first statement:
       #+BEGIN_SRC scheme
       0
       #+END_SRC

       second statement:
       #+BEGIN_SRC scheme
       1
       2
       3
       4
       5
       #+END_SRC

       third statement:
       #+BEGIN_SRC scheme
       6
       7
       #+END_SRC

     - Exercise 3.52: Consider the sequence of expressions

       #+BEGIN_SRC scheme
       (define sum 0)
       (define (accum x) (set! sum (+ x sum)) sum)
       (define seq
               (stream-map accum
                           (stream-enumerate-interval 1 20)))
       (define y (stream-filter even? seq))
       (define z
               (stream-filter (lambda (x) (= (remainder x 5) 0))
                              seq))
       (stream-ref y 7)
       (display-stream z)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-filter pred seq)
        (if (stream-empty? seq) 
            the-empty-stream
            (if (pred (stream-car seq))
                (cons-stream (stream-car seq)
                             (stream-filter pred (stream-cdr stream)))
                (stream-filter pred (stream-cdr stream)))))
       #+END_SRC

       The basic sequence is:
       1 3 6 10 15 21 28 36 45 55  66  78  91  105 120 136 153 171 190 
       1 2 3 4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19 
       What is the value of sum after each of the above expressions is
       evaluated? What is the printed response to evaluating the
       stream-ref and display-stream expressions? Would these
       responses differ if we had implemented (delay <exp>) simply as
       (lambda () <exp>) without using the optimization provided by
       memo-proc? Explain.

       After defining seq: 1
       After defining y: 6
       After defining z: 10
       After evaluating (stream-ref y 7): 136
       After evaluating (display-stream z): 190

       The value would have been different, because we would have had
       to re-calculate the sequence values every time we re-iterated
       the sequence, which would have involved calling accum since we
       use stream-map. Accum would have then added values to sum every
       time, so each time we evaluated we would get larger values.
       
*** 3.5.2 Infinite streams

    We have seen how to support the illusion of manipulating streams
    as complete entities even though, in actuality, we compute only as
    much of the streams as we need to access. We can exploit this
    technique to represent sequences efficiently as streams, even if
    the sequences are very long. What is more striking, we can use
    streams to represent sequences that are infinitely long. For
    instance, consider the following definition of the stream of
    positive integers:

    #+BEGIN_SRC scheme
    (define (integers-starting-from n)
     (cons-stream n (integers-starting-from (+ n 1))))
    (define integers (integers-starting-from 1))
    #+END_SRC

    This makes sense because integers will be a pair whose car is 1
    and whose cdr is a promise to produce the integers beginning
    with 2. This is an infinitely long tream, but in any given time we
    can examine only a finite protion of it. Thus, our programs will
    never know that the entire infinite stream is not there.

    Using integers we can define other infinite streams, such as the
    stream of integers that are not divisible by 7:

    #+BEGIN_SRC scheme
    (define (divisble? x y) (= (remainder x y) 0))
    (define no-sevens
            (stream-filter (lambda (x) (not (divisible? x 7)))
                           integers))
    #+END_SRC

    Then we can find integers not divisible by 7 simply by accessing
    elements of this stream:

    #+BEGIN_SRC scheme
    (stream-ref no-sevens 100)
    #+END_SRC

    In analogy with integers, we can define the infinite stream of
    Fibonacci numbers:

    #+BEGIN_SRC scheme
    (define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
    (define fibs (fibgen 0 1))
    #+END_SRC

    fibs is a pair whose car is 0 and whose cdr is a promise to
    evaluate (fibgen 1 2), and so on.

    For a look at a more exciting infinite stream, we can generalize
    the no-sevens example to construct the infinite stream of prime
    numbers, using a method known as the _sieve of Eratosthenes_. We
    start with the integers beginning with 2, which is the first
    prime. To get the rest of hte primes, we start by filtering out
    the multiples of 2 from the rest of the integers. This leaves a
    stream beginning with 5, which is the next prime, and so on. In
    other words, we construct the primes by a sieving process,
    described as follows: To sieve a stream S, form a stream whose
    first element is the first element of S and the rest of which is
    obtained by filtering out all multiples of the first element of S
    out of the rest of S and sieving the result. This process is
    readily described in terms of stream operations:
    
    #+BEGIN_SRC scheme
    (define (sieve stream)
     (cons-stream
      (stream-car stream)
      (sieve (stream-filter
              (lambda (x)
               (not (divisible? x (stream-car stream))))
              (stream-cdr stream)))))
    (define primes (sieve (integers-starting-from 2)))
    #+END_SRC

    Now to find a particular prime we need only ask for it:

    #+BEGIN_SRC scheme
    (stream-ref primes 50)
    233
    #+END_SRC

    It is interesting to contemplate the signal-processing system set
    up by sieve, shown in the "Henderson diagram" in Figure 3.31. The
    input stream feeds into an "unconser" that separates the first
    element of the stream from the rest of the stream. The first
    element is used to construct a divisibility filter, through which
    the rest is passed, and the output of the filter is fed to another
    sieve box. Then the original first element is consed onto the
    output of the itnernal sieve to form the output stream. Thus, not
    only is the stream infinite, but the signal processor is also
    infinite, because the sieve contains a sieve within it. 

**** Defining streams implicitly
     
     The integers and fibs streams above were defined by specifying
     "generating" procedures that explicitly compute the stream
     elements one by one. An alternative way to specify streams is to
     take advantage of delayed evaluation to define streams
     implicitly. For example, the following expression defines the
     stream ones to be an infinite stream of ones:

     #+BEGIN_SRC scheme
     (define ones (cons-stream 1 ones))
     #+END_SRC

     This works much like the definition of a recursive procedure:
     ones is a pair whose car is 1 and whose cdr is a promise to
     evaluate ones. Evaluating the cdr gives us again a 1 and a
     promise to evaluate ones, and so on.

     We can do more interesting things by manipulating streams with
     operations such as add-streams, which produces the elementwise
     sum of two given streams:

     #+BEGIN_SRC scheme
     (define (add-streams s1 s2) (stream-map + s1 s2))
     #+END_SRC

     Now we can define the integers as follows:

     #+BEGIN_SRC scheme
     (define integers
             (cons-stream 1 (add-streams ones integers)))
     #+END_SRC

     This defines integers to be a stream whose first element is 1 and
     the rest of which is the sum of ones and integers. Thus, the
     second element of integers is 1 plus the first element of
     integers, or 3; and so on. This definition works because, at any
     point, enough of the integers stream has been generated so that
     we can feed it back into the definition and produce the next
     integer. 

     We can define the Fibonacci numbers in the same style:

     #+BEGIN_SRC scheme
     (define fibs
      (cons-stream
       0
       (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
     #+END_SRC

     This definition says that fibs is a stream beginning with 0 and
     1, such that the rest of the stream can be generated by adding
     fibs to itself shifted by one place:

     #+BEGIN_SRC scheme
           1  1  2  3  5  8   13  21  ...  = (stream-cdr fibs)
           0  1  1  2  3  5   8   13  ...  = fibs
     0  1  1  2  3  5  8  13  21  34  ...  = fibs
     #+END_SRC
    

     scale-stream is another useful procedure in formulating such
     stream definitions. This multiplies each item in a stream by a
     given constant:

     #+BEGIN_SRC scheme
     (define (scale-stream stream factor)
      (stream-map (lambda (x) (* x factor))
                  stream))
     #+END_SRC

     For example,

     #+BEGIN_SRC scheme
     (define double (cons-stream 1 (scale-stream double 2)))
     #+END_SRC

     produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ...

     An alternate definition of the stream of primes can be given by
     starting with the integers and filtering them by testing for
     primality. We will need the first prime, 2, to get started:

     #+BEGIN_SRC scheme
     (define primes
      (cons-stream
       2
       (stream-filter prime? (itnegers-starting-from 3))))
     #+END_SRC

     This definition is not so straightforward as it appears, because
     we will test whether a number _n_ is prime by checking whetehr
     _n_ is divisible by a prime (not by just any integer) less than
     or equal to sqrt(n):

     #+BEGIN_SRC scheme
     (define (prime? n)
      (define (iter ps)
       (cons ((> (square (stream-car ps)) n) true)
             ((divisible? n (stream-car ps)) false)
             (else (iter (stream-cdr ps)))))
      (iter primes))
     #+END_SRC

     This is a recursive definition, since primes is defined in terms
     of the prime? predicate, which itself uses the primes stream. The
     reason this procedure works is that, at any point, enough of the
     primes stream has been generated to test the primality of the
     numbers we need to check next. That is, for every _n_ we test for
     primality, either _n_ is not prime (in which case there is a
     prime already generated that divides it) or _n_ is prime (in
     which case there is a prime already generated -- i.e., a prime
     less than _n_ -- that is greater than sqrt(n)). 


     - Exercise 3.53: Without running the program, describe the
       elements of the stream defined by

       #+BEGIN_SRC scheme
       (define s (cons-stream 1 (add-streams s s)))
       #+END_SRC

       1 2 4 8 16 ...
       
       The powers of two.

     - Exercise 3.54: Define a procedure mul-streams, analogous to
       add-streams, that produces the elementwise product of its two
       input streams. Use this together with the stream of integers to
       complete the following definition of the stream whose nth
       element (counting from 0) is n + 1 factorial:

       #+BEGIN_SRC scheme
       (define factorials
        (cons-stream 1 (mul-streams <??> <??>)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (mul-streams s1 s2) (stream-map * s1 s2))
       (define factorials
        (cons-stream 1 (mul-streams factorials (integers-starting-from 2))))
       #+END_SRC

     - Exercise 3.55: Define a procedure partial-sums that takes as
       argument a stream S and returns the stream whose elements are
       S_0, S_0 + S_1, S_0 + S_1 + S_2, .... For example,
       (partial-sums integers) should be the stream 1, 3, 6, 10,
       15,...

       #+BEGIN_SRC scheme
       (define (partial-sums s)
        (cons-stream
         (stream-car s)
         (partial-sums
          (cons-stream (+ (stream-car s)
                          (stream-car (stream-cdr s)))
                       (stream-cdr (stream-cdr s))))))
       #+END_SRC

     - Exercise 3.56: A famous problem, first raised by R. Hamming, is
       to enumerate, in ascending order with no repititions, all
       positive integers with no prime factors other than 2, 3,
       or 5. One obvious way to do this is to simply test each integer
       in turn to see whether it has any factors other than 2, 3,
       and 5. One obvious way to do this is to simply test each
       integer in turn to see whether it has any factors other than 2,
       3, and 5. But this is very inefficient, since, as the integers
       get larger, fewer and fewer of them fit the requirement. As an
       alternative, let us call the required stream of numbers S and
       notice the following facts about it.

       - S begins with 1.

       - The elements of (scale-stream S 2) are also elements of S.

       - The same is true for (scale-stream S 3) and (scale-stream 5
         S).

       - These are all the elements of S.

       Now all we have to do is combine elements from these
       sources. For this we define a procedure merge that combines two
       ordered streams into one ordered result stream, eliminating
       repetitions:

       #+BEGIN_SRC scheme
       (define (merge s1 s2)
       (cond ((stream-null? s1) s2)
       ((stream-null? s2) s1)
       (else
       (let ((s1car (stream-car s1))
       (s2car (stream-car s2)))
       (cond ((< s1car s2car)
       (cons-stream
       s1car
       (merge (stream-cdr s1) s2)))
       ((> s1car s2car)
       (cons-stream
       s2car
       (merge s1 (stream-cdr s2))))
       (else (cons-stream
       s1car
       (merge (stream-cdr s1)
       (stream-cdr s2)))))))))
       #+END_SRC
       
       Then the required stream may be constructed with merge, as follows:

       #+BEGIN_SRC scheme
       (define S (cons-stream 1 (merge (scale-stream S 2)
       (merge (scale-stream S 3)
       (scale-stream S 5)))))
       #+END_SRC

     - Exercise 3.57: How many additions are performed when we compute
       the _nth_ Fibonacci number using the definition of fibs based
       on the add-streams procedure? Show that the number of
       additions would be exponentially greater if we had implemented
       (delay <exp>) simply as (lambda () <exp>), without using the
       optimization provided by the memo-proc procedure described in
       Section 3.5.1. 

       #+BEGIN_SRC scheme
       (define fibo (cons-stream 0 
                     (cons-stream 1
                      (add-streams fibo (stream-cdr fibo)))))
       #+END_SRC

       the nth fibonacci number is defined as basically
       (stream-map + fibo (stream-cdr fibo)), where fibo is already
       'defined' up to n. If we didn't save this, when we compute a
       fibo number, we have to compute the entire stream back up to n
       -1 and n - 2, taking roughly twice as long as n-1. Since each
       time we go up in n we multiply runtime by two, we end up with
       2^n.

       However, if we save the results of our computations, the
       branching basically doesn't happen. For each element in the
       stream, we add the previous two, which, if we saved the results
       and are computing this current element, are already defined,
       and have O(n) access time. So we end up with O(n^2) runtime.

     - Exercise 3.58: Give an interpretation of the stream computed by
       the following procedure:

       #+BEGIN_SRC scheme
       (define (expand num den radix)
        (cons-stream
         (quotient (* num radix) den)
         (expand (remainder (* num radix) den) den radix)))
       #+END_SRC

       (quotient is a primitive that returns the integer quotient of
       two integers.) What are the successive elements produced by
       (expand 1 7 10)? What is produced by (expand 3 8 10)?

       (expand 1 7 10)
       1 
       (expand 3 7 10)
       4
       (expand 2 7 10)
       2
       (expand 6 7 10)
       8
       (expand 4 7 10)
       5
       (expand 5 7 10)
       7
       (expand 1 7 10)
       1     

       It's a repeating sequence. It always loops around, repeating
       the same set of values, 1 4 2 8 5 7. We 'tried' as num all
       numbers between 1 and 7 (exclusive of 7), and if any of them
       had divided evenly, we would have converged to 0 and been
       expanding 0 permanently for infinity. But none of these values,
       multiplied by ten, had a common factor with seven. We got as
       outputs all the quotients of multiplies of ten when the
       multiplier is between [1, 7). For example, 3 is not an output
       because (3x7) = 21 is not a quotient of any multiple of
       ten. Any time a denominator is relatively prime to the num and
       radix both, you will get an infinite repeating sequence of
       values. Otherwise, you will converge to zero and exit.

       (expand 3 8 10)
       3
       (expand 6 8 10)
       7
       (expand 4 8 10)
       5
       (expand 0 8 10)
       0
       ....

       This expansion does not repeat the same set of values over and
       over, it converges to 0, and repeats 0 forever.

       I think that any time den and either num or radix have common
       factors, you convege to zero. Otherwise, you end up with a
       repeating set of values.

     - Exercise 3.59: In Section 2.5.3 we saw how to implement a
       polynomial arithmetic system representing polynomials as lists
       of terms. In a similar way, we can work with _power series_,
       such as 

       #+BEGIN_EXAMPLE
       e^x = 1 + x x^2/2 + x^3/(3 * 2) + x^4/(4 * 3 * 2) + ...,
       cos x = 1 - x^2/2 + x^4/(4 * 3 * 2) - ...
       sin x = x - x^3/(3 * 2) + x^5/(5 * 4 * 3 * 2) - ...
       #+END_EXAMPLE

       represented as infinite streams. We will represent the series
       a_0 + a_1*x + a_2*x^2 + a_3*x^3 + ... as the stream whose
       elements are the coefficients a_0, a_1, a_2, a_3, ...

       a. The integral of the series a_0 + a_1*x + a_2*x^2 + a_3*x^3 +
       ... is the series

       \begin{series}
       c + a_{0}x + \frac{1}{2}a_{1}x^{2} + \frac{1}{3}a_{2}x^{3} + \frac{1}{4}a_{3}x^{4} + ...
       \end{series}

       where _c_ is any constant. Define a procedure integrate-series
       that takes as input a stream a_0, a_1, a_2, ... representing a
       power series and returns the stream a_0, 1/2a_1, 1/3a_2, ... of
       coefficients of the non-constant terms of the integral of the
       series. (Since the result has no constant term, it doesn't
       represent a power series; when we use integrate-series, we will
       cons on the appropriate constant.)

       #+BEGIN_SRC scheme
       (define (integrate-series coefficients)
        (define (integrate-inner current-denom stream)
          (cons-stream
           (* (/ 1.0 current-denom) (stream-car stream))
           (integrate-inner (+ 1 current-denom) (stream-cdr stream))))
        (integrate-inner 1 coefficients))
       #+END_SRC

       b. The function x -> e^x is its own derivative. This implies
       that e^x and the integral of e^x are the same series, except
       for the constant term, which is e^0 = 1. Accordingly, we can
       generate the series for e^x as

       #+BEGIN_SRC scheme
       (define exp-series
        (cons-stream 1 (integrate-series exp-series)))
       #+END_SRC

       Show how to generate the series for sine and cosine, starting
       from the facts that the derivative of sine is cosine and the
       derivative of cosine is the negative of sine:

       #+BEGIN_SRC scheme
       (define (negate stream)
        (cons-stream (* -1 (stream-car stream))
                     (negate (stream-cdr stream))))
       (define cosine-series (cons-stream 1.0 (negate (integrate-series sine-series))))
       (define sine-series (cons-stream 0.0 (integrate-series cosine-series)))
       #+END_SRC

     - Exercise 3.60: With power series represented as streams of
       coefficients as in Exercise 3.59, adding series is implemented
       by add-streams. Complete the definition of the following
       procedure for multiplying series:

       #+BEGIN_SRC scheme
       (define (mul-series s1 s2)
        (cons-stream <??> (add-streams <??> <??>)))
       #+END_SRC

       You can test your procedure by verifying that sin^2 x + cos^2 x
       = 1, using the series from Exercise 3.59. 

       #+BEGIN_SRC scheme
       (define (mul-series s1 s2)
        (cons-stream (* (stream-car s1) (stream-car s2))
                     (add-streams
                      (add-streams
                       (scale-stream (stream-car s1) (stream-cdr s2))
                       (scale-stream (stream-car s2) (stream-cdr s1)))
                      (cons-stream 0
                       (mul-series (stream-cdr s1) (stream-cdr s2))))))
       #+END_SRC

     - Exercise 3.61: Let _S_ be a power series (Exercise 3.59) whose
       constant term is 1. Suppose we want to find the power series
       1/S, that is, the series X such that SX = 1. Write S = 1 + S_R
       where S_R is the part of S after the constant term. Then we can
       solve for X as follows:

               S * X = 1
       (1 + S_R) * X = 1
         X + S_R * X = 1
                   X = 1 - S_R * X.

       In other words, X is the power series whose constant term is 1
       and whose higher-order terms are given by the negative of S_R
       times X. Use this idea to write a procedure invert-unit-series
       that computes 1/S for a power series S with constant
       term 1. You will need to use mul-series from Exercise 3.60.

       #+BEGIN_SRC scheme
       (define (invert-unit-series s)
        (cons-stream
         1
         (negate (mul-series (stream-cdr s)
                             (invert-unit-series s)))))
       #+END_SRC

     - Exercise 3.62: Use the results of Exercise 3.60 and Exercise
       3.61 to define a procedure div-series that divides two power
       series. div-series should work for any two series, provided
       that the denominator series begins with a nonzero constant
       term. (If the denominator has a zero constant term, then
       div-series should signal an error.) Show how to use div-series
       together with the result of Exercise 3.59 to generate the power
       series for tangent.

       #+BEGIN_SRC scheme
       (define (div-series s1 s2)
        (if (not (= 1 (stream-car s2)))
            (error "Denominator must begin with 1 -- DIV-SERIES" s2)
            (mul-series s1 (invert-unit-series s2))))
       (define tan-series (div-series sine-series cosine-series))
       #+END_SRC

       An important thing to note is that the valid range of this
       function is between -0.5PI to 0.5PI. After that it makes no
       sense. Inverted cosine also has a narrow range of valid
       behavior.

*** 3.5.3. Exploiting the Stream Paradigm

    Streams with delayed evaluation can be a powerful modeling tool,
    providing many of the benefits of local state and
    assignment. Moreover, they avoid some of the theoretical tangles
    that accompany the introduction of assignment into a programming
    language.

    The stream approach can be illuminating because it allows us to
    build systems with different module boundaries than systems
    organized around assignment to state variables. For example, we
    can think of an entire time series (or signal) as a focus of
    interest, rather than the values of the state variables at
    individual moments. This makes it convenient to combine and
    compare components of state from different moments.

**** Formulating iterations as stream processes

     In Section 1.2.1, we introduced iterative processes, which
     proceed by updating state variables. We know now that we can
     represent state as a "timeless" stream of values rather than as a
     set of variables to be updated. Let's adopt this perspective in
     revisiting the square-root procedure from Section 1.1.7. Recall
     that the idea is to generate a sequence of better and better
     guesses for the square root of _x_ by applying over and over
     again the procedure that improves guesses:

     #+BEGIN_SRC scheme
     (define (sqrt-improve guess x)
      (average guess (/ x guess)))
     #+END_SRC

     In our original sqrt procedure, we made these guesses be the
     successive values of a state variable. Instead we can generate
     the infinite stream of guesses, starting with an initial guess of
     1:

     #+BEGIN_SRC scheme
     (define (sqrt-stream x)
      (define guesses
       (cons-stream
        1.0
        (stream-map (lambda (guess) (sqrt-improve guess x))
                    guesses)))
      guesses)

     (display-stream (sqrt-stream 2))
     1.
     1.5
     1.416666
     1.412156
     1.414213
     ...
     #+END_SRC

     We can generate more and more terms of the stream to get better
     and better guesses. If we like, we can write a procedure that
     keeps generating terms until the answer is good enough. (See
     Exercise 3.64)

     Another iteration that we can treat in the same way is to
     generate an approximation to pi, based upon the alternating
     series that we saw in Section 1.3.1:

     \begin{eq}
     \frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} +
     ...
     \end{eq}

     We first generate the stream of summands of the series (the
     reciprocals of the odd integers, with alternating signs). Then we
     take the stream of sums of more and more terms (using the
     partial-sums procedure of Exercise 3.55) and scale the result by
     4:

     #+BEGIN_SRC scheme
     (define (pi-summands n)
      (cons-stream (/ 1.0 n)
                   (stream-map - (pi-summands (+ n 2)))))
     (define pi-stream
      (scale-stream (partial-sums (pi-summands 1)) 4))

     (display-stream pi-stream)
     4.
     2.66666
     2.46666
     2.89523
     3.33968
     2.97604
     3.28373
     3.01707
     #+END_SRC

     This gives us a stream of better and better approximations of pi,
     although the approximations converge rather slowly. Eight terms
     of the sequence bound the value of pi between 3.284 and 3.017. 

     So far, our use of the stream of states approach is not much
     different from updating state variables. But streams give us an
     opportunity to do some interesting tricks. For example, we can
     transform a stream with a _sequence accelerator_ that converts a
     sequence of approximations to a new sequence that converges to
     the same value as the original, only faster.

     One such accelerator, due to the eighteenth-century Swiss
     mathematician Leonhard Euler, works well with sequences that are
     partial sums of alternating series (series of terms with
     alternating signs). In Euler's technique, if S_n is the nth term
     of the original sum sequence, then the accelarated sequence has
     the terms

     S_{n+1} - \frac{(S_{n+1} - S_{n})^2}{S_{n-1} - 2S_{n} + S_{n+1}}

     Thus, if the original sequence is represented as a stream of
     values, the transformed sequence is given by

     #+BEGIN_SRC scheme
     (define (euler-transform s)
      (let ((s0 (stream-ref s 0))
            (s1 (stream-ref s 1))
            (s2 (stream-ref s 2)))
       (cons-stream (- s2 (/ (square (- s2 s1))
                             (+ s0 (* -2 s1) s2)))
                    (euler-transform (stream-cdr s)))))
     #+END_SRC

     We can demonstrate Euler acceleration with our sequence of
     approximations of pi:

     #+BEGIN_SRC scheme
     (display-stream (euler-transform pi-stream))
     3.16666
     3.13333
     3.14523
     3.13968
     3.14271
     3.14088
     3.14207
     3.14125
     #+END_SRC

     Even better, we can accelerate the accelerated sequence, and
     recursively accelerate that, and so on. Namely, we create a
     stream of streams (a structure we'll call a _tableau_) in which
     each stream is the transform of the preceding one:

     #+BEGIN_SRC scheme
     (define (make-tableau transform s)
      (cons-stream s (make-tableau transform (transform s))))
     #+END_SRC
     
     The tableau has the form

     \begin{sequence}
     S_{00} S_{01} S_{02} S_{03} S_{04} ...
            S_{10} S_{11} S_{12} S_{13} ...
                   S_{20} S_{21} S_{22} ...
                          ...
     \end{sequence}

     Finally, we form a sequence by taking the first term in each row
     of the tableau:

     #+BEGIN_SRC scheme
     (define (accelerated-sequence transform s)
      (stream-map stream-car (make-tableau transform s)))
     #+END_SRC

     We can demonstrate this kind of "super-acceleration" of the pi
     sequence:

     #+BEGIN_SRC scheme
     (display-stream
      (accelerated-sequence euler-transform pi-stream))
     4. 
     3.166666
     3.142105
     3.141599
     3.141592
     #+END_SRC

     The result is impressive. Taking eight terms of the sequence
     yields the correct value of pi to 14 decimal places. If we had
     used only the original pi sequence, we would need to compute on
     the order of 10^13 terms (i.e. expanding the series far enough so
     that the individual terms are less than 10^-13) to get that much
     accuracy!

     We could have implemented these acceleration techniques without
     using streams. But the stream formulation is particularly elegant
     and convenient because the entire sequence of states is available
     to us as a data structure that can be manipulated with a uniform
     set of operations.

     - Exercise 3.63: Louis Reasoner asks why the sqrt-stream
       procedure was not written in the following more straightforward
       way, without the local variable guesses:

       #+BEGIN_SRC scheme
       (define (sqrt-stream x)
        (cons-stream 1.0 (stream-map
                          (lambda (guess)
                           (sqrt-improve guess x))
                          (sqrt-stream x))))
       #+END_SRC

       Alyssa P. Hacker replies that this version of the procedure is
       considerably less efficient because it performs redundant
       computation. Explain Alyssa's answer. Would the two versions
       still differ in efficiency if our implementation of delay used
       only (lambda () <exp>) without using the optimization provided
       by memo-proc (Section 3.5.1)?

       It is inefficient because it creates a copy of sqrt-stream each
       time it gets to the recursive case. So originally we have

       1 .. (stream-map (lambda (guess) (sqrt-improve guess x))
       (sqrt-stream x))

       which in turn computes
       1 .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
       (sqrt-stream x)))

       1 
       .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
           (sqrt-stream x))) 
       .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
           (stream-cdr (sqrt-stream x))))

       and so on. Although the stream (sqrt-stream x) at least saves
       its own past, so _that_ isn't as inefficient, we end up
       computing each value twice, because the (sqrt-stream x) stream
       generated by the inner call to sqrt-stream is a separate
       stream. So each of the mapping calls re-generates a value we
       just computed previously.

     - Exercise 3.64: Write a procedure stream-limit that takes as
       arguments a stream and a number (the tolerance). It should
       examine the stream until it finds two successive elements that
       differ in absolute value by less than the tolerance, and return
       the second of the two elements. Using this, we could compute
       square roots up to a given tolerance by

       #+BEGIN_SRC scheme
       (define (sqrt x tolerance)
        (stream-limit (sqrt-stream x) tolerance))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-limit s tolerance)
         (define (iter stream last-value)
           (if (<= (abs (- (stream-car stream) last-value))
                   tolerance)
               (stream-car stream)
               (iter (stream-cdr stream) (stream-car stream))))
         (iter (stream-cdr s) (stream-car s)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (sqrt-improve guess sqrt-of)
        (/ (+ guess (/ sqrt-of guess)) 2))
       #+END_SRC

     - Exercise 3.65: Use the series

       ln 2 = 1 - 1/2 + 1/3 - 1/4 + ...

       to compute three sequences of approximations to the natural
       logarithm of 2, in the way we did above for pi. How rapidly do
       these sequences converge?
     
       #+BEGIN_SRC scheme
       (define (sum-stream n s) 
        (define (iter value i stream) 
         (if (> i n) 
             value
             (iter (+ value 
                      (stream-car stream))
     	           (+ i 1)
                   (stream-cdr stream))))
         (iter 0 0 s))
                      
       (define (ln2-stream) 
        (define (iter i sign) (cons-stream (* sign (/ 1 i)) 
                                           (iter (+ i 1) (* sign -1))))
	      (iter 1 1))
       (define ln2 (ln2-stream))
       (define (approx-ln2 i)
        (sum-stream i ln2))
       (define approx-stream (stream-map approx-ln2 (stream-enumerate-from 1)))
       (define accel-approx-stream (euler-transform approx-stream))
       (define tableu-stream (accelerated-sequence euler-transform approx-stream))
       #+END_SRC

       I printed out the first 50 elements of the first two, and the
       first 15 of the second. The second converged in nine elements
       and stopped changing. The first one didn't converge in fifty,
       so I changed stream-limit to print the convergence number:

       #+BEGIN_SRC scheme
       (define (stream-limit s tolerance)
         (define (iter stream last-value i)
           (if (<= (abs (- (stream-car stream) last-value))
                   tolerance)
               i
               (iter (stream-cdr stream) (stream-car stream) (+ i 1))))
         (iter (stream-cdr s) (stream-car s) 0))
       #+END_SRC       

       for the first stream I got 997 with tolerance = 0.001. For the
       second stream I got 3, for the third I got 2. I decided 0.001
       was too generous and changed it to 1e-6. The results were:

       tableau-stream: 3
       accel-approx-stream: 59
       approx-stream: (didn't return after five minutes, suffice it to
       say it was in the thousands)

**** Infinite streams of pairs 

     In section 2.2.3, we saw how the sequence paradigm handles
     traditional nested loops as processes defined on sequences of
     pairs. If we generalize this technique to infinite streams, then
     we can write programs that are not easily represented as loops,
     because the "looping" must range over an infinite set. 

     For example, suppose we want to generalize the prime-sum-pairs
     procedure of Section 2.2.3 to produce the stream of pairs of
     _all_ integers (i, j) with i <= j such that i + j is prime. If
     int-pairs is the sequence of all pairs of integers (i, j) with i
     <= j, then our required stream is simply

     #+BEGIN_SRC scheme
     (stream-filter
      (lambda (pair) (prime? (+ (car pair) (cadr pair))))
      int-pairs) 
     #+END_SRC

     Our problem, then, is to produce the stream int-pairs. More
     generally, suppose we have two streams S = (S_{i}) and T =
     (T_{j}), and imagine the infinite rectangular array


     (S_{0},T_{0}) (S_{0},T_{1}) (S_{0},T_{2}) ...
     (S_{1},T_{0}) (S_{1},T_{1}) (S_{1},T_{2}) ...
     (S_{2},T_{0}) (S_{2},T_{1}) (S_{2},T_{2}) ...
     ...


     We wish to generate a stream that contains all the pairs in the
     array that lie on or above the diagonal, i.e. the pairs

     
     (S_{0},T_{0}) (S_{0},T_{1}) (S_{0},T_{2}) ...
                   (S_{1},T_{1}) (S_{1},T_{2}) ...
                                 (S_{2},T_{2}) ...
                                               ...

     
     (If we take both S and T to be the stream of integers, then this
     will be our desired stream int-pairs.)

     Call the general stream of pairs (pairs S T), and consider it to
     be composed of three parts: the pair (S_{0}, T_{0}), the rest of
     the pairs in the first row, and the remaining pairs:

     \begin{tabular}{c | c c c}
     (S_{0},T_{0}) & (S_{0},T_{1}) & (S_{0},T_{2}) & ... \\
     \hline
                   & (S_{1},T_{1}) & (S_{1},T_{2}) & ... \\
                   &               & (S_{2},T_{2}) & ... \\
                   &               &               & ... \\
     \end{tabluar}

     Observe that the third piece in this decomposition (pairs that
     are not in the first row) is (recursively) the pairs formed from
     (stream-cdr S) and (stream-cdr T). Also note that the second
     piece (the rest of the first row) is

     #+BEGIN_SRC scheme
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     #+END_SRC

     Thus we can form our stream of pairs as follows:

     #+BEGIN_SRC scheme
     (define (pairs s t)
      (cons-stream
       (list (stream-car s) (stream-car t))
       (<combine-in-some-way>
        (stream-map (lambda (x) (list (stream-car s) x))
                    (stream-cdr t))
        (pairs (stream-cdr s) (stream-cdr t)))))
     #+END_SRC

     In order to complete the procedure, we must choose some way to
     combine the two inner streams. One idea is to use the stream
     analog of the append procedure from Section 2.2.1:

     #+BEGIN_SRC scheme
     (define (stream-append s1 s2)
      (if (stream-null? s1)
          s2
          (cons-stream (stream-car s1)
                       (stream-append (stream-cdr s1) s2))))
     #+END_SRC

     This is unsuitable for infinite streams, however, because it
     takes all the elements from the first stream before incorporating
     the second stream. In particular, if we try to generate all pairs
     of positive integers using

     #+BEGIN_SRC scheme
     (pairs integers integers)
     #+END_SRC

     our stream of results will first try to run through all pairs
     with the first integer equal to 1, and hence will never produce
     pairs with any other value of the first integer. 

     To handle infinite streams, we need to devise an order of
     combination that ensures that every element will eventually be
     reached if we let our program run long enough. An elegant way to
     accomplish this is with the following interleave procedure:

     #+BEGIN_SRC scheme
     (define (interleave s1 s2)
      (if (stream-null? s1)
          s2
          (cons-stream (stream-car s1)
                       (interleave s2 (stream-cdr s1)))))
     #+END_SRC

     Since interleave takes elements alternately from the two streams,
     every element of the second stream will eventually find its way
     into the interleaved stream, even if the first stream is
     infinite. 

     We can thus generate the required stream of pairs as

     #+BEGIN_SRC scheme
     (define (pairs s t)
      (cons-stream 
       (list (stream-car s) (stream-car t))
       (interleave
        (stream-map (lambda (x) (list (stream-car s) x))
                    (stream-cdr t))
        (pairs (stream-cdr s) (stream-cdr t)))))
     #+END_SRC

     - Exercise 3.66: Examine the stream (pairs integers
       integers). Can you make any general comments about the order in
       which the pairs are placed into the stream? For example,
       approximately how many pairs precede the pair (1, 100)? the
       pair (99, 100)? the pair (100, 100)? (If you can make precise
       mathematical statements here, the better. But feel free to give
       more qualitative answers if you find yourself getting bogged
       down.) 

       The first integer in the int stream is 1, so the first pair is
       (1, 1), supposing both streams are 1..N. The interleave
       function swaps the streams around but doesn't do any kind of
       'deep' interleaving. Basically, elements from the first stream
       are heavily overrepresented. Interleave will use the first
       stream, defined by
       
       #+BEGIN_SRC scheme
       (interleave (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t)))
       #+END_SRC

       for every other cons-stream, since it swaps around its
       arguments. If the stream was by itself, there would be 99
       elements preceding the pair 1, 100, from the beginning of the
       stream, and it could be refed with 99 (i.e. (stream-ref s 99)
       is (1, 100) in the stream of just those elements.). Since
       elements from the stream starting with 1 begin the stream, and
       each are interleaved with another element, we double the number
       of preceding elements, to 198. However, this would be if we
       just called interleave. The full procedure actually takes a car
       form each stream and calls interleave with the cdrs, with s
       first. That results in 

       s_1, s_2, ....

       first, elements from the first stream get repeated. So the
       doubling applies to elements after s_2. There are 98 elements
       then that should be doubled, plus one: 196 + 1 = 197, so there
       are 197 elements before (1, 100)

     - Exercise 3.67: Modify the pairs procedure so that (pairs
       integers integers) will produce the stream of _all_ pairs of
       integers (i, j) (without the condition i <= j). Hint: You will
       need to max in an additional stream.

       #+BEGIN_SRC scheme
       (define (allpairs s t)
        (cons-stream 
         (list (stream-car s) (stream-car t))
         (interleave
            (stream-map (lambda (x) (list (stream-car s) x))
                        (stream-cdr t))
            (interleave 
              (stream-map (lambda (x) (list x (stream-car t)))
                        (stream-cdr s))
              (allpairs (stream-cdr s) (stream-cdr t))))))
       #+END_SRC

     - Exercise 3.68: Louis Reasoner thinks that building a stream of
       pairs from three parts is unecessarily complicated. Instead of
       separating the pair (S_{0}, T_{0}) from the rest of the pairs
       in the first row, he proposes to work with the whole first row,
       as follows: 

       #+BEGIN_SRC scheme
       (define (pairs s t)
        (interleave
         (stream-map (lambda (x) (list (stream-car s) x))
                     t)
         (pairs (stream-cdr s) (stream-cdr t))))
       #+END_SRC

       Does this work? Consider what happens if we evaluate (pairs
       integers integers) using Louis' definition of pairs. 

       Well, it doesn't work practically speaking. Because there is no
       cons-stream that causes a delay, and we always evaluate
       arguments first, we recursively attempt to evaluate (pairs
       (stream-cdr s) (stream-cdr t)). Since s and t are infinite
       streams, we will never exit the invocation of pairs and never
       get any result.

     - Exercise 3.69: Write a procedure triples that takes three
       infinite streams, S, T, and U, and produces the stream of
       triples (S_{i},T_{j},U_{k}) such that i <= j <= k. Use triples
       to generate the stream of all Pythagorean triples of positive
       integers, i.e., the triples (i,j,k) such that i <= j and
       i^{2} + j^{2} = k^{2}

       #+BEGIN_SRC scheme
       (define (triples s t u)
        (cons-stream
         (list (stream-car s)
               (stream-car t)
               (stream-car u))
         (interleave
          (stream-map (lambda (x)
                       (list (stream-car s)
                             (car x)
                             (cadr x)))
                     (stream-cdr (pairs t
                                        u)))
          (triples (stream-cdr s)
                   (stream-cdr t)
                   (stream-cdr u)))))
       (define pythagorean-triples
               (stream-filter
                (lambda (x) (= (+ (square (car x)) (square (cadr x)))
                               (square (caddr x))))
                (triples integers integers integers)))
       #+END_SRC

       - Exercise 3.70: It would be nice to be able to generate streams
         in which the pairs appear in some useful order, rather than
         the order that results from an _ad hoc_ interleaving
         process. We can use a technique similar to the merge procedure
         of Exercise 3.56, if we define a way to say that one pair of
         integers is "less than" another. One way to do this is to
         define a "weighting function" W(i,j) and stipulate that (i_1,
         j_1) is less than (i_2,j_2) if W(i_1,j_1) < W(i_2,j_2). Write
         a procedure merge-weighted that is like merge, except that
         merge-weighted takes an additional argument weight, which is a
         procedure that computes the weight of a pair, and is used to
         determine the order in which elements should appear in the
         resulting merged stream. Using this, generalize pairs to a
         procedure weighted-pairs that takes two streams, together with
         a procedure that computes a weighting function, and generates
         the stream of pairs, ordered according to weight. Use your
         procedure to generate

	 #+BEGIN_SRC scheme
         (define (merge-weighted weight s1 s2)
          (let ((a1 (stream-car s1))
		(a2 (stream-car s2)))
           (cond
            ((eq? 'equal (weight a1 a2))
             (cons-stream a1
              (cons-stream a2 
               (merge-weighted weight (stream-cdr s1) (stream-cdr s2)))))
            ((eq? 'less (weight a1 a2))
             (cons-stream a1 (merge-weighted weight (stream-cdr s1) s2)))
            ((eq? 'greater (weight a1 a2))
             (cons-stream a2 (merge-weighted weight s1 (stream-cdr s2)))))))
	 #+END_SRC

	 a. the stream of all pairs of positive integers (i, j) with i
         <= j ordered according to the sum i + j,

	 The pairs procedure already produces pairs of positive
         integers (i, j) such that i <= j.

	 #+BEGIN_SRC scheme
         (define (weigher x1 x2)
          (let ((sum1 (apply + x1))
		(sum2 (apply + x2)))
           (cond 
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))

         (define (pairs-weighted weigher s1 s2)
	       (cond
		((empty-stream? s1) s2)
		((empty-stream? s2) s1)
		(else (cons-stream
		  (list (stream-car s1) (stream-car s2))
		  (merge-weighted weigher
				  (stream-map 
				   (lambda (x) (list (stream-car s1) x))
				   (stream-cdr s2))
				  (pairs-weighted weigher (stream-cdr s1) (stream-cdr s2)))))))
	 #+END_SRC

	 b. the stream of all pairs of positive integers (i,j) with i
         <= j, where neither i nor j is divisible by 2, 3, or 5, and
         the pairs are ordered according to the sum 2i + 3j + 5ij. 

	 #+BEGIN_SRC scheme
         (define (weigher x1 x2)
          (define (make-sum double)
           (+ (* 2 (car double)) (* 3 (cadr double)) 
              (* 5 (car double) (cadr double))))
          (let ((sum1 (make-sum x1))
		(sum2 (make-sum x2)))
           (cond
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))
         (define the-pairs (pairs-weighted weigher integers-not-divisible integers-not-divisible))
         (define integers-not-divisible (filter (lambda (x) 
                                                 (and (not (= (remainder x 5) 0))
                                                      (not (= (remainder x 2) 0))
                                                      (not (= (remainder x 3) 0))))
                                                      integers))
	 #+END_SRC

	 #+BEGIN_SRC scheme
	 (print-stream the-pairs 50)

          ; => (1 1)
          ; => (1 7)
          ; => (1 11)
          ; => (1 13)
          ; => (1 17)
          ; => (1 19)
          ; => (1 23)
          ; => (1 29)
          ; => (1 31)
          ; => (7 7)
          ; => (1 37)
          ; => (1 41)
          ; => (1 43)
          ; => (1 47)
          ; => (1 49)
          ; => (1 53)
          ; => (7 11)
          ; => (1 59)
          ; => (1 61)
          ; => (7 13)
          ; => (1 67)
          ; => (1 71)
          ; => (1 73)
          ; => (1 77)
          ; => (1 79)
          ; => (7 17)
          ; => (11 11)
          ; => (1 83)
          ; => (1 89)
          ; => (1 91)
          ; => (7 19)
          ; => (11 13)
          ; => (1 97)
          ; => (1 101)
          ; => (1 103)
          ; => (1 107)
          ; => (1 109)
          ; => (7 23)
          ; => (1 113)
          ; => (13 13)
          ; => (1 119)
          ; => (1 121)
          ; => (11 17)
          ; => (1 127)
          ; => (1 131)
          ; => (1 133)
          ; => (1 137)
          ; => (1 139)
          ; => (7 29)
          ; => (11 19)
	 #+END_SRC

       - Exercise 3.71: Numbers that can be expressed as the sum of
         two cubes in more than one way are sometimes called
         _Ramanujan numbers_, in honor of the mathematician Srinivasa
         Ramanujan. Ordered streams of pairs provide an elegant
         solution to the problem of computing these numbers. To find a
         number that can be written as the sum of two cubes in two
         different ways, we need only generate the stream of pairs of
         integers (i,j) weighted according to the sum i^3 + j^3 (see
         Exercise 3.70), then search the stream for two consecutive
         pairs with the same weight. Write a procedure to generate the
         Ramanujan numbers. The first such number is 1729. What are
         the next five?

	 #+BEGIN_SRC
         (define (cube x) (* x (square x)))
         (define (sum-of-cubes x)
          (+ (cube (car x)) (cube (cadr x))))
         (define (weigher x1 x2)
          (let ((sum1 (sum-of-cubes x1))
                (sum2 (sum-of-cubes x2)))
           (cond
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))
         (define (sums-equal? a b)
          (= (sum-of-cubes a)
             (sum-of-cubes b)))
         (define (filter-identical-pairs s)
          (define (inner-filter s)
           (cond
            ((or (empty-stream? s)
                 (empty-stream? (stream-cdr s)))
             the-empty-stream)
            ((sums-equal? (stream-car s) (stream-car (stream-cdr s)))
             (cons-stream (sum-of-cubes (stream-car s))
                          (inner-filter (stream-cdr (stream-cdr s)))))
            (else
             (inner-filter (stream-cdr s)))))
          (inner-filter s))
         (filter-identical-pairs
          (pairs-weighted weigher
                          integers
                          integers))
         (stream-list (filter-identical-pairs
                       (pairs-weighted weigher integers integers)) 6)
	 #+END_SRC
	 output:
	 #+BEGIN_SRC scheme
         ; => (1729 4104 13832 20683 32832 39312 40033)
	 #+END_SRC

       - Exercise 3.72: In a similar way to Exercise 3.71 generate a
         stream of all numbers that can be written as the sum of two
         squares in three different ways (showing how they can be so
         written). 

	 #+BEGIN_SRC scheme
         (define (sum-squares x)
          (+ (square (car x)) (square (cadr x))))
         (define (sum-squares-equal? x y)
          (= (sum-squares x) (sum-squares y)))
         (define (sum-squares-equal3? x y z)
          (= (sum-squares x)
             (sum-squares y)
             (sum-squares z)))
         (define (weigher-sum-squares a b)
          (let ((s1 (sum-squares a))
                (s2 (sum-squares b)))
           (cond
            ((= s1 s2) 'equal)
            ((< s1 s2) 'less)
            ((> s1 s2) 'greater))))
         (define (filter-identical-triples
                  is-three-eql? s)
          (cond
           ((or (empty-stream? s)
                (empty-stream? (stream-cdr s))
                (empty-stream? (stream-cdr (stream-cdr s))))
             the-empty-stream)
             
           ((is-three-eql?
             (stream-car s)
             (stream-car (stream-cdr s))
             (stream-car (stream-cdr (stream-cdr s))))
            (cons-stream
             (list (sum-squares (stream-car s))
                   (stream-car s)
                   (stream-car (stream-cdr s))
                   (stream-car (stream-cdr (stream-cdr s))))
             (filter-identical-triples
              is-three-eql?
              (stream-cdr (stream-cdr (stream-cdr s))))))
           (else
            (filter-identical-triples
             is-three-eql?
             (stream-cdr s)))))
         (stream->list (filter-identical-triples
          sum-squares-equal3?
          (pairs-weighted weigher-sum-squares integers integers))
          10)
	 #+END_SRC

	 #+BEGIN_SRC scheme
         ((325 (1 18) (6 17) (10 15)) 
          (425 (5 20) (8 19) (13 16)) 
          (650 (5 25) (11 23) (17 19)) 
          (725 (7 26) (10 25) (14 23)) 
          (845 (2 29) (13 26) (19 22)) 
          (850 (3 29) (11 27) (15 25)) 
          (925 (5 30) (14 27) (21 22)) 
          (1025 (1 32) (8 31) (20 25)) 
          (1105 (4 33) (9 32) (12 31)) 
          (1250 (5 35) (17 31) (25 25)) 
          (1300 (2 36) (12 34) (20 30)))
	 #+END_SRC
	 
**** Streams as signals
     We began our discussion of streams by describing them as
     computational analogs of the "signals" in signal-processing
     systems. In fact, we can use streams to model signal-processing
     systems in a very direct way, representing the values of a signal
     at successive time intervals as consecutive elements of a
     stream. For instance, we can implement an _integrator_ or
     _summer_ that, for an input stream x = (x_i), an initial value
     _C_, and a small increment _dt_, accumulates the sum

     S_{i} = C + \sum_{j=1}^{i} x_{j}dt

     and returns the stream of values S = (S_{i}). The following
     integral procedure is reminiscent of the "implicit style"
     definition of the stream of integers (Section 3.5.2):

     #+BEGIN_SRC scheme
     (define (integral integrand initial-value dt)
      (define int
       (cons-stream initial-value
                    (add-streams (scale-stream integrand dt)
                                 int)))
      int)
     #+END_SRC
     
     Fiture 3.32 is a picture of a signal-processing system that
     corresponds to the integral procedure. The input stream is scaled
     by _dt_ and passed through an adder, whose output is passed back
     through the same adder. The self-reference in the definition of
     int is reflected in the figure by the feedback loop that connects
     the output of the adder to one of the inputs.

     - Exercise 3.73: We can model electrical circuits using streams
       to represent the values of currents or voltage at a sequence of
       times. For instance, suppose we have an _RC circuit_ consisting
       of a resistor of resistance R and a capacitor of capacitance C
       in series. The voltage response _v_ of the circuit to an
       injected current _i_ is determined by the formula in Figure
       3.33, whose structure is shown by the accompanying signal-flow
       diagram.

       Write a procedure RC that models this circuit. RC should take
       as inputs the values of R, C, and dt and should return a
       procedure that takes as inputs a stream representing the
       current _i_ and an initial value for the capacitor voltage
       v_{0} and produces as output the stream of voltages v. For
       example, you should be able to use RC to model an RC circuit
       with R = 5 ohms, C = 1 farad, and a 0.5-second time step by
       evaluating (define RC1 (RC 5 1 0.5)). THis defines RC1 as a
       procedure that takes a stream representing the time sequence of
       currents and an initial capacitor voltage and produces the
       output stream of voltages.

       #+BEGIN_SRC scheme
       (define (RC r c ts)
        (define (circuit i v0)
         (add-streams
          (scale-stream i r)
          (integral
           (scale-stream
            (/ 1.0 c)
            i)
           v0
           ts)))
        circuit)
       #+END_SRC

     - Exercise 3.74: Alyssa P. Hacker is designing a system to
       process signals coming from physical sensors. One important
       feature she wishes to produce is a signal that describes the
       _zero crossings_ of the input signal. That is, the resulting
       signal should be +1 whenever the input signal changes from
       negative to positive, -1 whenever the input signal changes from
       positive to negative, and 0 otherwise. (Assume that the sign of
       a 0 input is positive.) For example, a typical input signal
       with its associated zero-crossing signal would be

       ... 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 ...
       ... 0 0  0  0  0   -1   0  0  0   0   1  0 0 ...

       In Alyssa's system, the signal from the sensor is represented
       as a stream sense-data and the stream zero-crossings is the
       corresponding stream of zero crossings. Alyssa first writes a
       procedure sign-change-detector that takes two values as
       arguments and compares the signs fo the values to produce an
       appropriate 0, 1, or -1. She then constructs her zero-crossing
       stream as follows:

       #+BEGIN_SRC scheme
       (define (make-zero-crossings input-stream last-value)
        (cons-stream
         (sign-change-detector
          (stream-car input-stream)
          last-value)
         (make-zero-crossings 
          (stream-cdr input-stream)
          (stream-car input-stream))))
       (define zero-crossings
        (make-zero-crossings sense-data 0))
       #+END_SRC

       Alyssa's boss, Eva Lu Ator, walks by and suggests that this
       program is approximately equivalent to the following one, which
       uses the generalized version of stream-map from Exercise 3.50:

       #+BEGIN_SRC scheme
       (define zero-crossings
        (stream-map sign-change-detector
                    sense-data
                    (cons-stream 0 sense-data)))
       #+END_SRC
     
       Complete the program by supplying the indicated <expression>.

     - Exercise 3.75: Unfortunately, Alyssa's zero-crossing detector
       in Exercise 3.74 proves to be insufficient, because the noisy
       signal from the sensor leads to spurious zero crossings. Lem
       E. Tweakit, a hardware specialist, suggests that Alyssa smooth
       the signal to filter out the noise before extracting the zero
       crossings. Alyssa takes his advice and decides to extract the
       zero crossings from the signal constructed by averaging each
       value of the sense data with the previous value. She explains
       the problem to her assistant, Louis Reasoner, who attempts to
       implement the idea, altering Alyssa's program as follows:

       #+BEGIN_SRC scheme
       (define (make-zero-crossings input-stream last-value)
        (let ((avpt (/ (+ (stream-car input-stream)
                           last-value)
                        2)))
        (cons-stream
         (sign-change-detector avpt last-value)
         (make-zero-crossings
          (stream-cdr input-stream)
          avpt))))
       #+END_SRC

       This does not correctly implement Alyssa's plan. Find the bug
       that Louis has installed and fix it without changing the
       structure of the program (Hint: You will need to increase the
       number of arguments to make-zero-crossings.)

       The problem is that he's passing an average, and using that to
       make another average. You still need the old average to compare
       to the new average, but an average should not be used to create
       another average. 
       
       #+BEGIN_SRC scheme
       (define (make-zero-crossings input-stream last-value last-avg)
        (let ((avpt (/ (+ (stream-car input-stream)
                           last-value)
                        2)))
        (cons-stream
         (sign-change-detector avpt last-avg)
         (make-zero-crossings
          (stream-cdr input-stream)
          (stream-car input-stream) avpt))))
       #+END_SRC

     - Exercise 3.76: Eva Lu Ator has a criticism of Louis's approach
       in Exercise 3.75. The program he wrote is not modular, because
       it intermixes the operation of smoothing with the zero-crossing
       extraction. For example, the extractor should not have changed
       if Alyssa finds a better way to condition her input
       signal. Help Louis by writing a procedure smooth that takes a
       stream as input and produces a stream in which each element is
       the average of two successive input stream elements. Then use
       smooth as a component to implement the zero-crossing detector
       in a more modular style. 

       #+BEGIN_SRC scheme
       (define (smooth s)
         (cons-stream (/ (+ (stream-ref s 0)
                            (stream-ref s 1)) 2)
                      (stream-smooth (stream-cdr s))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define zero-crossings
        (let ((smoothed (smooth sense-data)))
         (stream-map sign-change-detector
                     smoothed
                    (cons-stream 0 smoothed))))
       #+END_SRC
     
*** 3.5.4 Streams and Delayed Evaluation
    The integral procedure at the end of the preceding section shows
    how we can use streams to model signal-processing systems that
    contain feedback loops. The feedback loop for the adder shown in
    Figure 3.32 is modeled by the fact that integral's internal stream
    int is defined in terms of itself:

    #+BEGIN_SRC scheme
    (define int
     (cons-stream
      initial-value
      (add-streams (scale-stream integrand dt)
                   int)))
    #+END_SRC

    The interpreter's ability to deal with such an implicit definition
    depends on the delay that is incorporated into
    cons-stream. Without this delay, the interpreter could not
    construct int before evaluating both arguments to cons-stream,
    which would require that int already be defined. In general, delay
    is crucial for using streams to model signal-processing systems
    that contain loops. Without delay, our models would have to be
    formulated so that the inputs to any signal-processing component
    would be fully evaluated before the output could be produced. This
    would outlaw loops.

    Unfortunately, stream models of systems with loops may require
    uses of delay beyond the "hidden" delay supplied by
    cons-stream. For instance, Figure 3.34 shows a signal-processing
    system for solving the differential equation dy/dt = f(y) where f
    is a given function. The figure shows a mapping component, which
    applies f to its input signal, linked in a feedback loop to an
    integrator in a manner very similar to that of the analog computer
    circuits that are actually used to solve such equations.

    Assuming we are given an initial value y_{0} for y, we could try
    to model this system using the procedure

    #+BEGIN_SRC scheme
    (define (solve f y0 dt)
     (define y (integral dy y0 dt))
     (define dy (stream-map f y))
     y)
    #+END_SRC

    This procedure does not work, because in the first line of solve
    the call to integral requires that the input dy be defined, which
    does not happen until the second line of solve.

    On the other hand, the intent of our definition does make sense,
    because we can, in principle, begin to generate the y stream
    without knowing dy. Indeed, integral and many other stream
    operations have properties similar to those of cons-stream, in
    that we can generate part of the answer given only partial
    information about the arguments. For integral, the first element
    of the output stream is the specified initial-value. Thus, we can
    generate the first element of the output stream without evaluating
    the integrand dy. Once we know the first element of y, the
    stream-map on the second line of solve can begin working to
    generate the first element of dy, which will produce the next
    element of y, and so on.

    To take advantage of this idea, we will redefine integral to
    expect the integrand stream to be a _delayed argument_. integral
    will force the integrand to be evaluated only when it is required
    to generate more than the first element of the output stream:

    #+BEGIN_SRC scheme
    (define (integral delayed-integrand initial-value dt)
     (define int
      (cons-stream 
       initial-value
       (let ((integrand (force delayed-integrand)))
        (add-streams (scale-stream integrand dt) int))))
     int)
    #+END_SRC

    Now we can implement our solve procedure by delaying the
    evaluation of dy in the definition of y:

    #+BEGIN_SRC scheme
    (define (solve f y0 dt)
     (define y (integral (delay dy) y0 dt))
     (define dy (stream-map f y))
     y)
    #+END_SRC

    In general, every caller of integral must now delay the integrand
    argument. We can demonstrate that the solve procedure works by
    approximating e ~ 2.718 by computing the value at y = 1 of the
    solution to the differential equation dy/dt = y with initial
    condition y(0) = 1:

    #+BEGIN_SRC scheme
    (stream-ref (solve (lambda (y) y) 1 0.001) 1000)
    ; => 2.716924
    #+END_SRC

    - Exercise 3.77: The integral procedure used above was analogous
      to the "implicit" definition of the infinite stream of integers
      in Section 3.5.2. Alternatively, we can give a definition to
      integral that is more like integers-starting-from (also in
      Section 3.5.2):

      #+BEGIN_SRC scheme
      (define (integral integrand initial-value dt)
       (cons-stream
        initial-value
        (if (stream-null? integrand)
            the-empty-stream
            (integral (stream-cdr integrand)
                      (+ (* dt (stream-car integrand))
                         initial-value)
                      dt))))
      #+END_SRC

      When used in systems with loops, this procedure has the same
      problem as does our original version of integral. Modify the
      procedure so that it expects the integrand as a delayed argument
      and hence can be used in the solve procedure shown above.

      #+BEGIN_SRC scheme
      (define (integral delayed-integrand initial-value dt)
       (cons-stream
        initial-value
        (let ((integrand (force delayed-integrand)))
        (if (stream-null? integrand)
            the-empty-stream
            (integral (delay (stream-cdr integrand))
                      (+ (* dt (stream-car integrand))
                         initial-value)
                      dt))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (integral delayed-integrand initial-value dt)
       (define (integral-iter integrand last-value)
        (if (stream-null? integrand)
            the-empty-stream
            (let ((this-value (+ (* dt (stream-car integrand)) last-value)))
            (cons-stream
             this-value
             (integral-iter (stream-cdr integrand) this-value)))))
       (cons-stream initial-value
                    (integral-iter (force delayed-integrand)  initial-value)))
      #+END_SRC

    - Exercise 3.78: Consider the problem of designing a
      signal-processing system to study the homogeneous second-order
      linear differential equation

      \frac{d^{2}y}{dt^{2}} - a\frac{dy}{dt} - by = 0

      The output stream, modeling _y_, is generated by a network that
      contains a loop. This is because the value of d^2y/dt^2 depends
      upon the values of y and dy/dt and both of these are determined
      by integrating d^2y/dt^2. The diagram we would like to encode is
      shown in Figure 3.35. Write a procedure solve-2nd that takes as
      arguments the constants _a_, _b_, and _dt_ and the initial
      values y_{0} and dy_{0} for y and dy/dt and generates the stream
      of successive values of y.
      #+BEGIN_SRC scheme
      (define (solve f y0 dt)
        (define solution (integral (delay diff) y0 dt))
        (define diff (stream-map f solution))
        solution)
      #+END_SRC
      #+BEGIN_SRC scheme
      (define (solve-2nd a b dt y0 dy0)
       (define y-stream (integral
                         (delay d-stream)
                         y0
                         dt))
       (define d-stream (integral
                         (delay double-deriv-stream)
                         dy0
                         dt))
       (define double-deriv-stream
               (add-streams
                (scale-stream y-stream a)
                (scale-stream d-stream b)))
        y-stream)
      #+END_SRC

    - Exercise 3.79: Generalize the solve-2nd procedure of Exercise
      3.78 so that it can be used to solve general second-order
      differential equations d^2y/dt^2 = f(dy/dt, y).

      #+BEGIN_SRC scheme
      (define (solve-2nd f dt y0 dy0)
       (define y (integral
                  (delay dy)
                  y0
                  dt))
       (define dy (integral
                   (delay ddy)
                   dy0
                   dt))
      (define ddy (stream-map f y dy))
      y)
      #+END_SRC

    - Exercise 3.80: A _series RLC circuit_ consists of a resistor, a
      capacitor, and an inductor connected in series, as shown in
      Figure 3.36. If R, L, and C are the resistance, inductance, and
      capacitance, then the relations between voltage (v) and current
      (i) for the three components are described by the equations

      v_{R} = i_{R}R, v_{L} = L\frac{di_{L}}{dt}, i_{C} =
      C\frac{d_{v_{C}}}{dt},

      and the circuit connections dictate the relations

      i_{R} = i_{L} = -i_{C}, v_{C} = v_{L} + v_{R}

      Combining these equations shows that the state of the circuit
      (summarized by v_{C}, the voltage across the capcitor, and
      i_{L}, the current in the inductor) is described by the pair of
      differential equations

      dv_{C}/dt = -i_{L}/C, di_{L}/dt = \frac{1}{L}v_{C} - \frac{R}{L}i_{L}.

      The signal-flow diagram representing this system of differential
      equations is shown in Figure 3.37.

      Write a procedure RLC that takes as arguments the parameters R,
      L, and C of the circuit and the time increment dt. In a manner
      similar to that of the RC procedure of Exercise 3.73, RLC should
      produce a procedure that takes the initial values of the state
      variables, v_{C_{0}} and i_{L_{0}}, and produces a pair (using
      cons) of the streams of states v_{C} and i_{L}. Using RLC,
      generate the pair of streams that models the behavior of a
      series RLC circuit with R = 1 ohm, C = 0.2 farad, L = 1 henry,
      dt = 0.1 second, and initial values i_{L_{0}} = 0 amps and
      v_{C_{0}} = 10 volts.

      #+BEGIN_SRC scheme
      (define (RLC R L C dt)
       (lambda (vc0 il0)
        (define il (integral
                    (delay dil)
                    il0
                    dt))
        (define dvc (scale-stream il (/ -1 C)))
        (define vc (integral
                    (delay dvc)
                    vc0
                    dt))
        (define dil (add-streams
                     (scale-stream 
                            il
                            (/ (* -1 R) L))
                     (scale-stream 
                            vc
                            (/ 1 L))))
       (cons il vc)))
      #+END_SRC

**** Normal-order evaluation
     The examples in this section illustrate how the explicit use of
     delay and force provides great programming flexibility, but the
     same examples also show hwo this can make our programs more
     complex. Our new integral procedure, for instance, gives us the
     power to model systems with loops, but we msut now remember that
     integral should be called with a delayed integrand, and every
     procedure that uses integral must be aware of this. In effect, we
     have created two classes of procedures: ordinary procedures and
     procedures that take delayed arguments. In general, creating
     separate classes of procedures forces us to create separate
     classes of higher-order procedures as well.

     One way to avoid the need for two different classes of procedures
     is to make all procedures take delayed arguments. We could adopt
     a model of evaluation in which all arguments to procedures are
     automatically delayed and arguments are forced only when they are
     actually needed (for example, when they are required by a
     primitive operation). This would transform our language to use
     normal-order evaluation, which we first described when we
     introduced the substitution model for evaluation in Section
     1.1.5. Converting to normal-order evaluation provides a uniform
     and elegant way to simplify the use of delayed evaluation, and
     this would be a natural strategy to adopt of we were concerned
     only with stream processing. In Section 4.2, after we have
     studied the evaluator, we will see how to transform our language
     in just this way. Unfortunately, including delays in procedure
     calls wreaks havoc with our ability to design programs that
     depend on the order of events, such as programs that use
     assignment, mutable data, or perform input or output. Even the
     single delay in cons-stream can cause great confution, as
     illustrated by Exercise 3.51 and Exercise 3.52. As far as anyone
     knows, mutability and delayed evaluation do not mix well in
     programming languages, and devising ways to deal with both of
     these at once is an active area of research. 

*** 3.5.5 Modularity of Functional Programs and Modularity of Objects

    As we saw in Section 3.1.2, one of the major benefits of
    introducing assignment is that we can increase the modularity of
    our systems by encapsulating, or "hiding", parts of the state of a
    large system within local variables. Stream models can provide an
    equivalent modularity without the use of assignment. As an
    illustration, we can reimplement the Monte Carlo estimation of pi,
    which we examined in Section 3.1.2, from a stream-processing point
    of view.

    The key modularity issue was that we wished to hide the internal
    state of a random-number generator from programs that used random
    numbers. We began with a procedure rand-update, whose successive
    values furnished our supply of random numbers, and used this to
    produce a random-number generator:

    #+BEGIN_SRC scheme
    (define rand
     (let ((x random-init))
      (lambda ()
       (set! x (rand-update x))
       x)))
    #+END_SRC

    In the stream formulation there is no random-number generator _per
    se_, just a stream of random numbers produced by successive calls
    to rand-update:
    
    #+BEGIN_SRC scheme
    (define random-numbers
     (cons-stream random-init
                  (stream-map rand-update random-numbers)))
    #+END_SRC

    We use this to construct the stream of outcomes of the Cesaro
    experiment performed on consecutive pairs in the random-numbers
    stream:

    #+BEGIN_SRC scheme
    (define cesaro-stream
     (map-successive-pairs
      (lambda (r1 r2) (= (gcd r1 r2) 1))
      random-numbers))
    (define (map-successive-pairs f s)
     (cons-stream
      (f (stream-car s) (stream-car (stream-cdr s)))
      (map-successive-pairs f (stream-cdr (stream-cdr s)))))
    #+END_SRC

    The cesaro-stream is now fed to a monte-carlo procedure, which
    produces a stream of estimates and probabilities. The results  are
    then converted into a stream of estimates of pi. This version of
    the program doesn't need a parameter telling how many trials to
    perform. Better estimates of pi (from performing more experiments)
    are obtained by looking further into the pi stream:

    #+BEGIN_SRC scheme
    (define (monte-carlo experiment-stream passed failed)
     (define (next passed failed)
      (cons-stream
       (/ passed (+ passed failed))
       (monte-carlo
        (stream-cdr experiment-stream) passed failed)))
     (if (stream-car experiment-stream)
         (next (+ passed 1) failed)
         (next passed (+ failed 1))))
    (define pi
     (stream-map
      (lambda (p) (sqrt (/ 6 p)))
      (monte-carlo cesaro-stream 0 0)))
    #+END_SRC

    There is considerable modularity in this approach, because we
    still can formulate a general monte-carlo procedure that can deal
    with arbitrary experiments. Yet there is no assignment or local
    state.

    - Exercise 3.81: Exercise 3.6 discussed generalizing the
      random-number generator to allow one to reset the random-number
      sequence so as to produce repeatable sequences of "random"
      numbers. Produce a stream formulation of this same generator
      that operates on an input stream of requests to generate a new
      random number or to reset the sequence to a specified value and
      that produces the desired stream of random numbers. Don't use
      assignment in your solution.

      #+BEGIN_SRC scheme
      ; see the wikipedia page on Linear Congruential Generator
      (define (rand-update x)
	      (define mod (expt 2 64))
	      (define mul 49)
	      (define c 1)
	      (remainder (+ (* mul x) c) mod))
      (define (random-numbers input-requests)
       (define (rand-stream last-num stream)
         (let ((new-num (if (eq? (stream-car stream) 'generate)
                            (rand-update last-num)
                            (rand-update (stream-car stream)))))
          (cons-stream
           new-num
           (rand-stream new-num (stream-cdr stream)))))
       (rand-stream (stream-car input-requests) (stream-cdr input-requests)))
      #+END_SRC

    - Exercise 3.82: Redo Exercise 3.5 on Monte Carlo integration in
      terms of streams. The stream version of estimate-integral will
      not have an argument telling how many trials to
      perform. Instead, it will produce a stream of estimates based on
      successively more trials. 

      #+BEGIN_SRC scheme
      (define (estimate-integral predicate x1 y1 x2 y2)
       (define gen-stream (cons-stream 'generate gen-stream))
       (define rand-stream (random-numbers (cons-stream 9 gen-stream)))
       (define (stream-map-doubles double-func stream)
        (cons-stream
         (double-func (stream-ref stream 0)
                    (stream-ref stream 1))
         (stream-map-doubles double-func (stream-cdr stream))))
       (define points (stream-map-doubles
                       (lambda (xi yi)
                         (list (+ x1 (/ (remainder xi (* 100 (- x2 x1))) 100.0))
                               (+ y1 (/ (remainder yi (* 100 (- y2 y1))) 100.0))))
                       rand-stream))
       (stream-map (lambda (est)
                    (* est (* (- y2 y1) (- x2 x1))))
                   (monte-carlo 
                    (stream-map
                     (lambda (x) (apply predicate x))
                      points) 0 0)))
      #+END_SRC

**** A functional-programming view of time      
     Let us now return to the issues of objects and state that were
     raised at the beginning of this chapter and examine them in a new
     light. We introduced assignment and mutable objects to provide a
     mechanism for modular construction of programs that model systems
     with state. We constructed computational objects with local state
     variables and used assignment to modify these variables. We
     modeled the temporal behavior of the objects in the world by the
     temporal behavior of the corresponding computational objects.

     Now we have seen that streams provide an alternative way to model
     objects with local state. We can model a changing quantity, such
     as the local state of some object, using a stream that represents
     the time history of successive states. In essence, we represent
     time explicitly, using streams, so that we decouple time in our
     simulated world from the sequence of events that take place
     during evaluation. Indeed, because of the presence of delay there
     may be little relation between simulated time in the model and
     the order of events during the evaluation. 

     In order to contrast these two approaches to modeling, let us
     reconsider the implementation of a "withdrawal processor" that
     monitors the balance in a bank account. In Section 3.1.3 we
     implemented a simplified version of such a processor:

     #+BEGIN_SRC scheme
     (define (make-simplified-withdraw balance)
      (lambda (amount)
       (set! balance (- balance amount))
       balance))
     #+END_SRC

     Calls to make-simplified-withdraw produce computational objects,
     each with a local state variable balance that is decremented by
     successive calls to the object. The object takes an amount as an
     argument and returns the new balance. We can imagine the user of
     a bank account typing a sequence of inputs to such an object and
     observing the sequence of returned values shown on a display
     screen.

     Alternatively, we can model a withdrawal processor as a procedure
     that takes as input a balance and a stream of amounts to withdraw
     and produces the stream of successive balances in the account:

     #+BEGIN_SRC scheme
     (define (stream-withdraw balance amount-stream)
      (cons-stream
       balance
       (stream-withdraw (- balance (stream-car amount-stream))
                        (stream-cdr amount-stream))))
     #+END_SRC

     stream-withdraw implements a well-defined mathematical function
     whose output is fully determined by its input. Suppose, however,
     that the input amount-stream is the stream of successive values
     typed by the user and the resulting stream of balances is
     displayed. Then, from the perspective of the user who is typing
     values and watching results, the stream process has the same
     behavior as the object created by
     make-simplified-withdraw. However, with the stream version, there
     is no assignment, no local state variable, and consequently none
     of the theoretical difficulties that we encountered in Section
     3.1.3. Yet the system has state!

     This is really remarkable. Even though stream-withdraw implements
     a well-defined mathematical function whose behavior does not
     change, the user's perception here is one of interacting with a
     system that has a changing state. One way to resolve this paradox
     is to realize that it is the user's temporal existence that
     imposes state on the system. If the user could step back from the
     interaction and think in terms of streams of balances rather than
     individual transactions, the system would appear stateless.

     From the point of view of one part of a complex process, the
     other parts appear to change with time. They have hidden
     time-varying local state. If we wish to write programs that model
     this kind of natural decomposition in our world (as we see it
     from our viewpoint as a part of that world) with structures in
     our computer, we make computational objects that are not
     functional -- they must change with time. We model state with
     local state variables, and we model the changes of state with
     assignments to those variables. By doing this we make the time of
     execution of a computation model time in the world we are part
     of, and thus we get "objects" in our computer.

     Modeling with objects is powerful and intuitive, largely because
     this matches the perception of interacting with a world of which
     we are part. However, as we've seen repeatedly throughout this
     chapter, these models raise thorny problems of constraining the
     order of events and of synchronizing multiple processes. The
     possibility of avoiding these problems has stimulated the
     development of _functional programming languages_, which do not
     include any provision for assignment or mutable data. In such a
     language, all procedures implement well-defined mathematical
     functions of their arguments, whose behavior does not change. The
     functional approach is extremely attractive for dealing with
     concurrent systems.

     On the other hand, if we look closely, we can see time-related
     problems creeping into functional models as well. One
     particularly troublesome area arises when we wish to design
     interactive systems, especially ones that model interactions
     between independent entities. For instance, consider once more
     the implementation a banking system that permits joint bank
     accounts. In a conventional system using assignment and objects,
     we would model the fact that Peter and Paul share an account by
     having both Peter and Paul send their transaction requests to the
     same bank-account object, as we saw in Section 3.1.3. From the
     stream point of view, where there are no "objects" per se, we
     have already indicated that a bank account can be modeled as a
     process that operates on a stream of transaction requests to
     produce a stream of responses. Accordingly, we could model the
     fact that Peter and Paul have a joint bank account by merging
     Peter's stream of transaction requests with Paul's stream of
     requests and feeding the result to the bank-account stream
     process, as shown in Figure 3.38.

     The trouble with this formulation is the notion of _merge_. It
     will not do to merge the two streams by simply taking alternately
     one request from Peter and one request from Paul. Suppose Paul
     accesses the account only very rarely. We could hardly force
     Peter to wait for Paul to access the account before he could
     issue a second transaction. However such a merge is implemented,
     it must interleave the two transaction streams in some way that
     is constrained by "real time" as perceived by Peter and Paul, in
     the sense that, if Peter and Paul meet, they can agree that
     certain transactions were processed before the meeting, and other
     transactions were processed after the meeting. This is precisely
     the same constraint that we had to deal with in Section 3.4.1,
     where we found the need to introduce explicit synchronization to
     ensure a "correct" order of events in concurrent processing of
     objects with state. Thus, in an attempt to support the functional
     style, the need to merge inputs from different agents
     reintroduces the same problems that the functional style was
     meant to eliminate.

     We began this chapter with the goal of building computational
     models whose structure matches our perception of the real world
     we are trying to model. We can model the world as a collection of
     separate, time-bound, interacting objects with state, or we can
     model the world as a single, timeless, stateless unity. Each view
     has powerful advantages, but neither view alone is completely
     satisfactory. A grand unification has yet to emerge.

     
      
      

      

      
