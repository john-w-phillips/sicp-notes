**** blah
     - Exercise 3.51 In order to take a closer look at delayed
       evaluation, we will use the following procedure, which simply
       returns its argument after printing it:

       #+BEGIN_SRC scheme
       (define (show x)
        (display-line x)
        x)
       #+END_SRC

       What does the interpreter print in response to evaluating each
       expression in the following sequence?

       #+BEGIN_SRC scheme
       (define (stream-ref s n)
        (if (= n 0) (stream-car s) (stream-ref (stream-cdr s) (- n 1))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-map fun s)
        (if (empty-stream? s)
            the-empty-stream
            (stream-cons (fun (stream-car s))
                         (stream-map fun (stream-cdr s)))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define x
               (stream-map show
                           (stream-enumerate-interval 0 10)))
       (stream-ref x 5)
       (stream-ref x 7)
       #+END_SRC

       first statement:
       #+BEGIN_SRC scheme
       0
       #+END_SRC

       second statement:
       #+BEGIN_SRC scheme
       1
       2
       3
       4
       5
       #+END_SRC

       third statement:
       #+BEGIN_SRC scheme
       6
       7
       #+END_SRC

     - Exercise 3.52: Consider the sequence of expressions

       #+BEGIN_SRC scheme
       (define sum 0)
       (define (accum x) (set! sum (+ x sum)) sum)
       (define seq
               (stream-map accum
                           (stream-enumerate-interval 1 20)))
       (define y (stream-filter even? seq))
       (define z
               (stream-filter (lambda (x) (= (remainder x 5) 0))
                              seq))
       (stream-ref y 7)
       (display-stream z)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-filter pred seq)
        (if (stream-empty? seq) 
            the-empty-stream
            (if (pred (stream-car seq))
                (cons-stream (stream-car seq)
                             (stream-filter pred (stream-cdr stream)))
                (stream-filter pred (stream-cdr stream)))))
       #+END_SRC

       The basic sequence is:
       1 3 6 10 15 21 28 36 45 55  66  78  91  105 120 136 153 171 190 
       1 2 3 4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19 
       What is the value of sum after each of the above expressions is
       evaluated? What is the printed response to evaluating the
       stream-ref and display-stream expressions? Would these
       responses differ if we had implemented (delay <exp>) simply as
       (lambda () <exp>) without using the optimization provided by
       memo-proc? Explain.

       After defining seq: 1
       After defining y: 6
       After defining z: 10
       After evaluating (stream-ref y 7): 136
       After evaluating (display-stream z): 190

       The value would have been different, because we would have had
       to re-calculate the sequence values every time we re-iterated
       the sequence, which would have involved calling accum since we
       use stream-map. Accum would have then added values to sum every
       time, so each time we evaluated we would get larger values.
       
*** 3.5.2 Infinite streams

    We have seen how to support the illusion of manipulating streams
    as complete entities even though, in actuality, we compute only as
    much of the streams as we need to access. We can exploit this
    technique to represent sequences efficiently as streams, even if
    the sequences are very long. What is more striking, we can use
    streams to represent sequences that are infinitely long. For
    instance, consider the following definition of the stream of
    positive integers:

    #+BEGIN_SRC scheme
    (define (integers-starting-from n)
     (cons-stream n (integers-starting-from (+ n 1))))
    (define integers (integers-starting-from 1))
    #+END_SRC

    This makes sense because integers will be a pair whose car is 1
    and whose cdr is a promise to produce the integers beginning
    with 2. This is an infinitely long tream, but in any given time we
    can examine only a finite protion of it. Thus, our programs will
    never know that the entire infinite stream is not there.

    Using integers we can define other infinite streams, such as the
    stream of integers that are not divisible by 7:

    #+BEGIN_SRC scheme
    (define (divisble? x y) (= (remainder x y) 0))
    (define no-sevens
            (stream-filter (lambda (x) (not (divisible? x 7)))
                           integers))
    #+END_SRC

    Then we can find integers not divisible by 7 simply by accessing
    elements of this stream:

    #+BEGIN_SRC scheme
    (stream-ref no-sevens 100)
    #+END_SRC

    In analogy with integers, we can define the infinite stream of
    Fibonacci numbers:

    #+BEGIN_SRC scheme
    (define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
    (define fibs (fibgen 0 1))
    #+END_SRC

    fibs is a pair whose car is 0 and whose cdr is a promise to
    evaluate (fibgen 1 2), and so on.

    For a look at a more exciting infinite stream, we can generalize
    the no-sevens example to construct the infinite stream of prime
    numbers, using a method known as the _sieve of Eratosthenes_. We
    start with the integers beginning with 2, which is the first
    prime. To get the rest of hte primes, we start by filtering out
    the multiples of 2 from the rest of the integers. This leaves a
    stream beginning with 5, which is the next prime, and so on. In
    other words, we construct the primes by a sieving process,
    described as follows: To sieve a stream S, form a stream whose
    first element is the first element of S and the rest of which is
    obtained by filtering out all multiples of the first element of S
    out of the rest of S and sieving the result. This process is
    readily described in terms of stream operations:
    
    #+BEGIN_SRC scheme
    (define (sieve stream)
     (cons-stream
      (stream-car stream)
      (sieve (stream-filter
              (lambda (x)
               (not (divisible? x (stream-car stream))))
              (stream-cdr stream)))))
    (define primes (sieve (integers-starting-from 2)))
    #+END_SRC

    Now to find a particular prime we need only ask for it:

    #+BEGIN_SRC scheme
    (stream-ref primes 50)
    233
    #+END_SRC

    It is interesting to contemplate the signal-processing system set
    up by sieve, shown in the "Henderson diagram" in Figure 3.31. The
    input stream feeds into an "unconser" that separates the first
    element of the stream from the rest of the stream. The first
    element is used to construct a divisibility filter, through which
    the rest is passed, and the output of the filter is fed to another
    sieve box. Then the original first element is consed onto the
    output of the itnernal sieve to form the output stream. Thus, not
    only is the stream infinite, but the signal processor is also
    infinite, because the sieve contains a sieve within it. 

**** Defining streams implicitly
     
     The integers and fibs streams above were defined by specifying
     "generating" procedures that explicitly compute the stream
     elements one by one. An alternative way to specify streams is to
     take advantage of delayed evaluation to define streams
     implicitly. For example, the following expression defines the
     stream ones to be an infinite stream of ones:

     #+BEGIN_SRC scheme
     (define ones (cons-stream 1 ones))
     #+END_SRC

     This works much like the definition of a recursive procedure:
     ones is a pair whose car is 1 and whose cdr is a promise to
     evaluate ones. Evaluating the cdr gives us again a 1 and a
     promise to evaluate ones, and so on.

     We can do more interesting things by manipulating streams with
     operations such as add-streams, which produces the elementwise
     sum of two given streams:

     #+BEGIN_SRC scheme
     (define (add-streams s1 s2) (stream-map + s1 s2))
     #+END_SRC

     Now we can define the integers as follows:

     #+BEGIN_SRC scheme
     (define integers
             (cons-stream 1 (add-streams ones integers)))
     #+END_SRC

     This defines integers to be a stream whose first element is 1 and
     the rest of which is the sum of ones and integers. Thus, the
     second element of integers is 1 plus the first element of
     integers, or 3; and so on. This definition works because, at any
     point, enough of the integers stream has been generated so that
     we can feed it back into the definition and produce the next
     integer. 

     We can define the Fibonacci numbers in the same style:

     #+BEGIN_SRC scheme
     (define fibs
      (cons-stream
       0
       (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
     #+END_SRC

     This definition says that fibs is a stream beginning with 0 and
     1, such that the rest of the stream can be generated by adding
     fibs to itself shifted by one place:

     #+BEGIN_SRC scheme
           1  1  2  3  5  8   13  21  ...  = (stream-cdr fibs)
           0  1  1  2  3  5   8   13  ...  = fibs
     0  1  1  2  3  5  8  13  21  34  ...  = fibs
     #+END_SRC
    

     scale-stream is another useful procedure in formulating such
     stream definitions. This multiplies each item in a stream by a
     given constant:

     #+BEGIN_SRC scheme
     (define (scale-stream stream factor)
      (stream-map (lambda (x) (* x factor))
                  stream))
     #+END_SRC

     For example,

     #+BEGIN_SRC scheme
     (define double (cons-stream 1 (scale-stream double 2)))
     #+END_SRC

     produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, ...

     An alternate definition of the stream of primes can be given by
     starting with the integers and filtering them by testing for
     primality. We will need the first prime, 2, to get started:

     #+BEGIN_SRC scheme
     (define primes
      (cons-stream
       2
       (stream-filter prime? (itnegers-starting-from 3))))
     #+END_SRC

     This definition is not so straightforward as it appears, because
     we will test whether a number _n_ is prime by checking whetehr
     _n_ is divisible by a prime (not by just any integer) less than
     or equal to sqrt(n):

     #+BEGIN_SRC scheme
     (define (prime? n)
      (define (iter ps)
       (cons ((> (square (stream-car ps)) n) true)
             ((divisible? n (stream-car ps)) false)
             (else (iter (stream-cdr ps)))))
      (iter primes))
     #+END_SRC

     This is a recursive definition, since primes is defined in terms
     of the prime? predicate, which itself uses the primes stream. The
     reason this procedure works is that, at any point, enough of the
     primes stream has been generated to test the primality of the
     numbers we need to check next. That is, for every _n_ we test for
     primality, either _n_ is not prime (in which case there is a
     prime already generated that divides it) or _n_ is prime (in
     which case there is a prime already generated -- i.e., a prime
     less than _n_ -- that is greater than sqrt(n)). 


     - Exercise 3.53: Without running the program, describe the
       elements of the stream defined by

       #+BEGIN_SRC scheme
       (define s (cons-stream 1 (add-streams s s)))
       #+END_SRC

       1 2 4 8 16 ...
       
       The powers of two.

     - Exercise 3.54: Define a procedure mul-streams, analogous to
       add-streams, that produces the elementwise product of its two
       input streams. Use this together with the stream of integers to
       complete the following definition of the stream whose nth
       element (counting from 0) is n + 1 factorial:

       #+BEGIN_SRC scheme
       (define factorials
        (cons-stream 1 (mul-streams <??> <??>)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (mul-streams s1 s2) (stream-map * s1 s2))
       (define factorials
        (cons-stream 1 (mul-streams factorials (integers-starting-from 2))))
       #+END_SRC

     - Exercise 3.55: Define a procedure partial-sums that takes as
       argument a stream S and returns the stream whose elements are
       S_0, S_0 + S_1, S_0 + S_1 + S_2, .... For example,
       (partial-sums integers) should be the stream 1, 3, 6, 10,
       15,...

       #+BEGIN_SRC scheme
       (define (partial-sums s)
        (cons-stream
         (stream-car s)
         (partial-sums
          (cons-stream (+ (stream-car s)
                          (stream-car (stream-cdr s)))
                       (stream-cdr (stream-cdr s))))))
       #+END_SRC

     - Exercise 3.56: A famous problem, first raised by R. Hamming, is
       to enumerate, in ascending order with no repititions, all
       positive integers with no prime factors other than 2, 3,
       or 5. One obvious way to do this is to simply test each integer
       in turn to see whether it has any factors other than 2, 3,
       and 5. One obvious way to do this is to simply test each
       integer in turn to see whether it has any factors other than 2,
       3, and 5. But this is very inefficient, since, as the integers
       get larger, fewer and fewer of them fit the requirement. As an
       alternative, let us call the required stream of numbers S and
       notice the following facts about it.

       - S begins with 1.

       - The elements of (scale-stream S 2) are also elements of S.

       - The same is true for (scale-stream S 3) and (scale-stream 5
         S).

       - These are all the elements of S.

       Now all we have to do is combine elements from these
       sources. For this we define a procedure merge that combines two
       ordered streams into one ordered result stream, eliminating
       repetitions:

       #+BEGIN_SRC scheme
       (define (merge s1 s2)
       (cond ((stream-null? s1) s2)
       ((stream-null? s2) s1)
       (else
       (let ((s1car (stream-car s1))
       (s2car (stream-car s2)))
       (cond ((< s1car s2car)
       (cons-stream
       s1car
       (merge (stream-cdr s1) s2)))
       ((> s1car s2car)
       (cons-stream
       s2car
       (merge s1 (stream-cdr s2))))
       (else (cons-stream
       s1car
       (merge (stream-cdr s1)
       (stream-cdr s2)))))))))
       #+END_SRC
       
       Then the required stream may be constructed with merge, as follows:

       #+BEGIN_SRC scheme
       (define S (cons-stream 1 (merge (scale-stream S 2)
       (merge (scale-stream S 3)
       (scale-stream S 5)))))
       #+END_SRC

     - Exercise 3.57: How many additions are performed when we compute
       the _nth_ Fibonacci number using the definition of fibs based
       on the add-streams procedure? Show that the number of
       additions would be exponentially greater if we had implemented
       (delay <exp>) simply as (lambda () <exp>), without using the
       optimization provided by the memo-proc procedure described in
       Section 3.5.1. 

       #+BEGIN_SRC scheme
       (define fibo (cons-stream 0 
                     (cons-stream 1
                      (add-streams fibo (stream-cdr fibo)))))
       #+END_SRC

       the nth fibonacci number is defined as basically
       (stream-map + fibo (stream-cdr fibo)), where fibo is already
       'defined' up to n. If we didn't save this, when we compute a
       fibo number, we have to compute the entire stream back up to n
       -1 and n - 2, taking roughly twice as long as n-1. Since each
       time we go up in n we multiply runtime by two, we end up with
       2^n.

       However, if we save the results of our computations, the
       branching basically doesn't happen. For each element in the
       stream, we add the previous two, which, if we saved the results
       and are computing this current element, are already defined,
       and have O(n) access time. So we end up with O(n^2) runtime.

     - Exercise 3.58: Give an interpretation of the stream computed by
       the following procedure:

       #+BEGIN_SRC scheme
       (define (expand num den radix)
        (cons-stream
         (quotient (* num radix) den)
         (expand (remainder (* num radix) den) den radix)))
       #+END_SRC

       (quotient is a primitive that returns the integer quotient of
       two integers.) What are the successive elements produced by
       (expand 1 7 10)? What is produced by (expand 3 8 10)?

       (expand 1 7 10)
       1 
       (expand 3 7 10)
       4
       (expand 2 7 10)
       2
       (expand 6 7 10)
       8
       (expand 4 7 10)
       5
       (expand 5 7 10)
       7
       (expand 1 7 10)
       1     

       It's a repeating sequence. It always loops around, repeating
       the same set of values, 1 4 2 8 5 7. We 'tried' as num all
       numbers between 1 and 7 (exclusive of 7), and if any of them
       had divided evenly, we would have converged to 0 and been
       expanding 0 permanently for infinity. But none of these values,
       multiplied by ten, had a common factor with seven. We got as
       outputs all the quotients of multiplies of ten when the
       multiplier is between [1, 7). For example, 3 is not an output
       because (3x7) = 21 is not a quotient of any multiple of
       ten. Any time a denominator is relatively prime to the num and
       radix both, you will get an infinite repeating sequence of
       values. Otherwise, you will converge to zero and exit.

       (expand 3 8 10)
       3
       (expand 6 8 10)
       7
       (expand 4 8 10)
       5
       (expand 0 8 10)
       0
       ....

       This expansion does not repeat the same set of values over and
       over, it converges to 0, and repeats 0 forever.

       I think that any time den and either num or radix have common
       factors, you convege to zero. Otherwise, you end up with a
       repeating set of values.

     - Exercise 3.59: In Section 2.5.3 we saw how to implement a
       polynomial arithmetic system representing polynomials as lists
       of terms. In a similar way, we can work with _power series_,
       such as 

       #+BEGIN_EXAMPLE
       e^x = 1 + x x^2/2 + x^3/(3 * 2) + x^4/(4 * 3 * 2) + ...,
       cos x = 1 - x^2/2 + x^4/(4 * 3 * 2) - ...
       sin x = x - x^3/(3 * 2) + x^5/(5 * 4 * 3 * 2) - ...
       #+END_EXAMPLE

       represented as infinite streams. We will represent the series
       a_0 + a_1*x + a_2*x^2 + a_3*x^3 + ... as the stream whose
       elements are the coefficients a_0, a_1, a_2, a_3, ...

       a. The integral of the series a_0 + a_1*x + a_2*x^2 + a_3*x^3 +
       ... is the series

       \begin{series}
       c + a_{0}x + \frac{1}{2}a_{1}x^{2} + \frac{1}{3}a_{2}x^{3} + \frac{1}{4}a_{3}x^{4} + ...
       \end{series}

       where _c_ is any constant. Define a procedure integrate-series
       that takes as input a stream a_0, a_1, a_2, ... representing a
       power series and returns the stream a_0, 1/2a_1, 1/3a_2, ... of
       coefficients of the non-constant terms of the integral of the
       series. (Since the result has no constant term, it doesn't
       represent a power series; when we use integrate-series, we will
       cons on the appropriate constant.)

       #+BEGIN_SRC scheme
       (define (integrate-series coefficients)
        (define (integrate-inner current-denom stream)
          (cons-stream
           (* (/ 1.0 current-denom) (stream-car stream))
           (integrate-inner (+ 1 current-denom) (stream-cdr stream))))
        (integrate-inner 1 coefficients))
       #+END_SRC

       b. The function x -> e^x is its own derivative. This implies
       that e^x and the integral of e^x are the same series, except
       for the constant term, which is e^0 = 1. Accordingly, we can
       generate the series for e^x as

       #+BEGIN_SRC scheme
       (define exp-series
        (cons-stream 1 (integrate-series exp-series)))
       #+END_SRC

       Show how to generate the series for sine and cosine, starting
       from the facts that the derivative of sine is cosine and the
       derivative of cosine is the negative of sine:

       #+BEGIN_SRC scheme
       (define (negate stream)
        (cons-stream (* -1 (stream-car stream))
                     (negate (stream-cdr stream))))
       (define cosine-series (cons-stream 1.0 (negate (integrate-series sine-series))))
       (define sine-series (cons-stream 0.0 (integrate-series cosine-series)))
       #+END_SRC

     - Exercise 3.60: With power series represented as streams of
       coefficients as in Exercise 3.59, adding series is implemented
       by add-streams. Complete the definition of the following
       procedure for multiplying series:

       #+BEGIN_SRC scheme
       (define (mul-series s1 s2)
        (cons-stream <??> (add-streams <??> <??>)))
       #+END_SRC

       You can test your procedure by verifying that sin^2 x + cos^2 x
       = 1, using the series from Exercise 3.59. 

       #+BEGIN_SRC scheme
       (define (mul-series s1 s2)
        (cons-stream (* (stream-car s1) (stream-car s2))
                     (add-streams
                      (add-streams
                       (scale-stream (stream-car s1) (stream-cdr s2))
                       (scale-stream (stream-car s2) (stream-cdr s1)))
                      (cons-stream 0
                       (mul-series (stream-cdr s1) (stream-cdr s2))))))
       #+END_SRC

     - Exercise 3.61: Let _S_ be a power series (Exercise 3.59) whose
       constant term is 1. Suppose we want to find the power series
       1/S, that is, the series X such that SX = 1. Write S = 1 + S_R
       where S_R is the part of S after the constant term. Then we can
       solve for X as follows:

               S * X = 1
       (1 + S_R) * X = 1
         X + S_R * X = 1
                   X = 1 - S_R * X.

       In other words, X is the power series whose constant term is 1
       and whose higher-order terms are given by the negative of S_R
       times X. Use this idea to write a procedure invert-unit-series
       that computes 1/S for a power series S with constant
       term 1. You will need to use mul-series from Exercise 3.60.

       #+BEGIN_SRC scheme
       (define (invert-unit-series s)
        (cons-stream
         1
         (negate (mul-series (stream-cdr s)
                             (invert-unit-series s)))))
       #+END_SRC

     - Exercise 3.62: Use the results of Exercise 3.60 and Exercise
       3.61 to define a procedure div-series that divides two power
       series. div-series should work for any two series, provided
       that the denominator series begins with a nonzero constant
       term. (If the denominator has a zero constant term, then
       div-series should signal an error.) Show how to use div-series
       together with the result of Exercise 3.59 to generate the power
       series for tangent.

       #+BEGIN_SRC scheme
       (define (div-series s1 s2)
        (if (not (= 1 (stream-car s2)))
            (error "Denominator must begin with 1 -- DIV-SERIES" s2)
            (mul-series s1 (invert-unit-series s2))))
       (define tan-series (div-series sine-series cosine-series))
       #+END_SRC

       An important thing to note is that the valid range of this
       function is between -0.5PI to 0.5PI. After that it makes no
       sense. Inverted cosine also has a narrow range of valid
       behavior.

*** 3.5.3. Exploiting the Stream Paradigm

    Streams with delayed evaluation can be a powerful modeling tool,
    providing many of the benefits of local state and
    assignment. Moreover, they avoid some of the theoretical tangles
    that accompany the introduction of assignment into a programming
    language.

    The stream approach can be illuminating because it allows us to
    build systems with different module boundaries than systems
    organized around assignment to state variables. For example, we
    can think of an entire time series (or signal) as a focus of
    interest, rather than the values of the state variables at
    individual moments. This makes it convenient to combine and
    compare components of state from different moments.


**** Formulating iterations as stream processes

     In Section 1.2.1, we introduced iterative processes, which
     proceed by updating state variables. We know now that we can
     represent state as a "timeless" stream of values rather than as a
     set of variables to be updated. Let's adopt this perspective in
     revisiting the square-root procedure from Section 1.1.7. Recall
     that the idea is to generate a sequence of better and better
     guesses for the square root of _x_ by applying over and over
     again the procedure that improves guesses:

     #+BEGIN_SRC scheme
     (define (sqrt-improve guess x)
      (average guess (/ x guess)))
     #+END_SRC

     In our original sqrt procedure, we made these guesses be the
     successive values of a state variable. Instead we can generate
     the infinite stream of guesses, starting with an initial guess of
     1:

     #+BEGIN_SRC scheme
     (define (sqrt-stream x)
      (define guesses
       (cons-stream
        1.0
        (stream-map (lambda (guess) (sqrt-improve guess x))
                    guesses)))
      guesses)

     (display-stream (sqrt-stream 2))
     1.
     1.5
     1.416666
     1.412156
     1.414213
     ...
     #+END_SRC

     We can generate more and more terms of the stream to get better
     and better guesses. If we like, we can write a procedure that
     keeps generating terms until the answer is good enough. (See
     Exercise 3.64)

     Another iteration that we can treat in the same way is to
     generate an approximation to pi, based upon the alternating
     series that we saw in Section 1.3.1:

     \begin{eq}
     \frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} +
     ...
     \end{eq}

     We first generate the stream of summands of the series (the
     reciprocals of the odd integers, with alternating signs). Then we
     take the stream of sums of more and more terms (using the
     partial-sums procedure of Exercise 3.55) and scale the result by
     4:

     #+BEGIN_SRC scheme
     (define (pi-summands n)
      (cons-stream (/ 1.0 n)
                   (stream-map - (pi-summands (+ n 2)))))
     (define pi-stream
      (scale-stream (partial-sums (pi-summands 1)) 4))

     (display-stream pi-stream)
     4.
     2.66666
     2.46666
     2.89523
     3.33968
     2.97604
     3.28373
     3.01707
     #+END_SRC

     This gives us a stream of better and better approximations of pi,
     although the approximations converge rather slowly. Eight terms
     of the sequence bound the value of pi between 3.284 and 3.017. 

     So far, our use of the stream of states approach is not much
     different from updating state variables. But streams give us an
     opportunity to do some interesting tricks. For example, we can
     transform a stream with a _sequence accelerator_ that converts a
     sequence of approximations to a new sequence that converges to
     the same value as the original, only faster.

     One such accelerator, due to the eighteenth-century Swiss
     mathematician Leonhard Euler, works well with sequences that are
     partial sums of alternating series (series of terms with
     alternating signs). In Euler's technique, if S_n is the nth term
     of the original sum sequence, then the accelarated sequence has
     the terms

     S_{n+1} - \frac{(S_{n+1} - S_{n})^2}{S_{n-1} - 2S_{n} + S_{n+1}}

     Thus, if the original sequence is represented as a stream of
     values, the transformed sequence is given by

     #+BEGIN_SRC scheme
     (define (euler-transform s)
      (let ((s0 (stream-ref s 0))
            (s1 (stream-ref s 1))
            (s2 (stream-ref s 2)))
       (cons-stream (- s2 (/ (square (- s2 s1))
                             (+ s0 (* -2 s1) s2)))
                    (euler-transform (stream-cdr s)))))
     #+END_SRC

     We can demonstrate Euler acceleration with our sequence of
     approximations of pi:

     #+BEGIN_SRC scheme
     (display-stream (euler-transform pi-stream))
     3.16666
     3.13333
     3.14523
     3.13968
     3.14271
     3.14088
     3.14207
     3.14125
     #+END_SRC

     Even better, we can accelerate the accelerated sequence, and
     recursively accelerate that, and so on. Namely, we create a
     stream of streams (a structure we'll call a _tableau_) in which
     each stream is the transform of the preceding one:

     #+BEGIN_SRC scheme
     (define (make-tableau transform s)
      (cons-stream s (make-tableau transform (transform s))))
     #+END_SRC
     
     The tableau has the form

     \begin{sequence}
     S_{00} S_{01} S_{02} S_{03} S_{04} ...
            S_{10} S_{11} S_{12} S_{13} ...
                   S_{20} S_{21} S_{22} ...
                          ...
     \end{sequence}

     Finally, we form a sequence by taking the first term in each row
     of the tableau:

     #+BEGIN_SRC scheme
     (define (accelerated-sequence transform s)
      (stream-map stream-car (make-tableau transform s)))
     #+END_SRC

     We can demonstrate this kind of "super-acceleration" of the pi
     sequence:

     #+BEGIN_SRC scheme
     (display-stream
      (accelerated-sequence euler-transform pi-stream))
     4. 
     3.166666
     3.142105
     3.141599
     3.141592
     #+END_SRC

     The result is impressive. Taking eight terms of the sequence
     yields the correct value of pi to 14 decimal places. If we had
     used only the original pi sequence, we would need to compute on
     the order of 10^13 terms (i.e. expanding the series far enough so
     that the individual terms are less than 10^-13) to get that much
     accuracy!

     We could have implemented these acceleration techniques without
     using streams. But the stream formulation is particularly elegant
     and convenient because the entire sequence of states is available
     to us as a data structure that can be manipulated with a uniform
     set of operations.

     - Exercise 3.63: Louis Reasoner asks why the sqrt-stream
       procedure was not written in the following more straightforward
       way, without the local variable guesses:

       #+BEGIN_SRC scheme
       (define (sqrt-stream x)
        (cons-stream 1.0 (stream-map
                          (lambda (guess)
                           (sqrt-improve guess x))
                          (sqrt-stream x))))
       #+END_SRC

       Alyssa P. Hacker replies that this version of the procedure is
       considerably less efficient because it performs redundant
       computation. Explain Alyssa's answer. Would the two versions
       still differ in efficiency if our implementation of delay used
       only (lambda () <exp>) without using the optimization provided
       by memo-proc (Section 3.5.1)?

       It is inefficient because it creates a copy of sqrt-stream each
       time it gets to the recursive case. So originally we have

       1 .. (stream-map (lambda (guess) (sqrt-improve guess x))
       (sqrt-stream x))

       which in turn computes
       1 .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
       (sqrt-stream x)))

       1 
       .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
           (sqrt-stream x))) 
       .. ((lambda (guess) (sqrt-improve guess x)) (stream-car
           (stream-cdr (sqrt-stream x))))

       and so on. Although the stream (sqrt-stream x) at least saves
       its own past, so _that_ isn't as inefficient, we end up
       computing each value twice, because the (sqrt-stream x) stream
       generated by the inner call to sqrt-stream is a separate
       stream. So each of the mapping calls re-generates a value we
       just computed previously.

     - Exercise 3.64: Write a procedure stream-limit that takes as
       arguments a stream and a number (the tolerance). It should
       examine the stream until it finds two successive elements that
       differ in absolute value by less than the tolerance, and return
       the second of the two elements. Using this, we could compute
       square roots up to a given tolerance by

       #+BEGIN_SRC scheme
       (define (sqrt x tolerance)
        (stream-limit (sqrt-stream x) tolerance))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (stream-limit s tolerance)
         (define (iter stream last-value)
           (if (<= (abs (- (stream-car stream) last-value))
                   tolerance)
               (stream-car stream)
               (iter (stream-cdr stream) (stream-car stream))))
         (iter (stream-cdr s) (stream-car s)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (sqrt-improve guess sqrt-of)
        (/ (+ guess (/ sqrt-of guess)) 2))
       #+END_SRC

     - Exercise 3.65: Use the series

       ln 2 = 1 - 1/2 + 1/3 - 1/4 + ...

       to compute three sequences of approximations to the natural
       logarithm of 2, in the way we did above for pi. How rapidly do
       these sequences converge?
     
       #+BEGIN_SRC scheme
       (define (sum-stream n s) 
        (define (iter value i stream) 
         (if (> i n) 
             value
             (iter (+ value 
                      (stream-car stream))
     	           (+ i 1)
                   (stream-cdr stream))))
         (iter 0 0 s))
                      
       (define (ln2-stream) 
        (define (iter i sign) (cons-stream (* sign (/ 1 i)) 
                                           (iter (+ i 1) (* sign -1))))
	      (iter 1 1))
       (define ln2 (ln2-stream))
       (define (approx-ln2 i)
        (sum-stream i ln2))
       (define approx-stream (stream-map approx-ln2 (stream-enumerate-from 1)))
       (define accel-approx-stream (euler-transform approx-stream))
       (define tableu-stream (accelerated-sequence euler-transform approx-stream))
       #+END_SRC

       I printed out the first 50 elements of the first two, and the
       first 15 of the second. The second converged in nine elements
       and stopped changing. The first one didn't converge in fifty,
       so I changed stream-limit to print the convergence number:

       #+BEGIN_SRC scheme
       (define (stream-limit s tolerance)
         (define (iter stream last-value i)
           (if (<= (abs (- (stream-car stream) last-value))
                   tolerance)
               i
               (iter (stream-cdr stream) (stream-car stream) (+ i 1))))
         (iter (stream-cdr s) (stream-car s) 0))
       #+END_SRC       

       for the first stream I got 997 with tolerance = 0.001. For the
       second stream I got 3, for the third I got 2. I decided 0.001
       was too generous and changed it to 1e-6. The results were:

       tableau-stream: 3
       accel-approx-stream: 59
       approx-stream: (didn't return after five minutes, suffice it to
       say it was in the thousands)


**** Infinite streams of pairs 

     In section 2.2.3, we saw how the sequence paradigm handles
     traditional nested loops as processes defined on sequences of
     pairs. If we generalize this technique to infinite streams, then
     we can write programs that are not easily represented as loops,
     because the "looping" must range over an infinite set. 

     For example, suppose we want to generalize the prime-sum-pairs
     procedure of Section 2.2.3 to produce the stream of pairs of
     _all_ integers (i, j) with i <= j such that i + j is prime. If
     int-pairs is the sequence of all pairs of integers (i, j) with i
     <= j, then our required stream is simply

     #+BEGIN_SRC scheme
     (stream-filter
      (lambda (pair) (prime? (+ (car pair) (cadr pair))))
      int-pairs) 
     #+END_SRC

     Our problem, then, is to produce the stream int-pairs. More
     generally, suppose we have two streams S = (S_{i}) and T =
     (T_{j}), and imagine the infinite rectangular array


     (S_{0},T_{0}) (S_{0},T_{1}) (S_{0},T_{2}) ...
     (S_{1},T_{0}) (S_{1},T_{1}) (S_{1},T_{2}) ...
     (S_{2},T_{0}) (S_{2},T_{1}) (S_{2},T_{2}) ...
     ...


     We wish to generate a stream that contains all the pairs in the
     array that lie on or above the diagonal, i.e. the pairs

     
     (S_{0},T_{0}) (S_{0},T_{1}) (S_{0},T_{2}) ...
                   (S_{1},T_{1}) (S_{1},T_{2}) ...
                                 (S_{2},T_{2}) ...
                                               ...

     
     (If we take both S and T to be the stream of integers, then this
     will be our desired stream int-pairs.)

     Call the general stream of pairs (pairs S T), and consider it to
     be composed of three parts: the pair (S_{0}, T_{0}), the rest of
     the pairs in the first row, and the remaining pairs:

     \begin{tabular}{c | c c c}
     (S_{0},T_{0}) & (S_{0},T_{1}) & (S_{0},T_{2}) & ... \\
     \hline
                   & (S_{1},T_{1}) & (S_{1},T_{2}) & ... \\
                   &               & (S_{2},T_{2}) & ... \\
                   &               &               & ... \\
     \end{tabluar}

     Observe that the third piece in this decomposition (pairs that
     are not in the first row) is (recursively) the pairs formed from
     (stream-cdr S) and (stream-cdr T). Also note that the second
     piece (the rest of the first row) is

     #+BEGIN_SRC scheme
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     #+END_SRC

     Thus we can form our stream of pairs as follows:

     #+BEGIN_SRC scheme
     (define (pairs s t)
      (cons-stream
       (list (stream-car s) (stream-car t))
       (<combine-in-some-way>
        (stream-map (lambda (x) (list (stream-car s) x))
                    (stream-cdr t))
        (pairs (stream-cdr s) (stream-cdr t)))))
     #+END_SRC

     In order to complete the procedure, we must choose some way to
     combine the two inner streams. One idea is to use the stream
     analog of the append procedure from Section 2.2.1:

     #+BEGIN_SRC scheme
     (define (stream-append s1 s2)
      (if (stream-null? s1)
          s2
          (cons-stream (stream-car s1)
                       (stream-append (stream-cdr s1) s2))))
     #+END_SRC

     This is unsuitable for infinite streams, however, because it
     takes all the elements from the first stream before incorporating
     the second stream. In particular, if we try to generate all pairs
     of positive integers using

     #+BEGIN_SRC scheme
     (pairs integers integers)
     #+END_SRC

     our stream of results will first try to run through all pairs
     with the first integer equal to 1, and hence will never produce
     pairs with any other value of the first integer. 

     To handle infinite streams, we need to devise an order of
     combination that ensures that every element will eventually be
     reached if we let our program run long enough. An elegant way to
     accomplish this is with the following interleave procedure:

     #+BEGIN_SRC scheme
     (define (interleave s1 s2)
      (if (stream-null? s1)
          s2
          (cons-stream (stream-car s1)
                       (interleave s2 (stream-cdr s1)))))
     #+END_SRC

     Since interleave takes elements alternately from the two streams,
     every element of the second stream will eventually find its way
     into the interleaved stream, even if the first stream is
     infinite. 

     We can thus generate the required stream of pairs as

     #+BEGIN_SRC scheme
     (define (pairs s t)
      (cons-stream 
       (list (stream-car s) (stream-car t))
       (interleave
        (stream-map (lambda (x) (list (stream-car s) x))
                    (stream-cdr t))
        (pairs (stream-cdr s) (stream-cdr t)))))
     #+END_SRC

     - Exercise 3.66: Examine the stream (pairs integers
       integers). Can you make any general comments about the order in
       which the pairs are placed into the stream? For example,
       approximately how many pairs precede the pair (1, 100)? the
       pair (99, 100)? the pair (100, 100)? (If you can make precise
       mathematical statements here, the better. But feel free to give
       more qualitative answers if you find yourself getting bogged
       down.) 

       The first integer in the int stream is 1, so the first pair is
       (1, 1), supposing both streams are 1..N. The interleave
       function swaps the streams around but doesn't do any kind of
       'deep' interleaving. Basically, elements from the first stream
       are heavily overrepresented. Interleave will use the first
       stream, defined by
       
       #+BEGIN_SRC scheme
       (interleave (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t)))
       #+END_SRC

       for every other cons-stream, since it swaps around its
       arguments. If the stream was by itself, there would be 99
       elements preceding the pair 1, 100, from the beginning of the
       stream, and it could be refed with 99 (i.e. (stream-ref s 99)
       is (1, 100) in the stream of just those elements.). Since
       elements from the stream starting with 1 begin the stream, and
       each are interleaved with another element, we double the number
       of preceding elements, to 198. However, this would be if we
       just called interleave. The full procedure actually takes a car
       form each stream and calls interleave with the cdrs, with s
       first. That results in 

       s_1, s_2, ....

       first, elements from the first stream get repeated. So the
       doubling applies to elements after s_2. There are 98 elements
       then that should be doubled, plus one: 196 + 1 = 197, so there
       are 197 elements before (1, 100)

     - Exercise 3.67: Modify the pairs procedure so that (pairs
       integers integers) will produce the stream of _all_ pairs of
       integers (i, j) (without the condition i <= j). Hint: You will
       need to max in an additional stream.

       #+BEGIN_SRC scheme
       (define (allpairs s t)
        (cons-stream 
         (list (stream-car s) (stream-car t))
         (interleave
            (stream-map (lambda (x) (list (stream-car s) x))
                        (stream-cdr t))
            (interleave 
              (stream-map (lambda (x) (list x (stream-car t)))
                        (stream-cdr s))
              (allpairs (stream-cdr s) (stream-cdr t))))))
       #+END_SRC

     - Exercise 3.68: Louis Reasoner thinks that building a stream of
       pairs from three parts is unecessarily complicated. Instead of
       separating the pair (S_{0}, T_{0}) from the rest of the pairs
       in the first row, he proposes to work with the whole first row,
       as follows: 

       #+BEGIN_SRC scheme
       (define (pairs s t)
        (interleave
         (stream-map (lambda (x) (list (stream-car s) x))
                     t)
         (pairs (stream-cdr s) (stream-cdr t))))
       #+END_SRC

       Does this work? Consider what happens if we evaluate (pairs
       integers integers) using Louis' definition of pairs. 

       Well, it doesn't work practically speaking. Because there is no
       cons-stream that causes a delay, and we always evaluate
       arguments first, we recursively attempt to evaluate (pairs
       (stream-cdr s) (stream-cdr t)). Since s and t are infinite
       streams, we will never exit the invocation of pairs and never
       get any result.

     - Exercise 3.69: Write a procedure triples that takes three
       infinite streams, S, T, and U, and produces the stream of
       triples (S_{i},T_{j},U_{k}) such that i <= j <= k. Use triples
       to generate the stream of all Pythagorean triples of positive
       integers, i.e., the triples (i,j,k) such that i <= j and
       i^{2} + j^{2} = k^{2}

       #+BEGIN_SRC scheme
       (define (triples s t u)
        (cons-stream
         (list (stream-car s)
               (stream-car t)
               (stream-car u))
         (interleave
          (stream-map (lambda (x)
                       (list (stream-car s)
                             (car x)
                             (cadr x)))
                     (stream-cdr (pairs t
                                        u)))
          (triples (stream-cdr s)
                   (stream-cdr t)
                   (stream-cdr u)))))
       (define pythagorean-triples
               (stream-filter
                (lambda (x) (= (+ (square (car x)) (square (cadr x)))
                               (square (caddr x))))
                (triples integers integers integers)))
       #+END_SRC

       - Exercise 3.70: It would be nice to be able to generate streams
         in which the pairs appear in some useful order, rather than
         the order that results from an _ad hoc_ interleaving
         process. We can use a technique similar to the merge procedure
         of Exercise 3.56, if we define a way to say that one pair of
         integers is "less than" another. One way to do this is to
         define a "weighting function" W(i,j) and stipulate that (i_1,
         j_1) is less than (i_2,j_2) if W(i_1,j_1) < W(i_2,j_2). Write
         a procedure merge-weighted that is like merge, except that
         merge-weighted takes an additional argument weight, which is a
         procedure that computes the weight of a pair, and is used to
         determine the order in which elements should appear in the
         resulting merged stream. Using this, generalize pairs to a
         procedure weighted-pairs that takes two streams, together with
         a procedure that computes a weighting function, and generates
         the stream of pairs, ordered according to weight. Use your
         procedure to generate

	 #+BEGIN_SRC scheme
         (define (merge-weighted weight s1 s2)
          (let ((a1 (stream-car s1))
		(a2 (stream-car s2)))
           (cond
            ((eq? 'equal (weight a1 a2))
             (cons-stream a1
              (cons-stream a2 
               (merge-weighted weight (stream-cdr s1) (stream-cdr s2)))))
            ((eq? 'less (weight a1 a2))
             (cons-stream a1 (merge-weighted weight (stream-cdr s1) s2)))
            ((eq? 'greater (weight a1 a2))
             (cons-stream a2 (merge-weighted weight s1 (stream-cdr s2)))))))
	 #+END_SRC

	 a. the stream of all pairs of positive integers (i, j) with i
         <= j ordered according to the sum i + j,

	 The pairs procedure already produces pairs of positive
         integers (i, j) such that i <= j.

	 #+BEGIN_SRC scheme
         (define (weigher x1 x2)
          (let ((sum1 (apply + x1))
		(sum2 (apply + x2)))
           (cond 
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))

         (define (pairs-weighted weigher s1 s2)
	       (cond
		((empty-stream? s1) s2)
		((empty-stream? s2) s1)
		(else (cons-stream
		  (list (stream-car s1) (stream-car s2))
		  (merge-weighted weigher
				  (stream-map 
				   (lambda (x) (list (stream-car s1) x))
				   (stream-cdr s2))
				  (pairs-weighted weigher (stream-cdr s1) (stream-cdr s2)))))))
	 #+END_SRC

	 b. the stream of all pairs of positive integers (i,j) with i
         <= j, where neither i nor j is divisible by 2, 3, or 5, and
         the pairs are ordered according to the sum 2i + 3j + 5ij. 

	 #+BEGIN_SRC scheme
         (define (weigher x1 x2)
          (define (make-sum double)
           (+ (* 2 (car double)) (* 3 (cadr double)) 
              (* 5 (car double) (cadr double))))
          (let ((sum1 (make-sum x1))
		(sum2 (make-sum x2)))
           (cond
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))
         (define the-pairs (pairs-weighted weigher integers-not-divisible integers-not-divisible))
         (define integers-not-divisible (filter (lambda (x) 
                                                 (and (not (= (remainder x 5) 0))
                                                      (not (= (remainder x 2) 0))
                                                      (not (= (remainder x 3) 0))))
                                                      integers))
	 #+END_SRC

	 #+BEGIN_SRC scheme
	 (print-stream the-pairs 50)

          ; => (1 1)
          ; => (1 7)
          ; => (1 11)
          ; => (1 13)
          ; => (1 17)
          ; => (1 19)
          ; => (1 23)
          ; => (1 29)
          ; => (1 31)
          ; => (7 7)
          ; => (1 37)
          ; => (1 41)
          ; => (1 43)
          ; => (1 47)
          ; => (1 49)
          ; => (1 53)
          ; => (7 11)
          ; => (1 59)
          ; => (1 61)
          ; => (7 13)
          ; => (1 67)
          ; => (1 71)
          ; => (1 73)
          ; => (1 77)
          ; => (1 79)
          ; => (7 17)
          ; => (11 11)
          ; => (1 83)
          ; => (1 89)
          ; => (1 91)
          ; => (7 19)
          ; => (11 13)
          ; => (1 97)
          ; => (1 101)
          ; => (1 103)
          ; => (1 107)
          ; => (1 109)
          ; => (7 23)
          ; => (1 113)
          ; => (13 13)
          ; => (1 119)
          ; => (1 121)
          ; => (11 17)
          ; => (1 127)
          ; => (1 131)
          ; => (1 133)
          ; => (1 137)
          ; => (1 139)
          ; => (7 29)
          ; => (11 19)
	 #+END_SRC

       - Exercise 3.71: Numbers that can be expressed as the sum of
         two cubes in more than one way are sometimes called
         _Ramanujan numbers_, in honor of the mathematician Srinivasa
         Ramanujan. Ordered streams of pairs provide an elegant
         solution to the problem of computing these numbers. To find a
         number that can be written as the sum of two cubes in two
         different ways, we need only generate the stream of pairs of
         integers (i,j) weighted according to the sum i^3 + j^3 (see
         Exercise 3.70), then search the stream for two consecutive
         pairs with the same weight. Write a procedure to generate the
         Ramanujan numbers. The first such number is 1729. What are
         the next five?

	 #+BEGIN_SRC
         (define (cube x) (* x (square x)))
         (define (sum-of-cubes x)
          (+ (cube (car x)) (cube (cadr x))))
         (define (weigher x1 x2)
          (let ((sum1 (sum-of-cubes x1))
                (sum2 (sum-of-cubes x2)))
           (cond
            ((= sum1 sum2) 'equal)
            ((< sum1 sum2) 'less)
            ((> sum1 sum2) 'greater))))
         (define (sums-equal? a b)
          (= (sum-of-cubes a)
             (sum-of-cubes b)))
         (define (filter-identical-pairs s)
          (define (inner-filter s)
           (cond
            ((or (empty-stream? s)
                 (empty-stream? (stream-cdr s)))
             the-empty-stream)
            ((sums-equal? (stream-car s) (stream-car (stream-cdr s)))
             (cons-stream (sum-of-cubes (stream-car s))
                          (inner-filter (stream-cdr (stream-cdr s)))))
            (else
             (inner-filter (stream-cdr s)))))
          (inner-filter s))
         (filter-identical-pairs
          (pairs-weighted weigher
                          integers
                          integers))
         (stream-list (filter-identical-pairs
                       (pairs-weighted weigher integers integers)) 6)
	 #+END_SRC
	 output:
	 #+BEGIN_SRC scheme
         ; => (1729 4104 13832 20683 32832 39312 40033)
	 #+END_SRC

       - Exercise 3.72: In a similar way to Exercise 3.71 generate a
         stream of all numbers that can be written as the sum of two
         squares in three different ways (showing how they can be so
         written). 

	 #+BEGIN_SRC scheme
         (define (sum-squares x)
          (+ (square (car x)) (square (cadr x))))
         (define (sum-squares-equal? x y)
          (= (sum-squares x) (sum-squares y)))
         (define (sum-squares-equal3? x y z)
          (= (sum-squares x)
             (sum-squares y)
             (sum-squares z)))
         (define (weigher-sum-squares a b)
          (let ((s1 (sum-squares a))
                (s2 (sum-squares b)))
           (cond
            ((= s1 s2) 'equal)
            ((< s1 s2) 'less)
            ((> s1 s2) 'greater))))
         (define (filter-identical-triples
                  is-three-eql? s)
          (cond
           ((or (empty-stream? s)
                (empty-stream? (stream-cdr s))
                (empty-stream? (stream-cdr (stream-cdr s))))
             the-empty-stream)
             
           ((is-three-eql?
             (stream-car s)
             (stream-car (stream-cdr s))
             (stream-car (stream-cdr (stream-cdr s))))
            (cons-stream
             (sum-squares (stream-car s))
             (filter-identical-triples
              is-three-eql?
              (stream-cdr (stream-cdr (stream-cdr s))))))
           (else
            (filter-identical-triples
             is-three-eql?
             (stream-cdr s)))))
         (stream->list (filter-identical-triples
          sum-squares-equal3?
          (pairs-weighted weigher-sum-squares integers integers))
          10)
	 #+END_SRC
	 
	 

	

	
