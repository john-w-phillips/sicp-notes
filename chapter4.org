* Chapter 4
** Metalinguistic Abstraction
   In our study of program design, we have seen that expert
   programmers control the complexity of their designs with the same
   general techniques used by designers of all complex systems. They
   combine primitive elements to form compound objects, they abstract
   compound objects to form higher-level building blocks, and they
   preserve modularity by adopting appropriate large-scale views of
   system structure. In illustrating these techniques, we have used
   Lisp as a language for describing processes and for constructing
   computational data objects and processes to model complex phenomena
   in the real world. However, as we confront increasingly complex
   problems, we will find that Lisp, or indeed any fixed programming
   language, is not sufficient for our needs. We must constantly turn
   to new languages in order to expresss our ideas more
   effectively. Establishing new languages is a powerful strategy for
   controlling complexity in engineering design; we can often enhance
   our ability to deal with a complex problem by adopting a new
   language that enables us to describe (and hence to think about) the
   problem in a different way, using primitives, means of combination,
   and means of abstraction that are particularly well suited to the
   problem at hand.

   Programming is endowed with a multitude of languages. There are
   physical languages, such as the machine languages for particular
   computers. These languages are concerned with the representation of
   data and control in terms of individual bits of storage and
   primitive machine instructions. The machine-language programmer is
   concerned with using the given hardware to erect systems and
   utilities for the efficient implementation of resource-limited
   computations. High-level languages, erected on a machine-language
   substrate, hide concerns about the representation of data as
   collections of bits and the representation of programs as sequences
   of primitive instructions. These languages have means of
   combination and abstraction, such as procedure definition, but are
   appropriate to the larger-scale organization of systems.

   _Metalinguistic abstraction_ -- establishing new languages -- plays
   an important role in all branches of engineering design. It is
   particularly important to computer programming, because in
   programming not only can we formulate new languages but we can also
   implement these languages by constructing evaluators. An
   _evaluator_ (or _interpreter_) for a programming language is a
   procedure that, when applied to an expression of the language,
   performs the actions required to evaluate that expression.

   It is no exaggeration to regard this as the most fundamental idea
   in programming:

   The evaluator, which determines the meaning of expressions in a
   programming language, is just another program.

   To appreciate this point is to change our images of ourselves as
   programmers. We come to see ourselves as designers of languages,
   rather than only users of languages designed by others.

   In fact, we can regard almost any program as the evaluator of some
   language. For instance, the polynomial manipulation system of
   Section 2.5.3 embodies the rules of polynomial arithmetic and
   implements them in terms of operations on list-structured data. If
   we augment this system with procedures to read and print polynomial
   expressions, we have the core of a special-purpose language for
   dealing with problems in symbolic mathematics. The digital-logic
   simulator of Section 3.3.4 and the constraint propagator of Section
   3.3.5 are legitimate languages in their own right, each with its
   own primitives, means of combination, and means of
   abstraction. Seen from this perspective, the technology for coping
   with large-scale computer systems merges with the technology for
   building new computer languages, and computer science itself
   becomes no more (and no less) than the discipline of constructing
   appropriate descriptive languages.

   We now embark on a tour of the technology by which languages are
   established in terms of other languages. In this chapter we shall
   use Lisp as a base, implementing evaluators as Lisp
   procedures. Lisp is particularly well suited to this task, because
   of its ability to represent and manipulate symbolic expressions. We
   will take the first step in understanding how languages are
   implemented by building an evaluator for Lisp itself. The language
   implemented by our evaluator will be a subset of the Scheme dialect
   of Lisp that we use in this book. Although the evaluator described
   in this chapter is written for a particular dialect of Lisp, it
   contains the essential structure of an evaluator for any
   expression-oriented language designed for writing programs for a
   sequential machine. (In fact, most language processors contain,
   deep within them, a little "Lisp" evaluator.) The evaluator has
   been simplified for the purposes of illustration and discussion,
   and some features have been left out that would be important to
   include in a production-quality Lisp system. Nevertheless, this
   simple evaluator is adequate to execute most of the programs in
   this book.

   An important  advantage of making the evaluator accessible as a
   Lisp program is that we can implement alternative evaluation rules
   by describing these as modifications to the evaluator program. One
   place where we can use this power to good effect is to gain extra
   control over the ways in which computational models embody the
   notion of time, which was so central to the discussion in
   Chapter 3. There, we mitigated some of the complexities of state
   and assignment by using streams to decouple the representation of
   time in the world from time in the computer. Our stream programs,
   however, were sometimes cumbersome, because they were constrained
   by the applicative-order evaluation of Scheme. In Section 4.2,
   we'll change the underlying language to provide for a more elegant
   approach, by modifying the evaluator to provide for _normal-order
   evaluation_. 

   Section 4.3 implements a more ambitious linguistic change, whereby
   expressions have many values, rather than just a single value. In
   this language of _nondeterministic computing_, it is natural to
   express processes that generate all possible values for expressions
   and then search for those values that satisfy certain
   constraints. In terms of models of computation and time, this is
   like having time branch into a set of "possible futures" and then
   searching for appropriate time lines. With our nondeterministic
   evaluator, keeping track of multiple values and performing searches
   are handled automatically by the underlying mechanism of the
   language.

   In Section 4.4 we implement a _logic-programming_ language in which
   knowledge is expressed in terms of relations, rather than in terms
   of computations with inputs and outputs. Even though this makes the
   language drastically different from Lisp, or indeed from any
   conventional language, we will see that the logic-programming
   evaluator shares the essential structure of a Lisp evaluator.

** 4.1 The Metacircular Evaluator

   Our evaluator for Lisp will be implemented as a Lisp program. It
   may seem circular to think about evaluating Lisp programs using an
   evaluator that is itself implemented in Lisp. However, evaluation
   is a process, so it is appropriate to describe the evaluation
   process using Lisp, which, after all, is our tool for describing
   processes. An evaluator that is written in the same language that
   it evaluates is said to be _metacircular_. 

   The metacircular evaluator is essentially a Scheme formulation of
   the environment model of evaluation described in Section
   3.2. Recall that the model has two basic parts:

   1. To evaluate a combination (a compound expression other than a
      special form), evaluate the subexpressions and then apply the
      value of the operator subexpression to the values of the operand
      subexpressions.
   2. To apply a compound procedure to a set of arguments, evaluate
      the body of the procedure in a new environment. To construct
      this environment, extend the environment part of the procedure
      object by a frame in which the formal parameters of the
      procedure are bound to the arguments to which the procedure is
      applied.

      
   These two rules describe the essence of the evaluation process, a
   basic cycle in which expressions to be evaluated in environments
   are reduced to procedures to be applied to arguments, which in turn
   are reduced to new expressions to be evaluated in new environments,
   and so on, until we get down to symbols, whose values are looked up
   in the environment, and to primitive procedures, which are applied
   directly (see Figure 4.1). This evaluation cycle will be embodied
   by the interplay between the two critical procedures in the
   evaluator, eval and apply, which are described in Section 4.1.1
   (see Figure 4.1).
   
   The implementation of the evaluator will depend upon procedures
   that define the _syntax_ of the expressions to be evaluated. We
   will use data abstraction to make the evaluator independent of the
   representation of the language. For example, rather than committing
   to a choice that an assignment is to be represented by a list
   beginning with the symbol set! we use an abstract predicate
   assignment? to test for an assignment, and we use abstract
   selectors assignment-variable and assignment-value to access the
   parts of an assignment. Implementation of expressions will be
   described in detail in Section 4.1.2. There are also operations,
   described in Section 4.1.3, that specify the representation of
   procedures and environments. For example, make-procedure constructs
   compound procedures, lookup-variable-value accesses the values of
   variables, and apply-primitive-procedure applies a primitive
   procedure to a given list of arguments. 

*** 4.1.1 The Core of the Evaluator

    The evaluation process can be described as the interplay between
    two procedures: eval and apply.

**** Eval
     Eval takes as arguments an expression and an environment. It
     classifies the expression and directs its evaluation. eval is
     structured as a case analysis of the syntactic type of the
     expression to be evaluated. In order to keep the procedure
     general, we express the determination of the type of an
     expression abstractly, making no commitment to any particular
     representation for the various types of expressions. Each type of
     expression has a predicate that tests for it and an abstract
     means for selecting its parts. This _abstract syntax_ makes it
     easy to see how we can change the syntax of the language by using
     the same evaluator, but with a different collection of syntax
     procedures.

***** Primitive expressions
      - For self-evaluating expressions, such as numbers, eval returns
        the expression itself.
      - eval must look up variables in the environment to find their
        values.

***** Special forms
      - For quoted expressions, eval returns the expression that was
        quoted.
      - An assignment to (or a definition of) a variable must
        recursively call eval to compute the new value to be
        associated with the variable. The environment must be modified
        to change (or create) the binding of the variable.
      - An if expression requires special processing of its parts, so
        as to evaluate the consequent if the predicate is true, and
        otherwise to evaluate the alternative.
      - A lambda expression must be transformed into an applicable
        procedure by packaging together the parameters and body
        specified by the lambda expression with the environment of
        evaluation.
      - A begin expression requires evaluating its sequence of
        expressions in the order in which they appear.
      - A case analysis (cond) is transformed into a nest of if
        expressions and then evaluated.

***** Combinations
      - For a procedure application, eval must recursively evaluate
        the operator part and the operands of the combination. The
        resulting procedure and arguments are passed to apply, which
        handles the actual procedure application.

	

     Here is the definition of eval:

     #+BEGIN_SRC scheme
       (define (eval exp env)
         (cond ((self-evaluating? exp) exp)
               ((variable? exp) (lookup-variable-value exp env))
               ((quoted? exp) (text-of-quotation exp))
               ((assignment? exp) (eval-assignment exp env))
               ((definition? exp) (eval-definition exp env))
               ((if? exp) (eval-if exp env))
               ((lambda? exp) (make-procedure (lambda-parameters exp)
                                              (lambda-body exp)
                                              env))
               ((begin? exp)
                (eval-sequence (begin-actions exp) env))
               ((cond? exp) (eval (cond->if exp) env))
               ((application? exp)
                (apply (eval (operator exp) env)
                       (list-of-values (operands exp) env)))
               (else 
                (error "Unknown expression type: EVAL " exp))))
     #+END_SRC

     For clarity, eval has been implemented as a case analysis using
     cond. The disadvantage of this is that our procedure handles only
     a few distinguishable types of expressions, and no new ones can
     be defined without editing the definition of eval. In most Lisp
     implementations, dispatching on the type of an expression is done
     in a data-directed style. This allows a user to add new types of
     expressions that eval can distinguish, without modifying the
     definition of eval itself.

**** Apply     

     apply takes two arguments, a procedure and a list of arguments to
     which the procedure should be applied. apply classifies
     procedures into two kinds: It calls apply-primitive-procedure to
     apply primitives; it applies compound procedures by sequentially
     evaluating the expressions that make up the body of the
     procedure. The environment for the evaluation of the body of a
     compound procedure is constructed by extending the base
     environment carried by the procedure to include a frame that
     binds the parameters of the procedure to the arguments to which
     the procedure is to be applied. Here is the definition of apply:

     #+BEGIN_SRC scheme
       (define (apply procedure arguments)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure procedure arguments))
               ((compound-procedure? procedure)
                (eval-sequence
                 (procedure-body procedure)
                 (extend-environment
                  (procedure-parameters procedure)
                  arguments
                  (procedure-environment procedure))))
               (else
                (error "Unknown procedure type: APPLY" procedure))))
     #+END_SRC

***** Procedure arguments
      When eval processes a procedure application, it uses
      list-of-values to produce a list of arguments to which the
      procedure is to be applied. list-of-values takes as an argument
      the operands of the combination. It evaluates each operand and
      returns a list of the corresponding values:

      #+BEGIN_SRC scheme
      (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (cons (eval (first-operand exps) env)
                 (list-of-values (rest-operands exps) env))))
      #+END_SRC
***** Conditionals

      eval-if evaluates the predicate part of an if expression in the
      given environment. If the result is true, eval-if evaluates the
      consequent, otherwise it evaluates the alternative:

      #+BEGIN_SRC scheme
      (define (eval-if exp env)
       (if (true? (eval (if-predicate exp) env))
           (eval (if-consequent exp) env)
           (eval (if-alternative exp) env)))
      #+END_SRC

      The use of true? in eval-if highlights the issue of the
      connection between an implemented language and an implementation
      language. The if-predicate is evaluated in the language being
      implemented and thus yields a value in that language. The
      interpreter predicate true? translates that value into a value
      that can be tested by the if in the implementation language: The
      metacircular representation of truth might not be the same as
      that of the underlying Scheme.

***** Sequences

      eval-sequence is used by apply to evaluate the sequence of
      expressions in a procedure body and by eval to evaluate the
      sequence of expressions in a begin expression. It takes as
      arguments a sequence of expressions and an environment, and
      evaluates the expressions in the order in which they occur. The
      value returned is the value of the final expression.

      #+BEGIN_SRC scheme
        (define (eval-sequence exps env)
          (cond ((last-exp? exps)
                 (eval (first-exp exps) env))
                (else
                 (eval (first-exp exps) env)
                 (eval-sequence (rest-exps) env))))
      #+END_SRC

***** Assignments and definitions
      The following procedure handles assignments to variables. It
      calls eval to find the value to be assigned and transmits the
      variable and the resulting value to set-variable-value! to bee
      installed in the designated environment. 
      
      #+BEGIN_SRC scheme
      (define (eval-assignment exp env)
       (set-variable-value! (assignment-variable exp)
                            (eval (assignment-value exp) env)
                            env)
       'ok)
      #+END_SRC

      Definitions of variables are handled in a similar manner.

      #+BEGIN_SRC scheme
      (define (eval-definition exp env)
       (define-variable! (definition-variable exp)
                         (eval (definition-value exp) env)
                         env)
       'ok)
      #+END_SRC

      We have chosen here to return the symbol ok as the value of an
      assignment or definition.

      - Exercise 4.1: Notice that we cannot tell whether the
        metacircular evaluator evaluates operands from left to right
        or from right to left. Its evaluation order is inherited from
        the underlying Lisp: If the arguments to cons in
        list-of-values are evaluated from left to right, then
        list-of-values will evaluate operands from right to left.

	Write a version of list-of-values that evaluates operands from
        left to right regardless of the order of evaluation in the
        underlying Lisp. Also write a version of list-of-values that
        evaluates operands from right to left.

	#+BEGIN_SRC scheme
          ;; left to right
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((arg-value (eval (first-operand exps) env)))
                  (let ((rest-value (list-of-values (rest-operands exps) env)))
                    (cons arg-value rest-value)))))
          ;; right to left
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((rest-value (list-of-values (rest-operands exps) env)))
                  (let ((arg-value (eval (first-operand exps) env)))
                    (cons arg-value
                          rest-value)))))
	#+END_SRC

*** 4.1.2 Representing Expressions
    The evaluator is reminiscent of the symbolic differentiation
    program discussed in Section 2.3.2. Both programs operate on
    symbolic expressions. In both programs, the result of operating on
    a compound expression is determined by operating recursively on
    the pieces of the expression and combining the results in a way
    that depends on the type of the expression. In both programs we
    used data abstraction to decouple the general rules of operation
    from the details of how expressions are represented. In the
    differentiation program this meant that the same differentiation
    procedure could deal with algebraic expressions in prefix form, in
    infix form, or in some other form. For the evaluator, this means
    that the syntax of the language being evaluated is determined
    solely by the procedures that classify and extract pieces of
    expressions. Here is the specification of the syntax of our
    language:

    - The only self-evaluating items are numbers and strings:

      #+BEGIN_SRC scheme
      (define (self-evaluating? exp)
       (cond ((number? exp) true)
             ((string? exp) true)
             (else false)))
      #+END_SRC

    - Variables are represented by symbols:

      #+BEGIN_SRC scheme
      (define (variable? exp) (symbol? exp))
      #+END_SRC

    - Quotations have the form (quote <text-of-quotation>):
      
      #+BEGIN_SRC scheme
      (define (quoted? exp) (tagged-list? exp 'quote))
      (define (text-of-quotation exp) (cadr exp))
      #+END_SRC

      quoted? is defined in terms of the procedure tagged-list?, which
      identifies lists beginning with a designated symbol:

      #+BEGIN_SRC scheme
      (define (tagged-list? exp tag)
       (if (pair? exp)
           (eq? (car exp) tag)
           false))
      #+END_SRC

    - Assignments have the form (set! <var> <value>):
      
      #+BEGIN_SRC scheme
        (define (assignment? exp) (tagged-list? exp 'set!))
        (define (assignment-variable exp) (cadr exp))
        (define (assignment-value exp) (caddr exp))
      #+END_SRC

    - Definitions have the form

      #+BEGIN_SRC scheme
      (define <var> <value>)
      #+END_SRC

      or the form

      #+BEGIN_SRC scheme
      (define (<var> <parameter1> ... <parametern>)
       <body>)
      #+END_SRC

      The latter form (standard procedure definition) is syntactic
      sugar for

      #+BEGIN_SRC scheme
      (define <var>
       (lambda (<parameter1> ... <parametern>)
        <body>))
      #+END_SRC

      The corresponding syntax procedures are the following:

      #+BEGIN_SRC scheme
      (define (definition? exp) (tagged-list? exp 'define))
      (define (definition-variable exp)
       (if (symbol? (cadr exp))
           (cadr exp)
           (caadr exp)))
      (define (definition-value exp)
       (if (symbol? (cadr exp))
           (caddr exp)
           (make-lambda (cdadr exp)
                        (cddr exp))))
      #+END_SRC

    - lambda expressions are lists that begin with the symbol lambda:
      
      #+BEGIN_SRC scheme
      (define (lambda? exp) (tagged-list? exp 'lambda))
      (define (lambda-parameters exp) (cadr exp))
      (define (lambda-body exp) (cddr exp))
      #+END_SRC

      We also provide a constructor for lambda expressions, which is
      used by definition-value, above:

      #+BEGIN_SRC scheme
      (define (make-lambda parameters body)
       (cons 'lambda (cons parameters body)))
      #+END_SRC

    - Conditionals begin with if and have a predicate, a consequent,
      and an (optional) alternative. If the expression has no
      alternative part, we provide false as an alternative.

      #+BEGIN_SRC scheme
      (define (if? exp) (tagged-list? exp 'if))
      (define (if-predicate exp) (cadr exp))
      (define (if-consequent exp) (caddr exp))
      (define (if-alternative exp)
       (if (not (null? (cdddr expr)))
           (cadddr exp)
           'false))
      #+END_SRC

      We also provide a constructor for if expressions, to be used by
      cond->if to transform cond expressions into if expressions:

      #+BEGIN_SRC scheme
      (define (make-if predicate consequent alternative)
       (list 'if predicate consequent alternative))
      #+END_SRC

    - begin packages a sequence of expressions into a single
      expression. We include syntax operations on begin expressions to
      extract the actual sequence from the begin expression, as well
      as selectors that return the first expression and rest of the
      expressions in the sequence.

      #+BEGIN_SRC scheme
      (define (begin? exp) (tagged-list? exp 'begin))
      (define (begin-actions exp) (cdr exp))
      (define (last-exp? seq) (null? (cdr seq)))
      (define (first-exp seq) (car seq))
      (define (rest-exps seq) (cdr seq))
      #+END_SRC

      We also include a constructor sequence->exp (for use by
      cond->if) that transforms a sequence into a single expression,
      using begin if necessary:

      #+BEGIN_SRC scheme
      (define (sequence->exp seq)
       (cond ((null? seq) seq)
             ((last-exp? seq) (first-exp seq))
             (else (make-begin seq))))
      (define (make-begin seq) (cons 'begin seq))
      #+END_SRC

    - A procedure application is any compound expression that is not
      one of the above expression types. The car of the expression is
      the operator, and the cdr is a list of operands:

      #+BEGIN_SRC scheme
      (define (application? exp) (pair? exp))
      (define (operator exp) (car exp))
      (define (operands exp) (cdr exp))
      (define (no-operands? ops) (null? ops))
      (define (first-operand ops) (car ops))
      (define (rest-operands ops) (cdr ops))
      #+END_SRC
**** Derived expressions
     Some special forms in our language can be defined in terms of
     expressions involving other special forms, rather than being
     implemented directly. One example is cond, which can be
     implemented as a nest of if expressions. For example, we can
     reduce the problem of evaluating the expression

     #+BEGIN_SRC scheme
     (cond ((> x 0) x)
           ((= x 0) (display 'zero) 0)
           (else (- x)))
     #+END_SRC

     to the problem of evaluating the following expression involving
     if and begin expressions:

     #+BEGIN_SRC scheme
     (if (> x 0)
         x
         (if (= x 0)
             (begin (display 'zero) 0)
             (0 x)))
     #+END_SRC

     Implementing the evaluation of cond in this way simplifies the
     evaluator because it reduces the number of special forms for
     which the evaluation process must be explicitly specified.

     We include syntax procedures that extract the parts of a cond
     expression, and a procedure cond->if that transforms cond
     expressions into if expressions. A case analysis begins with cond
     and has a list of predicate-action clauses. A clause is an else
     clause if its predicate is the symbol else.

     #+BEGIN_SRC scheme
     (define (cond? exp) (tagged-list? exp 'cond))
     (define (cond-clauses exp) (cdr exp))
     (define (cond-else-clause? clause)
      (eq? (cond-predicate clause) 'else))
     (define (cond-predicate clause) (car clause))
     (define (cond-actions clause) (cdr clause))
     (define (cond->if exp) (expand-clauses (cond-clauses exp)))
     (define (expand-clauses clauses)
      (if (null? clauses)
          'false
          (let ((first (car clauses))
                (rest (cdr clauses)))
           (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (else "ELSE clause isn't last: COND->IF"
                      clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
     #+END_SRC

     Expressions (such as cond) that we choose to implement as
     syntactic transformations are called _derived expressions_. let
     expressions are also derived expressions (see Exercise 4.6).

     - Exercise 4.2: Louis Reasoner plans to reorder the cond clauses
       in eval so that the clause for procedure applications appears
       before the clause for assignments. He argues that this will
       make the interpreter more efficient: Since programs usually
       contain more applications than assignments, definitions, and so
       on, his modified eval will usually check fewer clauses than the
       original eval before identifying the type of expression.

       a. What is wrong with Louis' plan? (Hint: What will Louis'
       evaluator do with the expression (define x 3)?)

       The problem is his evaluator will assume expressions that
       should have special meanings, like cond clauses, if clauses,
       definitions, lambdas, &c, are all applications of procedures,
       and you won't be able to use the interpreter at all.

       b. Louis is upset that his plan didn't work. He is willing to
       go to any lengths to make his evaluator recognize procedure
       applications before it checks for most other kinds of
       expressions. Help him by changing the syntax of the evaluated
       language so that the procedure applications start with
       call. For example, instead of (factorial 3) we will now have to
       write (call factorial 3) and instead of (+ 1 2) we will have to
       write (call + 1 2). 

       #+BEGIN_SRC scheme
       (define (application? expr) (tagged-list? expr 'call))
       (define (operator exp) (cadr exp))
       (define (operands exp) (cddr exp))
       (define (no-operands? ops) (null? ops))
       (define (first-operand ops) (car ops))
       (define (rest-operands ops) (cdr ops))
       #+END_SRC

     - Exercise 4.3: Rewrite eval so that the dispatch is done in a
       data-directed style. Compare this with the data-directed
       differentiation procedure of Exercise 2.73 (You may use the car
       of a compound expression as the type of the expression, as is
       appropriate for the syntax implemented in this section.)

       #+BEGIN_SRC scheme
       (put 'eval 'cond eval-cond)
       (put 'eval 'definition eval-definition)
       (put 'eval 'set! eval-assignment)
       (put 'eval 'begin eval-sequence)
       (put 'eval 'if eval-if)
       (put 'eval 'lambda (lambda (exp env)
                            (make-procedure (lambda-parameters exp)
                                            (lambda-body exp)
                                            env)))
       (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
       (define (expr-type expr) (car expr))
       (define (eval expr env)
         (cond
          ((self-evaluating? expr) expr)
          ((variable? exp) (lookup-variable-value exp env))
          (else
           (let ((proc (get 'eval (expr-type expr)))))
            (cond
             (proc (proc (expr-contents expr) env))
             ((application? expr)
              (apply (eval (operator exp) env)
                     (list-of-values (operands exp) env)))
             (else
              (error "Unknown expression type -- EVAL" expr)))))))
       #+END_SRC

     - Exercise 4.4: Recall the definitions of the special forms and
       and or from Chapter 1:

       - and: The expressions are evaluated from left to right. If any
         expression evaluates to false, false is returned; any
         remaining expressions are not evaluated. If all the
         expressions evaluate to true values, the value of the last
         expression is returned. If there are no expressions then true
         is returned.

       - or: The expressions are evaluated from left to right. If any
         expression evaluates to a true value, that value is returned;
         any remaining expressions are not evaluated. If all
         expressions evaluate to true or false, or if there are no
         expressions, then false is returned. 

       Install and and or as new special forms for the evaluator by
       defining appropriate syntax procedures and evaluation
       procedures eval-and and eval-or. Alternatively, show how to
       implement and and or as derived expressions. 

       #+BEGIN_SRC scheme
       (define (eval-and expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (false? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'and eval-and)

       (define (eval-or expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (true? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'or eval-or)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (and->if ops)
       (if (no-operands? ops)
       'true
       (make-if
       (first-operand ops)
       (and->if (rest-operands ops))
       'false)))
       (define (or->if ops)
       (if (no-operands? ops)
       'false
       (make-if
       (first-operand ops)
       'true
       (or->if (rest-operands ops)))))
       #+END_SRC

     - Exercise 4.5: Scheme allows an additional syntax for cond
       clauses, (<test> => <recipient>). If <test> evaluates to a true
       value, then <recipient> is evaluated. Its value must be a
       procedure of one argument; this procedure is then invoked on
       the value of the <test>, and the result is returned as the
       value of the cond expression. For example

       #+BEGIN_SRC scheme
       (cond ((assoc 'b '((a 1) (b 2))) => cadr)
             (else false))
       #+END_SRC

       returns 2. Modify the handling of cond so that it supports this
       extended syntax.

       You only have to change the cond-actions bit:

       #+BEGIN_SRC scheme
       (define (cond-actions expr)
        (if (eq? '=> (cadr expr))
            (list (caddr expr) (car expr))
            (cadr expr)))
       #+END_SRC

       However, this doesn't save the variable. In case of a
       side-effect, or just to save computation time, we should
       rewrite so that we can save the variable. 

       #+BEGIN_SRC scheme
       (lambda (expr) (if expr (action-value expr) 
                               (expand-clauses rest)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (expand-action cond-clause rest-clauses)
        (if (cond=>clause? cond-clause)
            (make-application
             (make-lambda '(expr-result)
              (make-expr-sequence
              (make-if
               'expr-result
               (make-application
                (car (cond-actions cond-clause))
                '(expr-result))
               (expand-clauses rest-clauses))))
              (list (cond-predicate cond-clause)))
             (make-if
              (cond-predicate cond-clause)
              (sequence->exp (cond-actions cond-clause))
              (expand-clauses rest-clauses))))

       (define (expand-clauses clauses)
        (if (null? clauses)
            'false
            (let ((first (car clauses))
                  (rest (cdr clauses)))
             (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last: COND->IF"
                         clauses))
              (expand-action
               first
               rest)))))
       #+END_SRC

     - Exercise 4.6: let expressions are derived expressions, because

       #+BEGIN_SRC scheme
       (let ((<var1> <exp1>) ... (<varn> <expn>))
        <body>)
       #+END_SRC

       is equivalent to

       #+BEGIN_SRC scheme
       ((lambda (<var1> ... <varn>)
         <body>)
        <exp1>
        ...
        <expn>)
       #+END_SRC

       Implement a syntactic transformation let->combination that
       reduces evaluating let expressions to evaluating combinations
       of the type shown above, and add the appropriate clause to eval
       to handle let expressions.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))
       (define (let-bindings expr) (cadr expr))
       (define (let-seq expr) (cddr expr))
       (define (let->combination expr)
        (make-application
         (make-lambda
          (map car (let-bindings expr))
          (let-seq expr))
         (map cadr (let-bindings expr))))
       (define (eval-let expr env)
        (eval (let->combination expr) env))
       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.7: let* is similar to let, except that the bindings
       of the let* variables are performed sequentially from left to
       right, and each binding is made in an environment in which all
       of the preceding bindings are visible. For example

       #+BEGIN_SRC scheme
       (let* ((x 3) (y (+ x 2)) (z (+ x y 5)))
        (* x z))
       #+END_SRC

       #+BEGIN_SRC scheme
         (define (empty-bindings? bindings) (null? bindings))
         (define (let*-bindings let*) (cadr let*))
         (define (let*-body let*) (caddr let*))
         (define first-binding car)
         (define rest-bindings cdr)

         (define (make-let bindings body)
          (list 'let bindings body))

         (define (cons-binding binding rest)
          (cons binding rest))
         (define (empty-bindings) '())

         (define (let*-bindings->nested-lets let-body bindings)
          (if (empty-bindings? bindings)
              let-body
              (make-let
               (cons-binding (first-binding bindings) (empty-bindings))
               (let*-bindings->nested-lets let-body (rest-bindings bindings)))))

         (define (let*->nested-lets expr)
          (let ((bindings (let*-bindings expr))
                (body (let*-body expr)))
           (let*-bindings->nested-lets body bindings)))

         (define (eval-let* expr env)
          (eval (let*->nested-lets expr) env))

         (put 'eval 'let* eval-let*)
       #+END_SRC

     - Exercise 4.8: "Named let" is a variant of let that has the form

       #+BEGIN_SRC scheme
       (let <var> <bindings> <body>)
       #+END_SRC

       The <bindings> and <body> are just as in ordinary let, except
       that <var> is bound within <body> to a procedure whose body is
       <body> and whose parameters are the variables in the
       <bindings>. Thus, one can repeatedly execute the <body> by
       invoking the procedure named <var>. For example, the iterative
       Fibonacci procedure (Section 1.2.2) can be rewritten using
       named let as follows:

       #+BEGIN_SRC scheme
       (define (fib n)
        (let fib-iter ((a 1)
                       (b 0)
                       (count n))
         (if (= count 0)
             b
             (fib-iter (+ a b) a (- count 1)))))
       #+END_SRC

       Modify let->combination of Exercise 4.6 to also support named
       let.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))

       (define (named-let? expr) (symbol? (cadr expr)))

       (define (let-bindings expr) 
        (if (named-let? expr)
            (caddr expr)
            (cadr expr)))

       (define (let-seq expr) 
        (if (named-let? expr)
            (cdddr expr)
            (cddr expr)))

       (define (let-name expr) (cadr expr))

       (define (make-sequence values)
        (cons 'begin values))

       (define (make-definition name value)
        (list 'define name value))

       (define (make-function-definition name params value)
        (list 'define (cons name params) value))

       (define (named-let->combination expr)
        (make-sequence
         (list
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map cadr (let-bindings expr))))))

       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map cadr (let-bindings expr)))))

       (define (eval-let expr env)
        (eval (let->combination expr) env))

       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.9: Many language support a variety of iteration
       constructs, such as do, for, while, and until. In Scheme,
       iterative processes can be expressed in terms of ordinary
       procedure calls, so special iteration constructs provide no
       essential gain in computational power. On the other hand, such
       constructs are often convenient. Design some iteration
       constructs, give examples of their use, and show how to
       implement them as derived expressions.

       #+BEGIN_SRC scheme
       (define (do-init-bindings expr) (cadr expr))
       (define (do-final-expr expr) (caddr expr))
       (define (do-predicate expr) (cadddr expr))
       (define (do-body expr) (cadr (cdddr expr)))
       (define (do->combination expr)
        (make-sequence
         (list
          (make-function-definition
           'dobody
           (map car (do-init-bindings expr))
           (make-if
            (do-predicate expr)
            (make-sequence (list (do-final-expr expr)))
            (make-application 
             'dobody
             (map caddr (do-init-bindings expr)))))
          (make-application 'dobody (map cadr (do-init-bindings expr))))))
       #+END_SRC

     - Exercise 4.10: By using data abstraction, we were able to write
       an eval procedure that is independent of the particular syntax
       of the language to be evaluated. To illustrate this, design and
       implement a new syntax for Scheme by modifying the procedures
       in this section, without changing eval or apply.

       You just change the predicates and accessors since we used data
       abstraction.

       #+BEGIN_SRC scheme
       (defprocedure add (x y) (+ x y))
       (defvar x 1)
       (if (>=  (add 1 2) 3) then true else false)
       (setvars (x <- 1 y <- 2 z <- 3)
         (+ x y z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (assignment? exp) (eq? (cadr exp) '<-))
       (define (assignment-variable exp) (car exp))
       (define (assignment-value exp) (caddr exp))
       (define (eval-assignment exp env)
        (set-variable-value! (assignment-variable exp)
                             (eval (assignment-value exp) env)
                             env)
        'ok)

       (define (if? exp) 
        (and
         (eq? (car exp) 'if)
         (eq? (caddr exp) 'then)
         (eq? (cadr (cdddr exp)) 'else)))
       (define (if-predicate exp) (cadr exp))
       (define (if-consequent exp) (cadddr exp))
       (define (if-alternative exp)
        (caddr (cdddr exp)))

       (define (definition? expr)
        (or (eq? (car expr) 'defprocedure)
            (eq? (car expr) 'defvar)))
       (define (definition-variable exp)
        (cadr exp))

       (define (definition-value exp)
        (if (eq? 'defprocedure (car expr))
             (make-lambda (caddr expr)
                          (cadddr expr))
             (caddr expr)))

       (define (let? exp) (eq? (car expr) 'setvars))
       (define (let-bindings expr)
         (if (named-let? expr)
             (caddr expr)
             (cadr expr)))
       (define (let-seq expr)
        (if (named-let? expr)
            (cadddr expr)
            (caddr expr)))
       (define (named-let->combination expr)
        (make-sequence
         (list 
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map caddr (let-bindings expr))))))
       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map caddr (let-bindings expr)))))
       #+END_SRC

*** 4.1.3 Evaluator Data Structures
    In addition to defining the external syntax of expressions, the
    evaluator implementation must also define the data structures that
    the evaluator manipulates internally, as part of the execution of
    a program, such as the representation of procedures and
    environments and the representation of true and false.

**** Testing of predicates
     For conditionals, we accept anything to be true that is not the
     explicit false object.

     #+BEGIN_SRC scheme
     (define (true? x) (not (eq? x false)))
     (define (false? x) (eq? x false))
     #+END_SRC

**** Representing procedures

     To handle primitives, we assume that we have available the
     following procedures:

     - (apply-primitive-procedure <proc> <args>)
       applies the given primitive procedure to the argument values in
       the list <args> and returns the result of the application.
     - (primitive-procedure? <proc>)
       tests whether <proc> is a primitive procedure.

       
     These mechanisms for handling primitives are further described in
     section 4.1.4. 

     Compound procedures are constructed from parameters, procedure
     bodies, and environments using the constructor make-procedure:

     #+BEGIN_SRC scheme
     (define (make-procedure parameters body env)
      (list 'procedure parameters body env))
     (define (compound-procedure? p)
      (tagged-list? p 'procedure))
     (define (procedure-parameters p) (cadr p))
     (define (procedure-body p) (caddr p))
     (define (procedure-environment p) (cadddr p))
     #+END_SRC

**** Operations on Environments
     The evaluator needs operations for manipulating environments. As
     explained in Section 3.2, an environment is a sequence of frames,
     where each frame is a table of bindings that associate variables
     with their corresponding values. We use the following operations
     for manipulating environments:

     - (lookup-variable-value <var> <env>)
       returns the value that is bound to the symbol <var> in the
       environment <env>, or signals an error if the variable is
       unbound.
     - (extend-environment <variables> <values> <base-env>)
       returns a new environment, consisting of a new frame in which
       the symbols in the list <variables> are bound to the
       corresponding elements in the list <values>, where the
       enclosing environment is the environment <base-env>.
     - (define-variable! <var> <value> <env>)
       adds to the first frame in the environment <env> a new binding
       that associates the variable <var> with the value <value>.
     - (set-variable-value! <var> <value> <env>)
       changes the binding of the variable <var> in the environment
       <env> so that the variable is now bound to the value <value>,
       or signals an error if the variable is unbound.

       
     To implement these operations we represent an environment as a
     list of frames. The enclosing environment of an environment is
     the cdr of the list. The empty environment is simply the empty
     list.

     #+BEGIN_SRC scheme
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     #+END_SRC

     Each frame of an environment is represented as a pair of lists: a
     list of the variables bound in that frame and a list of the
     associated values:
     
     #+BEGIN_SRC scheme
     (define (make-frame variables values)
      (cons variables values))
     (define (frame-variables frame) (car frame))
     (define (frame values frame) (cdr frame))
     (define (add-binding-to-frame! var val frame)
      (set-car! frame (cons var (car frame)))
      (set-cdr! frame (cons val (cdr frame))))
     #+END_SRC

     To extend an environment by a new frame that associates variables
     with values, we make a frame consisting of the list of variables
     and the list of values, and we adjoin this to the environment. We
     signal an error if the number of variables does not match the
     number of values.

     #+BEGIN_SRC scheme
     (define (extend-environment vars vals base-env)
      (if (= (length vars) (length vals))
          (cons (make-frame vars vals) base-env)
          (if (< (length vars) (length vals))
              (error "Too many arguments supplied" vars vals)
              (error "Too few arguments supplied" vars vals))))
     #+END_SRC

     To look up a variable in an environment, we scan the list of
     variables in the first frame. If we find the desired variable, we
     return the corresponding element in the list of values. If we do
     not find the variable in the current frame, we search the
     enclosing environment, and so on. If we reach an empty
     environment, we signal an "unbound variable" error.

     #+BEGIN_SRC scheme
     (define (lookup-variable-value var env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars)) (car vals))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To set a variable to a new value in a specified environment, we
     scan for the variable, just as in lookup-variable-value, and
     change the corresponding value when we find it. 

     #+BEGIN_SRC scheme
     (define (set-variable-value! var val env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable: SET!" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To define a variable, we search the first frame for a binding for
     the variable, and change the binding if it exists (just as in
     set-variable-value!). If no such binding exists, we adjoin one to
     the first frame.

     #+BEGIN_SRC scheme
     (define (define-variable! var val env)
      (let ((frame (first-frame env)))
       (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars)) (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (scan (frame-variables frame) (frame-values frame))))
     #+END_SRC

     The method described here is only one of many plausible ways to
     represent environments. Since we used data abstraction to isolate
     the rest of the evaluator from the detailed choice of
     representation, we could change the environment representation if
     we wanted to. (See Exercise 4.11.) In a production-quality Lisp
     system, the speed of the evaluator's environment operations -
     especially that of variable lookup - has a major impact on the
     performance of the system. The representation described here,
     although conceptually simple, is not efficient and would not
     ordinarily be used in a production system.

     - Exercise 4.11: Instead of representing a frame as a pair of
       lists, we can represent a frame as a list of bindings, where
       each binding is a name-value pair. Rewrite the environment
       operations to use this alternative representation.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (lookup-cell var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (lookup-variable-value var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- LOOKUP-VARIABLE-VALUE" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (cdar lookup)))))

       (define (set-variable-value! var val env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- SET-VARIABLE-VALUE!" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (set-cdr! (car lookup) val)))))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.12: The procedures set-variable-value!,
       define-variable! and lookup-variable-value can be expressed in
       terms of more abstract procedures for traversing the
       environment structure. Define abstractions that capture the
       common patterns and redefine the three procedures in terms of
       these abstractions.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (find-cell-in-frame var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (set-cell-val! val cell)
        (set-cdr! (car cell) val))

       (define (cell-val cell)
        (cdar cell))

       (define (null-cell? cell) (null? cell))

       (define (operate-on-cell proc var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- OPERATE-ON-CELL" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null-cell? lookup)
                 (operate-on-cell var (enclosing-environment env))
                 (proc lookup)))))

       (define (lookup-variable-value var env)
        (operate-on-cell
         (lambda (cell)
          (cell-val cell))
         var env))

       (define (set-variable-value! var val env)
        (operate-on-cell
         (lambda (cell)
          (set-cell-val! val cell))
         var env))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.13: Scheme allows us to create new bindings for
       variables by means of define, but provides no way to get rid of
       bindings. Implement for the evaluator a special form
       make-unbound! that removes the binding of a given symbol from
       the environment in which the make-unbound! expression is
       evaluated. This problem is not completely specified. For
       example, should we remove only the binding in the first frame
       of the environment? Complete the specification and justify any
       choices you make.

       I'm only going to remove it from the first frame that has
       it. It doesn't make sense to me to unbind all instances, you
       could then have a utility function inside a function that
       unbinds all variables, even ones in use in enclosing
       functions. Then if you really want to unbind them all you can
       repeatedly unbind.

       #+BEGIN_SRC scheme
       (define (remove-bindings-from-frame var frame)
        (filter (lambda (binding) (not (eq? (car binding) var)))
                frame))
       (define (make-unbound! var env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (make-unbound! var (enclosing-environment env))
              (set-car! env (remove-bindings-from-frame var frame))))))
       #+END_SRC

*** 4.1.4 Running the Evaluator as a Program

    Given the evaluator, we have in our hands a description (expressed
    in Lisp) of the process by which Lisp expressions are
    evaluated. One advantage of expressing the evaluator as a program
    is that we can run the program. This gives us, running within
    Lisp, a working model of how Lisp itself evaluates
    expressions. This can serve as a framework for experimenting with
    evaluation rules, as we shall do later in this chapter. 

    Our evaluator program reduces expressions ultimately to the
    application of primitive procedures. Therefore, all that we need
    to run the evaluator is to create a mechanism that calls on the
    underlying Lisp system to model the application of primitive
    procedures.

    There must be a binding for each primitive procedure name, so that
    when eval evaluates the operator of an application of a primitive,
    it will find an object to pass to apply. We thus set up a global
    environment that associates unique objects with the names of the
    primitive procedures that can appear in the expressions we will be
    evaluating. The global environment also includes bindings for the
    symbols true and false, so that they can be used as variables in
    expressions to be evaluated.

    #+BEGIN_SRC scheme
    (define (setup-environment)
     (let ((initial-env
            (extend-environment (primitive-procedure-names)
                                (primitive-procedure-objects)
                                the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))
    (define the-global-environment (setup-environment))
    #+END_SRC

    It does not matter how we represent the primitive procedure
    objects, so long as apply can identify and apply them by using the
    procedures primitive-procedure? and apply-primitive-procedure. We
    have chosen to represent a primitive procedure as a list beginning
    with the symbol primitive and containing a procedure in the
    underlying Lisp that implements that primitive.

    #+BEGIN_SRC scheme
    (define (primitive-procedure? proc)
     (tagged-list? proc 'primitive))
    (define (primitive-implementation proc) (cadr proc))
    #+END_SRC

    setup-environment will get the primitive names and implementation
    procedures from a list:

    #+BEGIN_SRC scheme
    (define primitive-procedures
     (list (list 'car car)
           (list 'cdr cdr)
           (list 'cons cons)
           (list 'null? null?)
           <more primitives>))
    (define (primitive-procedure-names)
     (map car primitive-procedures))
    (define (primitive-procedure-objects)
     (map (lambda (proc) (list 'primitive (cadr proc)))
          primitive-procedures))
    #+END_SRC

    To apply a primitive procedure, we simply apply the implementation
    procedure to the arguments, using the underlying Lisp system:

    #+BEGIN_SRC scheme
    (define (apply-primitive-procedure proc args)
     (apply-in-underlying-scheme
      (primitive-implementation proc) args))
    #+END_SRC

    For convenience in running the metacircular evaluator, we provide
    a _driver loop_ that models the read-eval-print loop of the
    underlying Lisp system. It prints a _primpt_, reads an input
    expression, evaluates this expression in the global environment,
    and prints the result. We precede each printed result by an
    _output prompt_ so as to distinguish the value of the expression
    from other output that may be printed.

    #+BEGIN_SRC scheme
    (define input-prompt ";;; M-Eval input:")
    (define output-prompt ";;; M-Eval value:")
    (define (driver-loop)
     (prompt-for-input input-prompt)
     (let ((input (read)))
      (let ((output (eval input the-global-environment)))
       (announce-output out-prompt)
       (user-print output)))
     (driver-loop))
    (define (prompt-for-input string)
     (newline) (newline) (display string) (newline))
    (define (announce-output string)
     (newline) (display string) (newline))       
    #+END_SRC

    We use a special printing procedure, user-print, to avoid printing
    the environment part of a compound procedure, which may be a very
    long list (or may even contain cycles). 

    #+BEGIN_SRC scheme
    (define (user-print object)
     (if (compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
         (display object)))
    #+END_SRC

    Now all we need to do to run the evaluator is to initialize the
    global environment and start the driver loop. Here is a sample
    interaction:

    #+BEGIN_SRC scheme
    (define the-global-environment (setup-environment))
    (driver-loop)

    ;;; M-Eval input:
    (define (append x y)
     (if (null? x)
         y
         (cons (car x) (append (cdr x) y))))

    ;;; M-Eval value:
    ok

    ;;; M-Eval input:
    (append '(a b c) '(d e f))
      
    ;;; M-Eval value:
    (a b c d e f)
    #+END_SRC

    - Exercise 4.1.4: Eva Lu Ator and Louis Reasoner are each
      experimenting with the metacircular evaluator. Eva types in the
      definition of map, and runs some test programs that use it. They
      work fine. Louis, in contrast, has installed the system version
      of map as a primitive for the metacircular evaluator. When he
      tries it, things go terribly wrong. Explain why Louis' map fails
      even though Eva's works.

      Louis's version, the underlying scheme version, needs a
      procedure object of the kind defined by the underlying lisp, not
      a procedure from our lisp. However, what it will get is a
      procedure definition from our own lisp, even if it's a
      primitive, it will not get an actual procedure object, so it
      will not be able to map that way. 

*** 4.1.4 Data as Programs
    In thinking about a Lisp program that evaluates Lisp expressions,
    an analogy might be helpful. One operational view of the meaning
    of a program is that the program is a description of an abstract
    (perhaps infinitely large) machine. For exmaple, consider the
    familiar program to compute factorials:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1) n))))
    #+END_SRC

    We may regard this program as the description of a machine
    containing parts that decrement, multiply, and test for equality,
    together with a two-position switch and another factorial
    machine. (The factorial machine is infinite because it contains
    another factorial machine within it.) Figure 4.2 is a flow diagram
    for the factorial  machine, showing how the parts are wired
    together.

    In a similar way, we can regard the evaluator as a very special
    machine that takes as input a description of a machine. Given this
    input, the evaluator configures itself to emulate the machine
    described. For example, if we feed our evaluator the definition of
    factorial, as shown in Figure 4.3, the evaluator will be able to
    compute factorials.

    From this perspective, our evaluator is seen to be a _universal
    machine_. It mimics other machines when these are described as
    Lisp programs. This is striking. Try to imagine an analogous
    evaluator for electrical circuits. This would be a circuit that
    takes as input a signal encoding the plans for some other circuit,
    such as a filter. Given this input, the circuit evaluator would
    then behave like a filter with the same description. Such a
    universal electrical circuit is almost unimaginably complex. It is
    remarkable that the program evaluator is a rather simple program.

    Another striking aspect of the evaluator is that it acts as a
    bridge between the data objects that are manipulated by our
    programming language and the programming language itself. Imagine
    that the evaluator program (implemented in Lisp) is running, and
    that a user is typing expressions to the evaluator and observing
    the results. From the perspective of the user, an input expression
    such as (* x x) is an expression in the programming language,
    which the evaluator should execute. From the perspective of the
    evaluator, however, the expression is simply a list (in this case,
    a list of three symbols: *, x, and x) that is to be manipulated
    according to a well-defined set of rules. 
    
    That the user's programs are the evaluator's data need not be a
    source of confusion. In fact, it is sometimes convenient to ignore
    this distinction, and to give the user the ability to explicitly
    evaluate a data object as a Lisp expression, by making eval
    available for use in programs. Many Lisp dialects provide a
    primitive eval procedure that takes as arguments an expression and
    an environment and evaluates the expression relative to the
    environment. Thus,

    #+BEGIN_SRC scheme
    (eval '(* 5 5) user-initial-environment)
    #+END_SRC
    
    and

    #+BEGIN_SRC scheme
    (eval (cons '* (list 5 5)) user-initial-environment)
    #+END_SRC

    will both return 25.

    - Exercise 4.15: Given a one-argument procedure p and an object a,
      p is said to "halt" on a if evaluating the expression (p a)
      returns a value (as opposed to terminating with an error message
      or running forever). Show that it is impossible to write a
      procedure halts? that correctly determines whether p halts on a
      for any procedure p and object a. Use the following reasoning:
      If you had such a procedure halts?, you could implement the
      following program:

      #+BEGIN_SRC scheme
      (define (run-forever) (run-forever))
      (define (try p)
       (if (halts? p p) (run-forever) 'halted))
      #+END_SRC

      Now consider evaluating the expression (try try) and show that
      any possible outcome (either halting or running forever)
      violates the intended behavior of halts?.

      Try is supposed to run forever if the procedure given to it
      halts when given itself, and halt if it would run forever. If
      the halts? procedure decides that (try try) halts it will
      actually run forever, making that procedure inconsistent and
      breaking the law of functions. If it decides it runs forever the
      procedure will halt, again breaking the rules of functions by
      having a different result for the same input.

*** 4.1.6 Internal Definitions

    Our environment model of evaluation and our metacircular evaluator
    execute definitions in sequence, extending the environment frame
    one definition at a time. This is particularly convenient for
    interactive program development, in which the programmer needs to
    freely mix the application of procedures with the definition of
    new procedures. However, if we think carefully about the internal
    definitions used to implement block structure (introduced in
    Section 1.1.8), we find that name-by-name extension of the
    environment may not be the best way to define local
    variables. Consider a procedure with internal definitions, such as

    #+BEGIN_SRC scheme
    (define (f x)
     (define (even? n) (if (= n 0) true (odd? (- n 1))))
     (define (odd? n) (if (= n 0) false (even? (- n 1))))
     <rest of body of f>)
    #+END_SRC

    Our intention here is that the name odd? in the body of the
    procedure even? should refer to the procedure odd? that is defined
    after even?. The scope of the name odd? is the entire body of f,
    not just the portion of the body of f starting at the point where
    the define for odd? occurs. Indeed, when we consider that odd? is
    itself defined in terms of even? -- so that even? and odd? are
    mutually recursive procedures -- we see that the only satisfactory
    interpretation of the two defines is to regard them as if the
    names even? and odd? were being added to the environment
    simultaneously. More generally, in block structure, the scope of a
    local name is the entire procedure body in which the define is
    evaluated.

    As it happens, our interpreter will evaluate calls to f correctly,
    but for an "accidental" reason: Since the definitions of the
    internal procedures come first, no calls to these procedures will
    be evaluated until all of them have been defined. Hence, odd? will
    have been defined by the time even? is executed. In fact, our
    sequential evaluation mechanism will give the same result as a
    mechanism that directly implements simultaneous definition for any
    procedure in which the internal definitions come first in a body
    and evaluation of the value expressions for the defined variables
    doesn't actually use any of the defined variables. (For an example
    of a procedure that doesn't obey these restrictions, so that
    sequential definition isn't equivalent to simultaneous definition,
    see Exercise 4.19). 

    There is, however, a simple way to treat definitions so that
    internally defined names have truly simultaneous scope -- just
    create all local variables that will be in the current environment
    before evaluating any of the value expressions. One way to do this
    is by a syntax transformation on lambda expressions. Before
    evaluating the body of a lambda expression, we "scan out" and
    eliminate all the internal definitions in the body. For example,
    the procedure

    #+BEGIN_SRC scheme
    (lambda <vars>
     (define u <e1>)
     (define v <e2>)
     <e3>)
    #+END_SRC

    would be transformed into

    #+BEGIN_SRC scheme
    (lambda <vars>
     (let ((u '*unassigned*)
           (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))
    #+END_SRC

    where \*unassigned\* is a special symbol that causes looking up a
    variable to signal an error if an attempt is made to use the value
    of the not-yet-assigned variable.

    An alternative strategy for scanning out internal definitions is
    shown in Exercise 4.18. Unlike the transformation shown above,
    this enforces the restriction that defined variables' values can
    be evaluated without using any of the variables' values. 

    - Exercise 4.16: In this exercise we implement the method just
      described for interpreting internal definitions. We assume that
      the evaluator supports let (see Exercise 4.6).

      a. Change lookup-variable-value (Section 4.13) to signal an
      error if the value it finds is the symbol \*unassigned\*.

      b. Write a procedure scan-out-defines that takes a procedure
      body and returns an equivalent one that has no internal
      definitions, by making the transformation described above. 
      
      c. Install scan-out-defines in the interpreter, either in
      make-procedure or in procedure-body (see Section 4.1.3). Which
      place is better? Why? 

      It makes more sense to put it in make-procedure, if the
      procedure-body is accessed multiple times, we only transform it
      once in make-procedure.

    - Exercise 4.17: Draw diagrams of the environment in effect when
      evaluating the expression <e3> in the procedure in the text,
      comparing how this will be structured when definitions are
      interpreted sequentially with how it will be structured if
      definitions are scanned out as described. Why is there an extra
      frame in the transformed program? Explain why this difference in
      environment structure can never make a difference in the
      behavior of a correct program. Design a way to make the
      interpreter implement the "simultaneous" scope rule for internal
      definitions without constructing the extra frame.

      There is an extra frame because we introduced an extra let
      expression, which is just syntactical sugar for lambda, which is
      a procedure, which creates an extra frame. It makes no
      difference in program behavior because we set variables
      immediately inside the let, so there is no opportunity for the
      program to try to find the value of a variable and not get
      it. We can implement simultaneous scope by using defines instead
      of lets, the program expansion from the text would be:

      #+BEGIN_SRC scheme
      (lambda <vars>
       (define u '*unassigned*)
       (define v '*unassigned*)
       (set! u <e1>)
       (set! v <e2>)
       <e3>)
      #+END_SRC

    - Exercise 4.18: Consider an alternative strategy for scanning out
      definitions that translates the example in the text to

      #+BEGIN_SRC scheme
      (lambda <vars>
       (let ((u '*unassigned*) (v '*unassigned*))
        (let ((a <e1>) (b <e2>))
         (set! u a)
         (set! v b))
        <e3>))
      #+END_SRC

      Here a and b are meant to represent new variable names, created
      by the interpreter, that do not appear in the user's
      program. Consider the solve procedure from Section 3.5.4:

      #+BEGIN_SRC scheme
      (define (solve f y0 dt)
       (define y (integral (delay dy) y0 dt))
       (define dy (stream-map f y))
       y)
      #+END_SRC

      Will this procedure work if internal definitions are scanned out
      as shown in this exercise? What if they are scanned out as shown
      in the text? Explain.

      It should, since dy is delayed for evaluation (although our
      interpreter doesn't have a delay keyword). The definition of dy
      itself however may not work. y will be set to \*unassigned\*
      when it tries to stream-map on y, which is not a valid
      stream. stream-map will try to evaluate one application of f on
      the y stream. The expansion would look like this:

      #+BEGIN_SRC scheme
      (lambda (f y0 dt)
       (let ((y '*unassigned*) (dy '*unassigned))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
         (set! y a)
         (set! dy b))
        y))
      #+END_SRC

      What will happen is stream-map will try to evaluate 
      (cons-stream (f (stream-car y)) (stream-map f (stream-cdr y)))
      The first expression (f (stream-car y)) will be evaluated
      immediately, and looking up the value of y will throw an
      error. The original transformation would work, since it does
      actually evaluate set! expressions in the same order that the
      defines occured, so y would be defined as a stream.

    - Exercise 4.19: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator
      are arguing about the desired result of evaluating the
      expression

      #+BEGIN_SRC scheme
      (let ((a 1))
       (define (f x)
        (define b (+ a x))
        (define a 5)
        (+ a b))
      (f 10))
      #+END_SRC

      Ben asserts that the result should be obtained using the
      sequential rule for define: b is defined to be 11, then a is
      defined to be 5, so the result is 16. Alyssa objects that mutual
      recursion requires the simultaneous scope rule for internal
      procedure definitions, and that it is unreasonable to treat
      procedure names differently from other names. Thus, she argues
      for the mechanism implemented in Exercise 4.16. This would lead
      to a being unassigned at the time that the value for b is to be
      computed. Hence, in Alyssa's view the procedure should produce
      an error. Eva has a third opinion. She says that if the
      definitions of a and b are truly meant to be simultaneous, then
      the value 5 for a should be used in evaluating b. Hence, in
      Eva's view a should be 5, b should be 15, and the answer should
      be 20. Which (if any) of these viewpoints do you support? Can
      you devise a way to implement internal definitions so that they
      behave as Eva prefers?

      If we say that internal definitions are supposed to be in
      principle simultaneous, I would say that Alyssa is right. It
      doesn't make sense that a would be defined during a parallel
      assignment. If it is, then assignment is not parallel but
      ordered in some way. This should produce an error.

      The only way to do it the way Eva wants is to analyze the
      expressions and order the sets so that they occur in the right
      order. So you would have to scan each definition for references
      to the others. This doesn't work in a circular definition
      case. This is why I don't think Eva's definition actually makes
      sense, if assignment is simultaneous, saying that a is defined
      to be 5 implicitly defines an ordering.

      However another, simpler way that accomplishes these semantics
      but changes other semantics is to use delay in eval-ing the
      value of the set! expressions. You can do this simply by adding
      a wrapping (delay) in the eval-assignment function, and testing
      if a variable lookup-value is a promise with promise? when doing
      a lookup. This causes the code above to function in the way Eva
      wants. However, it breaks/changes the semantics of other
      expressions, specifically any side-effect expression.

      #+BEGIN_SRC scheme
      (define g 20)
      (define (s x) (set! g (- g x)) g)
      (define (d x) (set! g (/ g x)) g)

      (define (f x)
       (define m (h 2))
       (define x (d 3))
       (+ x m))

      #+END_SRC

    - Exercise 4.20: Because internal definitions look sequential but
      are actually simultaneous, some people prefer to avoid them
      entirely, and use the special form letrec instead. letrec looks
      like let, so it is not surprising that the variables it binds
      are bound simultaneously and have the same scope as each
      other. The sample procedure f above can be written without
      internal definitions, but with exactly the same meaning, as

      #+BEGIN_SRC scheme
      (define (f x)
       (letrec
        ((even? (lambda (n)
                 (if (= n 0) true (odd? (- n 1)))))
         (odd?  (lambda (n)
                 (if (= n 0) false (even? (- n 1))))))
         <rest of body of f>))
      #+END_SRC

      letrec expressions, which have the form

      #+BEGIN_SRC scheme
      (letrec ((<var1> <exp1>) ... (<varn> <expn>))
       <body>)
      #+END_SRC

      are a variation on let in which the expressions <expk> that
      provide the initial values for the variables <vark> are
      evaluated in an environment that includes all the letrec
      bindings. This permits recursion in the bindings, such as the
      mutual recursion of even? and odd? in the example above, or the
      evaluation of 10 factorial with

      #+BEGIN_SRC scheme
      (letrec
       ((fact (lambda (n)
               (if (= n 1) 1 (* n (fact (- n 1)))))))
       (fact 10))
      #+END_SRC

      a. Implement letrec as a derived expression, by transforming a
      letrec expression into a let expression as shown in the text
      above or in exercise 4.18. That is, the letrec variables should
      be created with a let and then be assigned their values with a
      set!.
      
      #+BEGIN_SRC scheme
      (define (letrec? expr)
       (eq? (car expr) 'letrec))
      (define (letrec-bindings expr)
       (cadr expr))
      (define (letrec-body expr)
       (cddr expr))
      (define (letrec->let expr)
       (let ((binding-vars (map binding-var (letrec-bindings expr))))
        (let ((undefined-bindings
               (map (lambda (name) (make-binding name UNDEFINED-VARIABLE))
                    binding-vars))
              (assignments
               (map (lambda (binding)
                     (make-assignment
                      (binding-var binding)
                      (binding-val binding)))
                    (letrec-bindings expr)))) 
         (make-let
          undefined-bindings
          (concat-exps
           assignments
           (letrec-body expr))))))
      #+END_SRC

      b. Louis Reasoner is confused by all this fuss about internal
      definitions. The way he sees it, if you don't like to use define
      inside a procedure, you can just use let. Illustrate what is
      loose about his reasoning by drawing an environment diagram that
      shows the environment in which the <rest of body of f> is
      evaluated during evaluation of the expression (f 5), with f
      defined as in this exercise. Draw an environment diagram for the
      same evaluation, but with let in place of letrec in the
      definition of f. 

      The issue is that let creates a new internal environment, but
      evaluates the binding value expressions in the environment of
      the outer environment. As a result, evaluating a (lambda) in a
      plain let results in a procedure who's parent environment is not
      the new environment being created but the one above that. So it
      cannot 'see' names in the same environment being created by the
      let. So when a variable lookup happens inside the body of the
      lambda, it looks in the environment above the current let, and
      can't find anything in the current let. letrec creates the
      bindings first and evaluates the lambda inside the new
      environment, so mutual reference is possible.

    - Exercise 4.21: Amazingly, Louis's intuiition in Exercise 4.20 is
      correct. It is indeed possible to specify recursive procedures
      without using letrec (or even define), although the method for
      accomplishing this is much more subtle than Louis imagined. The
      following expression computes 10 factorial by applying a
      recursive factorial procedure:

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fact) (fact fact n))
         (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
        10)
      #+END_SRC

      a. Check (by evaluating the expression) that this really does
      compute factorials. Devise an analogous expression for computing
      Fibonacci numbers.

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fibo) (fibo fibo n))
         (lambda (fib n)
          (cond ((or (= n 2) (= n 1)) 1)
                ((= n 0) 0)
                (else (+ (fib fib (- n 1)) (fib fib (- n 2))))))))
       10)
      #+END_SRC

      b. Consider the following procedure, which includes mutually
      recursive internal definitions:

      #+BEGIN_SRC scheme
      (define (f x)
       (define (even? n)
        (if (= n 0) true (odd? (- n 1))))
       (define (odd? n)
        (if (= n 0) false (even? (- n 1))))
       (even? x))
      #+END_SRC

      Fill in the missing expressions to complete an alternative
      definition of f, which uses neither internal definitions nor
      letrec:

      #+BEGIN_SRC scheme
      (define (f x)
       ((lambda (even? odd?) (even? even? odd? x))
        (lambda (ev? od? n)
         (if (= n 0) true (od? ev? od? (- n 1))))
        (lambda (ev? od? n)
         (if (= n 0) false (ev? ev? od? (- n 1))))))
      #+END_SRC
*** 4.1.7 Separating Syntactic Analysis from Execution
    The evaluator implemented above is simple, but it is very
    inefficient, because the syntactic analysis of expressions is
    interleaved with their execution. Thus if a program is executed
    many times, its syntax is analyzed many times. Consider, for
    example, evaluating (factorial 4) using the following definition
    of factorial:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1)) n)))
    #+END_SRC

    Each time factorial is called, the evaluator must determine that
    the body is an if expression and extract the predicate. Only then
    can it evaluate the predicate and dispatch on its value. Each time
    it evaluates the expression (* (factorial (- n 1)) n), or the
    subexpressions (factorial (- n 1)) and (- n 1), the evaluator must
    perform the case analysis in eval to determine that the expression
    is an application, and must extract its operator and
    operands. This analysis is expensive. Performing it repeatedly is
    wasteful.

    We can transform the evaluator to be significantly more efficient
    by arranging things so that syntactic analysis is performed only
    once. We split eval, which takes an expression and an environment,
    into two parts. The procedure analyze takes only the
    expression. It performs the syntactic analysis and returns a new
    procedure, the _execution procedure_, that encapsulates the work
    to be done in executing the analyzed expression. The execution
    procedure takes an environment as its argument and completes the
    evaluation. This saves work because analyze will be called only
    once on an expression, while the execution procedure may be called
    many times. 

    With the separation into analysis and execution, eval now becomes

    #+BEGIN_SRC scheme
    (define (eval exp env) ((analyze exp) env))
    #+END_SRC

    The result of calling analyze is the execution procedure to be
    applied to the environment. The analyze procedure is the same case
    analysis as performed by the original eval of Section 4.1.1,
    except that the procedures to which we dispatch perform only
    analysis, not full evaluation:

    #+BEGIN_SRC scheme
    (define (analyze exp)
     (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
           ((quoted? exp) (analyize-quoted exp))
           ((variable? exp) (analyze-variable exp))
           ((assignment? exp) (analyze-assignment exp))
           ((definition? exp) (analyze-definition exp))
           ((if? exp) (analyze-if exp))
           ((lambda? exp) (analyze-lambda exp))
           ((begin? exp) (analyze-sequence (begin-actions exp)))
           ((cond? exp) (analyze (cond->if exp)))
           ((application? exp) (analyze-application exp))
           (else (error "Unknown expression type: ANALYZE" exp))))
    #+END_SRC

    Here is the simplest syntactic analysis procedure, which handles
    self-evaluating expressions. It returns an execution procedure
    that ignores its environment argument and just returns the
    expression:

    #+BEGIN_SRC scheme
    (define (analyze-self-evaluating exp)
     (lambda (env) exp))
    #+END_SRC

    For a quoted expression, we can gain a little efficiency by
    extracting the text of the quotation only once, in the analysis
    phase, rather than in the execution phase.

    #+BEGIN_SRC scheme
    (define (analyze-quoted exp)
     (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
    #+END_SRC

    Looking up a variable value must still be done in the execution
    phase, since this depends upon knowing the environment. 

    #+BEGIN_SRC scheme
    (define (analyze-variable exp)
     (lambda (env) (lookup-variable-value exp env)))
    #+END_SRC

    analyze-assignment also must defer actually setting the variable
    until the execution, when the environment has been
    supplied. However, the fact that the assignment-value expression
    can be analyzed (recursively) during analysis is a major gain in
    efficiency, because the assignment-value expression will now be
    analyzed only once. The same holds true for definitions.

    #+BEGIN_SRC scheme
    (define (analyze-assignment exp)
     (let ((var (assignment-variable exp))
           (vproc (analyze (assignment-value exp))))
      (lambda (env)
       (set-variable-value! var (vproc env) env)
       'ok)))
    (define (analyze-definition exp)
     (let ((var (definition-variable exp))
           (vproc (analyze (definition-value exp))))
      (lambda (env)
       (define-variable! var (vproc env) env)
       'ok)))
    #+END_SRC

    For if expressions, we extract and analyze the predicate,
    consequent, and alternative at analysis time.

    #+BEGIN_SRC scheme
    (define (analyze-if exp)
     (let ((pproc (analyze (if-predicate exp)))
           (cproc (analyze (if-consequent exp)))
           (aproc (analyze (if-alternative exp))))
      (lambda (env)
       (if (true? (pproc env))
           (cproc env)
           (aproc env)))))
    #+END_SRC

    Analyzing a lambda expression also achieves a major gain in
    efficiency: We analyze the lambda body only once, even though
    procedures resulting from evaluation of the lambda may be applied
    many times.

    #+BEGIN_SRC scheme
    (define (analyze-lambda exp)
     (let ((vars (lambda-parameters exp))
           (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
    #+END_SRC

    Analysis of a sequence of expressions (as in a begin or the body
    of a lambda expression) is more involved. Each expression in the
    sequence is analyzed, yielding an execution procedure. These
    execution procedures are combined to produce an execution
    procedure that takes an environment as argument and sequentially
    calls each individual execution procedure with the environment as
    argument.

    #+BEGIN_SRC scheme
    (define (analyze-sequence exps)
     (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
     (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
     (let ((procs (map analyze exps)))
      (if (null? procs) 
          (error "Empty sequence: ANALYZE")
          (loop (car procs) (cdr procs)))))              
    #+END_SRC

    To analyze an application, we analyze the operator and operands
    and construct an execution procedure that calls the operator
    execution procedure that calls the operator execution procedure
    (to obtain the actual procedure to be applied) and the operand
    execution procedures (to obtain the actual arguments). We then
    pass these to execute-application, which is the analog of apply in
    Section 4.1.1. execute-application differs from apply in that the
    procedure body for a compound procedure has already been analyzed,
    so there is no need to do further analysis. Instead, we just call
    the execution procedure for the body on the extended environment.

    #+BEGIN_SRC scheme
    (define (analyze-application exp)
     (let ((fproc (analyze (operator exp)))
           (aprocs (map analyze (operands exp))))
      (lambda (env)
       (execute-application
        (fproc env)
        (map (lambda (aproc) (aproc env))
             aprocs)))))
    (define (execute-application proc args)
     (cond ((primitive-procedure? proc)
            (apply-primitive-procedure proc args))
           ((compound-procedure? proc)
            ((procedure-body proc)
             (extend-environment
              (procedure-parameters proc)
              args
              (procedure-environment proc))))
           (else
            (error "Unknwon procedure type: EXECUTE-APPLICATION"
                   proc)))) 
    #+END_SRC

    Our new evaluator uses the same data structures, syntax
    procedures, and run-time support procedures as in sections Section
    4.1.2, Section 4.1.3, and Section 4.1.4. 

    - Exercise 4.22: Extend the evaluator in this section to support
      the special form let.
      
      let is only a syntactical construct so all we have to do is add
      
      #+BEGIN_SRC scheme
      ((let? exp) (analyze (let->combination exp)))
      #+END_SRC

      to the case statement in analyze.

    - Exercise 4.23: Alyssa P. Hacker doesn't understand why
      analyze-sequence needs to be so complicated. All the other
      analysis procedures are straightforward transformations of the
      corresponding evaluation procedures (or eval clauses) in Section
      4.1.1. She expected analyze-sequence to look like this:

      #+BEGIN_SRC scheme
      (define (analyze-sequence exps)
       (define (execute-sequence procs env)
        (cond ((null? (cdr procs))
               ((car procs) env))
              (else
               ((car procs) env)
               (execute-sequence (cdr procs) env))))
       (let ((procs (map analyze exps)))
        (if (null? procs)
            (error "Empty sequence: ANALYZE"))
        (lambda (env)
         (execute-sequence procs))))
      #+END_SRC

      Eva Lu Ator explains to Alyssa that the version in the text does
      more of the work of evaluating a sequence at analysis
      time. Alyssa's sequence-execution procedure, rather than having
      the calls to the individual execution procedures built in, loops
      through the procedures in order to call them: In effect,
      although the individual expressions in the sequence have been
      analyzed, the sequence itself has not been.

      Compare the two versions of analyze-sequence. For example,
      consider the common case (typical of procedure bodies) where the
      sequence has just one expression. What work will the execution
      procedure proeduced by Alyssa's program do? What about the
      execution procedure produced by the program in the text above?
      How do the two version compare for a sequence with two
      expressions?

      The original actual execution procedure will only execute the
      actual analyzed body, resulting in a single procedure call.

      Alyssa's procedure, on the other hand, will run execute-sequence
      on a single-item list. It will test if the next item is null,
      find that it is, and then do an execution. This results in three
      procedure calls -- execute-sequence?, null?, and the actual
      call, three calls.

      For two expressions, the original definition:

      (lambda (env) (proc1 env) (lambda (env) (proc2 env) (proc3 env)))
      Calling this procedure calls the original 3, plus two
      lambdas. This is 5 procedure calls. The number of procedure
      calls is multiplied by 2 (minus 1) -- 2 * n - 1.

      Alyssa's definition calls the original execute-sequence
      recursively, and tests for null each time. This is a list of
      procedure calls made:

      execute-sequence, null?, proc1, execute-sequence, null? proc2,
      execute-sequence, null?, proc3

      A total of 9 procedure calls.

      In general, Alyssa's definition multiplies the number of calls
      by 3, each time the body is evaluated -- 3 * n.

    - Exercise 4.24: Design and carry out some experiments to compare
      the speed of the original metacircular evaluator with the
      version in this section. Use your results to estimate the
      fraction of time that is spent in analysis versus execution for
      various procedures.

      The most obvious thing to do is write a procedure, like fibo,
      and execute it with a sizeable input and compare the results.

      The first thing I did was manually time the execution of
      (fibo 25) in each interpreter, with fibo defined as:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))
      #+END_SRC

      The analyze-execute version took 14 seconds, and the first naive
      evaluator that we implemented with no separate analysis step
      took 34 seconds. 

      The next step was to provide the interpreter itself with a way
      of telling time. I provided it with the primitive procedure
      get-universal-time, from the underlying scheme, and typed in
      this:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))

      (begin
       (let ((t1 (get-universal-time)))
        (fibo 25)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      The results were 33 for the original interpreter and 14 again
      for the analyzing interpreter. I repeated the experiment several
      time for both interpreters and got [34,33,34,34] and
      [14,14,13,13]. The averages are then 33.75 and 13.5, the
      original interpreter takes 2.5 times as long to do fibo. Since
      no 'analysis' is done in the analyzing interpreter and it is
      done every time in the first interpreter. So we can conclude
      that the fraction of time spent in analysis is (33.75 -
      13.5)/33.75, or .6 -- 60% of the interpreter's time is spent
      analyzing syntax if we don't extract that step. 

      We can also try a different kind of procedure. Instead of a
      multiple recursion procedure, we can try linear recursion.

      #+BEGIN_SRC scheme
      (define (sum n)
       (define (loop n result)
       (if (= n 0) 
           result
           (loop (- n 1) (+ result n))))
       (loop n 0))

      (begin
       (let ((t1 (get-universal-time)))
        (sum 100000)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      With the classic interpreter, I get 13, 13, 12, 13. With
      the analyzing interpreter, I get 6, 6, 7, 6. Despite the fact
      that the computational nature of the procedure is very
      different, the ratios are similar:

      (13 - 6)/13 = .54 (previous was .6)
      13/6 = 2.1 (previous was 2.5)

** 4.2 Variations on a Scheme -- Lazy Evaluation
   Now that we have an evaluator expressed as a Lisp program, we can
   experiment with alternative choices in language design simply by
   modifying the evaluator. Indeed, new languages are often invented
   by first writing an evaluator that embeds the new language within
   an existing high-level language. For example, if we wish to discuss
   some aspect of a proposed modification to Lisp with another member
   of the Lisp community, we can supply an evaluator that embodies the
   change. The recipient can then experiment with the new evaluator
   and send back comments as further modifications. Not only does the
   high-level implementation base make it easier to test and debug the
   evaluator; in addition, the embedding enables the designer to snarf
   features from the underlying language, just as our embedded Lisp
   evaluator uses primitives and control structures from the
   underlying Lisp. Only later (if ever) need the designer go to the
   trouble of building a complete implementation in a low-level
   language or in hardware. In this section and the next we will
   explore some variations on Scheme that provie significant
   additional expressive power.

*** 4.2.1 Normal Order and Applicative Order
    In Section 1.1, where we began our discussion of models of
    evaluation, we noted that Scheme is an _applicative-order_
    language, namely, that all the arguments to Scheme procedures are
    evaluated when the procedure is applied. In contrast,
    _normal-order_ languages delay evaluation of procedure arguments
    until the actual argument values are needed. Delaying evaluation
    of procedure arguments until the last possible moment (e.g., until
    they are required by a primitive operation) is called _lazy
    evaluation_. Consider the procedure
    
    #+BEGIN_SRC scheme
    (define (try a b) (if (= a 0) 1 b))
    #+END_SRC
    
    Evaluating (try 0 (/ 1 0)) generates an error in Scheme. With lazy
    evaluation, there would be no error. Evaluating the expression
    would return 1, because the argument (/ 1 0) would never be
    evaluated. An example that exploits lazy evaluation is the
    definition of a procedure unless
    
    #+BEGIN_SRC scheme
    (define (unless condition usual-value exceptional-value)
     (if condition exceptional-value usual-value))
    #+END_SRC

    that can be used in expressions such as

    #+BEGIN_SRC scheme
    (unless (= b 0)
            (/ a b)
            (begin (display "Exception: Returning 0") 0)) 
    #+END_SRC

    This won't work in an applicative-order language because both the
    usual value and the exceptional value will be evaluated before
    unless is called (compare Exercise 1.6). An advantage of lazy
    evaluation is that some procedures, such as unless, can do useful
    computation even if evaluation of some of their arguments would
    produce errors or would not terminate. 

    If the body of a procedure is entered before an argument has been
    evaluated we say that the procedure is _non-strict_ in that
    argument. If the argument is evaluated before the body of the
    procedure is entered we say that the procedure is _strict_ in that
    argument. In a purely applicative-order language, all procedures
    are strict in each argument. In a purely normal-order language,
    all procedures are strict in each argument. In a purely
    normal-order language, all compound procedures are non-strict in
    each argument, and primitive proceduers may be either strict or
    non-strict. There are also languages (see Exercise 4.31) that give
    programmers detailed control over the strictness of the procedures
    they define. 

    A striking example of a procedure that can usefully be made
    non-strict is cons (or, in general, almost any constructor for
    data structures). One can do useful computation, cimbining
    elements to form data structures and operating on the resulting
    data structures, even if the values of the elements are not
    known. It makes perfect sense, for instance, to compute the length
    of a list without knowing the values of the individual elements in
    the list. We will exploit this idea in Section 4.2.3 to implement
    the stream of Chapter 3 as lists formed of non-strict cons pairs.

    - Exercise 4.25: Suppose that (in ordinary applicative-order
      Scheme) we define unless as shown above and then define
      factorial in terms of unless as

      #+BEGIN_SRC scheme
      (define (factorial n)
       (unless (= n 1)
               (* n (factorial (- n 1)))
               1))
      #+END_SRC

      What happens if we attempt to evaluate (factorial 5)? Will our
      definitions work in a normal-order language?

      Because unless in a applicative-order language would simply be a
      normal procedure whose arguments are evaluated first before the
      procedure itself is called, the procedure will never terminate,
      no matter what arguments we give it. It will call (* n
      (factorial (- n 1))) forever.

      This definition would work in a normal-order language, assuming
      that once you actually try to call a primitive function or do a
      variable lookup, the value is actually evaluated.

    - Exercise 4.26: Ben Bitdiddle and Alyssa P. Hacker disagree over
      the importance of lazy evaluation for implementing things such
      as unless. Ben points out that it's possible to implement unless
      in applicative order as a special form. Alyssa counters that, if
      one did that, unless would be merely syntax, not a procedure
      that could be used in conjunction with higher-order
      procedures. Fill in the details on both sides of the
      argument. Show how to implement unless as a derived expression
      (like cond or let), and give an example of a situation where it
      might be useful to have unless available as a procedure, rather
      than as a special form.

      Ben is correct, in that you can implement a version of
      unless that will work for the factorial function we defined. You
      would just write a procedure, unless->if, that, like cond,
      converts its unless input syntax to if to be actuall
      evaluated. You would add the following case to the eval procedure:

      ((unless? expr) (eval (unless->if expr)))

      The procedure:

      #+BEGIN_SRC scheme
      (define (unless->if expr)
       (make-if
        (unless-condition expr)
        (unless-failure expr)
        (unless- expr)))
      #+END_SRC

      However, Alyssa is also correct, you can't pass unless as a
      procedural argument to higher-order procedures, so something
      like this:

      #+BEGIN_SRC scheme
      (higher-order-procedure unless (list 'a 'b 'c))
      #+END_SRC

      will simply produce a variable-not-found error. It may be useful
      to have unless if you have some kind of higher-order procedure
      where it's behavior is modified by what operator you give it.

      #+BEGIN_SRC scheme
      (define (proc f vals)
       (map 
        (lambda (val) 
         (f (car val) (cadr val) (caddr val)))
        vals))
      #+END_SRC

      This procedure takes lists of triples, and applies f to each
      triple in a map. 

      #+BEGIN_SRC scheme
      (proc unless '((1 2 3) (false 1 2)))
      (list 3 1)
      #+END_SRC

      You can't do that with unless as syntax. You can do it however
      with unless as a normal applicative-order function in our
      current interpreter. However, we can also, assuming that list is
      also normal-order, write:

      (list (list (= a 1) (factorial 10) 33) (list (= a 22)
      (factorial 11) 33))

      And in general write something like a batch-processed system of
      conditionals that you can apply to data structures.

      
*** 4.2.2 An Interpreter with Lazy Evaluation
    In this section we will implement a normal-order language that is
    the same as Scheme except that compound procedures are non-strict
    in each language. Primitive procedures will still be strict. It is
    not difficult to modify the evaluator of Section 4.1.1 so that the
    language it interprets behaves this way. Almost all the required
    changes center around procedure application.

    The basic idea is that, when applying a procedure, the interpreter
    must determine which arguments are to be evaluated and which are
    to be delayed. The delayed arguments are not evaluated; instead,
    they are transformed into objects called _thunks_. The thunk must
    contain the information required to produce the value of the
    argument when it is needed, as if it had been evaluated at the
    time of the application. Thus, the thunk must contain the argument
    expression and the environment in which the procedure application
    is being evaluated.

    The process of evaluating the expression in a thunk is called
    _forcing_. In general, a thunk will be forced only when its value
    is needed: when it is passed to a primitive procedure that will
    use the value of the thunk; when it is the value of a predicate of
    a conditional; and when it is the value of an operator that is
    about to be applied as a procedure. One design choice we have
    available is whether or not to _memoize_ thunks, as we did with
    delayed objects in Section 3.5.1. With memoization, the first time
    a thunk is forced, it stores the value that is
    computed. Subsequent forcings simply return the stored value
    without repeating the computation. We'll make our interpreter
    memoize, because this is more efficient for many
    applications. There are tricky considerations here, however.

**** Modifying the evaluator.
     
     The main difference between the lazy evaluator and the one in
     Section 4.1 is in the handling of the procedure applications in
     eval and apply. The application? clause of eval becomes

     #+BEGIN_SRC scheme
     ((application? exp)
      (apply (actual-value (operator exp) env)
             (operands exp)
             env))
     #+END_SRC

     This is almost the same as the application? clause of eval in
     Section 4.1.1. For lazy evaluation, however, we call apply with
     the operand expressions, rather than the arguments produced by
     evaluating them. Since we will need the environment to construct
     thunks if the arguments are to be delayed, we must pass this as
     well. We still evaluate the operator, because apply needs the
     actual procedure to be applied in order to dispatch on its type
     (primitive versus compound) and apply it. 

     Whenever we need the actual value of an expression, we use
     
     #+BEGIN_SRC scheme
     (define (actual-value exp env)
      (force-it (eval exp env)))
     #+END_SRC

     instead of just eval, so that if the expression's value is a
     thunk, it will be forced.

     Our new version of apply is also almost the same as the version
     in Section 4.1.1. The difference is that eval has passed in
     unevaluated operand expressions: For primitive procedures (which
     are strict), we evaluate all the arguments before applying the
     primitive; for compound procedures (which are non-strict) we
     delay all the arguments before appling the procedure. 

     #+BEGIN_SRC scheme
     (define (apply procedure arguments env)
      (cond ((primitive-procedure? procedure)
             (apply-primitive-procedure
              procedure
              (list-of-arg-values arguments env)))
            ((compound-procedure? procedure)
             (eval-sequence
              (procedure-body procedure)
              (extend-environment
               (procedure-parameters procedure)
               (list-of-delayed-args arguments env)
               (procedure-environment procedure))))
            (else (error "Unknown procedure type: APPLY"
                         procedure))))
     #+END_SRC

     The procedures that process the arguments are just like
     list-of-values from Section 4.1.1, except that
     list-of-delayed-args delays the arguments instead of evaluating
     them, and list-of-arg-values uses actual-value instead of eval:

     #+BEGIN_SRC scheme
     (define (list-of-arg-values exps env)
      (if (no-operands? exps)
          '()
          (cons (actual-value (first-operand exps)
                              env)
                (list-of-arg-values (rest-operands exps)
                                    env))))
     (define (list-of-delayed-args exps env)
      (if (no-operands? exps)
          '()
          (cons (delay-it (first-operand exps)
                          env)
                (list-of-delayed-args (rest-operands exps)
                                      env))))
     #+END_SRC

     The other place we must change the evaluator is in the handling
     of if, where we must use actual-value instead of eval to get the
     value of the predicate expression before testing whether it is
     true or false:

     #+BEGIN_SRC scheme
     (define (eval-if exp env)
      (if (true? (actual-value (if-predicate exp) env))
          (eval (if-consequent exp) env)
          (eval (if-alternative exp) env)))
     #+END_SRC

     Finally, we must change the driver-loop procedure (Section 4.1.4)
     to use actual-value instead of eval, so that if a delayed value
     is propagated back to the read-eval-print loop, it will be forced
     before being printed. We also change the prompts to indicate that
     this is the lazy evaluator:

     #+BEGIN_SRC scheme
     (define input-prompt  ";;; L-Eval input:")
     (define output-prompt ";;; L-Eval value:")
     (define (driver-loop)
      (prompt-for-input input-prompt)
      (let ((input (read)))
       (let ((output
              (actual-value
               input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)
      (driver-loop))
     #+END_SRC

     With these changes made, we can start the evaluator and test
     it. The successful evaluation of the try expression discussed in
     Section 4.2.1 indicates that the interpreter is performing lazy
     evaluation:

     #+BEGIN_SRC scheme
     (define the-global-environment (setup-environment))
     (driver-loop)
     ;;; L-Eval input:
     (define (try a b) (if (= a 0) 1 b))
     ;;; L-Eval value:
     ok
     ;;; L-Eval input:
     (try 0 (/ 1 0))
     ;;; L-Eval value:
     1
     #+END_SRC

     

     

     

      

      

      


    
      



    
      
