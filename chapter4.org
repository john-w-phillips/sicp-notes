* Chapter 4
** Metalinguistic Abstraction
   In our study of program design, we have seen that expert
   programmers control the complexity of their designs with the same
   general techniques used by designers of all complex systems. They
   combine primitive elements to form compound objects, they abstract
   compound objects to form higher-level building blocks, and they
   preserve modularity by adopting appropriate large-scale views of
   system structure. In illustrating these techniques, we have used
   Lisp as a language for describing processes and for constructing
   computational data objects and processes to model complex phenomena
   in the real world. However, as we confront increasingly complex
   problems, we will find that Lisp, or indeed any fixed programming
   language, is not sufficient for our needs. We must constantly turn
   to new languages in order to expresss our ideas more
   effectively. Establishing new languages is a powerful strategy for
   controlling complexity in engineering design; we can often enhance
   our ability to deal with a complex problem by adopting a new
   language that enables us to describe (and hence to think about) the
   problem in a different way, using primitives, means of combination,
   and means of abstraction that are particularly well suited to the
   problem at hand.

   Programming is endowed with a multitude of languages. There are
   physical languages, such as the machine languages for particular
   computers. These languages are concerned with the representation of
   data and control in terms of individual bits of storage and
   primitive machine instructions. The machine-language programmer is
   concerned with using the given hardware to erect systems and
   utilities for the efficient implementation of resource-limited
   computations. High-level languages, erected on a machine-language
   substrate, hide concerns about the representation of data as
   collections of bits and the representation of programs as sequences
   of primitive instructions. These languages have means of
   combination and abstraction, such as procedure definition, but are
   appropriate to the larger-scale organization of systems.

   _Metalinguistic abstraction_ -- establishing new languages -- plays
   an important role in all branches of engineering design. It is
   particularly important to computer programming, because in
   programming not only can we formulate new languages but we can also
   implement these languages by constructing evaluators. An
   _evaluator_ (or _interpreter_) for a programming language is a
   procedure that, when applied to an expression of the language,
   performs the actions required to evaluate that expression.

   It is no exaggeration to regard this as the most fundamental idea
   in programming:

   The evaluator, which determines the meaning of expressions in a
   programming language, is just another program.

   To appreciate this point is to change our images of ourselves as
   programmers. We come to see ourselves as designers of languages,
   rather than only users of languages designed by others.

   In fact, we can regard almost any program as the evaluator of some
   language. For instance, the polynomial manipulation system of
   Section 2.5.3 embodies the rules of polynomial arithmetic and
   implements them in terms of operations on list-structured data. If
   we augment this system with procedures to read and print polynomial
   expressions, we have the core of a special-purpose language for
   dealing with problems in symbolic mathematics. The digital-logic
   simulator of Section 3.3.4 and the constraint propagator of Section
   3.3.5 are legitimate languages in their own right, each with its
   own primitives, means of combination, and means of
   abstraction. Seen from this perspective, the technology for coping
   with large-scale computer systems merges with the technology for
   building new computer languages, and computer science itself
   becomes no more (and no less) than the discipline of constructing
   appropriate descriptive languages.

   We now embark on a tour of the technology by which languages are
   established in terms of other languages. In this chapter we shall
   use Lisp as a base, implementing evaluators as Lisp
   procedures. Lisp is particularly well suited to this task, because
   of its ability to represent and manipulate symbolic expressions. We
   will take the first step in understanding how languages are
   implemented by building an evaluator for Lisp itself. The language
   implemented by our evaluator will be a subset of the Scheme dialect
   of Lisp that we use in this book. Although the evaluator described
   in this chapter is written for a particular dialect of Lisp, it
   contains the essential structure of an evaluator for any
   expression-oriented language designed for writing programs for a
   sequential machine. (In fact, most language processors contain,
   deep within them, a little "Lisp" evaluator.) The evaluator has
   been simplified for the purposes of illustration and discussion,
   and some features have been left out that would be important to
   include in a production-quality Lisp system. Nevertheless, this
   simple evaluator is adequate to execute most of the programs in
   this book.

   An important  advantage of making the evaluator accessible as a
   Lisp program is that we can implement alternative evaluation rules
   by describing these as modifications to the evaluator program. One
   place where we can use this power to good effect is to gain extra
   control over the ways in which computational models embody the
   notion of time, which was so central to the discussion in
   Chapter 3. There, we mitigated some of the complexities of state
   and assignment by using streams to decouple the representation of
   time in the world from time in the computer. Our stream programs,
   however, were sometimes cumbersome, because they were constrained
   by the applicative-order evaluation of Scheme. In Section 4.2,
   we'll change the underlying language to provide for a more elegant
   approach, by modifying the evaluator to provide for _normal-order
   evaluation_. 

   Section 4.3 implements a more ambitious linguistic change, whereby
   expressions have many values, rather than just a single value. In
   this language of _nondeterministic computing_, it is natural to
   express processes that generate all possible values for expressions
   and then search for those values that satisfy certain
   constraints. In terms of models of computation and time, this is
   like having time branch into a set of "possible futures" and then
   searching for appropriate time lines. With our nondeterministic
   evaluator, keeping track of multiple values and performing searches
   are handled automatically by the underlying mechanism of the
   language.

   In Section 4.4 we implement a _logic-programming_ language in which
   knowledge is expressed in terms of relations, rather than in terms
   of computations with inputs and outputs. Even though this makes the
   language drastically different from Lisp, or indeed from any
   conventional language, we will see that the logic-programming
   evaluator shares the essential structure of a Lisp evaluator.

** 4.1 The Metacircular Evaluator

   Our evaluator for Lisp will be implemented as a Lisp program. It
   may seem circular to think about evaluating Lisp programs using an
   evaluator that is itself implemented in Lisp. However, evaluation
   is a process, so it is appropriate to describe the evaluation
   process using Lisp, which, after all, is our tool for describing
   processes. An evaluator that is written in the same language that
   it evaluates is said to be _metacircular_. 

   The metacircular evaluator is essentially a Scheme formulation of
   the environment model of evaluation described in Section
   3.2. Recall that the model has two basic parts:

   1. To evaluate a combination (a compound expression other than a
      special form), evaluate the subexpressions and then apply the
      value of the operator subexpression to the values of the operand
      subexpressions.
   2. To apply a compound procedure to a set of arguments, evaluate
      the body of the procedure in a new environment. To construct
      this environment, extend the environment part of the procedure
      object by a frame in which the formal parameters of the
      procedure are bound to the arguments to which the procedure is
      applied.

      
   These two rules describe the essence of the evaluation process, a
   basic cycle in which expressions to be evaluated in environments
   are reduced to procedures to be applied to arguments, which in turn
   are reduced to new expressions to be evaluated in new environments,
   and so on, until we get down to symbols, whose values are looked up
   in the environment, and to primitive procedures, which are applied
   directly (see Figure 4.1). This evaluation cycle will be embodied
   by the interplay between the two critical procedures in the
   evaluator, eval and apply, which are described in Section 4.1.1
   (see Figure 4.1).
   
   The implementation of the evaluator will depend upon procedures
   that define the _syntax_ of the expressions to be evaluated. We
   will use data abstraction to make the evaluator independent of the
   representation of the language. For example, rather than committing
   to a choice that an assignment is to be represented by a list
   beginning with the symbol set! we use an abstract predicate
   assignment? to test for an assignment, and we use abstract
   selectors assignment-variable and assignment-value to access the
   parts of an assignment. Implementation of expressions will be
   described in detail in Section 4.1.2. There are also operations,
   described in Section 4.1.3, that specify the representation of
   procedures and environments. For example, make-procedure constructs
   compound procedures, lookup-variable-value accesses the values of
   variables, and apply-primitive-procedure applies a primitive
   procedure to a given list of arguments. 

*** 4.1.1 The Core of the Evaluator

    The evaluation process can be described as the interplay between
    two procedures: eval and apply.

**** Eval
     Eval takes as arguments an expression and an environment. It
     classifies the expression and directs its evaluation. eval is
     structured as a case analysis of the syntactic type of the
     expression to be evaluated. In order to keep the procedure
     general, we express the determination of the type of an
     expression abstractly, making no commitment to any particular
     representation for the various types of expressions. Each type of
     expression has a predicate that tests for it and an abstract
     means for selecting its parts. This _abstract syntax_ makes it
     easy to see how we can change the syntax of the language by using
     the same evaluator, but with a different collection of syntax
     procedures.

***** Primitive expressions
      - For self-evaluating expressions, such as numbers, eval returns
        the expression itself.
      - eval must look up variables in the environment to find their
        values.

***** Special forms
      - For quoted expressions, eval returns the expression that was
        quoted.
      - An assignment to (or a definition of) a variable must
        recursively call eval to compute the new value to be
        associated with the variable. The environment must be modified
        to change (or create) the binding of the variable.
      - An if expression requires special processing of its parts, so
        as to evaluate the consequent if the predicate is true, and
        otherwise to evaluate the alternative.
      - A lambda expression must be transformed into an applicable
        procedure by packaging together the parameters and body
        specified by the lambda expression with the environment of
        evaluation.
      - A begin expression requires evaluating its sequence of
        expressions in the order in which they appear.
      - A case analysis (cond) is transformed into a nest of if
        expressions and then evaluated.

***** Combinations
      - For a procedure application, eval must recursively evaluate
        the operator part and the operands of the combination. The
        resulting procedure and arguments are passed to apply, which
        handles the actual procedure application.

	

     Here is the definition of eval:

     #+BEGIN_SRC scheme
       (define (eval exp env)
         (cond ((self-evaluating? exp) exp)
               ((variable? exp) (lookup-variable-value exp env))
               ((quoted? exp) (text-of-quotation exp))
               ((assignment? exp) (eval-assignment exp env))
               ((definition? exp) (eval-definition exp env))
               ((if? exp) (eval-if exp env))
               ((lambda? exp) (make-procedure (lambda-parameters exp)
                                              (lambda-body exp)
                                              env))
               ((begin? exp)
                (eval-sequence (begin-actions exp) env))
               ((cond? exp) (eval (cond->if exp) env))
               ((application? exp)
                (apply (eval (operator exp) env)
                       (list-of-values (operands exp) env)))
               (else 
                (error "Unknown expression type: EVAL " exp))))
     #+END_SRC

     For clarity, eval has been implemented as a case analysis using
     cond. The disadvantage of this is that our procedure handles only
     a few distinguishable types of expressions, and no new ones can
     be defined without editing the definition of eval. In most Lisp
     implementations, dispatching on the type of an expression is done
     in a data-directed style. This allows a user to add new types of
     expressions that eval can distinguish, without modifying the
     definition of eval itself.

**** Apply     

     apply takes two arguments, a procedure and a list of arguments to
     which the procedure should be applied. apply classifies
     procedures into two kinds: It calls apply-primitive-procedure to
     apply primitives; it applies compound procedures by sequentially
     evaluating the expressions that make up the body of the
     procedure. The environment for the evaluation of the body of a
     compound procedure is constructed by extending the base
     environment carried by the procedure to include a frame that
     binds the parameters of the procedure to the arguments to which
     the procedure is to be applied. Here is the definition of apply:

     #+BEGIN_SRC scheme
       (define (apply procedure arguments)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure procedure arguments))
               ((compound-procedure? procedure)
                (eval-sequence
                 (procedure-body procedure)
                 (extend-environment
                  (procedure-parameters procedure)
                  arguments
                  (procedure-environment procedure))))
               (else
                (error "Unknown procedure type: APPLY" procedure))))
     #+END_SRC

***** Procedure arguments
      When eval processes a procedure application, it uses
      list-of-values to produce a list of arguments to which the
      procedure is to be applied. list-of-values takes as an argument
      the operands of the combination. It evaluates each operand and
      returns a list of the corresponding values:

      #+BEGIN_SRC scheme
      (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (cons (eval (first-operand exps) env)
                 (list-of-values (rest-operands exps) env))))
      #+END_SRC
***** Conditionals

      eval-if evaluates the predicate part of an if expression in the
      given environment. If the result is true, eval-if evaluates the
      consequent, otherwise it evaluates the alternative:

      #+BEGIN_SRC scheme
      (define (eval-if exp env)
       (if (true? (eval (if-predicate exp) env))
           (eval (if-consequent exp) env)
           (eval (if-alternative exp) env)))
      #+END_SRC

      The use of true? in eval-if highlights the issue of the
      connection between an implemented language and an implementation
      language. The if-predicate is evaluated in the language being
      implemented and thus yields a value in that language. The
      interpreter predicate true? translates that value into a value
      that can be tested by the if in the implementation language: The
      metacircular representation of truth might not be the same as
      that of the underlying Scheme.

***** Sequences

      eval-sequence is used by apply to evaluate the sequence of
      expressions in a procedure body and by eval to evaluate the
      sequence of expressions in a begin expression. It takes as
      arguments a sequence of expressions and an environment, and
      evaluates the expressions in the order in which they occur. The
      value returned is the value of the final expression.

      #+BEGIN_SRC scheme
        (define (eval-sequence exps env)
          (cond ((last-exp? exps)
                 (eval (first-exp exps) env))
                (else
                 (eval (first-exp exps) env)
                 (eval-sequence (rest-exps) env))))
      #+END_SRC

***** Assignments and definitions
      The following procedure handles assignments to variables. It
      calls eval to find the value to be assigned and transmits the
      variable and the resulting value to set-variable-value! to bee
      installed in the designated environment. 
      
      #+BEGIN_SRC scheme
      (define (eval-assignment exp env)
       (set-variable-value! (assignment-variable exp)
                            (eval (assignment-value exp) env)
                            env)
       'ok)
      #+END_SRC

      Definitions of variables are handled in a similar manner.

      #+BEGIN_SRC scheme
      (define (eval-definition exp env)
       (define-variable! (definition-variable exp)
                         (eval (definition-value exp) env)
                         env)
       'ok)
      #+END_SRC

      We have chosen here to return the symbol ok as the value of an
      assignment or definition.

      - Exercise 4.1: Notice that we cannot tell whether the
        metacircular evaluator evaluates operands from left to right
        or from right to left. Its evaluation order is inherited from
        the underlying Lisp: If the arguments to cons in
        list-of-values are evaluated from left to right, then
        list-of-values will evaluate operands from right to left.

	Write a version of list-of-values that evaluates operands from
        left to right regardless of the order of evaluation in the
        underlying Lisp. Also write a version of list-of-values that
        evaluates operands from right to left.

	#+BEGIN_SRC scheme
          ;; left to right
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((arg-value (eval (first-operand exps) env)))
                  (let ((rest-value (list-of-values (rest-operands exps) env)))
                    (cons arg-value rest-value)))))
          ;; right to left
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((rest-value (list-of-values (rest-operands exps) env)))
                  (let ((arg-value (eval (first-operand exps) env)))
                    (cons arg-value
                          rest-value)))))
	#+END_SRC

*** 4.1.2 Representing Expressions
    The evaluator is reminiscent of the symbolic differentiation
    program discussed in Section 2.3.2. Both programs operate on
    symbolic expressions. In both programs, the result of operating on
    a compound expression is determined by operating recursively on
    the pieces of the expression and combining the results in a way
    that depends on the type of the expression. In both programs we
    used data abstraction to decouple the general rules of operation
    from the details of how expressions are represented. In the
    differentiation program this meant that the same differentiation
    procedure could deal with algebraic expressions in prefix form, in
    infix form, or in some other form. For the evaluator, this means
    that the syntax of the language being evaluated is determined
    solely by the procedures that classify and extract pieces of
    expressions. Here is the specification of the syntax of our
    language:

    - The only self-evaluating items are numbers and strings:

      #+BEGIN_SRC scheme
      (define (self-evaluating? exp)
       (cond ((number? exp) true)
             ((string? exp) true)
             (else false)))
      #+END_SRC

    - Variables are represented by symbols:

      #+BEGIN_SRC scheme
      (define (variable? exp) (symbol? exp))
      #+END_SRC

    - Quotations have the form (quote <text-of-quotation>):
      
      #+BEGIN_SRC scheme
      (define (quoted? exp) (tagged-list? exp 'quote))
      (define (text-of-quotation exp) (cadr exp))
      #+END_SRC

      quoted? is defined in terms of the procedure tagged-list?, which
      identifies lists beginning with a designated symbol:

      #+BEGIN_SRC scheme
      (define (tagged-list? exp tag)
       (if (pair? exp)
           (eq? (car exp) tag)
           false))
      #+END_SRC

    - Assignments have the form (set! <var> <value>):
      
      #+BEGIN_SRC scheme
        (define (assignment? exp) (tagged-list? exp 'set!))
        (define (assignment-variable exp) (cadr exp))
        (define (assignment-value exp) (caddr exp))
      #+END_SRC

    - Definitions have the form

      #+BEGIN_SRC scheme
      (define <var> <value>)
      #+END_SRC

      or the form

      #+BEGIN_SRC scheme
      (define (<var> <parameter1> ... <parametern>)
       <body>)
      #+END_SRC

      The latter form (standard procedure definition) is syntactic
      sugar for

      #+BEGIN_SRC scheme
      (define <var>
       (lambda (<parameter1> ... <parametern>)
        <body>))
      #+END_SRC

      The corresponding syntax procedures are the following:

      #+BEGIN_SRC scheme
      (define (definition? exp) (tagged-list? exp 'define))
      (define (definition-variable exp)
       (if (symbol? (cadr exp))
           (cadr exp)
           (caadr exp)))
      (define (definition-value exp)
       (if (symbol? (cadr exp))
           (caddr exp)
           (make-lambda (cdadr exp)
                        (cddr exp))))
      #+END_SRC

    - lambda expressions are lists that begin with the symbol lambda:
      
      #+BEGIN_SRC scheme
      (define (lambda? exp) (tagged-list? exp 'lambda))
      (define (lambda-parameters exp) (cadr exp))
      (define (lambda-body exp) (cddr exp))
      #+END_SRC

      We also provide a constructor for lambda expressions, which is
      used by definition-value, above:

      #+BEGIN_SRC scheme
      (define (make-lambda parameters body)
       (cons 'lambda (cons parameters body)))
      #+END_SRC

    - Conditionals begin with if and have a predicate, a consequent,
      and an (optional) alternative. If the expression has no
      alternative part, we provide false as an alternative.

      #+BEGIN_SRC scheme
      (define (if? exp) (tagged-list? exp 'if))
      (define (if-predicate exp) (cadr exp))
      (define (if-consequent exp) (caddr exp))
      (define (if-alternative exp)
       (if (not (null? (cdddr expr)))
           (cadddr exp)
           'false))
      #+END_SRC

      We also provide a constructor for if expressions, to be used by
      cond->if to transform cond expressions into if expressions:

      #+BEGIN_SRC scheme
      (define (make-if predicate consequent alternative)
       (list 'if predicate consequent alternative))
      #+END_SRC

    - begin packages a sequence of expressions into a single
      expression. We include syntax operations on begin expressions to
      extract the actual sequence from the begin expression, as well
      as selectors that return the first expression and rest of the
      expressions in the sequence.

      #+BEGIN_SRC scheme
      (define (begin? exp) (tagged-list? exp 'begin))
      (define (begin-actions exp) (cdr exp))
      (define (last-exp? seq) (null? (cdr seq)))
      (define (first-exp seq) (car seq))
      (define (rest-exps seq) (cdr seq))
      #+END_SRC

      We also include a constructor sequence->exp (for use by
      cond->if) that transforms a sequence into a single expression,
      using begin if necessary:

      #+BEGIN_SRC scheme
      (define (sequence->exp seq)
       (cond ((null? seq) seq)
             ((last-exp? seq) (first-exp seq))
             (else (make-begin seq))))
      (define (make-begin seq) (cons 'begin seq))
      #+END_SRC

    - A procedure application is any compound expression that is not
      one of the above expression types. The car of the expression is
      the operator, and the cdr is a list of operands:

      #+BEGIN_SRC scheme
      (define (application? exp) (pair? exp))
      (define (operator exp) (car exp))
      (define (operands exp) (cdr exp))
      (define (no-operands? ops) (null? ops))
      (define (first-operand ops) (car ops))
      (define (rest-operands ops) (cdr ops))
      #+END_SRC
**** Derived expressions
     Some special forms in our language can be defined in terms of
     expressions involving other special forms, rather than being
     implemented directly. One example is cond, which can be
     implemented as a nest of if expressions. For example, we can
     reduce the problem of evaluating the expression

     #+BEGIN_SRC scheme
     (cond ((> x 0) x)
           ((= x 0) (display 'zero) 0)
           (else (- x)))
     #+END_SRC

     to the problem of evaluating the following expression involving
     if and begin expressions:

     #+BEGIN_SRC scheme
     (if (> x 0)
         x
         (if (= x 0)
             (begin (display 'zero) 0)
             (0 x)))
     #+END_SRC

     Implementing the evaluation of cond in this way simplifies the
     evaluator because it reduces the number of special forms for
     which the evaluation process must be explicitly specified.

     We include syntax procedures that extract the parts of a cond
     expression, and a procedure cond->if that transforms cond
     expressions into if expressions. A case analysis begins with cond
     and has a list of predicate-action clauses. A clause is an else
     clause if its predicate is the symbol else.

     #+BEGIN_SRC scheme
     (define (cond? exp) (tagged-list? exp 'cond))
     (define (cond-clauses exp) (cdr exp))
     (define (cond-else-clause? clause)
      (eq? (cond-predicate clause) 'else))
     (define (cond-predicate clause) (car clause))
     (define (cond-actions clause) (cdr clause))
     (define (cond->if exp) (expand-clauses (cond-clauses exp)))
     (define (expand-clauses clauses)
      (if (null? clauses)
          'false
          (let ((first (car clauses))
                (rest (cdr clauses)))
           (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (else "ELSE clause isn't last: COND->IF"
                      clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
     #+END_SRC

     Expressions (such as cond) that we choose to implement as
     syntactic transformations are called _derived expressions_. let
     expressions are also derived expressions (see Exercise 4.6).

     - Exercise 4.2: Louis Reasoner plans to reorder the cond clauses
       in eval so that the clause for procedure applications appears
       before the clause for assignments. He argues that this will
       make the interpreter more efficient: Since programs usually
       contain more applications than assignments, definitions, and so
       on, his modified eval will usually check fewer clauses than the
       original eval before identifying the type of expression.

       a. What is wrong with Louis' plan? (Hint: What will Louis'
       evaluator do with the expression (define x 3)?)

       The problem is his evaluator will assume expressions that
       should have special meanings, like cond clauses, if clauses,
       definitions, lambdas, &c, are all applications of procedures,
       and you won't be able to use the interpreter at all.

       b. Louis is upset that his plan didn't work. He is willing to
       go to any lengths to make his evaluator recognize procedure
       applications before it checks for most other kinds of
       expressions. Help him by changing the syntax of the evaluated
       language so that the procedure applications start with
       call. For example, instead of (factorial 3) we will now have to
       write (call factorial 3) and instead of (+ 1 2) we will have to
       write (call + 1 2). 

       #+BEGIN_SRC scheme
       (define (application? expr) (tagged-list? expr 'call))
       (define (operator exp) (cadr exp))
       (define (operands exp) (cddr exp))
       (define (no-operands? ops) (null? ops))
       (define (first-operand ops) (car ops))
       (define (rest-operands ops) (cdr ops))
       #+END_SRC

     - Exercise 4.3: Rewrite eval so that the dispatch is done in a
       data-directed style. Compare this with the data-directed
       differentiation procedure of Exercise 2.73 (You may use the car
       of a compound expression as the type of the expression, as is
       appropriate for the syntax implemented in this section.)

       #+BEGIN_SRC scheme
       (put 'eval 'cond eval-cond)
       (put 'eval 'definition eval-definition)
       (put 'eval 'set! eval-assignment)
       (put 'eval 'begin eval-sequence)
       (put 'eval 'if eval-if)
       (put 'eval 'lambda (lambda (exp env)
                            (make-procedure (lambda-parameters exp)
                                            (lambda-body exp)
                                            env)))
       (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
       (define (expr-type expr) (car expr))
       (define (eval expr env)
         (cond
          ((self-evaluating? expr) expr)
          ((variable? exp) (lookup-variable-value exp env))
          (else
           (let ((proc (get 'eval (expr-type expr)))))
            (cond
             (proc (proc (expr-contents expr) env))
             ((application? expr)
              (apply (eval (operator exp) env)
                     (list-of-values (operands exp) env)))
             (else
              (error "Unknown expression type -- EVAL" expr)))))))
       #+END_SRC

     - Exercise 4.4: Recall the definitions of the special forms and
       and or from Chapter 1:

       - and: The expressions are evaluated from left to right. If any
         expression evaluates to false, false is returned; any
         remaining expressions are not evaluated. If all the
         expressions evaluate to true values, the value of the last
         expression is returned. If there are no expressions then true
         is returned.

       - or: The expressions are evaluated from left to right. If any
         expression evaluates to a true value, that value is returned;
         any remaining expressions are not evaluated. If all
         expressions evaluate to true or false, or if there are no
         expressions, then false is returned. 

       Install and and or as new special forms for the evaluator by
       defining appropriate syntax procedures and evaluation
       procedures eval-and and eval-or. Alternatively, show how to
       implement and and or as derived expressions. 

       #+BEGIN_SRC scheme
       (define (eval-and expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (false? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'and eval-and)

       (define (eval-or expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (true? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'or eval-or)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (and->if ops)
       (if (no-operands? ops)
       'true
       (make-if
       (first-operand ops)
       (and->if (rest-operands ops))
       'false)))
       (define (or->if ops)
       (if (no-operands? ops)
       'false
       (make-if
       (first-operand ops)
       'true
       (or->if (rest-operands ops)))))
       #+END_SRC

     - Exercise 4.5: Scheme allows an additional syntax for cond
       clauses, (<test> => <recipient>). If <test> evaluates to a true
       value, then <recipient> is evaluated. Its value must be a
       procedure of one argument; this procedure is then invoked on
       the value of the <test>, and the result is returned as the
       value of the cond expression. For example

       #+BEGIN_SRC scheme
       (cond ((assoc 'b '((a 1) (b 2))) => cadr)
             (else false))
       #+END_SRC

       returns 2. Modify the handling of cond so that it supports this
       extended syntax.

       You only have to change the cond-actions bit:

       #+BEGIN_SRC scheme
       (define (cond-actions expr)
        (if (eq? '=> (cadr expr))
            (list (caddr expr) (car expr))
            (cadr expr)))
       #+END_SRC

       However, this doesn't save the variable. In case of a
       side-effect, or just to save computation time, we should
       rewrite so that we can save the variable. 

       #+BEGIN_SRC scheme
       (lambda (expr) (if expr (action-value expr) 
                               (expand-clauses rest)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (expand-action cond-clause rest-clauses)
        (if (cond=>clause? cond-clause)
            (make-application
             (make-lambda '(expr-result)
              (make-expr-sequence
              (make-if
               'expr-result
               (make-application
                (car (cond-actions cond-clause))
                '(expr-result))
               (expand-clauses rest-clauses))))
              (list (cond-predicate cond-clause)))
             (make-if
              (cond-predicate cond-clause)
              (sequence->exp (cond-actions cond-clause))
              (expand-clauses rest-clauses))))

       (define (expand-clauses clauses)
        (if (null? clauses)
            'false
            (let ((first (car clauses))
                  (rest (cdr clauses)))
             (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last: COND->IF"
                         clauses))
              (expand-action
               first
               rest)))))
       #+END_SRC

     - Exercise 4.6: let expressions are derived expressions, because

       #+BEGIN_SRC scheme
       (let ((<var1> <exp1>) ... (<varn> <expn>))
        <body>)
       #+END_SRC

       is equivalent to

       #+BEGIN_SRC scheme
       ((lambda (<var1> ... <varn>)
         <body>)
        <exp1>
        ...
        <expn>)
       #+END_SRC

       Implement a syntactic transformation let->combination that
       reduces evaluating let expressions to evaluating combinations
       of the type shown above, and add the appropriate clause to eval
       to handle let expressions.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))
       (define (let-bindings expr) (cadr expr))
       (define (let-seq expr) (cddr expr))
       (define (let->combination expr)
        (make-application
         (make-lambda
          (map car (let-bindings expr))
          (let-seq expr))
         (map cadr (let-bindings expr))))
       (define (eval-let expr env)
        (eval (let->combination expr) env))
       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.7: let* is similar to let, except that the bindings
       of the let* variables are performed sequentially from left to
       right, and each binding is made in an environment in which all
       of the preceding bindings are visible. For example

       #+BEGIN_SRC scheme
       (let* ((x 3) (y (+ x 2)) (z (+ x y 5)))
        (* x z))
       #+END_SRC

       #+BEGIN_SRC scheme
         (define (empty-bindings? bindings) (null? bindings))
         (define (let*-bindings let*) (cadr let*))
         (define (let*-body let*) (caddr let*))
         (define first-binding car)
         (define rest-bindings cdr)

         (define (make-let bindings body)
          (list 'let bindings body))

         (define (cons-binding binding rest)
          (cons binding rest))
         (define (empty-bindings) '())

         (define (let*-bindings->nested-lets let-body bindings)
          (if (empty-bindings? bindings)
              let-body
              (make-let
               (cons-binding (first-binding bindings) (empty-bindings))
               (let*-bindings->nested-lets let-body (rest-bindings bindings)))))

         (define (let*->nested-lets expr)
          (let ((bindings (let*-bindings expr))
                (body (let*-body expr)))
           (let*-bindings->nested-lets body bindings)))

         (define (eval-let* expr env)
          (eval (let*->nested-lets expr) env))

         (put 'eval 'let* eval-let*)
       #+END_SRC

     - Exercise 4.8: "Named let" is a variant of let that has the form

       #+BEGIN_SRC scheme
       (let <var> <bindings> <body>)
       #+END_SRC

       The <bindings> and <body> are just as in ordinary let, except
       that <var> is bound within <body> to a procedure whose body is
       <body> and whose parameters are the variables in the
       <bindings>. Thus, one can repeatedly execute the <body> by
       invoking the procedure named <var>. For example, the iterative
       Fibonacci procedure (Section 1.2.2) can be rewritten using
       named let as follows:

       #+BEGIN_SRC scheme
       (define (fib n)
        (let fib-iter ((a 1)
                       (b 0)
                       (count n))
         (if (= count 0)
             b
             (fib-iter (+ a b) a (- count 1)))))
       #+END_SRC

       Modify let->combination of Exercise 4.6 to also support named
       let.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))

       (define (named-let? expr) (symbol? (cadr expr)))

       (define (let-bindings expr) 
        (if (named-let? expr)
            (caddr expr)
            (cadr expr)))

       (define (let-seq expr) 
        (if (named-let? expr)
            (cdddr expr)
            (cddr expr)))

       (define (let-name expr) (cadr expr))

       (define (make-sequence values)
        (cons 'begin values))

       (define (make-definition name value)
        (list 'define name value))

       (define (make-function-definition name params value)
        (list 'define (cons name params) value))

       (define (named-let->combination expr)
        (make-sequence
         (list
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map cadr (let-bindings expr))))))

       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map cadr (let-bindings expr)))))

       (define (eval-let expr env)
        (eval (let->combination expr) env))

       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.9: Many language support a variety of iteration
       constructs, such as do, for, while, and until. In Scheme,
       iterative processes can be expressed in terms of ordinary
       procedure calls, so special iteration constructs provide no
       essential gain in computational power. On the other hand, such
       constructs are often convenient. Design some iteration
       constructs, give examples of their use, and show how to
       implement them as derived expressions.

       #+BEGIN_SRC scheme
       (define (do-init-bindings expr) (cadr expr))
       (define (do-final-expr expr) (caddr expr))
       (define (do-predicate expr) (cadddr expr))
       (define (do-body expr) (cadr (cdddr expr)))
       (define (do->combination expr)
        (make-sequence
         (list
          (make-function-definition
           'dobody
           (map car (do-init-bindings expr))
           (make-if
            (do-predicate expr)
            (make-sequence (list (do-final-expr expr)))
            (make-application 
             'dobody
             (map caddr (do-init-bindings expr)))))
          (make-application 'dobody (map cadr (do-init-bindings expr))))))
       #+END_SRC

     - Exercise 4.10: By using data abstraction, we were able to write
       an eval procedure that is independent of the particular syntax
       of the language to be evaluated. To illustrate this, design and
       implement a new syntax for Scheme by modifying the procedures
       in this section, without changing eval or apply.

       You just change the predicates and accessors since we used data
       abstraction.

       #+BEGIN_SRC scheme
       (defprocedure add (x y) (+ x y))
       (defvar x 1)
       (if (>=  (add 1 2) 3) then true else false)
       (setvars (x <- 1 y <- 2 z <- 3)
         (+ x y z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (assignment? exp) (eq? (cadr exp) '<-))
       (define (assignment-variable exp) (car exp))
       (define (assignment-value exp) (caddr exp))
       (define (eval-assignment exp env)
        (set-variable-value! (assignment-variable exp)
                             (eval (assignment-value exp) env)
                             env)
        'ok)

       (define (if? exp) 
        (and
         (eq? (car exp) 'if)
         (eq? (caddr exp) 'then)
         (eq? (cadr (cdddr exp)) 'else)))
       (define (if-predicate exp) (cadr exp))
       (define (if-consequent exp) (cadddr exp))
       (define (if-alternative exp)
        (caddr (cdddr exp)))

       (define (definition? expr)
        (or (eq? (car expr) 'defprocedure)
            (eq? (car expr) 'defvar)))
       (define (definition-variable exp)
        (cadr exp))

       (define (definition-value exp)
        (if (eq? 'defprocedure (car expr))
             (make-lambda (caddr expr)
                          (cadddr expr))
             (caddr expr)))

       (define (let? exp) (eq? (car expr) 'setvars))
       (define (let-bindings expr)
         (if (named-let? expr)
             (caddr expr)
             (cadr expr)))
       (define (let-seq expr)
        (if (named-let? expr)
            (cadddr expr)
            (caddr expr)))
       (define (named-let->combination expr)
        (make-sequence
         (list 
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map caddr (let-bindings expr))))))
       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map caddr (let-bindings expr)))))
       #+END_SRC

*** 4.1.3 Evaluator Data Structures
    In addition to defining the external syntax of expressions, the
    evaluator implementation must also define the data structures that
    the evaluator manipulates internally, as part of the execution of
    a program, such as the representation of procedures and
    environments and the representation of true and false.

**** Testing of predicates
     For conditionals, we accept anything to be true that is not the
     explicit false object.

     #+BEGIN_SRC scheme
     (define (true? x) (not (eq? x false)))
     (define (false? x) (eq? x false))
     #+END_SRC

**** Representing procedures

     To handle primitives, we assume that we have available the
     following procedures:

     - (apply-primitive-procedure <proc> <args>)
       applies the given primitive procedure to the argument values in
       the list <args> and returns the result of the application.
     - (primitive-procedure? <proc>)
       tests whether <proc> is a primitive procedure.

       
     These mechanisms for handling primitives are further described in
     section 4.1.4. 

     Compound procedures are constructed from parameters, procedure
     bodies, and environments using the constructor make-procedure:

     #+BEGIN_SRC scheme
     (define (make-procedure parameters body env)
      (list 'procedure parameters body env))
     (define (compound-procedure? p)
      (tagged-list? p 'procedure))
     (define (procedure-parameters p) (cadr p))
     (define (procedure-body p) (caddr p))
     (define (procedure-environment p) (cadddr p))
     #+END_SRC

**** Operations on Environments
     The evaluator needs operations for manipulating environments. As
     explained in Section 3.2, an environment is a sequence of frames,
     where each frame is a table of bindings that associate variables
     with their corresponding values. We use the following operations
     for manipulating environments:

     - (lookup-variable-value <var> <env>)
       returns the value that is bound to the symbol <var> in the
       environment <env>, or signals an error if the variable is
       unbound.
     - (extend-environment <variables> <values> <base-env>)
       returns a new environment, consisting of a new frame in which
       the symbols in the list <variables> are bound to the
       corresponding elements in the list <values>, where the
       enclosing environment is the environment <base-env>.
     - (define-variable! <var> <value> <env>)
       adds to the first frame in the environment <env> a new binding
       that associates the variable <var> with the value <value>.
     - (set-variable-value! <var> <value> <env>)
       changes the binding of the variable <var> in the environment
       <env> so that the variable is now bound to the value <value>,
       or signals an error if the variable is unbound.

       
     To implement these operations we represent an environment as a
     list of frames. The enclosing environment of an environment is
     the cdr of the list. The empty environment is simply the empty
     list.

     #+BEGIN_SRC scheme
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     #+END_SRC

     Each frame of an environment is represented as a pair of lists: a
     list of the variables bound in that frame and a list of the
     associated values:
     
     #+BEGIN_SRC scheme
     (define (make-frame variables values)
      (cons variables values))
     (define (frame-variables frame) (car frame))
     (define (frame values frame) (cdr frame))
     (define (add-binding-to-frame! var val frame)
      (set-car! frame (cons var (car frame)))
      (set-cdr! frame (cons val (cdr frame))))
     #+END_SRC

     To extend an environment by a new frame that associates variables
     with values, we make a frame consisting of the list of variables
     and the list of values, and we adjoin this to the environment. We
     signal an error if the number of variables does not match the
     number of values.

     #+BEGIN_SRC scheme
     (define (extend-environment vars vals base-env)
      (if (= (length vars) (length vals))
          (cons (make-frame vars vals) base-env)
          (if (< (length vars) (length vals))
              (error "Too many arguments supplied" vars vals)
              (error "Too few arguments supplied" vars vals))))
     #+END_SRC

     To look up a variable in an environment, we scan the list of
     variables in the first frame. If we find the desired variable, we
     return the corresponding element in the list of values. If we do
     not find the variable in the current frame, we search the
     enclosing environment, and so on. If we reach an empty
     environment, we signal an "unbound variable" error.

     #+BEGIN_SRC scheme
     (define (lookup-variable-value var env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars)) (car vals))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To set a variable to a new value in a specified environment, we
     scan for the variable, just as in lookup-variable-value, and
     change the corresponding value when we find it. 

     #+BEGIN_SRC scheme
     (define (set-variable-value! var val env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable: SET!" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To define a variable, we search the first frame for a binding for
     the variable, and change the binding if it exists (just as in
     set-variable-value!). If no such binding exists, we adjoin one to
     the first frame.

     #+BEGIN_SRC scheme
     (define (define-variable! var val env)
      (let ((frame (first-frame env)))
       (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars)) (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (scan (frame-variables frame) (frame-values frame))))
     #+END_SRC

     The method described here is only one of many plausible ways to
     represent environments. Since we used data abstraction to isolate
     the rest of the evaluator from the detailed choice of
     representation, we could change the environment representation if
     we wanted to. (See Exercise 4.11.) In a production-quality Lisp
     system, the speed of the evaluator's environment operations -
     especially that of variable lookup - has a major impact on the
     performance of the system. The representation described here,
     although conceptually simple, is not efficient and would not
     ordinarily be used in a production system.

     - Exercise 4.11: Instead of representing a frame as a pair of
       lists, we can represent a frame as a list of bindings, where
       each binding is a name-value pair. Rewrite the environment
       operations to use this alternative representation.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (lookup-cell var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (lookup-variable-value var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- LOOKUP-VARIABLE-VALUE" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (cdar lookup)))))

       (define (set-variable-value! var val env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- SET-VARIABLE-VALUE!" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (set-cdr! (car lookup) val)))))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.12: The procedures set-variable-value!,
       define-variable! and lookup-variable-value can be expressed in
       terms of more abstract procedures for traversing the
       environment structure. Define abstractions that capture the
       common patterns and redefine the three procedures in terms of
       these abstractions.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (find-cell-in-frame var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (set-cell-val! val cell)
        (set-cdr! (car cell) val))

       (define (cell-val cell)
        (cdar cell))

       (define (null-cell? cell) (null? cell))

       (define (operate-on-cell proc var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- OPERATE-ON-CELL" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null-cell? lookup)
                 (operate-on-cell var (enclosing-environment env))
                 (proc lookup)))))

       (define (lookup-variable-value var env)
        (operate-on-cell
         (lambda (cell)
          (cell-val cell))
         var env))

       (define (set-variable-value! var val env)
        (operate-on-cell
         (lambda (cell)
          (set-cell-val! val cell))
         var env))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.13: Scheme allows us to create new bindings for
       variables by means of define, but provides no way to get rid of
       bindings. Implement for the evaluator a special form
       make-unbound! that removes the binding of a given symbol from
       the environment in which the make-unbound! expression is
       evaluated. This problem is not completely specified. For
       example, should we remove only the binding in the first frame
       of the environment? Complete the specification and justify any
       choices you make.

       I'm only going to remove it from the first frame that has
       it. It doesn't make sense to me to unbind all instances, you
       could then have a utility function inside a function that
       unbinds all variables, even ones in use in enclosing
       functions. Then if you really want to unbind them all you can
       repeatedly unbind.

       #+BEGIN_SRC scheme
       (define (remove-bindings-from-frame var frame)
        (filter (lambda (binding) (not (eq? (car binding) var)))
                frame))
       (define (make-unbound! var env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (make-unbound! var (enclosing-environment env))
              (set-car! env (remove-bindings-from-frame var frame))))))
       #+END_SRC

*** 4.1.4 Running the Evaluator as a Program

    Given the evaluator, we have in our hands a description (expressed
    in Lisp) of the process by which Lisp expressions are
    evaluated. One advantage of expressing the evaluator as a program
    is that we can run the program. This gives us, running within
    Lisp, a working model of how Lisp itself evaluates
    expressions. This can serve as a framework for experimenting with
    evaluation rules, as we shall do later in this chapter. 

    Our evaluator program reduces expressions ultimately to the
    application of primitive procedures. Therefore, all that we need
    to run the evaluator is to create a mechanism that calls on the
    underlying Lisp system to model the application of primitive
    procedures.

    There must be a binding for each primitive procedure name, so that
    when eval evaluates the operator of an application of a primitive,
    it will find an object to pass to apply. We thus set up a global
    environment that associates unique objects with the names of the
    primitive procedures that can appear in the expressions we will be
    evaluating. The global environment also includes bindings for the
    symbols true and false, so that they can be used as variables in
    expressions to be evaluated.

    #+BEGIN_SRC scheme
    (define (setup-environment)
     (let ((initial-env
            (extend-environment (primitive-procedure-names)
                                (primitive-procedure-objects)
                                the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))
    (define the-global-environment (setup-environment))
    #+END_SRC

    It does not matter how we represent the primitive procedure
    objects, so long as apply can identify and apply them by using the
    procedures primitive-procedure? and apply-primitive-procedure. We
    have chosen to represent a primitive procedure as a list beginning
    with the symbol primitive and containing a procedure in the
    underlying Lisp that implements that primitive.

    #+BEGIN_SRC scheme
    (define (primitive-procedure? proc)
     (tagged-list? proc 'primitive))
    (define (primitive-implementation proc) (cadr proc))
    #+END_SRC

    setup-environment will get the primitive names and implementation
    procedures from a list:

    #+BEGIN_SRC scheme
    (define primitive-procedures
     (list (list 'car car)
           (list 'cdr cdr)
           (list 'cons cons)
           (list 'null? null?)
           <more primitives>))
    (define (primitive-procedure-names)
     (map car primitive-procedures))
    (define (primitive-procedure-objects)
     (map (lambda (proc) (list 'primitive (cadr proc)))
          primitive-procedures))
    #+END_SRC

    To apply a primitive procedure, we simply apply the implementation
    procedure to the arguments, using the underlying Lisp system:

    #+BEGIN_SRC scheme
    (define (apply-primitive-procedure proc args)
     (apply-in-underlying-scheme
      (primitive-implementation proc) args))
    #+END_SRC

    For convenience in running the metacircular evaluator, we provide
    a _driver loop_ that models the read-eval-print loop of the
    underlying Lisp system. It prints a _primpt_, reads an input
    expression, evaluates this expression in the global environment,
    and prints the result. We precede each printed result by an
    _output prompt_ so as to distinguish the value of the expression
    from other output that may be printed.

    #+BEGIN_SRC scheme
    (define input-prompt ";;; M-Eval input:")
    (define output-prompt ";;; M-Eval value:")
    (define (driver-loop)
     (prompt-for-input input-prompt)
     (let ((input (read)))
      (let ((output (eval input the-global-environment)))
       (announce-output out-prompt)
       (user-print output)))
     (driver-loop))
    (define (prompt-for-input string)
     (newline) (newline) (display string) (newline))
    (define (announce-output string)
     (newline) (display string) (newline))       
    #+END_SRC

    We use a special printing procedure, user-print, to avoid printing
    the environment part of a compound procedure, which may be a very
    long list (or may even contain cycles). 

    #+BEGIN_SRC scheme
    (define (user-print object)
     (if (compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
         (display object)))
    #+END_SRC

    Now all we need to do to run the evaluator is to initialize the
    global environment and start the driver loop. Here is a sample
    interaction:

    #+BEGIN_SRC scheme
    (define the-global-environment (setup-environment))
    (driver-loop)

    ;;; M-Eval input:
    (define (append x y)
     (if (null? x)
         y
         (cons (car x) (append (cdr x) y))))

    ;;; M-Eval value:
    ok

    ;;; M-Eval input:
    (append '(a b c) '(d e f))
      
    ;;; M-Eval value:
    (a b c d e f)
    #+END_SRC

    - Exercise 4.1.4: Eva Lu Ator and Louis Reasoner are each
      experimenting with the metacircular evaluator. Eva types in the
      definition of map, and runs some test programs that use it. They
      work fine. Louis, in contrast, has installed the system version
      of map as a primitive for the metacircular evaluator. When he
      tries it, things go terribly wrong. Explain why Louis' map fails
      even though Eva's works.

      Louis's version, the underlying scheme version, needs a
      procedure object of the kind defined by the underlying lisp, not
      a procedure from our lisp. However, what it will get is a
      procedure definition from our own lisp, even if it's a
      primitive, it will not get an actual procedure object, so it
      will not be able to map that way. 

*** 4.1.4 Data as Programs
    In thinking about a Lisp program that evaluates Lisp expressions,
    an analogy might be helpful. One operational view of the meaning
    of a program is that the program is a description of an abstract
    (perhaps infinitely large) machine. For exmaple, consider the
    familiar program to compute factorials:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1) n))))
    #+END_SRC

    We may regard this program as the description of a machine
    containing parts that decrement, multiply, and test for equality,
    together with a two-position switch and another factorial
    machine. (The factorial machine is infinite because it contains
    another factorial machine within it.) Figure 4.2 is a flow diagram
    for the factorial  machine, showing how the parts are wired
    together.

    In a similar way, we can regard the evaluator as a very special
    machine that takes as input a description of a machine. Given this
    input, the evaluator configures itself to emulate the machine
    described. For example, if we feed our evaluator the definition of
    factorial, as shown in Figure 4.3, the evaluator will be able to
    compute factorials.

    From this perspective, our evaluator is seen to be a _universal
    machine_. It mimics other machines when these are described as
    Lisp programs. This is striking. Try to imagine an analogous
    evaluator for electrical circuits. This would be a circuit that
    takes as input a signal encoding the plans for some other circuit,
    such as a filter. Given this input, the circuit evaluator would
    then behave like a filter with the same description. Such a
    universal electrical circuit is almost unimaginably complex. It is
    remarkable that the program evaluator is a rather simple program.

    Another striking aspect of the evaluator is that it acts as a
    bridge between the data objects that are manipulated by our
    programming language and the programming language itself. Imagine
    that the evaluator program (implemented in Lisp) is running, and
    that a user is typing expressions to the evaluator and observing
    the results. From the perspective of the user, an input expression
    such as (* x x) is an expression in the programming language,
    which the evaluator should execute. From the perspective of the
    evaluator, however, the expression is simply a list (in this case,
    a list of three symbols: *, x, and x) that is to be manipulated
    according to a well-defined set of rules. 
    
    That the user's programs are the evaluator's data need not be a
    source of confusion. In fact, it is sometimes convenient to ignore
    this distinction, and to give the user the ability to explicitly
    evaluate a data object as a Lisp expression, by making eval
    available for use in programs. Many Lisp dialects provide a
    primitive eval procedure that takes as arguments an expression and
    an environment and evaluates the expression relative to the
    environment. Thus,

    #+BEGIN_SRC scheme
    (eval '(* 5 5) user-initial-environment)
    #+END_SRC
    
    and

    #+BEGIN_SRC scheme
    (eval (cons '* (list 5 5)) user-initial-environment)
    #+END_SRC

    will both return 25.

    - Exercise 4.15: Given a one-argument procedure p and an object a,
      p is said to "halt" on a if evaluating the expression (p a)
      returns a value (as opposed to terminating with an error message
      or running forever). Show that it is impossible to write a
      procedure halts? that correctly determines whether p halts on a
      for any procedure p and object a. Use the following reasoning:
      If you had such a procedure halts?, you could implement the
      following program:

      #+BEGIN_SRC scheme
      (define (run-forever) (run-forever))
      (define (try p)
       (if (halts? p p) (run-forever) 'halted))
      #+END_SRC

      Now consider evaluating the expression (try try) and show that
      any possible outcome (either halting or running forever)
      violates the intended behavior of halts?.

      Try is supposed to run forever if the procedure given to it
      halts when given itself, and halt if it would run forever. If
      the halts? procedure decides that (try try) halts it will
      actually run forever, making that procedure inconsistent and
      breaking the law of functions. If it decides it runs forever the
      procedure will halt, again breaking the rules of functions by
      having a different result for the same input.

*** 4.1.6 Internal Definitions

    Our environment model of evaluation and our metacircular evaluator
    execute definitions in sequence, extending the environment frame
    one definition at a time. This is particularly convenient for
    interactive program development, in which the programmer needs to
    freely mix the application of procedures with the definition of
    new procedures. However, if we think carefully about the internal
    definitions used to implement block structure (introduced in
    Section 1.1.8), we find that name-by-name extension of the
    environment may not be the best way to define local
    variables. Consider a procedure with internal definitions, such as

    #+BEGIN_SRC scheme
    (define (f x)
     (define (even? n) (if (= n 0) true (odd? (- n 1))))
     (define (odd? n) (if (= n 0) false (even? (- n 1))))
     <rest of body of f>)
    #+END_SRC

    Our intention here is that the name odd? in the body of the
    procedure even? should refer to the procedure odd? that is defined
    after even?. The scope of the name odd? is the entire body of f,
    not just the portion of the body of f starting at the point where
    the define for odd? occurs. Indeed, when we consider that odd? is
    itself defined in terms of even? -- so that even? and odd? are
    mutually recursive procedures -- we see that the only satisfactory
    interpretation of the two defines is to regard them as if the
    names even? and odd? were being added to the environment
    simultaneously. More generally, in block structure, the scope of a
    local name is the entire procedure body in which the define is
    evaluated.

    As it happens, our interpreter will evaluate calls to f correctly,
    but for an "accidental" reason: Since the definitions of the
    internal procedures come first, no calls to these procedures will
    be evaluated until all of them have been defined. Hence, odd? will
    have been defined by the time even? is executed. In fact, our
    sequential evaluation mechanism will give the same result as a
    mechanism that directly implements simultaneous definition for any
    procedure in which the internal definitions come first in a body
    and evaluation of the value expressions for the defined variables
    doesn't actually use any of the defined variables. (For an example
    of a procedure that doesn't obey these restrictions, so that
    sequential definition isn't equivalent to simultaneous definition,
    see Exercise 4.19). 

    There is, however, a simple way to treat definitions so that
    internally defined names have truly simultaneous scope -- just
    create all local variables that will be in the current environment
    before evaluating any of the value expressions. One way to do this
    is by a syntax transformation on lambda expressions. Before
    evaluating the body of a lambda expression, we "scan out" and
    eliminate all the internal definitions in the body. For example,
    the procedure

    #+BEGIN_SRC scheme
    (lambda <vars>
     (define u <e1>)
     (define v <e2>)
     <e3>)
    #+END_SRC

    would be transformed into

    #+BEGIN_SRC scheme
    (lambda <vars>
     (let ((u '*unassigned*)
           (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))
    #+END_SRC

    where \*unassigned\* is a special symbol that causes looking up a
    variable to signal an error if an attempt is made to use the value
    of the not-yet-assigned variable.

    An alternative strategy for scanning out internal definitions is
    shown in Exercise 4.18. Unlike the transformation shown above,
    this enforces the restriction that defined variables' values can
    be evaluated without using any of the variables' values. 

    - Exercise 4.16: In this exercise we implement the method just
      described for interpreting internal definitions. We assume that
      the evaluator supports let (see Exercise 4.6).

      a. Change lookup-variable-value (Section 4.13) to signal an
      error if the value it finds is the symbol \*unassigned\*.

      b. Write a procedure scan-out-defines that takes a procedure
      body and returns an equivalent one that has no internal
      definitions, by making the transformation described above. 
      
      c. Install scan-out-defines in the interpreter, either in
      make-procedure or in procedure-body (see Section 4.1.3). Which
      place is better? Why? 

      It makes more sense to put it in make-procedure, if the
      procedure-body is accessed multiple times, we only transform it
      once in make-procedure.

    - Exercise 4.17: Draw diagrams of the environment in effect when
      evaluating the expression <e3> in the procedure in the text,
      comparing how this will be structured when definitions are
      interpreted sequentially with how it will be structured if
      definitions are scanned out as described. Why is there an extra
      frame in the transformed program? Explain why this difference in
      environment structure can never make a difference in the
      behavior of a correct program. Design a way to make the
      interpreter implement the "simultaneous" scope rule for internal
      definitions without constructing the extra frame.

      There is an extra frame because we introduced an extra let
      expression, which is just syntactical sugar for lambda, which is
      a procedure, which creates an extra frame. It makes no
      difference in program behavior because we set variables
      immediately inside the let, so there is no opportunity for the
      program to try to find the value of a variable and not get
      it. We can implement simultaneous scope by using defines instead
      of lets, the program expansion from the text would be:

      #+BEGIN_SRC scheme
      (lambda <vars>
       (define u '*unassigned*)
       (define v '*unassigned*)
       (set! u <e1>)
       (set! v <e2>)
       <e3>)
      #+END_SRC

    - Exercise 4.18: Consider an alternative strategy for scanning out
      definitions that translates the example in the text to

      #+BEGIN_SRC scheme
      (lambda <vars>
       (let ((u '*unassigned*) (v '*unassigned*))
        (let ((a <e1>) (b <e2>))
         (set! u a)
         (set! v b))
        <e3>))
      #+END_SRC

      Here a and b are meant to represent new variable names, created
      by the interpreter, that do not appear in the user's
      program. Consider the solve procedure from Section 3.5.4:

      #+BEGIN_SRC scheme
      (define (solve f y0 dt)
       (define y (integral (delay dy) y0 dt))
       (define dy (stream-map f y))
       y)
      #+END_SRC

      Will this procedure work if internal definitions are scanned out
      as shown in this exercise? What if they are scanned out as shown
      in the text? Explain.

      It should, since dy is delayed for evaluation (although our
      interpreter doesn't have a delay keyword). The definition of dy
      itself however may not work. y will be set to \*unassigned\*
      when it tries to stream-map on y, which is not a valid
      stream. stream-map will try to evaluate one application of f on
      the y stream. The expansion would look like this:

      #+BEGIN_SRC scheme
      (lambda (f y0 dt)
       (let ((y '*unassigned*) (dy '*unassigned))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
         (set! y a)
         (set! dy b))
        y))
      #+END_SRC

      What will happen is stream-map will try to evaluate 
      (cons-stream (f (stream-car y)) (stream-map f (stream-cdr y)))
      The first expression (f (stream-car y)) will be evaluated
      immediately, and looking up the value of y will throw an
      error. The original transformation would work, since it does
      actually evaluate set! expressions in the same order that the
      defines occured, so y would be defined as a stream.

    - Exercise 4.19: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator
      are arguing about the desired result of evaluating the
      expression

      #+BEGIN_SRC scheme
      (let ((a 1))
       (define (f x)
        (define b (+ a x))
        (define a 5)
        (+ a b))
      (f 10))
      #+END_SRC

      Ben asserts that the result should be obtained using the
      sequential rule for define: b is defined to be 11, then a is
      defined to be 5, so the result is 16. Alyssa objects that mutual
      recursion requires the simultaneous scope rule for internal
      procedure definitions, and that it is unreasonable to treat
      procedure names differently from other names. Thus, she argues
      for the mechanism implemented in Exercise 4.16. This would lead
      to a being unassigned at the time that the value for b is to be
      computed. Hence, in Alyssa's view the procedure should produce
      an error. Eva has a third opinion. She says that if the
      definitions of a and b are truly meant to be simultaneous, then
      the value 5 for a should be used in evaluating b. Hence, in
      Eva's view a should be 5, b should be 15, and the answer should
      be 20. Which (if any) of these viewpoints do you support? Can
      you devise a way to implement internal definitions so that they
      behave as Eva prefers?

      If we say that internal definitions are supposed to be in
      principle simultaneous, I would say that Alyssa is right. It
      doesn't make sense that a would be defined during a parallel
      assignment. If it is, then assignment is not parallel but
      ordered in some way. This should produce an error.

      The only way to do it the way Eva wants is to analyze the
      expressions and order the sets so that they occur in the right
      order. So you would have to scan each definition for references
      to the others. This doesn't work in a circular definition
      case. This is why I don't think Eva's definition actually makes
      sense, if assignment is simultaneous, saying that a is defined
      to be 5 implicitly defines an ordering.

      However another, simpler way that accomplishes these semantics
      but changes other semantics is to use delay in eval-ing the
      value of the set! expressions. You can do this simply by adding
      a wrapping (delay) in the eval-assignment function, and testing
      if a variable lookup-value is a promise with promise? when doing
      a lookup. This causes the code above to function in the way Eva
      wants. However, it breaks/changes the semantics of other
      expressions, specifically any side-effect expression.

      #+BEGIN_SRC scheme
      (define g 20)
      (define (s x) (set! g (- g x)) g)
      (define (d x) (set! g (/ g x)) g)

      (define (f x)
       (define m (h 2))
       (define x (d 3))
       (+ x m))

      #+END_SRC

    - Exercise 4.20: Because internal definitions look sequential but
      are actually simultaneous, some people prefer to avoid them
      entirely, and use the special form letrec instead. letrec looks
      like let, so it is not surprising that the variables it binds
      are bound simultaneously and have the same scope as each
      other. The sample procedure f above can be written without
      internal definitions, but with exactly the same meaning, as

      #+BEGIN_SRC scheme
      (define (f x)
       (letrec
        ((even? (lambda (n)
                 (if (= n 0) true (odd? (- n 1)))))
         (odd?  (lambda (n)
                 (if (= n 0) false (even? (- n 1))))))
         <rest of body of f>))
      #+END_SRC

      letrec expressions, which have the form

      #+BEGIN_SRC scheme
      (letrec ((<var1> <exp1>) ... (<varn> <expn>))
       <body>)
      #+END_SRC

      are a variation on let in which the expressions <expk> that
      provide the initial values for the variables <vark> are
      evaluated in an environment that includes all the letrec
      bindings. This permits recursion in the bindings, such as the
      mutual recursion of even? and odd? in the example above, or the
      evaluation of 10 factorial with

      #+BEGIN_SRC scheme
      (letrec
       ((fact (lambda (n)
               (if (= n 1) 1 (* n (fact (- n 1)))))))
       (fact 10))
      #+END_SRC

      a. Implement letrec as a derived expression, by transforming a
      letrec expression into a let expression as shown in the text
      above or in exercise 4.18. That is, the letrec variables should
      be created with a let and then be assigned their values with a
      set!.
      
      #+BEGIN_SRC scheme
      (define (letrec? expr)
       (eq? (car expr) 'letrec))
      (define (letrec-bindings expr)
       (cadr expr))
      (define (letrec-body expr)
       (cddr expr))
      (define (letrec->let expr)
       (let ((binding-vars (map binding-var (letrec-bindings expr))))
        (let ((undefined-bindings
               (map (lambda (name) (make-binding name UNDEFINED-VARIABLE))
                    binding-vars))
              (assignments
               (map (lambda (binding)
                     (make-assignment
                      (binding-var binding)
                      (binding-val binding)))
                    (letrec-bindings expr)))) 
         (make-let
          undefined-bindings
          (concat-exps
           assignments
           (letrec-body expr))))))
      #+END_SRC

      b. Louis Reasoner is confused by all this fuss about internal
      definitions. The way he sees it, if you don't like to use define
      inside a procedure, you can just use let. Illustrate what is
      loose about his reasoning by drawing an environment diagram that
      shows the environment in which the <rest of body of f> is
      evaluated during evaluation of the expression (f 5), with f
      defined as in this exercise. Draw an environment diagram for the
      same evaluation, but with let in place of letrec in the
      definition of f. 

      The issue is that let creates a new internal environment, but
      evaluates the binding value expressions in the environment of
      the outer environment. As a result, evaluating a (lambda) in a
      plain let results in a procedure who's parent environment is not
      the new environment being created but the one above that. So it
      cannot 'see' names in the same environment being created by the
      let. So when a variable lookup happens inside the body of the
      lambda, it looks in the environment above the current let, and
      can't find anything in the current let. letrec creates the
      bindings first and evaluates the lambda inside the new
      environment, so mutual reference is possible.

    - Exercise 4.21: Amazingly, Louis's intuiition in Exercise 4.20 is
      correct. It is indeed possible to specify recursive procedures
      without using letrec (or even define), although the method for
      accomplishing this is much more subtle than Louis imagined. The
      following expression computes 10 factorial by applying a
      recursive factorial procedure:

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fact) (fact fact n))
         (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
        10)
      #+END_SRC

      a. Check (by evaluating the expression) that this really does
      compute factorials. Devise an analogous expression for computing
      Fibonacci numbers.

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fibo) (fibo fibo n))
         (lambda (fib n)
          (cond ((or (= n 2) (= n 1)) 1)
                ((= n 0) 0)
                (else (+ (fib fib (- n 1)) (fib fib (- n 2))))))))
       10)
      #+END_SRC

      b. Consider the following procedure, which includes mutually
      recursive internal definitions:

      #+BEGIN_SRC scheme
      (define (f x)
       (define (even? n)
        (if (= n 0) true (odd? (- n 1))))
       (define (odd? n)
        (if (= n 0) false (even? (- n 1))))
       (even? x))
      #+END_SRC

      Fill in the missing expressions to complete an alternative
      definition of f, which uses neither internal definitions nor
      letrec:

      #+BEGIN_SRC scheme
      (define (f x)
       ((lambda (even? odd?) (even? even? odd? x))
        (lambda (ev? od? n)
         (if (= n 0) true (od? ev? od? (- n 1))))
        (lambda (ev? od? n)
         (if (= n 0) false (ev? ev? od? (- n 1))))))
      #+END_SRC
*** 4.1.7 Separating Syntactic Analysis from Execution
    The evaluator implemented above is simple, but it is very
    inefficient, because the syntactic analysis of expressions is
    interleaved with their execution. Thus if a program is executed
    many times, its syntax is analyzed many times. Consider, for
    example, evaluating (factorial 4) using the following definition
    of factorial:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1)) n)))
    #+END_SRC

    Each time factorial is called, the evaluator must determine that
    the body is an if expression and extract the predicate. Only then
    can it evaluate the predicate and dispatch on its value. Each time
    it evaluates the expression (* (factorial (- n 1)) n), or the
    subexpressions (factorial (- n 1)) and (- n 1), the evaluator must
    perform the case analysis in eval to determine that the expression
    is an application, and must extract its operator and
    operands. This analysis is expensive. Performing it repeatedly is
    wasteful.

    We can transform the evaluator to be significantly more efficient
    by arranging things so that syntactic analysis is performed only
    once. We split eval, which takes an expression and an environment,
    into two parts. The procedure analyze takes only the
    expression. It performs the syntactic analysis and returns a new
    procedure, the _execution procedure_, that encapsulates the work
    to be done in executing the analyzed expression. The execution
    procedure takes an environment as its argument and completes the
    evaluation. This saves work because analyze will be called only
    once on an expression, while the execution procedure may be called
    many times. 

    With the separation into analysis and execution, eval now becomes

    #+BEGIN_SRC scheme
    (define (eval exp env) ((analyze exp) env))
    #+END_SRC

    The result of calling analyze is the execution procedure to be
    applied to the environment. The analyze procedure is the same case
    analysis as performed by the original eval of Section 4.1.1,
    except that the procedures to which we dispatch perform only
    analysis, not full evaluation:

    #+BEGIN_SRC scheme
    (define (analyze exp)
     (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
           ((quoted? exp) (analyize-quoted exp))
           ((variable? exp) (analyze-variable exp))
           ((assignment? exp) (analyze-assignment exp))
           ((definition? exp) (analyze-definition exp))
           ((if? exp) (analyze-if exp))
           ((lambda? exp) (analyze-lambda exp))
           ((begin? exp) (analyze-sequence (begin-actions exp)))
           ((cond? exp) (analyze (cond->if exp)))
           ((application? exp) (analyze-application exp))
           (else (error "Unknown expression type: ANALYZE" exp))))
    #+END_SRC

    Here is the simplest syntactic analysis procedure, which handles
    self-evaluating expressions. It returns an execution procedure
    that ignores its environment argument and just returns the
    expression:

    #+BEGIN_SRC scheme
    (define (analyze-self-evaluating exp)
     (lambda (env) exp))
    #+END_SRC

    For a quoted expression, we can gain a little efficiency by
    extracting the text of the quotation only once, in the analysis
    phase, rather than in the execution phase.

    #+BEGIN_SRC scheme
    (define (analyze-quoted exp)
     (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
    #+END_SRC

    Looking up a variable value must still be done in the execution
    phase, since this depends upon knowing the environment. 

    #+BEGIN_SRC scheme
    (define (analyze-variable exp)
     (lambda (env) (lookup-variable-value exp env)))
    #+END_SRC

    analyze-assignment also must defer actually setting the variable
    until the execution, when the environment has been
    supplied. However, the fact that the assignment-value expression
    can be analyzed (recursively) during analysis is a major gain in
    efficiency, because the assignment-value expression will now be
    analyzed only once. The same holds true for definitions.

    #+BEGIN_SRC scheme
    (define (analyze-assignment exp)
     (let ((var (assignment-variable exp))
           (vproc (analyze (assignment-value exp))))
      (lambda (env)
       (set-variable-value! var (vproc env) env)
       'ok)))
    (define (analyze-definition exp)
     (let ((var (definition-variable exp))
           (vproc (analyze (definition-value exp))))
      (lambda (env)
       (define-variable! var (vproc env) env)
       'ok)))
    #+END_SRC

    For if expressions, we extract and analyze the predicate,
    consequent, and alternative at analysis time.

    #+BEGIN_SRC scheme
    (define (analyze-if exp)
     (let ((pproc (analyze (if-predicate exp)))
           (cproc (analyze (if-consequent exp)))
           (aproc (analyze (if-alternative exp))))
      (lambda (env)
       (if (true? (pproc env))
           (cproc env)
           (aproc env)))))
    #+END_SRC

    Analyzing a lambda expression also achieves a major gain in
    efficiency: We analyze the lambda body only once, even though
    procedures resulting from evaluation of the lambda may be applied
    many times.

    #+BEGIN_SRC scheme
    (define (analyze-lambda exp)
     (let ((vars (lambda-parameters exp))
           (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
    #+END_SRC

    Analysis of a sequence of expressions (as in a begin or the body
    of a lambda expression) is more involved. Each expression in the
    sequence is analyzed, yielding an execution procedure. These
    execution procedures are combined to produce an execution
    procedure that takes an environment as argument and sequentially
    calls each individual execution procedure with the environment as
    argument.

    #+BEGIN_SRC scheme
    (define (analyze-sequence exps)
     (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
     (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
     (let ((procs (map analyze exps)))
      (if (null? procs) 
          (error "Empty sequence: ANALYZE")
          (loop (car procs) (cdr procs)))))              
    #+END_SRC

    To analyze an application, we analyze the operator and operands
    and construct an execution procedure that calls the operator
    execution procedure that calls the operator execution procedure
    (to obtain the actual procedure to be applied) and the operand
    execution procedures (to obtain the actual arguments). We then
    pass these to execute-application, which is the analog of apply in
    Section 4.1.1. execute-application differs from apply in that the
    procedure body for a compound procedure has already been analyzed,
    so there is no need to do further analysis. Instead, we just call
    the execution procedure for the body on the extended environment.

    #+BEGIN_SRC scheme
    (define (analyze-application exp)
     (let ((fproc (analyze (operator exp)))
           (aprocs (map analyze (operands exp))))
      (lambda (env)
       (execute-application
        (fproc env)
        (map (lambda (aproc) (aproc env))
             aprocs)))))
    (define (execute-application proc args)
     (cond ((primitive-procedure? proc)
            (apply-primitive-procedure proc args))
           ((compound-procedure? proc)
            ((procedure-body proc)
             (extend-environment
              (procedure-parameters proc)
              args
              (procedure-environment proc))))
           (else
            (error "Unknwon procedure type: EXECUTE-APPLICATION"
                   proc)))) 
    #+END_SRC

    Our new evaluator uses the same data structures, syntax
    procedures, and run-time support procedures as in sections Section
    4.1.2, Section 4.1.3, and Section 4.1.4. 

    - Exercise 4.22: Extend the evaluator in this section to support
      the special form let.
      
      let is only a syntactical construct so all we have to do is add
      
      #+BEGIN_SRC scheme
      ((let? exp) (analyze (let->combination exp)))
      #+END_SRC

      to the case statement in analyze.

    - Exercise 4.23: Alyssa P. Hacker doesn't understand why
      analyze-sequence needs to be so complicated. All the other
      analysis procedures are straightforward transformations of the
      corresponding evaluation procedures (or eval clauses) in Section
      4.1.1. She expected analyze-sequence to look like this:

      #+BEGIN_SRC scheme
      (define (analyze-sequence exps)
       (define (execute-sequence procs env)
        (cond ((null? (cdr procs))
               ((car procs) env))
              (else
               ((car procs) env)
               (execute-sequence (cdr procs) env))))
       (let ((procs (map analyze exps)))
        (if (null? procs)
            (error "Empty sequence: ANALYZE"))
        (lambda (env)
         (execute-sequence procs))))
      #+END_SRC

      Eva Lu Ator explains to Alyssa that the version in the text does
      more of the work of evaluating a sequence at analysis
      time. Alyssa's sequence-execution procedure, rather than having
      the calls to the individual execution procedures built in, loops
      through the procedures in order to call them: In effect,
      although the individual expressions in the sequence have been
      analyzed, the sequence itself has not been.

      Compare the two versions of analyze-sequence. For example,
      consider the common case (typical of procedure bodies) where the
      sequence has just one expression. What work will the execution
      procedure proeduced by Alyssa's program do? What about the
      execution procedure produced by the program in the text above?
      How do the two version compare for a sequence with two
      expressions?

      The original actual execution procedure will only execute the
      actual analyzed body, resulting in a single procedure call.

      Alyssa's procedure, on the other hand, will run execute-sequence
      on a single-item list. It will test if the next item is null,
      find that it is, and then do an execution. This results in three
      procedure calls -- execute-sequence?, null?, and the actual
      call, three calls.

      For two expressions, the original definition:

      (lambda (env) (proc1 env) (lambda (env) (proc2 env) (proc3 env)))
      Calling this procedure calls the original 3, plus two
      lambdas. This is 5 procedure calls. The number of procedure
      calls is multiplied by 2 (minus 1) -- 2 * n - 1.

      Alyssa's definition calls the original execute-sequence
      recursively, and tests for null each time. This is a list of
      procedure calls made:

      execute-sequence, null?, proc1, execute-sequence, null? proc2,
      execute-sequence, null?, proc3

      A total of 9 procedure calls.

      In general, Alyssa's definition multiplies the number of calls
      by 3, each time the body is evaluated -- 3 * n.

    - Exercise 4.24: Design and carry out some experiments to compare
      the speed of the original metacircular evaluator with the
      version in this section. Use your results to estimate the
      fraction of time that is spent in analysis versus execution for
      various procedures.

      The most obvious thing to do is write a procedure, like fibo,
      and execute it with a sizeable input and compare the results.

      The first thing I did was manually time the execution of
      (fibo 25) in each interpreter, with fibo defined as:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))
      #+END_SRC

      The analyze-execute version took 14 seconds, and the first naive
      evaluator that we implemented with no separate analysis step
      took 34 seconds. 

      The next step was to provide the interpreter itself with a way
      of telling time. I provided it with the primitive procedure
      get-universal-time, from the underlying scheme, and typed in
      this:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))

      (begin
       (let ((t1 (get-universal-time)))
        (fibo 25)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      The results were 33 for the original interpreter and 14 again
      for the analyzing interpreter. I repeated the experiment several
      time for both interpreters and got [34,33,34,34] and
      [14,14,13,13]. The averages are then 33.75 and 13.5, the
      original interpreter takes 2.5 times as long to do fibo. Since
      no 'analysis' is done in the analyzing interpreter and it is
      done every time in the first interpreter. So we can conclude
      that the fraction of time spent in analysis is (33.75 -
      13.5)/33.75, or .6 -- 60% of the interpreter's time is spent
      analyzing syntax if we don't extract that step. 

      We can also try a different kind of procedure. Instead of a
      multiple recursion procedure, we can try linear recursion.

      #+BEGIN_SRC scheme
      (define (sum n)
       (define (loop n result)
       (if (= n 0) 
           result
           (loop (- n 1) (+ result n))))
       (loop n 0))

      (begin
       (let ((t1 (get-universal-time)))
        (sum 100000)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      With the classic interpreter, I get 13, 13, 12, 13. With
      the analyzing interpreter, I get 6, 6, 7, 6. Despite the fact
      that the computational nature of the procedure is very
      different, the ratios are similar:

      (13 - 6)/13 = .54 (previous was .6)
      13/6 = 2.1 (previous was 2.5)

** 4.2 Variations on a Scheme -- Lazy Evaluation
   Now that we have an evaluator expressed as a Lisp program, we can
   experiment with alternative choices in language design simply by
   modifying the evaluator. Indeed, new languages are often invented
   by first writing an evaluator that embeds the new language within
   an existing high-level language. For example, if we wish to discuss
   some aspect of a proposed modification to Lisp with another member
   of the Lisp community, we can supply an evaluator that embodies the
   change. The recipient can then experiment with the new evaluator
   and send back comments as further modifications. Not only does the
   high-level implementation base make it easier to test and debug the
   evaluator; in addition, the embedding enables the designer to snarf
   features from the underlying language, just as our embedded Lisp
   evaluator uses primitives and control structures from the
   underlying Lisp. Only later (if ever) need the designer go to the
   trouble of building a complete implementation in a low-level
   language or in hardware. In this section and the next we will
   explore some variations on Scheme that provie significant
   additional expressive power.

*** 4.2.1 Normal Order and Applicative Order
    In Section 1.1, where we began our discussion of models of
    evaluation, we noted that Scheme is an _applicative-order_
    language, namely, that all the arguments to Scheme procedures are
    evaluated when the procedure is applied. In contrast,
    _normal-order_ languages delay evaluation of procedure arguments
    until the actual argument values are needed. Delaying evaluation
    of procedure arguments until the last possible moment (e.g., until
    they are required by a primitive operation) is called _lazy
    evaluation_. Consider the procedure
    
    #+BEGIN_SRC scheme
    (define (try a b) (if (= a 0) 1 b))
    #+END_SRC
    
    Evaluating (try 0 (/ 1 0)) generates an error in Scheme. With lazy
    evaluation, there would be no error. Evaluating the expression
    would return 1, because the argument (/ 1 0) would never be
    evaluated. An example that exploits lazy evaluation is the
    definition of a procedure unless
    
    #+BEGIN_SRC scheme
    (define (unless condition usual-value exceptional-value)
     (if condition exceptional-value usual-value))
    #+END_SRC

    that can be used in expressions such as

    #+BEGIN_SRC scheme
    (unless (= b 0)
            (/ a b)
            (begin (display "Exception: Returning 0") 0)) 
    #+END_SRC

    This won't work in an applicative-order language because both the
    usual value and the exceptional value will be evaluated before
    unless is called (compare Exercise 1.6). An advantage of lazy
    evaluation is that some procedures, such as unless, can do useful
    computation even if evaluation of some of their arguments would
    produce errors or would not terminate. 

    If the body of a procedure is entered before an argument has been
    evaluated we say that the procedure is _non-strict_ in that
    argument. If the argument is evaluated before the body of the
    procedure is entered we say that the procedure is _strict_ in that
    argument. In a purely applicative-order language, all procedures
    are strict in each argument. In a purely normal-order language,
    all procedures are strict in each argument. In a purely
    normal-order language, all compound procedures are non-strict in
    each argument, and primitive proceduers may be either strict or
    non-strict. There are also languages (see Exercise 4.31) that give
    programmers detailed control over the strictness of the procedures
    they define. 

    A striking example of a procedure that can usefully be made
    non-strict is cons (or, in general, almost any constructor for
    data structures). One can do useful computation, cimbining
    elements to form data structures and operating on the resulting
    data structures, even if the values of the elements are not
    known. It makes perfect sense, for instance, to compute the length
    of a list without knowing the values of the individual elements in
    the list. We will exploit this idea in Section 4.2.3 to implement
    the stream of Chapter 3 as lists formed of non-strict cons pairs.

    - Exercise 4.25: Suppose that (in ordinary applicative-order
      Scheme) we define unless as shown above and then define
      factorial in terms of unless as

      #+BEGIN_SRC scheme
      (define (factorial n)
       (unless (= n 1)
               (* n (factorial (- n 1)))
               1))
      #+END_SRC

      What happens if we attempt to evaluate (factorial 5)? Will our
      definitions work in a normal-order language?

      Because unless in a applicative-order language would simply be a
      normal procedure whose arguments are evaluated first before the
      procedure itself is called, the procedure will never terminate,
      no matter what arguments we give it. It will call (* n
      (factorial (- n 1))) forever.

      This definition would work in a normal-order language, assuming
      that once you actually try to call a primitive function or do a
      variable lookup, the value is actually evaluated.

    - Exercise 4.26: Ben Bitdiddle and Alyssa P. Hacker disagree over
      the importance of lazy evaluation for implementing things such
      as unless. Ben points out that it's possible to implement unless
      in applicative order as a special form. Alyssa counters that, if
      one did that, unless would be merely syntax, not a procedure
      that could be used in conjunction with higher-order
      procedures. Fill in the details on both sides of the
      argument. Show how to implement unless as a derived expression
      (like cond or let), and give an example of a situation where it
      might be useful to have unless available as a procedure, rather
      than as a special form.

      Ben is correct, in that you can implement a version of
      unless that will work for the factorial function we defined. You
      would just write a procedure, unless->if, that, like cond,
      converts its unless input syntax to if to be actuall
      evaluated. You would add the following case to the eval procedure:

      ((unless? expr) (eval (unless->if expr)))

      The procedure:

      #+BEGIN_SRC scheme
      (define (unless->if expr)
       (make-if
        (unless-condition expr)
        (unless-failure expr)
        (unless- expr)))
      #+END_SRC

      However, Alyssa is also correct, you can't pass unless as a
      procedural argument to higher-order procedures, so something
      like this:

      #+BEGIN_SRC scheme
      (higher-order-procedure unless (list 'a 'b 'c))
      #+END_SRC

      will simply produce a variable-not-found error. It may be useful
      to have unless if you have some kind of higher-order procedure
      where it's behavior is modified by what operator you give it.

      #+BEGIN_SRC scheme
      (define (proc f vals)
       (map 
        (lambda (val) 
         (f (car val) (cadr val) (caddr val)))
        vals))
      #+END_SRC

      This procedure takes lists of triples, and applies f to each
      triple in a map. 

      #+BEGIN_SRC scheme
      (proc unless '((1 2 3) (false 1 2)))
      (list 3 1)
      #+END_SRC

      You can't do that with unless as syntax. You can do it however
      with unless as a normal applicative-order function in our
      current interpreter. However, we can also, assuming that list is
      also normal-order, write:

      (list (list (= a 1) (factorial 10) 33) (list (= a 22)
      (factorial 11) 33))

      And in general write something like a batch-processed system of
      conditionals that you can apply to data structures.

      
*** 4.2.2 An Interpreter with Lazy Evaluation
    In this section we will implement a normal-order language that is
    the same as Scheme except that compound procedures are non-strict
    in each language. Primitive procedures will still be strict. It is
    not difficult to modify the evaluator of Section 4.1.1 so that the
    language it interprets behaves this way. Almost all the required
    changes center around procedure application.

    The basic idea is that, when applying a procedure, the interpreter
    must determine which arguments are to be evaluated and which are
    to be delayed. The delayed arguments are not evaluated; instead,
    they are transformed into objects called _thunks_. The thunk must
    contain the information required to produce the value of the
    argument when it is needed, as if it had been evaluated at the
    time of the application. Thus, the thunk must contain the argument
    expression and the environment in which the procedure application
    is being evaluated.

    The process of evaluating the expression in a thunk is called
    _forcing_. In general, a thunk will be forced only when its value
    is needed: when it is passed to a primitive procedure that will
    use the value of the thunk; when it is the value of a predicate of
    a conditional; and when it is the value of an operator that is
    about to be applied as a procedure. One design choice we have
    available is whether or not to _memoize_ thunks, as we did with
    delayed objects in Section 3.5.1. With memoization, the first time
    a thunk is forced, it stores the value that is
    computed. Subsequent forcings simply return the stored value
    without repeating the computation. We'll make our interpreter
    memoize, because this is more efficient for many
    applications. There are tricky considerations here, however.

**** Modifying the evaluator.
     
     The main difference between the lazy evaluator and the one in
     Section 4.1 is in the handling of the procedure applications in
     eval and apply. The application? clause of eval becomes

     #+BEGIN_SRC scheme
     ((application? exp)
      (apply (actual-value (operator exp) env)
             (operands exp)
             env))
     #+END_SRC

     This is almost the same as the application? clause of eval in
     Section 4.1.1. For lazy evaluation, however, we call apply with
     the operand expressions, rather than the arguments produced by
     evaluating them. Since we will need the environment to construct
     thunks if the arguments are to be delayed, we must pass this as
     well. We still evaluate the operator, because apply needs the
     actual procedure to be applied in order to dispatch on its type
     (primitive versus compound) and apply it. 

     Whenever we need the actual value of an expression, we use
     
     #+BEGIN_SRC scheme
     (define (actual-value exp env)
      (force-it (eval exp env)))
     #+END_SRC

     instead of just eval, so that if the expression's value is a
     thunk, it will be forced.

     Our new version of apply is also almost the same as the version
     in Section 4.1.1. The difference is that eval has passed in
     unevaluated operand expressions: For primitive procedures (which
     are strict), we evaluate all the arguments before applying the
     primitive; for compound procedures (which are non-strict) we
     delay all the arguments before appling the procedure. 

     #+BEGIN_SRC scheme
     (define (apply procedure arguments env)
      (cond ((primitive-procedure? procedure)
             (apply-primitive-procedure
              procedure
              (list-of-arg-values arguments env)))
            ((compound-procedure? procedure)
             (eval-sequence
              (procedure-body procedure)
              (extend-environment
               (procedure-parameters procedure)
               (list-of-delayed-args arguments env)
               (procedure-environment procedure))))
            (else (error "Unknown procedure type: APPLY"
                         procedure))))
     #+END_SRC

     The procedures that process the arguments are just like
     list-of-values from Section 4.1.1, except that
     list-of-delayed-args delays the arguments instead of evaluating
     them, and list-of-arg-values uses actual-value instead of eval:

     #+BEGIN_SRC scheme
     (define (list-of-arg-values exps env)
      (if (no-operands? exps)
          '()
          (cons (actual-value (first-operand exps)
                              env)
                (list-of-arg-values (rest-operands exps)
                                    env))))
     (define (list-of-delayed-args exps env)
      (if (no-operands? exps)
          '()
          (cons (delay-it (first-operand exps)
                          env)
                (list-of-delayed-args (rest-operands exps)
                                      env))))
     #+END_SRC

     The other place we must change the evaluator is in the handling
     of if, where we must use actual-value instead of eval to get the
     value of the predicate expression before testing whether it is
     true or false:

     #+BEGIN_SRC scheme
     (define (eval-if exp env)
      (if (true? (actual-value (if-predicate exp) env))
          (eval (if-consequent exp) env)
          (eval (if-alternative exp) env)))
     #+END_SRC

     Finally, we must change the driver-loop procedure (Section 4.1.4)
     to use actual-value instead of eval, so that if a delayed value
     is propagated back to the read-eval-print loop, it will be forced
     before being printed. We also change the prompts to indicate that
     this is the lazy evaluator:

     #+BEGIN_SRC scheme
     (define input-prompt  ";;; L-Eval input:")
     (define output-prompt ";;; L-Eval value:")
     (define (driver-loop)
      (prompt-for-input input-prompt)
      (let ((input (read)))
       (let ((output
              (actual-value
               input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)
      (driver-loop))
     #+END_SRC

     With these changes made, we can start the evaluator and test
     it. The successful evaluation of the try expression discussed in
     Section 4.2.1 indicates that the interpreter is performing lazy
     evaluation:

     #+BEGIN_SRC scheme
     (define the-global-environment (setup-environment))
     (driver-loop)
     ;;; L-Eval input:
     (define (try a b) (if (= a 0) 1 b))
     ;;; L-Eval value:
     ok
     ;;; L-Eval input:
     (try 0 (/ 1 0))
     ;;; L-Eval value:
     1
     #+END_SRC

**** Representing thunks
     Our evaluator must arrange to create thunks when procedures are
     applied to arguments and to force these thunks later. A thunk
     must package an expression together with the environment, so that
     the argument can be produced later. To force the thunk, we simply
     extract the expression and environment from the thunk and
     evaluate the expression in the environment. We use actual-value
     rather than eval so that in case the value of the expression is
     itself a thunk, we will force that, and so on, until we reach
     something that is not a thunk:

     #+BEGIN_SRC scheme
     (define (force-it obj)
      (if (thunk? obj)
          (actual-value (thunk-exp obj) (thunk-env obj))
          obj))
     #+END_SRC

     One easy way to package an expression with an environment is to
     make a list containing the expression and the environment. Thus,
     we create a thunk as follows:

     #+BEGIN_SRC
     (define (delay-it exp env)
      (list 'thunk exp env))
     (define (thunk? obj)
      (tagged-list? obj 'thunk))
     (define (thunk-exp thunk) (cadr thunk))
     (define (thunk-env thunk) (caddr thunk))
     #+END_SRC
     
     Actually, what we want for our interpreter is not quite this, but
     rather chunks that have been memoized. When a thunk is forced, we
     will turn it into an evaluated thunk by replacing the stored
     expression with its value and changing the thunk tag so that it
     can be recognized as already evaluated.

     #+BEGIN_SRC scheme
     (define (evaluated-thunk? obj)
      (tagged-list? obj 'evaluated-thunk))
     (define (thunk-value eavluated-thunk)
      (cadr evaluated-thunk))
     (define (force-it obj)
      (cond ((thunk? obj)
             (let ((result (actual-value (thunk-exp obj)
                                         (thunk-env obj))))
              (set-car! obj 'evaluated-thunk)
              (set-car! (cdr obj)             ;; replace exp with value
                        result)
              (set-cdr! (cdr obj)             ;; forget unneeded env.
                        '())
              result))
            ((evaluated-thunk? obj) (thunk-value obj))
            (else obj)))
     #+END_SRC

     Notice that the same delay-it procedure works both with and
     without memoization.

     - Exercise 4.27: Suppose we type in the following definitions to
       the lazy evaluator:

       #+BEGIN_SRC scheme
       (define count 0)
       (define (id x) (set! count (+ count 1)) x)
       #+END_SRC

       Give the missing values in the following sequence of
       interactions, and explain your answers.

       #+BEGIN_SRC scheme
       (define w (id (id 10)))
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       <response>
       ;;; L-Eval input:
       w
       ;;; L-Eval value:
       <response>
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       <response>
       #+END_SRC

       #+BEGIN_SRC scheme
       (define w (id (id 10)))
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       1
       ;;; L-Eval input:
       w
       ;;; L-Eval value:
       10
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       2
       #+END_SRC

       When we evaluate (define w (id (id 10))), the evaluator sees a
       define. eval-define then evals the expression (id (id 10))
       before assigning it to w. We see the application of id, and
       eval-sequence the body of id after thunkifying its
       arguments. The body is ((set! count (+ count 1)) x). We do the
       set since that is a separate syntactical construct not subject
       to laziness, and it uses a primitive procedure on the
       right-hand side of the assignment. So, count is altered to
       be 1. Then we see x, which in this case is a thunkified
       argument -- (thunk (id 10)). Since we are lazy, we return this
       value from eval, and w is assigned to (thunk (id 10)), the
       return value of the initial id call. So then when we ask for
       count without first evaluating w, we get 1. Then, we evaluate
       w, which forces the thunk. We eval the call (id 10) all the way
       through. The first thing is again set!, which increments count
       from 1 to 2. Then we return x, which is self-evaluating 10. So
       w is 10. Then, we ask for count and get the again-altered
       value, 2.

       - Exercise 4.28: eval uses actual-value rather than eval to
         evaluate the operator before passing it to apply, in order to
         force the value of the operator. Give an example that
         demonstrates the need for this forcing. 

	 #+BEGIN_SRC scheme
         (define (f g x) (* 2 (g x)))
	 #+END_SRC

	 Without actual-value, when we try to evaluate (g x), we
         lookup g and get a thunk and try to apply using a thunk,
         which is an unknown procedure type.

       - Exercise 4.29: Exhibit a program that you would expect to run
         much more slowly without memoization than with
         memoization. Also, consider the following interaction, where
         the id procedure is defined as in Exercise 4.27 and count
         starts at 0:

	 Any program that uses arguments multiple times will run more
         slowly without memoization, especially if you pass it a
         parameter that is a function call.

	 In fibo, for example, we test n twice, and then call fibo
         with (- n 1) and (- n 2). So, in the case where n is not 0 or
         1, we have to force the thunk a total of four times every
         call to fibo we make (which will be a lot of calls since it's
         multiply recursive).
	 #+BEGIN_SRC scheme
         (define (fibo n)
          (cond
           ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (fibo (- n 1)) (fibo (- n 2))))))
	 #+END_SRC

	 The ackermann function is worse, because of the call (a (-
         m 1) (a m (- n 1))). If we call a with a value where m and n
         are both greater than zero, we will have to call a with (a m
         (- n 1)) as n, and n will have to be forced in the cond
         condition clauses twice at least, and if it's still greater
         than 0, again in the final default case. This is a huge
         overhead since the thunk is a function call and not a simple
         variable lookup, and it will re-evaluate a potentially
         multiply-recursive call each time.
	 #+BEGIN_SRC scheme
         (define (a m n)
          (cond
           ((= m 0) (+ n 1))
           ((and (> m 0) (= n 0)) (a (- m 1) 1))
           (else (a (- m 1) (a m (- n 1))))))

	 #+END_SRC

	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         <response>
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         <response>
	 #+END_SRC

	 Give the responses both when the evaluator memoizes and when
         it does not.

	 memoized:
	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         100
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         1
	 #+END_SRC

	 non-memoized:

	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         100
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         2
	 #+END_SRC

	 - Exercise 4.30: Cy D. Fect, a reformed C programmer, is
           worried that some side effects may never take place,
           because the lazy evaluator doesn't force the expressions in
           a sequence. Since the value of an expression in a sequence
           other than the last one is not used (the expression is
           there only for effect, such as assigning to a variable or
           printing), there can be no subsequent use of this value
           (e.g., as an argument to a primitive procedure) that will
           cause it to be forced. Cy thus thinks that when evaluating
           sequences, we must force all expressions in the sequence
           except the final one. He proposes to modify eval-sequence
           from Section 4.1.1 to use actual-value rather than eval:

	   #+BEGIN_SRC scheme
           (define (eval-sequence exps env)
            (cond ((last-exp? exps) (eval (first-exp exps) env))
                  (else (actual-value (first-exp exps) env)
                        (eval-sequence (rest-exps exps) env))))
	   #+END_SRC

	   a. Ben Bitdiddle thinks Cy is wrong. He shows Cy the
           for-each procedure described in Exercise 2.23, which gives
           an important example of a sequence with side effects:

	   #+BEGIN_SRC scheme
           (define (for-each proc items)
            (if (null? items)
                'done
                (begin (proc (car items))
                       (for-each proc (cdr items)))))
	   #+END_SRC

	   He claims that the evaluator in the text (with the original
           eval-sequence) handles this correctly:

	   #+BEGIN_SRC scheme
	   ;;; L-Eval input:
           (for-each (lambda (x) (newline) (display x))
                     (list  57 321 88))
           57
           321
           88
           ;;; L-Eval value:
           done
	   #+END_SRC

	   Explain why Ben is right about the behavior of for-each.

	   Although we don't evauate arguments to a procedure, we do
           recursively evaluate procedure applications, and any
           side-effect must be either a primitive or a syntactical
           eval-construct, which will get evaluated (like set!). In
           this example, newline and display are both primitives, so
           they have to be evaluated, we only thunk
           arguments. However, if we write a sequence where we have an
           evauation of an argument that has a side-effect, then the
           behavior will not be as simple.

	   

	   b. Cy agrees that Ben is right about the for-each example,
	   but says that that's not the kind of program he was
	   thinking about when he proposed his change to
	   eval-sequence. He defines the following two procedures in
	   the lazy evaluator:

	   #+BEGIN_SRC scheme
           (define (p1 x)
            (set! x (cons x '(2)))
            x)
           (define (p2 x)
            (define (p e)
             e
             x)
            (p (set! x (cons x '(2)))))
	   #+END_SRC

	   What are the values of (p1 1) and (p2 1) with the original
	   eval-sequence? What would the values be with Cy's proposed
	   change to eval-sequence?

	   (p1 1) is basically as expected since set! is a syntactical
	   construct and doesn't thunk its arguments, (cons x '(2)) is
	   also a primitive, so it forces the value of x. The returned
	   value is (1 2).

	   (p2 1) is different. The call to p will thunk the
	   expression (set! x (cons x '(2))). Then, e is
	   evaled. However, since all we do is lookup-variable-value
	   and don't actually force the thunk, e is never forced. x is
	   returned, unaltered. This is counterintuitive. The returned
	   value is the original value of x, 1. The set! was never
	   actually evaluated, because it was an argument and not an
	   application. So even though set! is a syntactical
	   construct, that didn't save it from being thunked and not
	   evaluated during the eval-sequence.

	   c. Cy also points out that changing eval-sequence as he
	   proposes does not affect the behavior of the example in
	   part a. Explain why this is true.

	   It doesn't change behavior because the only difference is
	   that he's forcing each expression, the expression in Ben's
	   example was already basically being 'forced' by the
	   primitives functions he was using. So there is no
	   difference.

	   d. How do you think sequence ought to be treated in the
	   lazy evaluator? Do you like Cy's approach, the approach in
	   the text, or some other approach?

	   Our evaluator has no way to, inside the language, force an
	   expression. So without this I think Cy's approach is best,
	   although the side effects themselves are probably examples
	   of bad programming practice, the behavior of p2 doesn't
	   make sense and we should try to make the results of the
	   evaluator make sense as much as possible, and it does not
	   make sense that some expressions would be effectively
	   unevaluated or unforced. However, if we could write a
	   'primtive' function or syntax that allows a programmer to
	   force values inside a begin, that might make more
	   sense. For the majority of applications, the current
	   evaluator works well, do just adding that would make sense
	   too.

         - Exercise 4.31: The approach taken in this section is
           somewhat unpleasant, because it makes an incompatible
           change to Scheme. It might be nicer to implement lazy
           evaluation as an _upward-compatible extension_, that is, so
           that ordinary Scheme programs will work as before.  We can
           do this by extending the syntax of procedure declarations
           to let the user control whether or not arguments are to be
           delayed. While we're at it, we may as well also give the
           user the choice between delaying with and without
           memoization. For example, the definition

	   #+BEGIN_SRC scheme
           (define (f a (b lazy) c (d lazy-memo))
            ...)
	   #+END_SRC

	   would define f to be a procedure of four arguments, where
           the first and third arguments are evaluated when the
           procedure is called, the second argument is delayed, and
           the fourth argument is both delayed and memoized. Thus,
           ordinary procedure definitions will produce the same
           behavior as ordinary Scheme, while adding the lazy-memo
           declaration to each parameter of every compound procedure
           will produce the behavior of the lazy evaluator defined in
           this section. Design and implement the changes required to
           produce such an extension to Scheme. You will have to
           implement new syntax procedures to handle the new syntax
           for define. You must also arrange for eval or apply to
           determine when arguments are to be delayed, and to force or
           delay arguments accordingly, and you must arrange for
           forcing to memoize or not, as appropriate.

*** 4.2.3 Streams as Lazy Lists
    In Section 3.4.1, we showed how to implement streams as delayed
    lists. We introduced special forms delay and cons-stream, which
    allowed us to construct a "promise" to compute the cdr of a
    stream, without actually fulfilling that promise until later. We
    could use this general technique of introducing special forms
    whenever we need more control over the evaluation process, but
    this is awkward. For one thing, a special form is not a
    first-class object like a procedure, so we cannot use it together
    with higher-order procedures. Additionally, we were forced to
    create streams as a new kind of data object similar but not
    identical to lists, and this required us to reimplement many
    ordinary list operations (map, append, and so on) for use with
    streams.

    With lazy evaluation, streams and lists can be identical, so there
    is no need for special forms or for separate list and stream
    operations. All we need to do is arrange matters so that cons is
    non-strict. One way to accomplish this is to extend the lazy
    evaluator to allow for non-strict primitives, and to implement
    cons as one of these. An easier way is to recall (Section 2.1.3)
    that there is no fundamental need to implement cons as a primitive
    at all. Instead, we can represent pairs as procedures:

    #+BEGIN_SRC scheme
    (define (cons x y) (lambda (m) (m x y)))
    (define (car z) (z (lambda (p q) p)))
    (define (cdr z) (z (lambda (p q) q)))
    #+END_SRC

    In terms of these basic operations, the standard definitions of
    the list operations will work with infinite lists (streams) as
    well as finite ones, and the stream operations can be implemented
    as list operations. Here are some examples:

    #+BEGIN_SRC scheme
    (define (list-ref items n)
     (if (= n 0)
         (car items)
         (list-ref (cdr items) (- n 1))))
    (define (map proc items)
     (if (null? items)
         '()
         (cons (proc (car items))
               (map proc (cdr items)))))
    (define (scale-list items factor)
     (map (lambda (x) (* x factor)) items))

    (define (add-lists list1 list2)
     (cond ((null? list1) list2)
           ((null? list2) list1)
           (else (cons (+ (car list1) (car list2))
                       (add-lists (cdr list1) (cdr list2))))))
    (define ones (cons 1 ones))
    (define integers (cons 1 (add-lists ones integers)))
    ;;; L-Eval input:
    (list-ref integers 17)
    ;;; L-Eval value:
    18
    #+END_SRC

    Note that these lazy lists are even lazier than the streams of
    Chapter 3: The car of the list, as well as the cdr, is delayed. In
    fact, even accessing the car or cdr of a lazy pair need not force
    the value of a list element. The value will be forced only when it
    is really needed -- e.g., for use as the argument of a primitive,
    or to be printed as an answer.

    Lazy pairs also help with the problem that arose with streams in
    Section 3.5.4, where we found that formulating stream models of
    systems with loops may require us to sprinkle our programs with
    explicit delay operations, beyond the ones supplied by
    cons-stream. With lazy evaluation, all arguments to procedures are
    delayed uniformly. For instance, we can implement procedures to
    integrate lists and solve differential equations as we originally
    intended in Section 3.5.4:

    #+BEGIN_SRC scheme
    (define (integral integrand initial-value dt)
     (define int
      (cons initial-value
            (add-lists (scale-list integrand dt) int)))
     int)

    (define (solve f y0 dt)
     (define y (integral dy y0 dt))
     (define dy (map f y))
     y)
    ;;; L-Eval input:
    (list-ref (solve (lambda (x) x) 1 0.001) 1000)
    ;;; L-Eval value:
    2.716924
    #+END_SRC

    - Exercise 4.32: Give some examples that illustrate the difference
      between the streams of Chapter 3 and the "lazier" lazy lists
      described in this section. How can you take advantage of this
      extra laziness?

      The full laziness allows us to have infinite car components. So
      for exmaple,

      #+BEGIN_SRC scheme
      (define (infinite-tree a b)
       (cons (infinite-tree b a) (infinite-tree a b)))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (pt n)
       (cons (pt-list n) (pt (+ n 1))))


      (define (pt-list n)
       (cond
        ((= n 0) ones)
        ((= n 1) integers)
        (else (pt-rec 0 (pt-list (- n 1)) 0))))

       (define (pt-rec i side-list last-element)
        (cond
         ((= i 0) (cons 1 (pt-rec 1 (cdr side-list) 1)))
         (else (let ((new-elem (+ last-element (car side-list))))
                (cons new-elem
                      (pt-rec (+ i 1) (cdr side-list)))))))
      #+END_SRC
   
      is possible. Even using cons-stream, calling this function in
      our normal evaluator would never end. Another example is that we
      can take as arguments non-terminating expressions, and put them
      into lists, even the car.

      (define x (let ((a <some-infinite-expression>)
                      (b <some-other-infinite-expression>))
                 (cons a b)))

      However, what's a little more interesting is that since we
      package an environment in our thunks, it can get modified after
      the fact.

      #+BEGIN_SRC scheme
      (define (solve-2nd f dt y0 dy0)
       (define y (integral
                  dy
                  y0
                  dt))
       (define dy (integral
                   ddy
                   dy0
                   dt))
      (define ddy (stream-map f y dy))
      y)
      #+END_SRC

      This function can now stand on its own. That's because we don't
      force the arguments dy or ddy. So they don't have to mean
      anything until we start referencing items of the list, this
      would not have happened just using lazy streams, we had to delay
      manually, creating a bit of a mess. Now we don't need that.

    - Exercise 4.33: Ben Bitdiddle tests the lazy list implementation
      given above by evaluating the expression:

      #+BEGIN_SRC scheme
      (car '(a b c))
      #+END_SRC
      
      To his surprise, this produces an error. After some thought, he
      realizes that the "lists" obtained by reading in quoted
      expressions are different from the lists manipulated by the new
      definitions of cons, car, and cdr. Modify the evaluator's
      treatment of quoted expressions so that that quoted lists typed
      at the driver loop will produce true lazy lists.

    - Exercise 4.34: Modify the driver loop for the evaluator so that
      lazy pairs and lists will print in some reasonable way. (What
      are you going to do about infinite lists?) You may also need to
      modify the representation of lazy pairs so that the evaluator
      can identify them in order to print them.

      We can handle some infinite lists by checking if the current
      list is identical to the cdr of the current list (using equal?
      which compares the actual functions in the underlying
      scheme), and outputting a symbol like '<infinite-list> in that
      event. However, this doesn't handle all infinite lists. If we
      make a list like this:

      #+BEGIN_SRC scheme
      (define ones (cons 1 ones))
      (define integers (cons 1 (add-lists integers ones)))
      #+END_SRC

      Our new procedure can handle ones, but it can't handle
      integers. The only way to handle integers is to 

      1.) Set a limit on the number of items printed for any list.
      2.) Somehow analyze the procedure to tell if it doesn't
      terminate.

      (2) is probably not possible and obviously overkill, so the
      practical solution is to define a global variable that is the
      max number of items to print and add a check to our printing
      procedure. We can then insert the symbol ... as the last element
      printed to indicate there are more items.

** 4.3 Variations on a Scheme -- Nondeterministic Computing

   In this section, we extend the Scheme evaluator to support a
   programming paradigm called _nondeterministic computing_ by
   building into the evaluator a facility to support automatic
   search. This is a much more profound change to the language than
   the introduction of lazy evaluation in Section 4.2.
   
   Nondeterministic computing, like stream processing, is useful for
   "generate and test" applications. Consider the task of starting
   with two lists of positive integers and finding a pair of integers
   -- one from the first list and one from the second list -- whose
   sum is prime. We saw how to handle this with finite sequence
   operations in Section 2.2.3 and with infinite streams in Section
   3.5.3. Our approach was to generate the sequence of all possible
   pairs and filter these to select the pairs whose sum is
   prime. Whether we actually generate the entire sequence of pairs
   first as in Chapter 2, or interleave the generating and filtering
   as in Chapter 3, is immaterial to the essential image of how the
   computation is organized. 

   The nondeterministic approach evokes a different image. Imagine
   simply that we choose (in some way) a number from the first list
   and a number from the second list and require (using some
   mechanism) that their sum be prime. This is expressed by following
   procedure:

   #+BEGIN_SRC scheme
   (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
     (require (prime? (+ a b)))
     (list a b)))
   #+END_SRC

   It might seem as if this procedure merely restates the problem,
   rather than specifying a way to solve it. Nevertheless, this is a
   legitimate nondeterministic program. 

   The key idea here is that expressions in a nondeterministic
   language can have more than one possible value. For instance,
   an-element-of might return any element of the given list. Our
   nondeterministic program might return any element of a given
   list. Our nondeterministic program evaluator will work by
   automatically choosing a possible value and keeping track of the
   choice. If a subsequent requirement is not met, the evaluator will
   try a different choice, and it will keep trying new choices until
   the evaluation succeeds, or until we run out of choices. Just as
   the lazy evaluator freed the programmer from the details of how
   values are delayed and forced, the nondeterministic program
   evaluator will free the programmer from the details of how choices
   are made.

   It is instructive to contrast the different images of time evoked
   by nondeterministic evaluation and stream processing. Stream
   processing uses lazy evaluation to decouple the time when the
   stream of possible answers is assembled from the time when the
   actual stream elements are produced. The evaluator supports the
   illusion that all the possible answers are laid out before us in a
   timeless sequence. With nondeterministic evaluation, an expression
   represents the exploration of a set of possible worlds, each
   determined by a set of choices. Some of the possible worlds lead to
   dead ends, while others have useful values. The nondeterministic
   program evaluator supports the illusion that time branches, and
   that our programs have different possible execution histories. When
   we reach a dead end, we can revisit a previous choice point and
   proceed along a different branch.

   The nondeterministic program evaluator implemented below is called
   the amb evaluator because it is based on a new special form called
   amb. We can type the above definition of prime-sum-pair at the amb
   evaluator driver loop (along with definitions of prime?,
   an-element-of, and require) and run the procedure as follows:

   #+BEGIN_SRC scheme
   ;;; Amb-Eval input: 
   (prime-sum-pair '(1 3 5 8) '(20 35 110))
   ;;; Starting a new problem
   ;;; Amb-Eval value:
   (3 20)
   #+END_SRC
   
   The  value returned was obtained after the evaluator repeatedly
   chose elements from each of the lists, until a successful choice
   was made. 

   Section 4.3.1 introduces amb and explains how it supports
   nondeterminism through the evaluator's automatic search
   mechanism. Section 4.3.2 presents examples of nondeterministic
   programs, and Section 4.3.3 gives the details of how to implement
   the amb evaluator by modifying the ordinary Scheme evaluator.

*** 4.3.1 Amb and Search
    To extend Scheme to support nondeterminism, we introduce a new
    special form called amb. The expression

    #+BEGIN_SRC scheme
    (amb <e1> <e2> ... <en>)
    #+END_SRC

    return the value of one of the n expressions <e1> "ambiguously."
    For example, the expression

    #+BEGIN_SRC scheme
    (list (amb 1 2 3) (amb 'a 'b))
    #+END_SRC

    can have six possible values:

    #+BEGIN_SRC scheme
    (1 a) (1 b) (2 a ) (2 b) (3 a) (3 b)
    #+END_SRC

    amb with a single choice produces an ordinary (single) value. 

    amb with no choices - the expression (amb) - is an expression with
    no acceptable values. Operationally, we can think of (amb) as an
    expression that when evaluated causes the computation to "fail":
    The computation aborts and no value is produced. Using this idea,
    we can express the requirement that a particular predicate
    expression p must be true as follows:

    #+BEGIN_SRC scheme
    (define (require p) (if (not p) (amb)))
    #+END_SRC

    With amb and require, we can implement the an-element-of procedure
    used above:

    #+BEGIN_SRC scheme
    (define (an-element-of items)
     (require (not (null? items)))
     (amb (car items) (an-element-of (cdr items))))
    #+END_SRC

    an-element-of fails if the list is empty. Otherwise it ambiguously
    returns either the first element of the list or an element chosen
    from the rest of the list.

    We can also express infinite ranges of choices. The following
    procedure potentially returns any integer greater than or equal to
    some given n:

    #+BEGIN_SRC scheme
    (define (an-integer-starting-from n)
     (amb n (an-integer-starting-from (+ n 1))))
    #+END_SRC

    This is like the stream procedure integers-starting-from described
    in Section 3.5.2, but with an important difference: The stream
    procedure returns an object that represents the sequence of all
    integers beginning with n, whereas amb returns a single integer.

    Abstractly, we can imagine that evaluating an amb expression
    causes time to split into branches, where the computation
    continues on each branch with one of the possible values of the
    expression. We say that amb represents a _nondeterministic choice
    point._ If we had a machine with a sufficient number of processors
    that could be dynamically allocated, we could implement the search
    in a straightforward way. Execution would proceed as in a
    sequential machine, until an amb expression is encoutered. At this
    point, more processors would be allocated and initialized to
    continue all of the parallel executions implied by the
    choice. Each processor would proceed sequentially as if it were
    the only choice, until it either terminates by encountering a
    failure, or it further subdivides, or it finishes.

    On the other hand, if we have a machine that can execute only one
    process (or a few concurrent processes), we must consider the
    alternatives sequentially. One could imagine modifying an
    evaluator to pick at random a branch to follow whenever it
    encounteres a choice point.

    Random choice, however, can easily lead to failing values. We
    might try running the evaluator over and over, making random
    choices and hoping to find a non-failing value, but it is better
    to _systematically search_ all possible execution paths. This amb
    evaluator that we will develop and work with in this section
    implements a systematic search as follows: When the evaluator
    encounters an application of amb, it initially selects the first
    alternative. This selection may itself lead to a further
    choice. The evaluator will always initially choose the first
    alternative at each choice point. If a choice results in a
    failure, then the evaluator automatically _backtracks_ to the most
    recent choice point and tries the next alternative. If it runs out
    of alternatives at any choice point, the evaluator will back up
    to the previous choice point and resume from there. This process
    leads to a search strategy known as _depth-first search_ or
    _chronological backtracking_. 

    
**** Driver loop
     The driver loop for the amb evaluator has some unusual
     properties. It reads an expression and prints the value of the
     first non-failing execution, as in the prime-sum-pair example
     shown above. If we want to see the value of the next successful
     execution, we can ask the interpreter to backtrack and attempt to
     generate a second non-failing execution. This is signaled by
     typing the symbol try-again. If any expression except try-again
     is given, the interpreter will start a new problem, discarding
     the unexplored alternatives in the previous problem. Here is a
     sample interaction:

     #+BEGIN_SRC scheme
     ;;; Amb-Eval input:
     (prime-sum-pair '(1 3 5 8) '(20 35 110))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (3 20)

     ;;; Amb-Eval input:
     try-again
     ;;; Amb-Eval value:
     (3 110)

     ;;; Amb-Eval input:
     try-again
     ;;; Amb-Eval value:
     (8 35)

     ;;; Amb-Eval input:
     try-again
     ;;; There are no more values of
     (prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))

     ;;; Amb-Eval input:
     (prime-sum-pair '(19 27 30) '(11 36 58))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (30 11)
     #+END_SRC

     - Exercise 4.35: Write a procedure an-integer-between that
       returns an integer between two given bounds. This can be used
       to implement a procedure that finds Pythagorean triples, i.e.,
       triples of integers (i, j, k) between the given bounds such
       that i <= j and i^2 + j^2 = k^2, as follows:

       #+BEGIN_SRC scheme
       (define (a-pythagorean-triple-between low high)
        (let ((i (an-integer-between low high))
              (hsq (* high high)))
         (let ((j (an-integer-between i high)))
          (let ((ksq (+ (* i i) (* j j))))
           (require (>= hsq ksq))
           (let ((k (sqrt ksq)))
            (require (integer? k))
            (list i j k))))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (an-integer-after n)
        (amb n (an-integer-after (+ 1 n))))
       (define (an-integer-between low high)
        (let ((x (an-integer-after low)))
         (require (< x high))
         x))
       #+END_SRC

*** 4.3.2 Examples of Nondeterministic Programs

    Section 4.3.3 describes the implementation of the amb
    evaluator. First, however, we give some examples of how it can be
    used. The advantage of nondeterministic programming is that we can
    suppress the details of how search is carried out, thereby
    expressing our programs at a higher level of abstraction.
    
**** Logic Puzzles

     The following puzzle (taken from Dinesman 1968) is typical of a
     large class of simple logic puzzles:

     Baker, Cooper, Fletcher, Miller, and Smith live on different
     floors of an apartment house that contains only five floors. Baker
     does not live on the top floor. Cooper does not live on the
     bottom floor. Fletcher does not live on either the top or the
     bottom floor. Miller lives on a higher floor than does
     Cooper. Smith does not live on a floor adjacent to
     Cooper's. Where does everyone live?

     We can determine who lives on each floor in a straightforward way
     by enumerating all the possibilities and imposing the given
     restrictions:

     #+BEGIN_SRC scheme
     (define (multiple-dwelling)
      (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
            (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
            (smith    (amb 1 2 3 4 5)))
       (require 
        (distinct? (list baker cooper fletcher miller smith)))
       (require
        (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (> miller cooper))
       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))
       (list (list 'baker baker)       (list 'cooper cooper)
             (list 'fletcher fletcher) (list 'miller miller)
             (list 'smith smith))))
     #+END_SRC 
    
     Evaluating the expression (multiple-dwelling) produces the result

     ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))

     Although this simple procedure works, it is very slow. Exercise
     4.39 and Exercise 4.40 discuss some possible improvements.

     - Exercise 4.38: Modify the multiple-dwelling procedure to omit
       the requirement that Smith and Fletcher do not live on adjacent
       floors. How many solutions are there to this modified puzzle?

       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
              (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
              (smith    (amb 1 2 3 4 5)))
         (require 
          (distinct? (list baker cooper fletcher miller smith)))
         (require
          (not (= baker 5)))
         (require (not (= cooper 1)))
         (require (not (= fletcher 5)))
         (require (not (= fletcher 1)))
         (require (> miller cooper))
         (require (not (= (abs (- fletcher cooper)) 1)))
         (list (list 'baker baker)       (list 'cooper cooper)
               (list 'fletcher fletcher) (list 'miller miller)
               (list 'smith smith))))
       #+END_SRC

       There are now five solutions.

     - Exercise 4.39: Does the order of the restrictions in the
       multiple-dwelling procedure affect the answer? If you think it
       matters, demonstrate a faster program obtained from the given
       one by reordering the restrictions. If you think it does not
       matter, argue your case.

       It should affect run time, but not the actual result. If we can
       remove a large number of options quickly without imposing other
       restrictions that eliminate fewer options, we should have many
       fewer steps to make.
   
       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
              (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
              (smith    (amb 1 2 3 4 5)))

         (require (> miller cooper))
         (require (not (<= (abs (- fletcher cooper)) 1)))
         (require (not (<= (abs (- smith fletcher)) 1)))
         (require
          (not (= baker 5)))
         (require (not (= cooper 1)))
         (require (not (= fletcher 5)))
         (require (not (= fletcher 1)))
         (require 
          (distinct? (list baker cooper fletcher miller smith)))
         (list (list 'baker baker)       (list 'cooper cooper)
               (list 'fletcher fletcher) (list 'miller miller)
               (list 'smith smith))))
       #+END_SRC

       This eliminates more possibilities quicker. (require (not (=
       baker 5))) only examines one item, baker, and doesn't actually
       eliminate many possibilities. But (require (> miller cooper))
       eliminates quite a few that would pass other requirements
       quickly, but without taking more runtime than a simple =
       call. So does the adjacency rule, since they affect more than
       just one list of possibilities. Additionally, distinct? is very
       slow, so we move it last, and make sure we eliminate as many
       'low-hanging-fruit' possibilities as possible before calling
       it.

     - Exercise 4.40: In the multiple dwelling problem, how many sets
       of assignments are there of people to floors, both before and
       after the requirement that floor assignments be distinct? It is
       very inefficient to generate all possible assignments of people
       to floors and then leave it to backtracking to eliminate
       them. For example, most of the restrictions depend on only one
       or two of the person-floor variables, and can thus be imposed
       before floors have been selected for all the people. Write and
       demonstrate a much more efficient nondeterministic procedure
       that solves this problem based upon generating only those
       possibilities that are not already ruled out by previous
       restrictions. (Hint: This will require a nest of let
       expressions.)

       Before we do any operations, we have 5 * 5 * 5 * 5 * 5 = 3125
       different floor assignments that we have to sort through with
       distinct? in the way it's written originally. After, it's 5! =
       120 unique sets of floor assignments, still a lot, before we
       eliminate things that were easy to eliminate in the first
       place, for example, all the floor assignments where miller is on 1. 

       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker (amb 1 2 3 4 5)))
         (require (not (= baker 5)))
         (let ((cooper (amb 1 2 3 4 5)))
          (require (not (= cooper 1)))
          (let ((miller (amb 1 2 3 4 5)))
           (require (> miller cooper))
           (let ((fletcher (amb 1 2 3 4 5)))
            (require (not (= fletcher 1)))
            (require (not (= fletcher 5)))
            (require (not (= (abs (- cooper fletcher)) 1)))
            (let ((smith (amb 1 2 3 4 5)))
             (require (not (= (abs (- smith fletcher)) 1)))
             (require 
              (distinct? (list baker cooper miller fletcher smith)))
             (list (list 'baker baker) (list 'cooper cooper)
                   (list 'fletcher fletcher) (list 'miller miller)
                   (list 'smith smith))))))))     
       #+END_SRC

     - Exercise 4.41: Write an ordinary Scheme program to solve the
       multiple dwelling puzzle.

       #+BEGIN_SRC scheme
       (define (distinct? a-list)
        (cond ((null? a-list) true)
              ((member (car a-list) (cdr a-list))
               false)
              (else 
               (distinct? (cdr a-list)))))
       (define (satisfies? baker cooper smith fletcher miller)
        (and
         (> miller cooper)
         (> (abs (- cooper fletcher)) 1)
         (> (abs (- smith fletcher)) 1)
         (not (= cooper 1))
         (not (= baker 5))
         (not (= fletcher 1))
         (not (= fletcher 5))
         (distinct? (list baker cooper smith fletcher miller))))

       (define (permute-one start max proc list-of-lists)
        (cond
         ((= start max) '())
         (else
          (append
           (map (lambda (alist) (proc start alist))
                list-of-lists)
           (permute-one (+ start 1) max proc list-of-lists)))))

       (define (count-up start max)
        (if (= start max) '()
            (cons (list start) (count-up (+ start 1) max))))
       (define (permutations start max in)
        (if (= in 1)
            (count-up start max)
            (permute-one
             start max
             (lambda (i alist)
              (cons i alist))
              (permutations start max (- in 1)))))
              
       (define (initial-floor-listing) 
         (permutations 1 6 5))

       (define (generate-next-floor-listing listof-floors)
         (cdr listof-floors))
       (define (bakers-floor floor-list) (list-ref (car floor-list) 0))
       (define (smiths-floor floor-list) (list-ref  (car floor-list) 1))
       (define (millers-floor floor-list) (list-ref  (car floor-list) 2))
       (define (fletchers-floor floor-list) (list-ref  (car floor-list) 3))
       (define (coopers-floor floor-list) (list-ref  (car floor-list) 4))

       (define (multiple-dwelling listof-floors)
        (cond 
           ((null? listof-floors) (error "No solution")) 
           ((satisfies? 
             (bakers-floor listof-floors)
             (coopers-floor listof-floors)
             (smiths-floor listof-floors)
             (fletchers-floor listof-floors)
             (millers-floor listof-floors))
            (list 
             (list 'miller (millers-floor listof-floors))
             (list 'smith (smiths-floor listof-floors))
             (list 'fletcher (fletchers-floor listof-floors))
             (list 'baker (bakers-floor listof-floors))
             (list 'cooper (coopers-floor listof-floors))))
            (else (multiple-dwelling (generate-next-floor-listing listof-floors)))))
       #+END_SRC

     - Exercise 4.42: Solve the following "Liars" puzzle (from
       Phillips 1934):

       Five schoolgirls sat for examination. Their parents -- so they
       thought -- showed an undue degree of interest in the
       result. They therefore agreed that, in writing home about the
       examination, each girl should make one true statement and one
       untrue one. The following are the relevant passages from their
       letters:

       - Betty: "Kitty was second in the examination. I was only third."

       - Ethel: "You'll be glad to hear that I was on top. Joan was 2nd."

       - Joan: "I was third, and poor old Ethel was bottom."

       - Kitty: "I came out second. Mary was only fourth."

       - Mary: "I was fourth. Top place was taken by Betty."

	 What in fact was the order in which the five girls were
         placed?


	 To write a program, we can use amb or just a normal scheme
         program. For an amb program, we can generate all possible
         permutations of statements. For example,

	 For betty: Kitty was second, Betty was third.

	 For Ethel: Ethel was first, Joan was second.

	 Then we examine for contradictions -- No statements must say
         that someone was in two places at once, or that one place was
         occupied by two people. We can represent statements:

	 #+BEGIN_SRC scheme
         (define (make-statement person place)
          (list person place))
         (define (statement-person a-statement) (car a-statement))
         (define (statement-place a-statement) (cadr a-statement))
	 #+END_SRC

	 OUr initial statements may look like this:
	 
	 #+BEGIN_SRC scheme
         (define betty-statements (list
                                    (make-statement 'betty 3)
                                    (make-statement 'kitty 2)))
         (define ethel-statements (list
                                   (make-statement 'ethel 1)
                                   (make-statement 'joan 2)))
         (define joan-statements (list
                                  (make-statement 'joan 3)
                                  (make-statement 'ethel 5)))
         (define kitty-statements (list
                                   (make-statement 'kitty 2)
                                   (make-statement 'mary 4)))
         (define mary-statements (list
                                  (make-statement 'betty 1)
                                  (make-statement 'mary 4)))  
	 #+END_SRC
	 
	 #+BEGIN_SRC scheme
           (define (make-statement-with-truth statement truthvalue)
             (cons statement truthvalue))
           (define (statement-with-truth-statement statement-with-truth)
             (car statement-with-truth))
           (define (statement-with-truth-truth statement-with-truth)
             (cdr statement-with-truth))
           (define (statement-with-truth-person statement-with-truth)
             (statement-person (statement-with-truth-statement statement-with-truth)))
           (define (statement-with-truth-place statement-with-truth)
             (statement-place (statement-with-truth-statement statement-with-truth)))
           (define (one-amb-statement a-statement)
             (amb (list (make-statement-with-truth (car a-statement) true)
                        (make-statement-with-truth (cadr a-statement) false))
                  (list (make-statement-with-truth (car a-statement) false)
                        (make-statement-with-truth (cadr a-statement) true))))
           (define (generate-statement-set statements)
             (if (null? statements)
                 '()
                 (append (one-amb-statement (car statements)) 
                       (generate-statement-set (cdr statements)))))

           (define (get-true-statements statements)
             (if (null? statements)
                 '()
                 (if (statement-with-truth-truth (car statements))
                     (cons (car statements) (get-true-statements (cdr statements)))
                     (get-true-statements (cdr statements)))))

           (define (require-no-same-place statements)
             (define (is-other-in-same-place? statement statements)
               (cond
                ((null? statements) false)
                ((and (= (statement-with-truth-place statement)
                         (statement-with-truth-place (car statements)))
                      (not (eq? (statement-with-truth-person statement)
                                (statement-with-truth-person (car statements)))))
                 true)
                (else (is-other-in-same-place? statement (cdr statements)))))
             (let ((true-statements (get-true-statements statements)))
               (define (iter-statements current-statement-list)
                 (if (null? current-statement-list) true
                     (begin
                       (require (not (is-other-in-same-place? (car current-statement-list)
                                                              (cdr current-statement-list))))
                       (iter-statements (cdr current-statement-list)))))
               (iter-statements true-statements)))

           (define (no-true-and-false statements)
             (define (no-duplicates a-statement statement-list)
               (if (null? statement-list)
                   true
                   (let ((statement-from-list (car statement-list)))
                     (and (or
                           (not (eq? (statement-with-truth-person statement-from-list)
                                     (statement-with-truth-person a-statement)))
                           (and (=
                                 (statement-with-truth-place a-statement)
                                 (statement-with-truth-place statement-from-list))
                                (eq?
                                 (statement-with-truth-truth a-statement)
                                 (statement-with-truth-truth statement-from-list)))
                           (and (false? (statement-with-truth-truth a-statement))
                                (false? (statement-with-truth-truth statement-from-list)))
                           (and (not (= (statement-with-truth-place a-statement)
                                        (statement-with-truth-place statement-from-list)))
                                (not (eq?
                                      (statement-with-truth-truth a-statement)
                                      (statement-with-truth-truth statement-from-list)))))
                          (no-duplicates a-statement (cdr statement-list))))))
             (if (null? statements)
                 true
                 (begin
                    (and (no-duplicates (car statements) (cdr statements))
                         (no-true-and-false (cdr statements))))))

           (define (require-no-contradictions statements)
             (require (no-true-and-false statements))
             (require-no-same-place statements)
             statements)

	 #+END_SRC

	 #+BEGIN_SRC scheme
         (define all-statements (list betty-statements
                                      ethel-statements
                                      joan-statements
                                      kitty-statements
                                      mary-statements))
         (define (get-placings)
          (let ((statement-set (generate-statement-set all-statements)))
           (require-no-contradictions statement-set)))
	 #+END_SRC

	 Our program tells us that the order is
	 kitty joan betty mary ethel

       - Exercise 4.43; use the amb evaluator to solve the following
         puzzle:
	 
	 Mary Ann Moore's father has a yacht and so has each of his
         four friends: Colonel Downing, Mr. Hall, Sir Barnacle Hood,
         and Dr. Parker. Each of the five also has one daughter and
         each has named his yacht after a daughter of one of the
         others. Sir Barnacle's yacht is the Gabrielle, Mr. Moore owns
         the Lorna; Mr. Hall the Rosalind. The Melissa, owned by
         Colonel Downing, is named after Sir Barnacle's
         daughter. Gabrielle's father owns the yacht that is named
         after Dr. Parker's daughter. Who's Lorna's father?

	 #+BEGIN_SRC scheme
         (define (make-relation father daughter boat-name)
          (list father daughter boat-name))
         (define (relation-father r)
          (car relation))
         (define (relation-daughter r)
          (cadr relation))
         (define (relation-boat-name r)
          (caddr r))
         
         (define (require-sane-single relation)
          (require (not (eq? (relation-daughter relation)
                             (relation-boat-name relation)))))
         (define (require-no-multi-fathers relation relations)
          (let ((father (relation-father relation)))
           (require (null? (filter 
                            (lambda (r) (eq? (relation-father r) father)))))))
         (define (require-no-multi-daughters relation relations)
          (let ((daughter relation-daughter relation))
           (require (null? (filter 
                            (lambda (r) (eq? (relation-daughter r) daughter)))))))
         (define (require-sane-relations relation-list)
           (cond
            ((null? relation-list) true)
            (else
             (require-sane-single (car relation-list))
             (require-no-multi-fathers (car relation-list) (cdr relation-list))
             (require-no-multi-daughters (car relation-list) (cdr relation-list)))))

         (let ((base-relations
                (list (make-relation 'mr-moore 'mary-ann 'lorna)
                      (make-relation 'cd 
                                     'melissa 
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'mr-hall
                                     'rosalind
                                     (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'dr-parker
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa)
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'sir-barnacle
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa)
                                      'melissa))))
            (require-sane-relations base-relations)
            base-relations)
	 #+END_SRC

       - Exercise 4.44: Exercise 2.42 described the "eight-queens
         puzzle" of placing queens on a chessboard so that no two
         attack each other. Write a nondeterministic program to solve
         this puzzle.

	 #+BEGIN_SRC scheme
           (define (require x) (if (not x) (amb)))
           (define (make-queen x y)
             (list x y))
           (define (queen-row q) (car q))
           (define (queen-col q) (cadr q))
           (define (queen-endangers? q1 q2)
             (or
              (= (abs (- (queen-row q1)
                         (queen-row q2)))
                 (abs (- (queen-col q1)
                         (queen-col q2))))
              (= (queen-row q1) (queen-row q2))
              (= (queen-col q1) (queen-col q2))))

           (define (possible-queen-rows rowsize)
             (if (= rowsize 1) (amb 1)
                 (amb rowsize (possible-queen-rows (- rowsize 1)))))

           (define (possible-queen-cols colsize)
             (if (= colsize 1) (amb 1)
                 (amb colsize (possible-queen-cols (- colsize 1)))))

           (define NQUEENS 8)

           (define (require-no-identical-positions listof-queens)
             (define (require-positions-different
                      a-queen
                      other-queens)
               (if (null? other-queens) true
                   (let ((other-queen (car other-queens)))
                     (require
                      (not (= (queen-row other-queen)
                              (queen-row a-queen))))
                     (require
                      (not (= (queen-col other-queen)
                              (queen-col a-queen))))
                     (require
                      (not (queen-endangers? a-queen other-queen)))
                     (require-positions-different
                      a-queen
                      (cdr other-queens)))))
             (if
              (null? listof-queens) true
              (begin
                (require-positions-different
                 (car listof-queens)
                 (cdr listof-queens))
                (require-no-identical-positions
                 (cdr listof-queens)))))

           (define (gen-queens nqueens)
             (if (= nqueens 0) '()
                 (cons (make-queen (possible-queen-rows nqueens)
                                   (possible-queen-cols nqueens))
                       (gen-queens (- nqueens 1)))))

           (let ((listof-queens (gen-queens NQUEENS)))
             (require-no-identical-positions listof-queens)
             listof-queens)
	 #+END_SRC
**** Parsing natural language
     Programs designed to accept natural language as input usually
     start by attempting to _parse_ the input, that is, to match the
     input against some grammatical structure. For example, we might
     try to recognize simple sentences consisting of an article
     followed by a noun followed by a verb, such as "The cat eats." To
     accomplish such an analysis, we must be able to identify the
     parts of speech of individual words. We could start with some
     lists that classify various words:

     #+BEGIN_SRC scheme
     (define nouns '(noun student professor cat class))
     (define verbs '(verb studies lectures eats sleeps))
     (define articles '(article the a))
     #+END_SRC

     We also need a _grammar_, that is, a set of rules describing how
     grammatical elements are composed from simpler elements. A very
     simple grammar might stipulate that a sentence always consists of
     two pieces -- a noun phrase followed by a verb -- and that a noun
     phrase consists of an article followed by a noun. WIth this
     grammar, the sentence "The cat eats" is parsed as follows:

     #+BEGIN_SRC scheme
     (sentence (noun-phrase (article the) (noun cat)) (verb eats))
     #+END_SRC

     We can generate such a parse with a simple program that has
     separate procedures for each of the grammatical rules. To parse a
     sentence, we identify its two constituent pieces and return a
     list of these two elements, tagged with the symbol sentence:

     #+BEGIN_SRC scheme
     (define (parse-sentence)
      (list 'sentence
            (parse-noun-phrase)
            (parse-word verbs)))
     #+END_SRC

     A noun phrase, similarly, is parsed by finding an article
     followed by a noun:

     #+BEGIN_SRC scheme
     (define (parse-noun-phrase)
      (list 'noun-phrase
            (parse-word articles)
            (parse-word nouns)))
     #+END_SRC

     At the lowest level, parsing boils down to repeatedly checking
     that the next unparsed word is a member of the list of words for
     the required part of speech. To implement this, we maintain a
     global variable \*unparsed\*, which is the input that has not yet
     been parsed. Each time we check a word, we require that
     \*unparsed\* must be non-empty and that it should begin with a
     word from the designated list. If so, we remove that word from
     \*unparsed\* and return the word together with its part of speech
     (which is found at the head of the list):

     #+BEGIN_SRC scheme
     (define (parse-word word-list)
      (require (not (null? *unparsed*)))
      (require (memq (car *unparsed*) (cdr word-list)))
      (let ((found-word (car *unparsed*)))
       (set! *unparsed* (cdr *unparsed*))
       (list (car word-list) found-word)))
     #+END_SRC

     To start the parsing, all we need to do is set \*unparsed\* to be
     the entire input, try to parse a sentence, and check that nothing
     is left over:

     #+BEGIN_SRC scheme
     (define *unparsed* '())
     (define (parse input)
      (set! *unparsed* input)
      (let ((sent (parse-sentence)))
       (require (null? *unparsed*)) sent))
     #+END_SRC

     We can now try the parser and verify that it works for our simple
     test sentence:

     #+BEGIN_SRC scheme
     ;;; Amb-Eval input:
     (parse '(the cat eats))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (sentence (noun-phrase (article the) (noun cat)) (verb eats))
     #+END_SRC

     The amb evaluator is useful here because it is convenient to
     express the parsing constraints with the aid of
     require. Automatic search and backtracking really pay off,
     however, when we consider more complex grammars where there are
     choices for how the units can be decomposed.

     Let's add to our grammar a list of prepositions:

     #+BEGIN_SRC scheme
     (define prepositions '(prep for to in by with))
     #+END_SRC

     and define a prepositional phrase (e.g., "for the cat") to be a
     preposition followed by a noun phrase:

     #+BEGIN_SRC scheme
     (define (parse-prepositional-phrase)
      (list 'prep-phrase
            (parse-word prepositions)
            (parse-noun-phrase)))
     #+END_SRC

     Now we can define a sentence to be a noun phrase followed by a
     verb phrase, where a verb phrase can be either a verb or a verb
     phrase extended by a prepositional phrase:

     #+BEGIN_SRC scheme
     (define (parse-sentence)
      (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
     (define (parse-verb-phrase)
      (define (maybe-extend verb-phrase)
       (amb verb-phrase
            (maybe-extend
             (list 'verb-phrase 
                   verb-phrase
                   (parse-prepositional-phrase)))))
      (maybe-extend (parse-word verbs)))
     #+END_SRC

     While we're at it, we can also elaborate the definition of noun
     phrases to permit such things as "a cat in the class". What we
     used to call a noun phrase, we'll now call a simple noun phrase,
     and a noun phrase will now be either a simple noun phrase or a
     noun phrase extended by a prepositional phrase:

     #+BEGIN_SRC scheme
     (define (parse-simple-noun-phrase)
      (list 'simple-noun-phrase
            (parse-word articles)
            (parse-word nouns)))
     (define (parse-noun-phrase)
      (define (maybe-extend noun-phrase)
       (amb noun-phrase
            (maybe-extend
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
      (maybe-extend (parse-simple-noun-phrase)))
     #+END_SRC

     Our new grammar lets us parse more complex sentences. For example

     #+BEGIN_SRC scheme
     (parse '(the student with the cat sleeps in the class))
     #+END_SRC

     produces

     #+BEGIN_SRC scheme
     (sentence
      (noun-phrase
       (simple-noun-phrase (article the) (noun student))
       (prep-phrase
        (prep with)
        (simple-noun-phrase (article the) (noun cat))))
      (verb-phrase
       (verb sleeps)
       (prep-phrase
        (prep in)
        (simple-noun-phrase (article the) (noun class)))))
     #+END_SRC

     Observe that a given input may have more than one legal parse. In
     the sentence "The professor lectures to the student with the
     cat", it may be that the professor is lecturing with the cat, or
     the student has the cat

     

	 
	 

     

       
