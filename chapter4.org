* Chapter 4
** Metalinguistic Abstraction
   In our study of program design, we have seen that expert
   programmers control the complexity of their designs with the same
   general techniques used by designers of all complex systems. They
   combine primitive elements to form compound objects, they abstract
   compound objects to form higher-level building blocks, and they
   preserve modularity by adopting appropriate large-scale views of
   system structure. In illustrating these techniques, we have used
   Lisp as a language for describing processes and for constructing
   computational data objects and processes to model complex phenomena
   in the real world. However, as we confront increasingly complex
   problems, we will find that Lisp, or indeed any fixed programming
   language, is not sufficient for our needs. We must constantly turn
   to new languages in order to expresss our ideas more
   effectively. Establishing new languages is a powerful strategy for
   controlling complexity in engineering design; we can often enhance
   our ability to deal with a complex problem by adopting a new
   language that enables us to describe (and hence to think about) the
   problem in a different way, using primitives, means of combination,
   and means of abstraction that are particularly well suited to the
   problem at hand.

   Programming is endowed with a multitude of languages. There are
   physical languages, such as the machine languages for particular
   computers. These languages are concerned with the representation of
   data and control in terms of individual bits of storage and
   primitive machine instructions. The machine-language programmer is
   concerned with using the given hardware to erect systems and
   utilities for the efficient implementation of resource-limited
   computations. High-level languages, erected on a machine-language
   substrate, hide concerns about the representation of data as
   collections of bits and the representation of programs as sequences
   of primitive instructions. These languages have means of
   combination and abstraction, such as procedure definition, but are
   appropriate to the larger-scale organization of systems.

   _Metalinguistic abstraction_ -- establishing new languages -- plays
   an important role in all branches of engineering design. It is
   particularly important to computer programming, because in
   programming not only can we formulate new languages but we can also
   implement these languages by constructing evaluators. An
   _evaluator_ (or _interpreter_) for a programming language is a
   procedure that, when applied to an expression of the language,
   performs the actions required to evaluate that expression.

   It is no exaggeration to regard this as the most fundamental idea
   in programming:

   The evaluator, which determines the meaning of expressions in a
   programming language, is just another program.

   To appreciate this point is to change our images of ourselves as
   programmers. We come to see ourselves as designers of languages,
   rather than only users of languages designed by others.

   In fact, we can regard almost any program as the evaluator of some
   language. For instance, the polynomial manipulation system of
   Section 2.5.3 embodies the rules of polynomial arithmetic and
   implements them in terms of operations on list-structured data. If
   we augment this system with procedures to read and print polynomial
   expressions, we have the core of a special-purpose language for
   dealing with problems in symbolic mathematics. The digital-logic
   simulator of Section 3.3.4 and the constraint propagator of Section
   3.3.5 are legitimate languages in their own right, each with its
   own primitives, means of combination, and means of
   abstraction. Seen from this perspective, the technology for coping
   with large-scale computer systems merges with the technology for
   building new computer languages, and computer science itself
   becomes no more (and no less) than the discipline of constructing
   appropriate descriptive languages.

   We now embark on a tour of the technology by which languages are
   established in terms of other languages. In this chapter we shall
   use Lisp as a base, implementing evaluators as Lisp
   procedures. Lisp is particularly well suited to this task, because
   of its ability to represent and manipulate symbolic expressions. We
   will take the first step in understanding how languages are
   implemented by building an evaluator for Lisp itself. The language
   implemented by our evaluator will be a subset of the Scheme dialect
   of Lisp that we use in this book. Although the evaluator described
   in this chapter is written for a particular dialect of Lisp, it
   contains the essential structure of an evaluator for any
   expression-oriented language designed for writing programs for a
   sequential machine. (In fact, most language processors contain,
   deep within them, a little "Lisp" evaluator.) The evaluator has
   been simplified for the purposes of illustration and discussion,
   and some features have been left out that would be important to
   include in a production-quality Lisp system. Nevertheless, this
   simple evaluator is adequate to execute most of the programs in
   this book.

   An important  advantage of making the evaluator accessible as a
   Lisp program is that we can implement alternative evaluation rules
   by describing these as modifications to the evaluator program. One
   place where we can use this power to good effect is to gain extra
   control over the ways in which computational models embody the
   notion of time, which was so central to the discussion in
   Chapter 3. There, we mitigated some of the complexities of state
   and assignment by using streams to decouple the representation of
   time in the world from time in the computer. Our stream programs,
   however, were sometimes cumbersome, because they were constrained
   by the applicative-order evaluation of Scheme. In Section 4.2,
   we'll change the underlying language to provide for a more elegant
   approach, by modifying the evaluator to provide for _normal-order
   evaluation_. 

   Section 4.3 implements a more ambitious linguistic change, whereby
   expressions have many values, rather than just a single value. In
   this language of _nondeterministic computing_, it is natural to
   express processes that generate all possible values for expressions
   and then search for those values that satisfy certain
   constraints. In terms of models of computation and time, this is
   like having time branch into a set of "possible futures" and then
   searching for appropriate time lines. With our nondeterministic
   evaluator, keeping track of multiple values and performing searches
   are handled automatically by the underlying mechanism of the
   language.

   In Section 4.4 we implement a _logic-programming_ language in which
   knowledge is expressed in terms of relations, rather than in terms
   of computations with inputs and outputs. Even though this makes the
   language drastically different from Lisp, or indeed from any
   conventional language, we will see that the logic-programming
   evaluator shares the essential structure of a Lisp evaluator.

** 4.1 The Metacircular Evaluator

   Our evaluator for Lisp will be implemented as a Lisp program. It
   may seem circular to think about evaluating Lisp programs using an
   evaluator that is itself implemented in Lisp. However, evaluation
   is a process, so it is appropriate to describe the evaluation
   process using Lisp, which, after all, is our tool for describing
   processes. An evaluator that is written in the same language that
   it evaluates is said to be _metacircular_. 

   The metacircular evaluator is essentially a Scheme formulation of
   the environment model of evaluation described in Section
   3.2. Recall that the model has two basic parts:

   1. To evaluate a combination (a compound expression other than a
      special form), evaluate the subexpressions and then apply the
      value of the operator subexpression to the values of the operand
      subexpressions.
   2. To apply a compound procedure to a set of arguments, evaluate
      the body of the procedure in a new environment. To construct
      this environment, extend the environment part of the procedure
      object by a frame in which the formal parameters of the
      procedure are bound to the arguments to which the procedure is
      applied.

      
   These two rules describe the essence of the evaluation process, a
   basic cycle in which expressions to be evaluated in environments
   are reduced to procedures to be applied to arguments, which in turn
   are reduced to new expressions to be evaluated in new environments,
   and so on, until we get down to symbols, whose values are looked up
   in the environment, and to primitive procedures, which are applied
   directly (see Figure 4.1). This evaluation cycle will be embodied
   by the interplay between the two critical procedures in the
   evaluator, eval and apply, which are described in Section 4.1.1
   (see Figure 4.1).
   
   The implementation of the evaluator will depend upon procedures
   that define the _syntax_ of the expressions to be evaluated. We
   will use data abstraction to make the evaluator independent of the
   representation of the language. For example, rather than committing
   to a choice that an assignment is to be represented by a list
   beginning with the symbol set! we use an abstract predicate
   assignment? to test for an assignment, and we use abstract
   selectors assignment-variable and assignment-value to access the
   parts of an assignment. Implementation of expressions will be
   described in detail in Section 4.1.2. There are also operations,
   described in Section 4.1.3, that specify the representation of
   procedures and environments. For example, make-procedure constructs
   compound procedures, lookup-variable-value accesses the values of
   variables, and apply-primitive-procedure applies a primitive
   procedure to a given list of arguments. 

*** 4.1.1 The Core of the Evaluator

    The evaluation process can be described as the interplay between
    two procedures: eval and apply.

**** Eval
     Eval takes as arguments an expression and an environment. It
     classifies the expression and directs its evaluation. eval is
     structured as a case analysis of the syntactic type of the
     expression to be evaluated. In order to keep the procedure
     general, we express the determination of the type of an
     expression abstractly, making no commitment to any particular
     representation for the various types of expressions. Each type of
     expression has a predicate that tests for it and an abstract
     means for selecting its parts. This _abstract syntax_ makes it
     easy to see how we can change the syntax of the language by using
     the same evaluator, but with a different collection of syntax
     procedures.

***** Primitive expressions
      - For self-evaluating expressions, such as numbers, eval returns
        the expression itself.
      - eval must look up variables in the environment to find their
        values.

***** Special forms
      - For quoted expressions, eval returns the expression that was
        quoted.
      - An assignment to (or a definition of) a variable must
        recursively call eval to compute the new value to be
        associated with the variable. The environment must be modified
        to change (or create) the binding of the variable.
      - An if expression requires special processing of its parts, so
        as to evaluate the consequent if the predicate is true, and
        otherwise to evaluate the alternative.
      - A lambda expression must be transformed into an applicable
        procedure by packaging together the parameters and body
        specified by the lambda expression with the environment of
        evaluation.
      - A begin expression requires evaluating its sequence of
        expressions in the order in which they appear.
      - A case analysis (cond) is transformed into a nest of if
        expressions and then evaluated.

***** Combinations
      - For a procedure application, eval must recursively evaluate
        the operator part and the operands of the combination. The
        resulting procedure and arguments are passed to apply, which
        handles the actual procedure application.

	

     Here is the definition of eval:

     #+BEGIN_SRC scheme
       (define (eval exp env)
         (cond ((self-evaluating? exp) exp)
               ((variable? exp) (lookup-variable-value exp env))
               ((quoted? exp) (text-of-quotation exp))
               ((assignment? exp) (eval-assignment exp env))
               ((definition? exp) (eval-definition exp env))
               ((if? exp) (eval-if exp env))
               ((lambda? exp) (make-procedure (lambda-parameters exp)
                                              (lambda-body exp)
                                              env))
               ((begin? exp)
                (eval-sequence (begin-actions exp) env))
               ((cond? exp) (eval (cond->if exp) env))
               ((application? exp)
                (apply (eval (operator exp) env)
                       (list-of-values (operands exp) env)))
               (else 
                (error "Unknown expression type: EVAL " exp))))
     #+END_SRC

     For clarity, eval has been implemented as a case analysis using
     cond. The disadvantage of this is that our procedure handles only
     a few distinguishable types of expressions, and no new ones can
     be defined without editing the definition of eval. In most Lisp
     implementations, dispatching on the type of an expression is done
     in a data-directed style. This allows a user to add new types of
     expressions that eval can distinguish, without modifying the
     definition of eval itself.

**** Apply     

     apply takes two arguments, a procedure and a list of arguments to
     which the procedure should be applied. apply classifies
     procedures into two kinds: It calls apply-primitive-procedure to
     apply primitives; it applies compound procedures by sequentially
     evaluating the expressions that make up the body of the
     procedure. The environment for the evaluation of the body of a
     compound procedure is constructed by extending the base
     environment carried by the procedure to include a frame that
     binds the parameters of the procedure to the arguments to which
     the procedure is to be applied. Here is the definition of apply:

     #+BEGIN_SRC scheme
       (define (apply procedure arguments)
         (cond ((primitive-procedure? procedure)
                (apply-primitive-procedure procedure arguments))
               ((compound-procedure? procedure)
                (eval-sequence
                 (procedure-body procedure)
                 (extend-environment
                  (procedure-parameters procedure)
                  arguments
                  (procedure-environment procedure))))
               (else
                (error "Unknown procedure type: APPLY" procedure))))
     #+END_SRC

***** Procedure arguments
      When eval processes a procedure application, it uses
      list-of-values to produce a list of arguments to which the
      procedure is to be applied. list-of-values takes as an argument
      the operands of the combination. It evaluates each operand and
      returns a list of the corresponding values:

      #+BEGIN_SRC scheme
      (define (list-of-values exps env)
       (if (no-operands? exps)
           '()
           (cons (eval (first-operand exps) env)
                 (list-of-values (rest-operands exps) env))))
      #+END_SRC
***** Conditionals

      eval-if evaluates the predicate part of an if expression in the
      given environment. If the result is true, eval-if evaluates the
      consequent, otherwise it evaluates the alternative:

      #+BEGIN_SRC scheme
      (define (eval-if exp env)
       (if (true? (eval (if-predicate exp) env))
           (eval (if-consequent exp) env)
           (eval (if-alternative exp) env)))
      #+END_SRC

      The use of true? in eval-if highlights the issue of the
      connection between an implemented language and an implementation
      language. The if-predicate is evaluated in the language being
      implemented and thus yields a value in that language. The
      interpreter predicate true? translates that value into a value
      that can be tested by the if in the implementation language: The
      metacircular representation of truth might not be the same as
      that of the underlying Scheme.

***** Sequences

      eval-sequence is used by apply to evaluate the sequence of
      expressions in a procedure body and by eval to evaluate the
      sequence of expressions in a begin expression. It takes as
      arguments a sequence of expressions and an environment, and
      evaluates the expressions in the order in which they occur. The
      value returned is the value of the final expression.

      #+BEGIN_SRC scheme
        (define (eval-sequence exps env)
          (cond ((last-exp? exps)
                 (eval (first-exp exps) env))
                (else
                 (eval (first-exp exps) env)
                 (eval-sequence (rest-exps) env))))
      #+END_SRC

***** Assignments and definitions
      The following procedure handles assignments to variables. It
      calls eval to find the value to be assigned and transmits the
      variable and the resulting value to set-variable-value! to bee
      installed in the designated environment. 
      
      #+BEGIN_SRC scheme
      (define (eval-assignment exp env)
       (set-variable-value! (assignment-variable exp)
                            (eval (assignment-value exp) env)
                            env)
       'ok)
      #+END_SRC

      Definitions of variables are handled in a similar manner.

      #+BEGIN_SRC scheme
      (define (eval-definition exp env)
       (define-variable! (definition-variable exp)
                         (eval (definition-value exp) env)
                         env)
       'ok)
      #+END_SRC

      We have chosen here to return the symbol ok as the value of an
      assignment or definition.

      - Exercise 4.1: Notice that we cannot tell whether the
        metacircular evaluator evaluates operands from left to right
        or from right to left. Its evaluation order is inherited from
        the underlying Lisp: If the arguments to cons in
        list-of-values are evaluated from left to right, then
        list-of-values will evaluate operands from right to left.

	Write a version of list-of-values that evaluates operands from
        left to right regardless of the order of evaluation in the
        underlying Lisp. Also write a version of list-of-values that
        evaluates operands from right to left.

	#+BEGIN_SRC scheme
          ;; left to right
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((arg-value (eval (first-operand exps) env)))
                  (let ((rest-value (list-of-values (rest-operands exps) env)))
                    (cons arg-value rest-value)))))
          ;; right to left
          (define (list-of-values exps env)
            (if (no-operands? exps)
                '()
                (let ((rest-value (list-of-values (rest-operands exps) env)))
                  (let ((arg-value (eval (first-operand exps) env)))
                    (cons arg-value
                          rest-value)))))
	#+END_SRC

*** 4.1.2 Representing Expressions
    The evaluator is reminiscent of the symbolic differentiation
    program discussed in Section 2.3.2. Both programs operate on
    symbolic expressions. In both programs, the result of operating on
    a compound expression is determined by operating recursively on
    the pieces of the expression and combining the results in a way
    that depends on the type of the expression. In both programs we
    used data abstraction to decouple the general rules of operation
    from the details of how expressions are represented. In the
    differentiation program this meant that the same differentiation
    procedure could deal with algebraic expressions in prefix form, in
    infix form, or in some other form. For the evaluator, this means
    that the syntax of the language being evaluated is determined
    solely by the procedures that classify and extract pieces of
    expressions. Here is the specification of the syntax of our
    language:

    - The only self-evaluating items are numbers and strings:

      #+BEGIN_SRC scheme
      (define (self-evaluating? exp)
       (cond ((number? exp) true)
             ((string? exp) true)
             (else false)))
      #+END_SRC

    - Variables are represented by symbols:

      #+BEGIN_SRC scheme
      (define (variable? exp) (symbol? exp))
      #+END_SRC

    - Quotations have the form (quote <text-of-quotation>):
      
      #+BEGIN_SRC scheme
      (define (quoted? exp) (tagged-list? exp 'quote))
      (define (text-of-quotation exp) (cadr exp))
      #+END_SRC

      quoted? is defined in terms of the procedure tagged-list?, which
      identifies lists beginning with a designated symbol:

      #+BEGIN_SRC scheme
      (define (tagged-list? exp tag)
       (if (pair? exp)
           (eq? (car exp) tag)
           false))
      #+END_SRC

    - Assignments have the form (set! <var> <value>):
      
      #+BEGIN_SRC scheme
        (define (assignment? exp) (tagged-list? exp 'set!))
        (define (assignment-variable exp) (cadr exp))
        (define (assignment-value exp) (caddr exp))
      #+END_SRC

    - Definitions have the form

      #+BEGIN_SRC scheme
      (define <var> <value>)
      #+END_SRC

      or the form

      #+BEGIN_SRC scheme
      (define (<var> <parameter1> ... <parametern>)
       <body>)
      #+END_SRC

      The latter form (standard procedure definition) is syntactic
      sugar for

      #+BEGIN_SRC scheme
      (define <var>
       (lambda (<parameter1> ... <parametern>)
        <body>))
      #+END_SRC

      The corresponding syntax procedures are the following:

      #+BEGIN_SRC scheme
      (define (definition? exp) (tagged-list? exp 'define))
      (define (definition-variable exp)
       (if (symbol? (cadr exp))
           (cadr exp)
           (caadr exp)))
      (define (definition-value exp)
       (if (symbol? (cadr exp))
           (caddr exp)
           (make-lambda (cdadr exp)
                        (cddr exp))))
      #+END_SRC

    - lambda expressions are lists that begin with the symbol lambda:
      
      #+BEGIN_SRC scheme
      (define (lambda? exp) (tagged-list? exp 'lambda))
      (define (lambda-parameters exp) (cadr exp))
      (define (lambda-body exp) (cddr exp))
      #+END_SRC

      We also provide a constructor for lambda expressions, which is
      used by definition-value, above:

      #+BEGIN_SRC scheme
      (define (make-lambda parameters body)
       (cons 'lambda (cons parameters body)))
      #+END_SRC

    - Conditionals begin with if and have a predicate, a consequent,
      and an (optional) alternative. If the expression has no
      alternative part, we provide false as an alternative.

      #+BEGIN_SRC scheme
      (define (if? exp) (tagged-list? exp 'if))
      (define (if-predicate exp) (cadr exp))
      (define (if-consequent exp) (caddr exp))
      (define (if-alternative exp)
       (if (not (null? (cdddr expr)))
           (cadddr exp)
           'false))
      #+END_SRC

      We also provide a constructor for if expressions, to be used by
      cond->if to transform cond expressions into if expressions:

      #+BEGIN_SRC scheme
      (define (make-if predicate consequent alternative)
       (list 'if predicate consequent alternative))
      #+END_SRC

    - begin packages a sequence of expressions into a single
      expression. We include syntax operations on begin expressions to
      extract the actual sequence from the begin expression, as well
      as selectors that return the first expression and rest of the
      expressions in the sequence.

      #+BEGIN_SRC scheme
      (define (begin? exp) (tagged-list? exp 'begin))
      (define (begin-actions exp) (cdr exp))
      (define (last-exp? seq) (null? (cdr seq)))
      (define (first-exp seq) (car seq))
      (define (rest-exps seq) (cdr seq))
      #+END_SRC

      We also include a constructor sequence->exp (for use by
      cond->if) that transforms a sequence into a single expression,
      using begin if necessary:

      #+BEGIN_SRC scheme
      (define (sequence->exp seq)
       (cond ((null? seq) seq)
             ((last-exp? seq) (first-exp seq))
             (else (make-begin seq))))
      (define (make-begin seq) (cons 'begin seq))
      #+END_SRC

    - A procedure application is any compound expression that is not
      one of the above expression types. The car of the expression is
      the operator, and the cdr is a list of operands:

      #+BEGIN_SRC scheme
      (define (application? exp) (pair? exp))
      (define (operator exp) (car exp))
      (define (operands exp) (cdr exp))
      (define (no-operands? ops) (null? ops))
      (define (first-operand ops) (car ops))
      (define (rest-operands ops) (cdr ops))
      #+END_SRC
**** Derived expressions
     Some special forms in our language can be defined in terms of
     expressions involving other special forms, rather than being
     implemented directly. One example is cond, which can be
     implemented as a nest of if expressions. For example, we can
     reduce the problem of evaluating the expression

     #+BEGIN_SRC scheme
     (cond ((> x 0) x)
           ((= x 0) (display 'zero) 0)
           (else (- x)))
     #+END_SRC

     to the problem of evaluating the following expression involving
     if and begin expressions:

     #+BEGIN_SRC scheme
     (if (> x 0)
         x
         (if (= x 0)
             (begin (display 'zero) 0)
             (0 x)))
     #+END_SRC

     Implementing the evaluation of cond in this way simplifies the
     evaluator because it reduces the number of special forms for
     which the evaluation process must be explicitly specified.

     We include syntax procedures that extract the parts of a cond
     expression, and a procedure cond->if that transforms cond
     expressions into if expressions. A case analysis begins with cond
     and has a list of predicate-action clauses. A clause is an else
     clause if its predicate is the symbol else.

     #+BEGIN_SRC scheme
     (define (cond? exp) (tagged-list? exp 'cond))
     (define (cond-clauses exp) (cdr exp))
     (define (cond-else-clause? clause)
      (eq? (cond-predicate clause) 'else))
     (define (cond-predicate clause) (car clause))
     (define (cond-actions clause) (cdr clause))
     (define (cond->if exp) (expand-clauses (cond-clauses exp)))
     (define (expand-clauses clauses)
      (if (null? clauses)
          'false
          (let ((first (car clauses))
                (rest (cdr clauses)))
           (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (else "ELSE clause isn't last: COND->IF"
                      clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
     #+END_SRC

     Expressions (such as cond) that we choose to implement as
     syntactic transformations are called _derived expressions_. let
     expressions are also derived expressions (see Exercise 4.6).

     - Exercise 4.2: Louis Reasoner plans to reorder the cond clauses
       in eval so that the clause for procedure applications appears
       before the clause for assignments. He argues that this will
       make the interpreter more efficient: Since programs usually
       contain more applications than assignments, definitions, and so
       on, his modified eval will usually check fewer clauses than the
       original eval before identifying the type of expression.

       a. What is wrong with Louis' plan? (Hint: What will Louis'
       evaluator do with the expression (define x 3)?)

       The problem is his evaluator will assume expressions that
       should have special meanings, like cond clauses, if clauses,
       definitions, lambdas, &c, are all applications of procedures,
       and you won't be able to use the interpreter at all.

       b. Louis is upset that his plan didn't work. He is willing to
       go to any lengths to make his evaluator recognize procedure
       applications before it checks for most other kinds of
       expressions. Help him by changing the syntax of the evaluated
       language so that the procedure applications start with
       call. For example, instead of (factorial 3) we will now have to
       write (call factorial 3) and instead of (+ 1 2) we will have to
       write (call + 1 2). 

       #+BEGIN_SRC scheme
       (define (application? expr) (tagged-list? expr 'call))
       (define (operator exp) (cadr exp))
       (define (operands exp) (cddr exp))
       (define (no-operands? ops) (null? ops))
       (define (first-operand ops) (car ops))
       (define (rest-operands ops) (cdr ops))
       #+END_SRC

     - Exercise 4.3: Rewrite eval so that the dispatch is done in a
       data-directed style. Compare this with the data-directed
       differentiation procedure of Exercise 2.73 (You may use the car
       of a compound expression as the type of the expression, as is
       appropriate for the syntax implemented in this section.)

       #+BEGIN_SRC scheme
       (put 'eval 'cond eval-cond)
       (put 'eval 'definition eval-definition)
       (put 'eval 'set! eval-assignment)
       (put 'eval 'begin eval-sequence)
       (put 'eval 'if eval-if)
       (put 'eval 'lambda (lambda (exp env)
                            (make-procedure (lambda-parameters exp)
                                            (lambda-body exp)
                                            env)))
       (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
       (define (expr-type expr) (car expr))
       (define (eval expr env)
         (cond
          ((self-evaluating? expr) expr)
          ((variable? exp) (lookup-variable-value exp env))
          (else
           (let ((proc (get 'eval (expr-type expr)))))
            (cond
             (proc (proc (expr-contents expr) env))
             ((application? expr)
              (apply (eval (operator exp) env)
                     (list-of-values (operands exp) env)))
             (else
              (error "Unknown expression type -- EVAL" expr)))))))
       #+END_SRC

     - Exercise 4.4: Recall the definitions of the special forms and
       and or from Chapter 1:

       - and: The expressions are evaluated from left to right. If any
         expression evaluates to false, false is returned; any
         remaining expressions are not evaluated. If all the
         expressions evaluate to true values, the value of the last
         expression is returned. If there are no expressions then true
         is returned.

       - or: The expressions are evaluated from left to right. If any
         expression evaluates to a true value, that value is returned;
         any remaining expressions are not evaluated. If all
         expressions evaluate to true or false, or if there are no
         expressions, then false is returned. 

       Install and and or as new special forms for the evaluator by
       defining appropriate syntax procedures and evaluation
       procedures eval-and and eval-or. Alternatively, show how to
       implement and and or as derived expressions. 

       #+BEGIN_SRC scheme
       (define (eval-and expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (false? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'and eval-and)

       (define (eval-or expr ops)
       (let ((first-op-value (eval (first-operand ops) env)))
       (if (true? first-op-value)
       first-op-value
       (eval-and-expr expr (rest-operands ops)))))
       (put 'or eval-or)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (and->if ops)
       (if (no-operands? ops)
       'true
       (make-if
       (first-operand ops)
       (and->if (rest-operands ops))
       'false)))
       (define (or->if ops)
       (if (no-operands? ops)
       'false
       (make-if
       (first-operand ops)
       'true
       (or->if (rest-operands ops)))))
       #+END_SRC

     - Exercise 4.5: Scheme allows an additional syntax for cond
       clauses, (<test> => <recipient>). If <test> evaluates to a true
       value, then <recipient> is evaluated. Its value must be a
       procedure of one argument; this procedure is then invoked on
       the value of the <test>, and the result is returned as the
       value of the cond expression. For example

       #+BEGIN_SRC scheme
       (cond ((assoc 'b '((a 1) (b 2))) => cadr)
             (else false))
       #+END_SRC

       returns 2. Modify the handling of cond so that it supports this
       extended syntax.

       You only have to change the cond-actions bit:

       #+BEGIN_SRC scheme
       (define (cond-actions expr)
        (if (eq? '=> (cadr expr))
            (list (caddr expr) (car expr))
            (cadr expr)))
       #+END_SRC

       However, this doesn't save the variable. In case of a
       side-effect, or just to save computation time, we should
       rewrite so that we can save the variable. 

       #+BEGIN_SRC scheme
       (lambda (expr) (if expr (action-value expr) 
                               (expand-clauses rest)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (expand-action cond-clause rest-clauses)
        (if (cond=>clause? cond-clause)
            (make-application
             (make-lambda '(expr-result)
              (make-expr-sequence
              (make-if
               'expr-result
               (make-application
                (car (cond-actions cond-clause))
                '(expr-result))
               (expand-clauses rest-clauses))))
              (list (cond-predicate cond-clause)))
             (make-if
              (cond-predicate cond-clause)
              (sequence->exp (cond-actions cond-clause))
              (expand-clauses rest-clauses))))

       (define (expand-clauses clauses)
        (if (null? clauses)
            'false
            (let ((first (car clauses))
                  (rest (cdr clauses)))
             (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "ELSE clause isn't last: COND->IF"
                         clauses))
              (expand-action
               first
               rest)))))
       #+END_SRC

     - Exercise 4.6: let expressions are derived expressions, because

       #+BEGIN_SRC scheme
       (let ((<var1> <exp1>) ... (<varn> <expn>))
        <body>)
       #+END_SRC

       is equivalent to

       #+BEGIN_SRC scheme
       ((lambda (<var1> ... <varn>)
         <body>)
        <exp1>
        ...
        <expn>)
       #+END_SRC

       Implement a syntactic transformation let->combination that
       reduces evaluating let expressions to evaluating combinations
       of the type shown above, and add the appropriate clause to eval
       to handle let expressions.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))
       (define (let-bindings expr) (cadr expr))
       (define (let-seq expr) (cddr expr))
       (define (let->combination expr)
        (make-application
         (make-lambda
          (map car (let-bindings expr))
          (let-seq expr))
         (map cadr (let-bindings expr))))
       (define (eval-let expr env)
        (eval (let->combination expr) env))
       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.7: let* is similar to let, except that the bindings
       of the let* variables are performed sequentially from left to
       right, and each binding is made in an environment in which all
       of the preceding bindings are visible. For example

       #+BEGIN_SRC scheme
       (let* ((x 3) (y (+ x 2)) (z (+ x y 5)))
        (* x z))
       #+END_SRC

       #+BEGIN_SRC scheme
         (define (empty-bindings? bindings) (null? bindings))
         (define (let*-bindings let*) (cadr let*))
         (define (let*-body let*) (caddr let*))
         (define first-binding car)
         (define rest-bindings cdr)

         (define (make-let bindings body)
          (list 'let bindings body))

         (define (cons-binding binding rest)
          (cons binding rest))
         (define (empty-bindings) '())

         (define (let*-bindings->nested-lets let-body bindings)
          (if (empty-bindings? bindings)
              let-body
              (make-let
               (cons-binding (first-binding bindings) (empty-bindings))
               (let*-bindings->nested-lets let-body (rest-bindings bindings)))))

         (define (let*->nested-lets expr)
          (let ((bindings (let*-bindings expr))
                (body (let*-body expr)))
           (let*-bindings->nested-lets body bindings)))

         (define (eval-let* expr env)
          (eval (let*->nested-lets expr) env))

         (put 'eval 'let* eval-let*)
       #+END_SRC

     - Exercise 4.8: "Named let" is a variant of let that has the form

       #+BEGIN_SRC scheme
       (let <var> <bindings> <body>)
       #+END_SRC

       The <bindings> and <body> are just as in ordinary let, except
       that <var> is bound within <body> to a procedure whose body is
       <body> and whose parameters are the variables in the
       <bindings>. Thus, one can repeatedly execute the <body> by
       invoking the procedure named <var>. For example, the iterative
       Fibonacci procedure (Section 1.2.2) can be rewritten using
       named let as follows:

       #+BEGIN_SRC scheme
       (define (fib n)
        (let fib-iter ((a 1)
                       (b 0)
                       (count n))
         (if (= count 0)
             b
             (fib-iter (+ a b) a (- count 1)))))
       #+END_SRC

       Modify let->combination of Exercise 4.6 to also support named
       let.

       #+BEGIN_SRC scheme
       (define (let? expr) (eq? (car expr) 'let))

       (define (named-let? expr) (symbol? (cadr expr)))

       (define (let-bindings expr) 
        (if (named-let? expr)
            (caddr expr)
            (cadr expr)))

       (define (let-seq expr) 
        (if (named-let? expr)
            (cdddr expr)
            (cddr expr)))

       (define (let-name expr) (cadr expr))

       (define (make-sequence values)
        (cons 'begin values))

       (define (make-definition name value)
        (list 'define name value))

       (define (make-function-definition name params value)
        (list 'define (cons name params) value))

       (define (named-let->combination expr)
        (make-sequence
         (list
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map cadr (let-bindings expr))))))

       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map cadr (let-bindings expr)))))

       (define (eval-let expr env)
        (eval (let->combination expr) env))

       (put 'eval 'let eval-let)
       #+END_SRC

     - Exercise 4.9: Many language support a variety of iteration
       constructs, such as do, for, while, and until. In Scheme,
       iterative processes can be expressed in terms of ordinary
       procedure calls, so special iteration constructs provide no
       essential gain in computational power. On the other hand, such
       constructs are often convenient. Design some iteration
       constructs, give examples of their use, and show how to
       implement them as derived expressions.

       #+BEGIN_SRC scheme
       (define (do-init-bindings expr) (cadr expr))
       (define (do-final-expr expr) (caddr expr))
       (define (do-predicate expr) (cadddr expr))
       (define (do-body expr) (cadr (cdddr expr)))
       (define (do->combination expr)
        (make-sequence
         (list
          (make-function-definition
           'dobody
           (map car (do-init-bindings expr))
           (make-if
            (do-predicate expr)
            (make-sequence (list (do-final-expr expr)))
            (make-application 
             'dobody
             (map caddr (do-init-bindings expr)))))
          (make-application 'dobody (map cadr (do-init-bindings expr))))))
       #+END_SRC

     - Exercise 4.10: By using data abstraction, we were able to write
       an eval procedure that is independent of the particular syntax
       of the language to be evaluated. To illustrate this, design and
       implement a new syntax for Scheme by modifying the procedures
       in this section, without changing eval or apply.

       You just change the predicates and accessors since we used data
       abstraction.

       #+BEGIN_SRC scheme
       (defprocedure add (x y) (+ x y))
       (defvar x 1)
       (if (>=  (add 1 2) 3) then true else false)
       (setvars (x <- 1 y <- 2 z <- 3)
         (+ x y z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (assignment? exp) (eq? (cadr exp) '<-))
       (define (assignment-variable exp) (car exp))
       (define (assignment-value exp) (caddr exp))
       (define (eval-assignment exp env)
        (set-variable-value! (assignment-variable exp)
                             (eval (assignment-value exp) env)
                             env)
        'ok)

       (define (if? exp) 
        (and
         (eq? (car exp) 'if)
         (eq? (caddr exp) 'then)
         (eq? (cadr (cdddr exp)) 'else)))
       (define (if-predicate exp) (cadr exp))
       (define (if-consequent exp) (cadddr exp))
       (define (if-alternative exp)
        (caddr (cdddr exp)))

       (define (definition? expr)
        (or (eq? (car expr) 'defprocedure)
            (eq? (car expr) 'defvar)))
       (define (definition-variable exp)
        (cadr exp))

       (define (definition-value exp)
        (if (eq? 'defprocedure (car expr))
             (make-lambda (caddr expr)
                          (cadddr expr))
             (caddr expr)))

       (define (let? exp) (eq? (car expr) 'setvars))
       (define (let-bindings expr)
         (if (named-let? expr)
             (caddr expr)
             (cadr expr)))
       (define (let-seq expr)
        (if (named-let? expr)
            (cadddr expr)
            (caddr expr)))
       (define (named-let->combination expr)
        (make-sequence
         (list 
          (make-function-definition
           (let-name expr)
           (map car (let-bindings expr))
           (let-seq expr))
          (make-application
           (let-name expr)
           (map caddr (let-bindings expr))))))
       (define (let->combination expr)
        (if (named-let? expr)
            (named-let->combination expr)
            (make-application
             (make-lambda
              (map car (let-bindings expr))
              (let-seq expr))
             (map caddr (let-bindings expr)))))
       #+END_SRC

*** 4.1.3 Evaluator Data Structures
    In addition to defining the external syntax of expressions, the
    evaluator implementation must also define the data structures that
    the evaluator manipulates internally, as part of the execution of
    a program, such as the representation of procedures and
    environments and the representation of true and false.

**** Testing of predicates
     For conditionals, we accept anything to be true that is not the
     explicit false object.

     #+BEGIN_SRC scheme
     (define (true? x) (not (eq? x false)))
     (define (false? x) (eq? x false))
     #+END_SRC

**** Representing procedures

     To handle primitives, we assume that we have available the
     following procedures:

     - (apply-primitive-procedure <proc> <args>)
       applies the given primitive procedure to the argument values in
       the list <args> and returns the result of the application.
     - (primitive-procedure? <proc>)
       tests whether <proc> is a primitive procedure.

       
     These mechanisms for handling primitives are further described in
     section 4.1.4. 

     Compound procedures are constructed from parameters, procedure
     bodies, and environments using the constructor make-procedure:

     #+BEGIN_SRC scheme
     (define (make-procedure parameters body env)
      (list 'procedure parameters body env))
     (define (compound-procedure? p)
      (tagged-list? p 'procedure))
     (define (procedure-parameters p) (cadr p))
     (define (procedure-body p) (caddr p))
     (define (procedure-environment p) (cadddr p))
     #+END_SRC

**** Operations on Environments
     The evaluator needs operations for manipulating environments. As
     explained in Section 3.2, an environment is a sequence of frames,
     where each frame is a table of bindings that associate variables
     with their corresponding values. We use the following operations
     for manipulating environments:

     - (lookup-variable-value <var> <env>)
       returns the value that is bound to the symbol <var> in the
       environment <env>, or signals an error if the variable is
       unbound.
     - (extend-environment <variables> <values> <base-env>)
       returns a new environment, consisting of a new frame in which
       the symbols in the list <variables> are bound to the
       corresponding elements in the list <values>, where the
       enclosing environment is the environment <base-env>.
     - (define-variable! <var> <value> <env>)
       adds to the first frame in the environment <env> a new binding
       that associates the variable <var> with the value <value>.
     - (set-variable-value! <var> <value> <env>)
       changes the binding of the variable <var> in the environment
       <env> so that the variable is now bound to the value <value>,
       or signals an error if the variable is unbound.

       
     To implement these operations we represent an environment as a
     list of frames. The enclosing environment of an environment is
     the cdr of the list. The empty environment is simply the empty
     list.

     #+BEGIN_SRC scheme
     (define (enclosing-environment env) (cdr env))
     (define (first-frame env) (car env))
     (define the-empty-environment '())
     #+END_SRC

     Each frame of an environment is represented as a pair of lists: a
     list of the variables bound in that frame and a list of the
     associated values:
     
     #+BEGIN_SRC scheme
     (define (make-frame variables values)
      (cons variables values))
     (define (frame-variables frame) (car frame))
     (define (frame values frame) (cdr frame))
     (define (add-binding-to-frame! var val frame)
      (set-car! frame (cons var (car frame)))
      (set-cdr! frame (cons val (cdr frame))))
     #+END_SRC

     To extend an environment by a new frame that associates variables
     with values, we make a frame consisting of the list of variables
     and the list of values, and we adjoin this to the environment. We
     signal an error if the number of variables does not match the
     number of values.

     #+BEGIN_SRC scheme
     (define (extend-environment vars vals base-env)
      (if (= (length vars) (length vals))
          (cons (make-frame vars vals) base-env)
          (if (< (length vars) (length vals))
              (error "Too many arguments supplied" vars vals)
              (error "Too few arguments supplied" vars vals))))
     #+END_SRC

     To look up a variable in an environment, we scan the list of
     variables in the first frame. If we find the desired variable, we
     return the corresponding element in the list of values. If we do
     not find the variable in the current frame, we search the
     enclosing environment, and so on. If we reach an empty
     environment, we signal an "unbound variable" error.

     #+BEGIN_SRC scheme
     (define (lookup-variable-value var env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars)) (car vals))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To set a variable to a new value in a specified environment, we
     scan for the variable, just as in lookup-variable-value, and
     change the corresponding value when we find it. 

     #+BEGIN_SRC scheme
     (define (set-variable-value! var val env)
      (define (env-loop env)
       (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (if (eq? env the-empty-environment)
           (error "Unbound variable: SET!" var)
           (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
       (env-loop env))
     #+END_SRC

     To define a variable, we search the first frame for a binding for
     the variable, and change the binding if it exists (just as in
     set-variable-value!). If no such binding exists, we adjoin one to
     the first frame.

     #+BEGIN_SRC scheme
     (define (define-variable! var val env)
      (let ((frame (first-frame env)))
       (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars)) (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
       (scan (frame-variables frame) (frame-values frame))))
     #+END_SRC

     The method described here is only one of many plausible ways to
     represent environments. Since we used data abstraction to isolate
     the rest of the evaluator from the detailed choice of
     representation, we could change the environment representation if
     we wanted to. (See Exercise 4.11.) In a production-quality Lisp
     system, the speed of the evaluator's environment operations -
     especially that of variable lookup - has a major impact on the
     performance of the system. The representation described here,
     although conceptually simple, is not efficient and would not
     ordinarily be used in a production system.

     - Exercise 4.11: Instead of representing a frame as a pair of
       lists, we can represent a frame as a list of bindings, where
       each binding is a name-value pair. Rewrite the environment
       operations to use this alternative representation.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (lookup-cell var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (lookup-variable-value var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- LOOKUP-VARIABLE-VALUE" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (cdar lookup)))))

       (define (set-variable-value! var val env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- SET-VARIABLE-VALUE!" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null? lookup)
                 (lookup-variable-value var (enclosing-environment env))
                 (set-cdr! (car lookup) val)))))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.12: The procedures set-variable-value!,
       define-variable! and lookup-variable-value can be expressed in
       terms of more abstract procedures for traversing the
       environment structure. Define abstractions that capture the
       common patterns and redefine the three procedures in terms of
       these abstractions.

       #+BEGIN_SRC scheme
       (define (make-frame variables values)
        (map cons variables values))
       (define (frame-variables frame) (map car frame))
       (define (frame-values frame) (map cdr frame))
       (define (add-binding-to-frame! var val frame)
        (let ((last-cell (last-pair frame)))
         (set-cdr! last-cell (list (cons var val)))))
       ;; extend-environment is the same.
       (define (extend-envrionment vars vals base-env)
        (if (= (length vars) (length vals))
            (cons (make-frame vars vals) base-env)
            (if (< (length vars) (length vals))
                (error "Too many arguments supplied" vars vals)
                (error "Too few arguments supplied" vars vals))))

       (define the-empty-environment '()) 
       (define (first-frame env) (car env))
       (define (enclosing-environment env) (cdr env))

       (define (find-cell-in-frame var frame)
        (filter (lambda (x) (eq? (car x) var)) frame))

       (define (set-cell-val! val cell)
        (set-cdr! (car cell) val))

       (define (cell-val cell)
        (cdar cell))

       (define (null-cell? cell) (null? cell))

       (define (operate-on-cell proc var env)
        (if (eq? env the-empty-environment)
            (error "Undefined variable -- OPERATE-ON-CELL" var)
            (let ((lookup (lookup-cell var (first-frame env))))
             (if (null-cell? lookup)
                 (operate-on-cell var (enclosing-environment env))
                 (proc lookup)))))

       (define (lookup-variable-value var env)
        (operate-on-cell
         (lambda (cell)
          (cell-val cell))
         var env))

       (define (set-variable-value! var val env)
        (operate-on-cell
         (lambda (cell)
          (set-cell-val! val cell))
         var env))

       (define (define-variable! var val env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (add-binding-to-frame! var val frame) 
              (set-cdr! (car lookup) val)))))
       #+END_SRC

     - Exercise 4.13: Scheme allows us to create new bindings for
       variables by means of define, but provides no way to get rid of
       bindings. Implement for the evaluator a special form
       make-unbound! that removes the binding of a given symbol from
       the environment in which the make-unbound! expression is
       evaluated. This problem is not completely specified. For
       example, should we remove only the binding in the first frame
       of the environment? Complete the specification and justify any
       choices you make.

       I'm only going to remove it from the first frame that has
       it. It doesn't make sense to me to unbind all instances, you
       could then have a utility function inside a function that
       unbinds all variables, even ones in use in enclosing
       functions. Then if you really want to unbind them all you can
       repeatedly unbind.

       #+BEGIN_SRC scheme
       (define (remove-bindings-from-frame var frame)
        (filter (lambda (binding) (not (eq? (car binding) var)))
                frame))
       (define (make-unbound! var env)
        (let ((frame (first-frame env)))
         (let ((lookup (lookup-cell var frame)))
          (if (null? lookup)
              (make-unbound! var (enclosing-environment env))
              (set-car! env (remove-bindings-from-frame var frame))))))
       #+END_SRC

*** 4.1.4 Running the Evaluator as a Program

    Given the evaluator, we have in our hands a description (expressed
    in Lisp) of the process by which Lisp expressions are
    evaluated. One advantage of expressing the evaluator as a program
    is that we can run the program. This gives us, running within
    Lisp, a working model of how Lisp itself evaluates
    expressions. This can serve as a framework for experimenting with
    evaluation rules, as we shall do later in this chapter. 

    Our evaluator program reduces expressions ultimately to the
    application of primitive procedures. Therefore, all that we need
    to run the evaluator is to create a mechanism that calls on the
    underlying Lisp system to model the application of primitive
    procedures.

    There must be a binding for each primitive procedure name, so that
    when eval evaluates the operator of an application of a primitive,
    it will find an object to pass to apply. We thus set up a global
    environment that associates unique objects with the names of the
    primitive procedures that can appear in the expressions we will be
    evaluating. The global environment also includes bindings for the
    symbols true and false, so that they can be used as variables in
    expressions to be evaluated.

    #+BEGIN_SRC scheme
    (define (setup-environment)
     (let ((initial-env
            (extend-environment (primitive-procedure-names)
                                (primitive-procedure-objects)
                                the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))
    (define the-global-environment (setup-environment))
    #+END_SRC

    It does not matter how we represent the primitive procedure
    objects, so long as apply can identify and apply them by using the
    procedures primitive-procedure? and apply-primitive-procedure. We
    have chosen to represent a primitive procedure as a list beginning
    with the symbol primitive and containing a procedure in the
    underlying Lisp that implements that primitive.

    #+BEGIN_SRC scheme
    (define (primitive-procedure? proc)
     (tagged-list? proc 'primitive))
    (define (primitive-implementation proc) (cadr proc))
    #+END_SRC

    setup-environment will get the primitive names and implementation
    procedures from a list:

    #+BEGIN_SRC scheme
    (define primitive-procedures
     (list (list 'car car)
           (list 'cdr cdr)
           (list 'cons cons)
           (list 'null? null?)
           <more primitives>))
    (define (primitive-procedure-names)
     (map car primitive-procedures))
    (define (primitive-procedure-objects)
     (map (lambda (proc) (list 'primitive (cadr proc)))
          primitive-procedures))
    #+END_SRC

    To apply a primitive procedure, we simply apply the implementation
    procedure to the arguments, using the underlying Lisp system:

    #+BEGIN_SRC scheme
    (define (apply-primitive-procedure proc args)
     (apply-in-underlying-scheme
      (primitive-implementation proc) args))
    #+END_SRC

    For convenience in running the metacircular evaluator, we provide
    a _driver loop_ that models the read-eval-print loop of the
    underlying Lisp system. It prints a _primpt_, reads an input
    expression, evaluates this expression in the global environment,
    and prints the result. We precede each printed result by an
    _output prompt_ so as to distinguish the value of the expression
    from other output that may be printed.

    #+BEGIN_SRC scheme
    (define input-prompt ";;; M-Eval input:")
    (define output-prompt ";;; M-Eval value:")
    (define (driver-loop)
     (prompt-for-input input-prompt)
     (let ((input (read)))
      (let ((output (eval input the-global-environment)))
       (announce-output out-prompt)
       (user-print output)))
     (driver-loop))
    (define (prompt-for-input string)
     (newline) (newline) (display string) (newline))
    (define (announce-output string)
     (newline) (display string) (newline))       
    #+END_SRC

    We use a special printing procedure, user-print, to avoid printing
    the environment part of a compound procedure, which may be a very
    long list (or may even contain cycles). 

    #+BEGIN_SRC scheme
    (define (user-print object)
     (if (compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
         (display object)))
    #+END_SRC

    Now all we need to do to run the evaluator is to initialize the
    global environment and start the driver loop. Here is a sample
    interaction:

    #+BEGIN_SRC scheme
    (define the-global-environment (setup-environment))
    (driver-loop)

    ;;; M-Eval input:
    (define (append x y)
     (if (null? x)
         y
         (cons (car x) (append (cdr x) y))))

    ;;; M-Eval value:
    ok

    ;;; M-Eval input:
    (append '(a b c) '(d e f))
      
    ;;; M-Eval value:
    (a b c d e f)
    #+END_SRC

    - Exercise 4.1.4: Eva Lu Ator and Louis Reasoner are each
      experimenting with the metacircular evaluator. Eva types in the
      definition of map, and runs some test programs that use it. They
      work fine. Louis, in contrast, has installed the system version
      of map as a primitive for the metacircular evaluator. When he
      tries it, things go terribly wrong. Explain why Louis' map fails
      even though Eva's works.

      Louis's version, the underlying scheme version, needs a
      procedure object of the kind defined by the underlying lisp, not
      a procedure from our lisp. However, what it will get is a
      procedure definition from our own lisp, even if it's a
      primitive, it will not get an actual procedure object, so it
      will not be able to map that way. 

*** 4.1.4 Data as Programs
    In thinking about a Lisp program that evaluates Lisp expressions,
    an analogy might be helpful. One operational view of the meaning
    of a program is that the program is a description of an abstract
    (perhaps infinitely large) machine. For exmaple, consider the
    familiar program to compute factorials:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1) n))))
    #+END_SRC

    We may regard this program as the description of a machine
    containing parts that decrement, multiply, and test for equality,
    together with a two-position switch and another factorial
    machine. (The factorial machine is infinite because it contains
    another factorial machine within it.) Figure 4.2 is a flow diagram
    for the factorial  machine, showing how the parts are wired
    together.

    In a similar way, we can regard the evaluator as a very special
    machine that takes as input a description of a machine. Given this
    input, the evaluator configures itself to emulate the machine
    described. For example, if we feed our evaluator the definition of
    factorial, as shown in Figure 4.3, the evaluator will be able to
    compute factorials.

    From this perspective, our evaluator is seen to be a _universal
    machine_. It mimics other machines when these are described as
    Lisp programs. This is striking. Try to imagine an analogous
    evaluator for electrical circuits. This would be a circuit that
    takes as input a signal encoding the plans for some other circuit,
    such as a filter. Given this input, the circuit evaluator would
    then behave like a filter with the same description. Such a
    universal electrical circuit is almost unimaginably complex. It is
    remarkable that the program evaluator is a rather simple program.

    Another striking aspect of the evaluator is that it acts as a
    bridge between the data objects that are manipulated by our
    programming language and the programming language itself. Imagine
    that the evaluator program (implemented in Lisp) is running, and
    that a user is typing expressions to the evaluator and observing
    the results. From the perspective of the user, an input expression
    such as (* x x) is an expression in the programming language,
    which the evaluator should execute. From the perspective of the
    evaluator, however, the expression is simply a list (in this case,
    a list of three symbols: *, x, and x) that is to be manipulated
    according to a well-defined set of rules. 
    
    That the user's programs are the evaluator's data need not be a
    source of confusion. In fact, it is sometimes convenient to ignore
    this distinction, and to give the user the ability to explicitly
    evaluate a data object as a Lisp expression, by making eval
    available for use in programs. Many Lisp dialects provide a
    primitive eval procedure that takes as arguments an expression and
    an environment and evaluates the expression relative to the
    environment. Thus,

    #+BEGIN_SRC scheme
    (eval '(* 5 5) user-initial-environment)
    #+END_SRC
    
    and

    #+BEGIN_SRC scheme
    (eval (cons '* (list 5 5)) user-initial-environment)
    #+END_SRC

    will both return 25.

    - Exercise 4.15: Given a one-argument procedure p and an object a,
      p is said to "halt" on a if evaluating the expression (p a)
      returns a value (as opposed to terminating with an error message
      or running forever). Show that it is impossible to write a
      procedure halts? that correctly determines whether p halts on a
      for any procedure p and object a. Use the following reasoning:
      If you had such a procedure halts?, you could implement the
      following program:

      #+BEGIN_SRC scheme
      (define (run-forever) (run-forever))
      (define (try p)
       (if (halts? p p) (run-forever) 'halted))
      #+END_SRC

      Now consider evaluating the expression (try try) and show that
      any possible outcome (either halting or running forever)
      violates the intended behavior of halts?.

      Try is supposed to run forever if the procedure given to it
      halts when given itself, and halt if it would run forever. If
      the halts? procedure decides that (try try) halts it will
      actually run forever, making that procedure inconsistent and
      breaking the law of functions. If it decides it runs forever the
      procedure will halt, again breaking the rules of functions by
      having a different result for the same input.

*** 4.1.6 Internal Definitions

    Our environment model of evaluation and our metacircular evaluator
    execute definitions in sequence, extending the environment frame
    one definition at a time. This is particularly convenient for
    interactive program development, in which the programmer needs to
    freely mix the application of procedures with the definition of
    new procedures. However, if we think carefully about the internal
    definitions used to implement block structure (introduced in
    Section 1.1.8), we find that name-by-name extension of the
    environment may not be the best way to define local
    variables. Consider a procedure with internal definitions, such as

    #+BEGIN_SRC scheme
    (define (f x)
     (define (even? n) (if (= n 0) true (odd? (- n 1))))
     (define (odd? n) (if (= n 0) false (even? (- n 1))))
     <rest of body of f>)
    #+END_SRC

    Our intention here is that the name odd? in the body of the
    procedure even? should refer to the procedure odd? that is defined
    after even?. The scope of the name odd? is the entire body of f,
    not just the portion of the body of f starting at the point where
    the define for odd? occurs. Indeed, when we consider that odd? is
    itself defined in terms of even? -- so that even? and odd? are
    mutually recursive procedures -- we see that the only satisfactory
    interpretation of the two defines is to regard them as if the
    names even? and odd? were being added to the environment
    simultaneously. More generally, in block structure, the scope of a
    local name is the entire procedure body in which the define is
    evaluated.

    As it happens, our interpreter will evaluate calls to f correctly,
    but for an "accidental" reason: Since the definitions of the
    internal procedures come first, no calls to these procedures will
    be evaluated until all of them have been defined. Hence, odd? will
    have been defined by the time even? is executed. In fact, our
    sequential evaluation mechanism will give the same result as a
    mechanism that directly implements simultaneous definition for any
    procedure in which the internal definitions come first in a body
    and evaluation of the value expressions for the defined variables
    doesn't actually use any of the defined variables. (For an example
    of a procedure that doesn't obey these restrictions, so that
    sequential definition isn't equivalent to simultaneous definition,
    see Exercise 4.19). 

    There is, however, a simple way to treat definitions so that
    internally defined names have truly simultaneous scope -- just
    create all local variables that will be in the current environment
    before evaluating any of the value expressions. One way to do this
    is by a syntax transformation on lambda expressions. Before
    evaluating the body of a lambda expression, we "scan out" and
    eliminate all the internal definitions in the body. For example,
    the procedure

    #+BEGIN_SRC scheme
    (lambda <vars>
     (define u <e1>)
     (define v <e2>)
     <e3>)
    #+END_SRC

    would be transformed into

    #+BEGIN_SRC scheme
    (lambda <vars>
     (let ((u '*unassigned*)
           (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))
    #+END_SRC

    where \*unassigned\* is a special symbol that causes looking up a
    variable to signal an error if an attempt is made to use the value
    of the not-yet-assigned variable.

    An alternative strategy for scanning out internal definitions is
    shown in Exercise 4.18. Unlike the transformation shown above,
    this enforces the restriction that defined variables' values can
    be evaluated without using any of the variables' values. 

    - Exercise 4.16: In this exercise we implement the method just
      described for interpreting internal definitions. We assume that
      the evaluator supports let (see Exercise 4.6).

      a. Change lookup-variable-value (Section 4.13) to signal an
      error if the value it finds is the symbol \*unassigned\*.

      b. Write a procedure scan-out-defines that takes a procedure
      body and returns an equivalent one that has no internal
      definitions, by making the transformation described above. 
      
      c. Install scan-out-defines in the interpreter, either in
      make-procedure or in procedure-body (see Section 4.1.3). Which
      place is better? Why? 

      It makes more sense to put it in make-procedure, if the
      procedure-body is accessed multiple times, we only transform it
      once in make-procedure.

    - Exercise 4.17: Draw diagrams of the environment in effect when
      evaluating the expression <e3> in the procedure in the text,
      comparing how this will be structured when definitions are
      interpreted sequentially with how it will be structured if
      definitions are scanned out as described. Why is there an extra
      frame in the transformed program? Explain why this difference in
      environment structure can never make a difference in the
      behavior of a correct program. Design a way to make the
      interpreter implement the "simultaneous" scope rule for internal
      definitions without constructing the extra frame.

      There is an extra frame because we introduced an extra let
      expression, which is just syntactical sugar for lambda, which is
      a procedure, which creates an extra frame. It makes no
      difference in program behavior because we set variables
      immediately inside the let, so there is no opportunity for the
      program to try to find the value of a variable and not get
      it. We can implement simultaneous scope by using defines instead
      of lets, the program expansion from the text would be:

      #+BEGIN_SRC scheme
      (lambda <vars>
       (define u '*unassigned*)
       (define v '*unassigned*)
       (set! u <e1>)
       (set! v <e2>)
       <e3>)
      #+END_SRC

    - Exercise 4.18: Consider an alternative strategy for scanning out
      definitions that translates the example in the text to

      #+BEGIN_SRC scheme
      (lambda <vars>
       (let ((u '*unassigned*) (v '*unassigned*))
        (let ((a <e1>) (b <e2>))
         (set! u a)
         (set! v b))
        <e3>))
      #+END_SRC

      Here a and b are meant to represent new variable names, created
      by the interpreter, that do not appear in the user's
      program. Consider the solve procedure from Section 3.5.4:

      #+BEGIN_SRC scheme
      (define (solve f y0 dt)
       (define y (integral (delay dy) y0 dt))
       (define dy (stream-map f y))
       y)
      #+END_SRC

      Will this procedure work if internal definitions are scanned out
      as shown in this exercise? What if they are scanned out as shown
      in the text? Explain.

      It should, since dy is delayed for evaluation (although our
      interpreter doesn't have a delay keyword). The definition of dy
      itself however may not work. y will be set to \*unassigned\*
      when it tries to stream-map on y, which is not a valid
      stream. stream-map will try to evaluate one application of f on
      the y stream. The expansion would look like this:

      #+BEGIN_SRC scheme
      (lambda (f y0 dt)
       (let ((y '*unassigned*) (dy '*unassigned))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
         (set! y a)
         (set! dy b))
        y))
      #+END_SRC

      What will happen is stream-map will try to evaluate 
      (cons-stream (f (stream-car y)) (stream-map f (stream-cdr y)))
      The first expression (f (stream-car y)) will be evaluated
      immediately, and looking up the value of y will throw an
      error. The original transformation would work, since it does
      actually evaluate set! expressions in the same order that the
      defines occured, so y would be defined as a stream.

    - Exercise 4.19: Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator
      are arguing about the desired result of evaluating the
      expression

      #+BEGIN_SRC scheme
      (let ((a 1))
       (define (f x)
        (define b (+ a x))
        (define a 5)
        (+ a b))
      (f 10))
      #+END_SRC

      Ben asserts that the result should be obtained using the
      sequential rule for define: b is defined to be 11, then a is
      defined to be 5, so the result is 16. Alyssa objects that mutual
      recursion requires the simultaneous scope rule for internal
      procedure definitions, and that it is unreasonable to treat
      procedure names differently from other names. Thus, she argues
      for the mechanism implemented in Exercise 4.16. This would lead
      to a being unassigned at the time that the value for b is to be
      computed. Hence, in Alyssa's view the procedure should produce
      an error. Eva has a third opinion. She says that if the
      definitions of a and b are truly meant to be simultaneous, then
      the value 5 for a should be used in evaluating b. Hence, in
      Eva's view a should be 5, b should be 15, and the answer should
      be 20. Which (if any) of these viewpoints do you support? Can
      you devise a way to implement internal definitions so that they
      behave as Eva prefers?

      If we say that internal definitions are supposed to be in
      principle simultaneous, I would say that Alyssa is right. It
      doesn't make sense that a would be defined during a parallel
      assignment. If it is, then assignment is not parallel but
      ordered in some way. This should produce an error.

      The only way to do it the way Eva wants is to analyze the
      expressions and order the sets so that they occur in the right
      order. So you would have to scan each definition for references
      to the others. This doesn't work in a circular definition
      case. This is why I don't think Eva's definition actually makes
      sense, if assignment is simultaneous, saying that a is defined
      to be 5 implicitly defines an ordering.

      However another, simpler way that accomplishes these semantics
      but changes other semantics is to use delay in eval-ing the
      value of the set! expressions. You can do this simply by adding
      a wrapping (delay) in the eval-assignment function, and testing
      if a variable lookup-value is a promise with promise? when doing
      a lookup. This causes the code above to function in the way Eva
      wants. However, it breaks/changes the semantics of other
      expressions, specifically any side-effect expression.

      #+BEGIN_SRC scheme
      (define g 20)
      (define (s x) (set! g (- g x)) g)
      (define (d x) (set! g (/ g x)) g)

      (define (f x)
       (define m (h 2))
       (define x (d 3))
       (+ x m))

      #+END_SRC

    - Exercise 4.20: Because internal definitions look sequential but
      are actually simultaneous, some people prefer to avoid them
      entirely, and use the special form letrec instead. letrec looks
      like let, so it is not surprising that the variables it binds
      are bound simultaneously and have the same scope as each
      other. The sample procedure f above can be written without
      internal definitions, but with exactly the same meaning, as

      #+BEGIN_SRC scheme
      (define (f x)
       (letrec
        ((even? (lambda (n)
                 (if (= n 0) true (odd? (- n 1)))))
         (odd?  (lambda (n)
                 (if (= n 0) false (even? (- n 1))))))
         <rest of body of f>))
      #+END_SRC

      letrec expressions, which have the form

      #+BEGIN_SRC scheme
      (letrec ((<var1> <exp1>) ... (<varn> <expn>))
       <body>)
      #+END_SRC

      are a variation on let in which the expressions <expk> that
      provide the initial values for the variables <vark> are
      evaluated in an environment that includes all the letrec
      bindings. This permits recursion in the bindings, such as the
      mutual recursion of even? and odd? in the example above, or the
      evaluation of 10 factorial with

      #+BEGIN_SRC scheme
      (letrec
       ((fact (lambda (n)
               (if (= n 1) 1 (* n (fact (- n 1)))))))
       (fact 10))
      #+END_SRC

      a. Implement letrec as a derived expression, by transforming a
      letrec expression into a let expression as shown in the text
      above or in exercise 4.18. That is, the letrec variables should
      be created with a let and then be assigned their values with a
      set!.
      
      #+BEGIN_SRC scheme
      (define (letrec? expr)
       (eq? (car expr) 'letrec))
      (define (letrec-bindings expr)
       (cadr expr))
      (define (letrec-body expr)
       (cddr expr))
      (define (letrec->let expr)
       (let ((binding-vars (map binding-var (letrec-bindings expr))))
        (let ((undefined-bindings
               (map (lambda (name) (make-binding name UNDEFINED-VARIABLE))
                    binding-vars))
              (assignments
               (map (lambda (binding)
                     (make-assignment
                      (binding-var binding)
                      (binding-val binding)))
                    (letrec-bindings expr)))) 
         (make-let
          undefined-bindings
          (concat-exps
           assignments
           (letrec-body expr))))))
      #+END_SRC

      b. Louis Reasoner is confused by all this fuss about internal
      definitions. The way he sees it, if you don't like to use define
      inside a procedure, you can just use let. Illustrate what is
      loose about his reasoning by drawing an environment diagram that
      shows the environment in which the <rest of body of f> is
      evaluated during evaluation of the expression (f 5), with f
      defined as in this exercise. Draw an environment diagram for the
      same evaluation, but with let in place of letrec in the
      definition of f. 

      The issue is that let creates a new internal environment, but
      evaluates the binding value expressions in the environment of
      the outer environment. As a result, evaluating a (lambda) in a
      plain let results in a procedure who's parent environment is not
      the new environment being created but the one above that. So it
      cannot 'see' names in the same environment being created by the
      let. So when a variable lookup happens inside the body of the
      lambda, it looks in the environment above the current let, and
      can't find anything in the current let. letrec creates the
      bindings first and evaluates the lambda inside the new
      environment, so mutual reference is possible.

    - Exercise 4.21: Amazingly, Louis's intuiition in Exercise 4.20 is
      correct. It is indeed possible to specify recursive procedures
      without using letrec (or even define), although the method for
      accomplishing this is much more subtle than Louis imagined. The
      following expression computes 10 factorial by applying a
      recursive factorial procedure:

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fact) (fact fact n))
         (lambda (ft k) (if (= k 1) 1 (* k (ft ft (- k 1)))))))
        10)
      #+END_SRC

      a. Check (by evaluating the expression) that this really does
      compute factorials. Devise an analogous expression for computing
      Fibonacci numbers.

      #+BEGIN_SRC scheme
      ((lambda (n)
        ((lambda (fibo) (fibo fibo n))
         (lambda (fib n)
          (cond ((or (= n 2) (= n 1)) 1)
                ((= n 0) 0)
                (else (+ (fib fib (- n 1)) (fib fib (- n 2))))))))
       10)
      #+END_SRC

      b. Consider the following procedure, which includes mutually
      recursive internal definitions:

      #+BEGIN_SRC scheme
      (define (f x)
       (define (even? n)
        (if (= n 0) true (odd? (- n 1))))
       (define (odd? n)
        (if (= n 0) false (even? (- n 1))))
       (even? x))
      #+END_SRC

      Fill in the missing expressions to complete an alternative
      definition of f, which uses neither internal definitions nor
      letrec:

      #+BEGIN_SRC scheme
      (define (f x)
       ((lambda (even? odd?) (even? even? odd? x))
        (lambda (ev? od? n)
         (if (= n 0) true (od? ev? od? (- n 1))))
        (lambda (ev? od? n)
         (if (= n 0) false (ev? ev? od? (- n 1))))))
      #+END_SRC
*** 4.1.7 Separating Syntactic Analysis from Execution
    The evaluator implemented above is simple, but it is very
    inefficient, because the syntactic analysis of expressions is
    interleaved with their execution. Thus if a program is executed
    many times, its syntax is analyzed many times. Consider, for
    example, evaluating (factorial 4) using the following definition
    of factorial:

    #+BEGIN_SRC scheme
    (define (factorial n)
     (if (= n 1) 1 (* (factorial (- n 1)) n)))
    #+END_SRC

    Each time factorial is called, the evaluator must determine that
    the body is an if expression and extract the predicate. Only then
    can it evaluate the predicate and dispatch on its value. Each time
    it evaluates the expression (* (factorial (- n 1)) n), or the
    subexpressions (factorial (- n 1)) and (- n 1), the evaluator must
    perform the case analysis in eval to determine that the expression
    is an application, and must extract its operator and
    operands. This analysis is expensive. Performing it repeatedly is
    wasteful.

    We can transform the evaluator to be significantly more efficient
    by arranging things so that syntactic analysis is performed only
    once. We split eval, which takes an expression and an environment,
    into two parts. The procedure analyze takes only the
    expression. It performs the syntactic analysis and returns a new
    procedure, the _execution procedure_, that encapsulates the work
    to be done in executing the analyzed expression. The execution
    procedure takes an environment as its argument and completes the
    evaluation. This saves work because analyze will be called only
    once on an expression, while the execution procedure may be called
    many times. 

    With the separation into analysis and execution, eval now becomes

    #+BEGIN_SRC scheme
    (define (eval exp env) ((analyze exp) env))
    #+END_SRC

    The result of calling analyze is the execution procedure to be
    applied to the environment. The analyze procedure is the same case
    analysis as performed by the original eval of Section 4.1.1,
    except that the procedures to which we dispatch perform only
    analysis, not full evaluation:

    #+BEGIN_SRC scheme
    (define (analyze exp)
     (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
           ((quoted? exp) (analyize-quoted exp))
           ((variable? exp) (analyze-variable exp))
           ((assignment? exp) (analyze-assignment exp))
           ((definition? exp) (analyze-definition exp))
           ((if? exp) (analyze-if exp))
           ((lambda? exp) (analyze-lambda exp))
           ((begin? exp) (analyze-sequence (begin-actions exp)))
           ((cond? exp) (analyze (cond->if exp)))
           ((application? exp) (analyze-application exp))
           (else (error "Unknown expression type: ANALYZE" exp))))
    #+END_SRC

    Here is the simplest syntactic analysis procedure, which handles
    self-evaluating expressions. It returns an execution procedure
    that ignores its environment argument and just returns the
    expression:

    #+BEGIN_SRC scheme
    (define (analyze-self-evaluating exp)
     (lambda (env) exp))
    #+END_SRC

    For a quoted expression, we can gain a little efficiency by
    extracting the text of the quotation only once, in the analysis
    phase, rather than in the execution phase.

    #+BEGIN_SRC scheme
    (define (analyze-quoted exp)
     (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))
    #+END_SRC

    Looking up a variable value must still be done in the execution
    phase, since this depends upon knowing the environment. 

    #+BEGIN_SRC scheme
    (define (analyze-variable exp)
     (lambda (env) (lookup-variable-value exp env)))
    #+END_SRC

    analyze-assignment also must defer actually setting the variable
    until the execution, when the environment has been
    supplied. However, the fact that the assignment-value expression
    can be analyzed (recursively) during analysis is a major gain in
    efficiency, because the assignment-value expression will now be
    analyzed only once. The same holds true for definitions.

    #+BEGIN_SRC scheme
    (define (analyze-assignment exp)
     (let ((var (assignment-variable exp))
           (vproc (analyze (assignment-value exp))))
      (lambda (env)
       (set-variable-value! var (vproc env) env)
       'ok)))
    (define (analyze-definition exp)
     (let ((var (definition-variable exp))
           (vproc (analyze (definition-value exp))))
      (lambda (env)
       (define-variable! var (vproc env) env)
       'ok)))
    #+END_SRC

    For if expressions, we extract and analyze the predicate,
    consequent, and alternative at analysis time.

    #+BEGIN_SRC scheme
    (define (analyze-if exp)
     (let ((pproc (analyze (if-predicate exp)))
           (cproc (analyze (if-consequent exp)))
           (aproc (analyze (if-alternative exp))))
      (lambda (env)
       (if (true? (pproc env))
           (cproc env)
           (aproc env)))))
    #+END_SRC

    Analyzing a lambda expression also achieves a major gain in
    efficiency: We analyze the lambda body only once, even though
    procedures resulting from evaluation of the lambda may be applied
    many times.

    #+BEGIN_SRC scheme
    (define (analyze-lambda exp)
     (let ((vars (lambda-parameters exp))
           (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))
    #+END_SRC

    Analysis of a sequence of expressions (as in a begin or the body
    of a lambda expression) is more involved. Each expression in the
    sequence is analyzed, yielding an execution procedure. These
    execution procedures are combined to produce an execution
    procedure that takes an environment as argument and sequentially
    calls each individual execution procedure with the environment as
    argument.

    #+BEGIN_SRC scheme
    (define (analyze-sequence exps)
     (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
     (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
     (let ((procs (map analyze exps)))
      (if (null? procs) 
          (error "Empty sequence: ANALYZE")
          (loop (car procs) (cdr procs)))))              
    #+END_SRC

    To analyze an application, we analyze the operator and operands
    and construct an execution procedure that calls the operator
    execution procedure that calls the operator execution procedure
    (to obtain the actual procedure to be applied) and the operand
    execution procedures (to obtain the actual arguments). We then
    pass these to execute-application, which is the analog of apply in
    Section 4.1.1. execute-application differs from apply in that the
    procedure body for a compound procedure has already been analyzed,
    so there is no need to do further analysis. Instead, we just call
    the execution procedure for the body on the extended environment.

    #+BEGIN_SRC scheme
    (define (analyze-application exp)
     (let ((fproc (analyze (operator exp)))
           (aprocs (map analyze (operands exp))))
      (lambda (env)
       (execute-application
        (fproc env)
        (map (lambda (aproc) (aproc env))
             aprocs)))))
    (define (execute-application proc args)
     (cond ((primitive-procedure? proc)
            (apply-primitive-procedure proc args))
           ((compound-procedure? proc)
            ((procedure-body proc)
             (extend-environment
              (procedure-parameters proc)
              args
              (procedure-environment proc))))
           (else
            (error "Unknwon procedure type: EXECUTE-APPLICATION"
                   proc)))) 
    #+END_SRC

    Our new evaluator uses the same data structures, syntax
    procedures, and run-time support procedures as in sections Section
    4.1.2, Section 4.1.3, and Section 4.1.4. 

    - Exercise 4.22: Extend the evaluator in this section to support
      the special form let.
      
      let is only a syntactical construct so all we have to do is add
      
      #+BEGIN_SRC scheme
      ((let? exp) (analyze (let->combination exp)))
      #+END_SRC

      to the case statement in analyze.

    - Exercise 4.23: Alyssa P. Hacker doesn't understand why
      analyze-sequence needs to be so complicated. All the other
      analysis procedures are straightforward transformations of the
      corresponding evaluation procedures (or eval clauses) in Section
      4.1.1. She expected analyze-sequence to look like this:

      #+BEGIN_SRC scheme
      (define (analyze-sequence exps)
       (define (execute-sequence procs env)
        (cond ((null? (cdr procs))
               ((car procs) env))
              (else
               ((car procs) env)
               (execute-sequence (cdr procs) env))))
       (let ((procs (map analyze exps)))
        (if (null? procs)
            (error "Empty sequence: ANALYZE"))
        (lambda (env)
         (execute-sequence procs))))
      #+END_SRC

      Eva Lu Ator explains to Alyssa that the version in the text does
      more of the work of evaluating a sequence at analysis
      time. Alyssa's sequence-execution procedure, rather than having
      the calls to the individual execution procedures built in, loops
      through the procedures in order to call them: In effect,
      although the individual expressions in the sequence have been
      analyzed, the sequence itself has not been.

      Compare the two versions of analyze-sequence. For example,
      consider the common case (typical of procedure bodies) where the
      sequence has just one expression. What work will the execution
      procedure proeduced by Alyssa's program do? What about the
      execution procedure produced by the program in the text above?
      How do the two version compare for a sequence with two
      expressions?

      The original actual execution procedure will only execute the
      actual analyzed body, resulting in a single procedure call.

      Alyssa's procedure, on the other hand, will run execute-sequence
      on a single-item list. It will test if the next item is null,
      find that it is, and then do an execution. This results in three
      procedure calls -- execute-sequence?, null?, and the actual
      call, three calls.

      For two expressions, the original definition:

      (lambda (env) (proc1 env) (lambda (env) (proc2 env) (proc3 env)))
      Calling this procedure calls the original 3, plus two
      lambdas. This is 5 procedure calls. The number of procedure
      calls is multiplied by 2 (minus 1) -- 2 * n - 1.

      Alyssa's definition calls the original execute-sequence
      recursively, and tests for null each time. This is a list of
      procedure calls made:

      execute-sequence, null?, proc1, execute-sequence, null? proc2,
      execute-sequence, null?, proc3

      A total of 9 procedure calls.

      In general, Alyssa's definition multiplies the number of calls
      by 3, each time the body is evaluated -- 3 * n.

    - Exercise 4.24: Design and carry out some experiments to compare
      the speed of the original metacircular evaluator with the
      version in this section. Use your results to estimate the
      fraction of time that is spent in analysis versus execution for
      various procedures.

      The most obvious thing to do is write a procedure, like fibo,
      and execute it with a sizeable input and compare the results.

      The first thing I did was manually time the execution of
      (fibo 25) in each interpreter, with fibo defined as:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))
      #+END_SRC

      The analyze-execute version took 14 seconds, and the first naive
      evaluator that we implemented with no separate analysis step
      took 34 seconds. 

      The next step was to provide the interpreter itself with a way
      of telling time. I provided it with the primitive procedure
      get-universal-time, from the underlying scheme, and typed in
      this:

      #+BEGIN_SRC scheme
      (define (fibo x)
       (cond
        ((= x 0) 0)
        ((= x 1) 1)
        (else (+ (fibo (- x 1)) (fibo (- x 2))))))

      (begin
       (let ((t1 (get-universal-time)))
        (fibo 25)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      The results were 33 for the original interpreter and 14 again
      for the analyzing interpreter. I repeated the experiment several
      time for both interpreters and got [34,33,34,34] and
      [14,14,13,13]. The averages are then 33.75 and 13.5, the
      original interpreter takes 2.5 times as long to do fibo. Since
      no 'analysis' is done in the analyzing interpreter and it is
      done every time in the first interpreter. So we can conclude
      that the fraction of time spent in analysis is (33.75 -
      13.5)/33.75, or .6 -- 60% of the interpreter's time is spent
      analyzing syntax if we don't extract that step. 

      We can also try a different kind of procedure. Instead of a
      multiple recursion procedure, we can try linear recursion.

      #+BEGIN_SRC scheme
      (define (sum n)
       (define (loop n result)
       (if (= n 0) 
           result
           (loop (- n 1) (+ result n))))
       (loop n 0))

      (begin
       (let ((t1 (get-universal-time)))
        (sum 100000)
        (let ((t2 (get-universal-time)))
         (- t2 t1))))
      #+END_SRC

      With the classic interpreter, I get 13, 13, 12, 13. With
      the analyzing interpreter, I get 6, 6, 7, 6. Despite the fact
      that the computational nature of the procedure is very
      different, the ratios are similar:

      (13 - 6)/13 = .54 (previous was .6)
      13/6 = 2.1 (previous was 2.5)

** 4.2 Variations on a Scheme -- Lazy Evaluation
   Now that we have an evaluator expressed as a Lisp program, we can
   experiment with alternative choices in language design simply by
   modifying the evaluator. Indeed, new languages are often invented
   by first writing an evaluator that embeds the new language within
   an existing high-level language. For example, if we wish to discuss
   some aspect of a proposed modification to Lisp with another member
   of the Lisp community, we can supply an evaluator that embodies the
   change. The recipient can then experiment with the new evaluator
   and send back comments as further modifications. Not only does the
   high-level implementation base make it easier to test and debug the
   evaluator; in addition, the embedding enables the designer to snarf
   features from the underlying language, just as our embedded Lisp
   evaluator uses primitives and control structures from the
   underlying Lisp. Only later (if ever) need the designer go to the
   trouble of building a complete implementation in a low-level
   language or in hardware. In this section and the next we will
   explore some variations on Scheme that provie significant
   additional expressive power.

*** 4.2.1 Normal Order and Applicative Order
    In Section 1.1, where we began our discussion of models of
    evaluation, we noted that Scheme is an _applicative-order_
    language, namely, that all the arguments to Scheme procedures are
    evaluated when the procedure is applied. In contrast,
    _normal-order_ languages delay evaluation of procedure arguments
    until the actual argument values are needed. Delaying evaluation
    of procedure arguments until the last possible moment (e.g., until
    they are required by a primitive operation) is called _lazy
    evaluation_. Consider the procedure
    
    #+BEGIN_SRC scheme
    (define (try a b) (if (= a 0) 1 b))
    #+END_SRC
    
    Evaluating (try 0 (/ 1 0)) generates an error in Scheme. With lazy
    evaluation, there would be no error. Evaluating the expression
    would return 1, because the argument (/ 1 0) would never be
    evaluated. An example that exploits lazy evaluation is the
    definition of a procedure unless
    
    #+BEGIN_SRC scheme
    (define (unless condition usual-value exceptional-value)
     (if condition exceptional-value usual-value))
    #+END_SRC

    that can be used in expressions such as

    #+BEGIN_SRC scheme
    (unless (= b 0)
            (/ a b)
            (begin (display "Exception: Returning 0") 0)) 
    #+END_SRC

    This won't work in an applicative-order language because both the
    usual value and the exceptional value will be evaluated before
    unless is called (compare Exercise 1.6). An advantage of lazy
    evaluation is that some procedures, such as unless, can do useful
    computation even if evaluation of some of their arguments would
    produce errors or would not terminate. 

    If the body of a procedure is entered before an argument has been
    evaluated we say that the procedure is _non-strict_ in that
    argument. If the argument is evaluated before the body of the
    procedure is entered we say that the procedure is _strict_ in that
    argument. In a purely applicative-order language, all procedures
    are strict in each argument. In a purely normal-order language,
    all procedures are strict in each argument. In a purely
    normal-order language, all compound procedures are non-strict in
    each argument, and primitive proceduers may be either strict or
    non-strict. There are also languages (see Exercise 4.31) that give
    programmers detailed control over the strictness of the procedures
    they define. 

    A striking example of a procedure that can usefully be made
    non-strict is cons (or, in general, almost any constructor for
    data structures). One can do useful computation, cimbining
    elements to form data structures and operating on the resulting
    data structures, even if the values of the elements are not
    known. It makes perfect sense, for instance, to compute the length
    of a list without knowing the values of the individual elements in
    the list. We will exploit this idea in Section 4.2.3 to implement
    the stream of Chapter 3 as lists formed of non-strict cons pairs.

    - Exercise 4.25: Suppose that (in ordinary applicative-order
      Scheme) we define unless as shown above and then define
      factorial in terms of unless as

      #+BEGIN_SRC scheme
      (define (factorial n)
       (unless (= n 1)
               (* n (factorial (- n 1)))
               1))
      #+END_SRC

      What happens if we attempt to evaluate (factorial 5)? Will our
      definitions work in a normal-order language?

      Because unless in a applicative-order language would simply be a
      normal procedure whose arguments are evaluated first before the
      procedure itself is called, the procedure will never terminate,
      no matter what arguments we give it. It will call (* n
      (factorial (- n 1))) forever.

      This definition would work in a normal-order language, assuming
      that once you actually try to call a primitive function or do a
      variable lookup, the value is actually evaluated.

    - Exercise 4.26: Ben Bitdiddle and Alyssa P. Hacker disagree over
      the importance of lazy evaluation for implementing things such
      as unless. Ben points out that it's possible to implement unless
      in applicative order as a special form. Alyssa counters that, if
      one did that, unless would be merely syntax, not a procedure
      that could be used in conjunction with higher-order
      procedures. Fill in the details on both sides of the
      argument. Show how to implement unless as a derived expression
      (like cond or let), and give an example of a situation where it
      might be useful to have unless available as a procedure, rather
      than as a special form.

      Ben is correct, in that you can implement a version of
      unless that will work for the factorial function we defined. You
      would just write a procedure, unless->if, that, like cond,
      converts its unless input syntax to if to be actuall
      evaluated. You would add the following case to the eval procedure:

      ((unless? expr) (eval (unless->if expr)))

      The procedure:

      #+BEGIN_SRC scheme
      (define (unless->if expr)
       (make-if
        (unless-condition expr)
        (unless-failure expr)
        (unless- expr)))
      #+END_SRC

      However, Alyssa is also correct, you can't pass unless as a
      procedural argument to higher-order procedures, so something
      like this:

      #+BEGIN_SRC scheme
      (higher-order-procedure unless (list 'a 'b 'c))
      #+END_SRC

      will simply produce a variable-not-found error. It may be useful
      to have unless if you have some kind of higher-order procedure
      where it's behavior is modified by what operator you give it.

      #+BEGIN_SRC scheme
      (define (proc f vals)
       (map 
        (lambda (val) 
         (f (car val) (cadr val) (caddr val)))
        vals))
      #+END_SRC

      This procedure takes lists of triples, and applies f to each
      triple in a map. 

      #+BEGIN_SRC scheme
      (proc unless '((1 2 3) (false 1 2)))
      (list 3 1)
      #+END_SRC

      You can't do that with unless as syntax. You can do it however
      with unless as a normal applicative-order function in our
      current interpreter. However, we can also, assuming that list is
      also normal-order, write:

      (list (list (= a 1) (factorial 10) 33) (list (= a 22)
      (factorial 11) 33))

      And in general write something like a batch-processed system of
      conditionals that you can apply to data structures.

      
*** 4.2.2 An Interpreter with Lazy Evaluation
    In this section we will implement a normal-order language that is
    the same as Scheme except that compound procedures are non-strict
    in each language. Primitive procedures will still be strict. It is
    not difficult to modify the evaluator of Section 4.1.1 so that the
    language it interprets behaves this way. Almost all the required
    changes center around procedure application.

    The basic idea is that, when applying a procedure, the interpreter
    must determine which arguments are to be evaluated and which are
    to be delayed. The delayed arguments are not evaluated; instead,
    they are transformed into objects called _thunks_. The thunk must
    contain the information required to produce the value of the
    argument when it is needed, as if it had been evaluated at the
    time of the application. Thus, the thunk must contain the argument
    expression and the environment in which the procedure application
    is being evaluated.

    The process of evaluating the expression in a thunk is called
    _forcing_. In general, a thunk will be forced only when its value
    is needed: when it is passed to a primitive procedure that will
    use the value of the thunk; when it is the value of a predicate of
    a conditional; and when it is the value of an operator that is
    about to be applied as a procedure. One design choice we have
    available is whether or not to _memoize_ thunks, as we did with
    delayed objects in Section 3.5.1. With memoization, the first time
    a thunk is forced, it stores the value that is
    computed. Subsequent forcings simply return the stored value
    without repeating the computation. We'll make our interpreter
    memoize, because this is more efficient for many
    applications. There are tricky considerations here, however.

**** Modifying the evaluator.
     
     The main difference between the lazy evaluator and the one in
     Section 4.1 is in the handling of the procedure applications in
     eval and apply. The application? clause of eval becomes

     #+BEGIN_SRC scheme
     ((application? exp)
      (apply (actual-value (operator exp) env)
             (operands exp)
             env))
     #+END_SRC

     This is almost the same as the application? clause of eval in
     Section 4.1.1. For lazy evaluation, however, we call apply with
     the operand expressions, rather than the arguments produced by
     evaluating them. Since we will need the environment to construct
     thunks if the arguments are to be delayed, we must pass this as
     well. We still evaluate the operator, because apply needs the
     actual procedure to be applied in order to dispatch on its type
     (primitive versus compound) and apply it. 

     Whenever we need the actual value of an expression, we use
     
     #+BEGIN_SRC scheme
     (define (actual-value exp env)
      (force-it (eval exp env)))
     #+END_SRC

     instead of just eval, so that if the expression's value is a
     thunk, it will be forced.

     Our new version of apply is also almost the same as the version
     in Section 4.1.1. The difference is that eval has passed in
     unevaluated operand expressions: For primitive procedures (which
     are strict), we evaluate all the arguments before applying the
     primitive; for compound procedures (which are non-strict) we
     delay all the arguments before appling the procedure. 

     #+BEGIN_SRC scheme
     (define (apply procedure arguments env)
      (cond ((primitive-procedure? procedure)
             (apply-primitive-procedure
              procedure
              (list-of-arg-values arguments env)))
            ((compound-procedure? procedure)
             (eval-sequence
              (procedure-body procedure)
              (extend-environment
               (procedure-parameters procedure)
               (list-of-delayed-args arguments env)
               (procedure-environment procedure))))
            (else (error "Unknown procedure type: APPLY"
                         procedure))))
     #+END_SRC

     The procedures that process the arguments are just like
     list-of-values from Section 4.1.1, except that
     list-of-delayed-args delays the arguments instead of evaluating
     them, and list-of-arg-values uses actual-value instead of eval:

     #+BEGIN_SRC scheme
     (define (list-of-arg-values exps env)
      (if (no-operands? exps)
          '()
          (cons (actual-value (first-operand exps)
                              env)
                (list-of-arg-values (rest-operands exps)
                                    env))))
     (define (list-of-delayed-args exps env)
      (if (no-operands? exps)
          '()
          (cons (delay-it (first-operand exps)
                          env)
                (list-of-delayed-args (rest-operands exps)
                                      env))))
     #+END_SRC

     The other place we must change the evaluator is in the handling
     of if, where we must use actual-value instead of eval to get the
     value of the predicate expression before testing whether it is
     true or false:

     #+BEGIN_SRC scheme
     (define (eval-if exp env)
      (if (true? (actual-value (if-predicate exp) env))
          (eval (if-consequent exp) env)
          (eval (if-alternative exp) env)))
     #+END_SRC

     Finally, we must change the driver-loop procedure (Section 4.1.4)
     to use actual-value instead of eval, so that if a delayed value
     is propagated back to the read-eval-print loop, it will be forced
     before being printed. We also change the prompts to indicate that
     this is the lazy evaluator:

     #+BEGIN_SRC scheme
     (define input-prompt  ";;; L-Eval input:")
     (define output-prompt ";;; L-Eval value:")
     (define (driver-loop)
      (prompt-for-input input-prompt)
      (let ((input (read)))
       (let ((output
              (actual-value
               input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)
      (driver-loop))
     #+END_SRC

     With these changes made, we can start the evaluator and test
     it. The successful evaluation of the try expression discussed in
     Section 4.2.1 indicates that the interpreter is performing lazy
     evaluation:

     #+BEGIN_SRC scheme
     (define the-global-environment (setup-environment))
     (driver-loop)
     ;;; L-Eval input:
     (define (try a b) (if (= a 0) 1 b))
     ;;; L-Eval value:
     ok
     ;;; L-Eval input:
     (try 0 (/ 1 0))
     ;;; L-Eval value:
     1
     #+END_SRC

**** Representing thunks
     Our evaluator must arrange to create thunks when procedures are
     applied to arguments and to force these thunks later. A thunk
     must package an expression together with the environment, so that
     the argument can be produced later. To force the thunk, we simply
     extract the expression and environment from the thunk and
     evaluate the expression in the environment. We use actual-value
     rather than eval so that in case the value of the expression is
     itself a thunk, we will force that, and so on, until we reach
     something that is not a thunk:

     #+BEGIN_SRC scheme
     (define (force-it obj)
      (if (thunk? obj)
          (actual-value (thunk-exp obj) (thunk-env obj))
          obj))
     #+END_SRC

     One easy way to package an expression with an environment is to
     make a list containing the expression and the environment. Thus,
     we create a thunk as follows:

     #+BEGIN_SRC
     (define (delay-it exp env)
      (list 'thunk exp env))
     (define (thunk? obj)
      (tagged-list? obj 'thunk))
     (define (thunk-exp thunk) (cadr thunk))
     (define (thunk-env thunk) (caddr thunk))
     #+END_SRC
     
     Actually, what we want for our interpreter is not quite this, but
     rather chunks that have been memoized. When a thunk is forced, we
     will turn it into an evaluated thunk by replacing the stored
     expression with its value and changing the thunk tag so that it
     can be recognized as already evaluated.

     #+BEGIN_SRC scheme
     (define (evaluated-thunk? obj)
      (tagged-list? obj 'evaluated-thunk))
     (define (thunk-value eavluated-thunk)
      (cadr evaluated-thunk))
     (define (force-it obj)
      (cond ((thunk? obj)
             (let ((result (actual-value (thunk-exp obj)
                                         (thunk-env obj))))
              (set-car! obj 'evaluated-thunk)
              (set-car! (cdr obj)             ;; replace exp with value
                        result)
              (set-cdr! (cdr obj)             ;; forget unneeded env.
                        '())
              result))
            ((evaluated-thunk? obj) (thunk-value obj))
            (else obj)))
     #+END_SRC

     Notice that the same delay-it procedure works both with and
     without memoization.

     - Exercise 4.27: Suppose we type in the following definitions to
       the lazy evaluator:

       #+BEGIN_SRC scheme
       (define count 0)
       (define (id x) (set! count (+ count 1)) x)
       #+END_SRC

       Give the missing values in the following sequence of
       interactions, and explain your answers.

       #+BEGIN_SRC scheme
       (define w (id (id 10)))
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       <response>
       ;;; L-Eval input:
       w
       ;;; L-Eval value:
       <response>
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       <response>
       #+END_SRC

       #+BEGIN_SRC scheme
       (define w (id (id 10)))
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       1
       ;;; L-Eval input:
       w
       ;;; L-Eval value:
       10
       ;;; L-Eval input:
       count
       ;;; L-Eval value:
       2
       #+END_SRC

       When we evaluate (define w (id (id 10))), the evaluator sees a
       define. eval-define then evals the expression (id (id 10))
       before assigning it to w. We see the application of id, and
       eval-sequence the body of id after thunkifying its
       arguments. The body is ((set! count (+ count 1)) x). We do the
       set since that is a separate syntactical construct not subject
       to laziness, and it uses a primitive procedure on the
       right-hand side of the assignment. So, count is altered to
       be 1. Then we see x, which in this case is a thunkified
       argument -- (thunk (id 10)). Since we are lazy, we return this
       value from eval, and w is assigned to (thunk (id 10)), the
       return value of the initial id call. So then when we ask for
       count without first evaluating w, we get 1. Then, we evaluate
       w, which forces the thunk. We eval the call (id 10) all the way
       through. The first thing is again set!, which increments count
       from 1 to 2. Then we return x, which is self-evaluating 10. So
       w is 10. Then, we ask for count and get the again-altered
       value, 2.

       - Exercise 4.28: eval uses actual-value rather than eval to
         evaluate the operator before passing it to apply, in order to
         force the value of the operator. Give an example that
         demonstrates the need for this forcing. 

	 #+BEGIN_SRC scheme
         (define (f g x) (* 2 (g x)))
	 #+END_SRC

	 Without actual-value, when we try to evaluate (g x), we
         lookup g and get a thunk and try to apply using a thunk,
         which is an unknown procedure type.

       - Exercise 4.29: Exhibit a program that you would expect to run
         much more slowly without memoization than with
         memoization. Also, consider the following interaction, where
         the id procedure is defined as in Exercise 4.27 and count
         starts at 0:

	 Any program that uses arguments multiple times will run more
         slowly without memoization, especially if you pass it a
         parameter that is a function call.

	 In fibo, for example, we test n twice, and then call fibo
         with (- n 1) and (- n 2). So, in the case where n is not 0 or
         1, we have to force the thunk a total of four times every
         call to fibo we make (which will be a lot of calls since it's
         multiply recursive).
	 #+BEGIN_SRC scheme
         (define (fibo n)
          (cond
           ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (fibo (- n 1)) (fibo (- n 2))))))
	 #+END_SRC

	 The ackermann function is worse, because of the call (a (-
         m 1) (a m (- n 1))). If we call a with a value where m and n
         are both greater than zero, we will have to call a with (a m
         (- n 1)) as n, and n will have to be forced in the cond
         condition clauses twice at least, and if it's still greater
         than 0, again in the final default case. This is a huge
         overhead since the thunk is a function call and not a simple
         variable lookup, and it will re-evaluate a potentially
         multiply-recursive call each time.
	 #+BEGIN_SRC scheme
         (define (a m n)
          (cond
           ((= m 0) (+ n 1))
           ((and (> m 0) (= n 0)) (a (- m 1) 1))
           (else (a (- m 1) (a m (- n 1))))))

	 #+END_SRC

	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         <response>
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         <response>
	 #+END_SRC

	 Give the responses both when the evaluator memoizes and when
         it does not.

	 memoized:
	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         100
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         1
	 #+END_SRC

	 non-memoized:

	 #+BEGIN_SRC scheme
         (define (square x) (* x x))
         ;;; L-Eval input:
         (square (id 10))
         ;;; L-Eval value:
         100
         ;;; L-Eval input:
         count
         ;;; L-Eval value:
         2
	 #+END_SRC

	 - Exercise 4.30: Cy D. Fect, a reformed C programmer, is
           worried that some side effects may never take place,
           because the lazy evaluator doesn't force the expressions in
           a sequence. Since the value of an expression in a sequence
           other than the last one is not used (the expression is
           there only for effect, such as assigning to a variable or
           printing), there can be no subsequent use of this value
           (e.g., as an argument to a primitive procedure) that will
           cause it to be forced. Cy thus thinks that when evaluating
           sequences, we must force all expressions in the sequence
           except the final one. He proposes to modify eval-sequence
           from Section 4.1.1 to use actual-value rather than eval:

	   #+BEGIN_SRC scheme
           (define (eval-sequence exps env)
            (cond ((last-exp? exps) (eval (first-exp exps) env))
                  (else (actual-value (first-exp exps) env)
                        (eval-sequence (rest-exps exps) env))))
	   #+END_SRC

	   a. Ben Bitdiddle thinks Cy is wrong. He shows Cy the
           for-each procedure described in Exercise 2.23, which gives
           an important example of a sequence with side effects:

	   #+BEGIN_SRC scheme
           (define (for-each proc items)
            (if (null? items)
                'done
                (begin (proc (car items))
                       (for-each proc (cdr items)))))
	   #+END_SRC

	   He claims that the evaluator in the text (with the original
           eval-sequence) handles this correctly:

	   #+BEGIN_SRC scheme
	   ;;; L-Eval input:
           (for-each (lambda (x) (newline) (display x))
                     (list  57 321 88))
           57
           321
           88
           ;;; L-Eval value:
           done
	   #+END_SRC

	   Explain why Ben is right about the behavior of for-each.

	   Although we don't evauate arguments to a procedure, we do
           recursively evaluate procedure applications, and any
           side-effect must be either a primitive or a syntactical
           eval-construct, which will get evaluated (like set!). In
           this example, newline and display are both primitives, so
           they have to be evaluated, we only thunk
           arguments. However, if we write a sequence where we have an
           evauation of an argument that has a side-effect, then the
           behavior will not be as simple.

	   

	   b. Cy agrees that Ben is right about the for-each example,
	   but says that that's not the kind of program he was
	   thinking about when he proposed his change to
	   eval-sequence. He defines the following two procedures in
	   the lazy evaluator:

	   #+BEGIN_SRC scheme
           (define (p1 x)
            (set! x (cons x '(2)))
            x)
           (define (p2 x)
            (define (p e)
             e
             x)
            (p (set! x (cons x '(2)))))
	   #+END_SRC

	   What are the values of (p1 1) and (p2 1) with the original
	   eval-sequence? What would the values be with Cy's proposed
	   change to eval-sequence?

	   (p1 1) is basically as expected since set! is a syntactical
	   construct and doesn't thunk its arguments, (cons x '(2)) is
	   also a primitive, so it forces the value of x. The returned
	   value is (1 2).

	   (p2 1) is different. The call to p will thunk the
	   expression (set! x (cons x '(2))). Then, e is
	   evaled. However, since all we do is lookup-variable-value
	   and don't actually force the thunk, e is never forced. x is
	   returned, unaltered. This is counterintuitive. The returned
	   value is the original value of x, 1. The set! was never
	   actually evaluated, because it was an argument and not an
	   application. So even though set! is a syntactical
	   construct, that didn't save it from being thunked and not
	   evaluated during the eval-sequence.

	   c. Cy also points out that changing eval-sequence as he
	   proposes does not affect the behavior of the example in
	   part a. Explain why this is true.

	   It doesn't change behavior because the only difference is
	   that he's forcing each expression, the expression in Ben's
	   example was already basically being 'forced' by the
	   primitives functions he was using. So there is no
	   difference.

	   d. How do you think sequence ought to be treated in the
	   lazy evaluator? Do you like Cy's approach, the approach in
	   the text, or some other approach?

	   Our evaluator has no way to, inside the language, force an
	   expression. So without this I think Cy's approach is best,
	   although the side effects themselves are probably examples
	   of bad programming practice, the behavior of p2 doesn't
	   make sense and we should try to make the results of the
	   evaluator make sense as much as possible, and it does not
	   make sense that some expressions would be effectively
	   unevaluated or unforced. However, if we could write a
	   'primtive' function or syntax that allows a programmer to
	   force values inside a begin, that might make more
	   sense. For the majority of applications, the current
	   evaluator works well, do just adding that would make sense
	   too.

         - Exercise 4.31: The approach taken in this section is
           somewhat unpleasant, because it makes an incompatible
           change to Scheme. It might be nicer to implement lazy
           evaluation as an _upward-compatible extension_, that is, so
           that ordinary Scheme programs will work as before.  We can
           do this by extending the syntax of procedure declarations
           to let the user control whether or not arguments are to be
           delayed. While we're at it, we may as well also give the
           user the choice between delaying with and without
           memoization. For example, the definition

	   #+BEGIN_SRC scheme
           (define (f a (b lazy) c (d lazy-memo))
            ...)
	   #+END_SRC

	   would define f to be a procedure of four arguments, where
           the first and third arguments are evaluated when the
           procedure is called, the second argument is delayed, and
           the fourth argument is both delayed and memoized. Thus,
           ordinary procedure definitions will produce the same
           behavior as ordinary Scheme, while adding the lazy-memo
           declaration to each parameter of every compound procedure
           will produce the behavior of the lazy evaluator defined in
           this section. Design and implement the changes required to
           produce such an extension to Scheme. You will have to
           implement new syntax procedures to handle the new syntax
           for define. You must also arrange for eval or apply to
           determine when arguments are to be delayed, and to force or
           delay arguments accordingly, and you must arrange for
           forcing to memoize or not, as appropriate.

*** 4.2.3 Streams as Lazy Lists
    In Section 3.4.1, we showed how to implement streams as delayed
    lists. We introduced special forms delay and cons-stream, which
    allowed us to construct a "promise" to compute the cdr of a
    stream, without actually fulfilling that promise until later. We
    could use this general technique of introducing special forms
    whenever we need more control over the evaluation process, but
    this is awkward. For one thing, a special form is not a
    first-class object like a procedure, so we cannot use it together
    with higher-order procedures. Additionally, we were forced to
    create streams as a new kind of data object similar but not
    identical to lists, and this required us to reimplement many
    ordinary list operations (map, append, and so on) for use with
    streams.

    With lazy evaluation, streams and lists can be identical, so there
    is no need for special forms or for separate list and stream
    operations. All we need to do is arrange matters so that cons is
    non-strict. One way to accomplish this is to extend the lazy
    evaluator to allow for non-strict primitives, and to implement
    cons as one of these. An easier way is to recall (Section 2.1.3)
    that there is no fundamental need to implement cons as a primitive
    at all. Instead, we can represent pairs as procedures:

    #+BEGIN_SRC scheme
    (define (cons x y) (lambda (m) (m x y)))
    (define (car z) (z (lambda (p q) p)))
    (define (cdr z) (z (lambda (p q) q)))
    #+END_SRC

    In terms of these basic operations, the standard definitions of
    the list operations will work with infinite lists (streams) as
    well as finite ones, and the stream operations can be implemented
    as list operations. Here are some examples:

    #+BEGIN_SRC scheme
    (define (list-ref items n)
     (if (= n 0)
         (car items)
         (list-ref (cdr items) (- n 1))))
    (define (map proc items)
     (if (null? items)
         '()
         (cons (proc (car items))
               (map proc (cdr items)))))
    (define (scale-list items factor)
     (map (lambda (x) (* x factor)) items))

    (define (add-lists list1 list2)
     (cond ((null? list1) list2)
           ((null? list2) list1)
           (else (cons (+ (car list1) (car list2))
                       (add-lists (cdr list1) (cdr list2))))))
    (define ones (cons 1 ones))
    (define integers (cons 1 (add-lists ones integers)))
    ;;; L-Eval input:
    (list-ref integers 17)
    ;;; L-Eval value:
    18
    #+END_SRC

    Note that these lazy lists are even lazier than the streams of
    Chapter 3: The car of the list, as well as the cdr, is delayed. In
    fact, even accessing the car or cdr of a lazy pair need not force
    the value of a list element. The value will be forced only when it
    is really needed -- e.g., for use as the argument of a primitive,
    or to be printed as an answer.

    Lazy pairs also help with the problem that arose with streams in
    Section 3.5.4, where we found that formulating stream models of
    systems with loops may require us to sprinkle our programs with
    explicit delay operations, beyond the ones supplied by
    cons-stream. With lazy evaluation, all arguments to procedures are
    delayed uniformly. For instance, we can implement procedures to
    integrate lists and solve differential equations as we originally
    intended in Section 3.5.4:

    #+BEGIN_SRC scheme
    (define (integral integrand initial-value dt)
     (define int
      (cons initial-value
            (add-lists (scale-list integrand dt) int)))
     int)

    (define (solve f y0 dt)
     (define y (integral dy y0 dt))
     (define dy (map f y))
     y)
    ;;; L-Eval input:
    (list-ref (solve (lambda (x) x) 1 0.001) 1000)
    ;;; L-Eval value:
    2.716924
    #+END_SRC

    - Exercise 4.32: Give some examples that illustrate the difference
      between the streams of Chapter 3 and the "lazier" lazy lists
      described in this section. How can you take advantage of this
      extra laziness?

      The full laziness allows us to have infinite car components. So
      for exmaple,

      #+BEGIN_SRC scheme
      (define (infinite-tree a b)
       (cons (infinite-tree b a) (infinite-tree a b)))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (pt n)
       (cons (pt-list n) (pt (+ n 1))))


      (define (pt-list n)
       (cond
        ((= n 0) ones)
        ((= n 1) integers)
        (else (pt-rec 0 (pt-list (- n 1)) 0))))

       (define (pt-rec i side-list last-element)
        (cond
         ((= i 0) (cons 1 (pt-rec 1 (cdr side-list) 1)))
         (else (let ((new-elem (+ last-element (car side-list))))
                (cons new-elem
                      (pt-rec (+ i 1) (cdr side-list)))))))
      #+END_SRC
   
      is possible. Even using cons-stream, calling this function in
      our normal evaluator would never end. Another example is that we
      can take as arguments non-terminating expressions, and put them
      into lists, even the car.

      (define x (let ((a <some-infinite-expression>)
                      (b <some-other-infinite-expression>))
                 (cons a b)))

      However, what's a little more interesting is that since we
      package an environment in our thunks, it can get modified after
      the fact.

      #+BEGIN_SRC scheme
      (define (solve-2nd f dt y0 dy0)
       (define y (integral
                  dy
                  y0
                  dt))
       (define dy (integral
                   ddy
                   dy0
                   dt))
      (define ddy (stream-map f y dy))
      y)
      #+END_SRC

      This function can now stand on its own. That's because we don't
      force the arguments dy or ddy. So they don't have to mean
      anything until we start referencing items of the list, this
      would not have happened just using lazy streams, we had to delay
      manually, creating a bit of a mess. Now we don't need that.

    - Exercise 4.33: Ben Bitdiddle tests the lazy list implementation
      given above by evaluating the expression:

      #+BEGIN_SRC scheme
      (car '(a b c))
      #+END_SRC
      
      To his surprise, this produces an error. After some thought, he
      realizes that the "lists" obtained by reading in quoted
      expressions are different from the lists manipulated by the new
      definitions of cons, car, and cdr. Modify the evaluator's
      treatment of quoted expressions so that that quoted lists typed
      at the driver loop will produce true lazy lists.

    - Exercise 4.34: Modify the driver loop for the evaluator so that
      lazy pairs and lists will print in some reasonable way. (What
      are you going to do about infinite lists?) You may also need to
      modify the representation of lazy pairs so that the evaluator
      can identify them in order to print them.

      We can handle some infinite lists by checking if the current
      list is identical to the cdr of the current list (using equal?
      which compares the actual functions in the underlying
      scheme), and outputting a symbol like '<infinite-list> in that
      event. However, this doesn't handle all infinite lists. If we
      make a list like this:

      #+BEGIN_SRC scheme
      (define ones (cons 1 ones))
      (define integers (cons 1 (add-lists integers ones)))
      #+END_SRC

      Our new procedure can handle ones, but it can't handle
      integers. The only way to handle integers is to 

      1.) Set a limit on the number of items printed for any list.
      2.) Somehow analyze the procedure to tell if it doesn't
      terminate.

      (2) is probably not possible and obviously overkill, so the
      practical solution is to define a global variable that is the
      max number of items to print and add a check to our printing
      procedure. We can then insert the symbol ... as the last element
      printed to indicate there are more items.

** 4.3 Variations on a Scheme -- Nondeterministic Computing

   In this section, we extend the Scheme evaluator to support a
   programming paradigm called _nondeterministic computing_ by
   building into the evaluator a facility to support automatic
   search. This is a much more profound change to the language than
   the introduction of lazy evaluation in Section 4.2.
   
   Nondeterministic computing, like stream processing, is useful for
   "generate and test" applications. Consider the task of starting
   with two lists of positive integers and finding a pair of integers
   -- one from the first list and one from the second list -- whose
   sum is prime. We saw how to handle this with finite sequence
   operations in Section 2.2.3 and with infinite streams in Section
   3.5.3. Our approach was to generate the sequence of all possible
   pairs and filter these to select the pairs whose sum is
   prime. Whether we actually generate the entire sequence of pairs
   first as in Chapter 2, or interleave the generating and filtering
   as in Chapter 3, is immaterial to the essential image of how the
   computation is organized. 

   The nondeterministic approach evokes a different image. Imagine
   simply that we choose (in some way) a number from the first list
   and a number from the second list and require (using some
   mechanism) that their sum be prime. This is expressed by following
   procedure:

   #+BEGIN_SRC scheme
   (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
     (require (prime? (+ a b)))
     (list a b)))
   #+END_SRC

   It might seem as if this procedure merely restates the problem,
   rather than specifying a way to solve it. Nevertheless, this is a
   legitimate nondeterministic program. 

   The key idea here is that expressions in a nondeterministic
   language can have more than one possible value. For instance,
   an-element-of might return any element of the given list. Our
   nondeterministic program might return any element of a given
   list. Our nondeterministic program evaluator will work by
   automatically choosing a possible value and keeping track of the
   choice. If a subsequent requirement is not met, the evaluator will
   try a different choice, and it will keep trying new choices until
   the evaluation succeeds, or until we run out of choices. Just as
   the lazy evaluator freed the programmer from the details of how
   values are delayed and forced, the nondeterministic program
   evaluator will free the programmer from the details of how choices
   are made.

   It is instructive to contrast the different images of time evoked
   by nondeterministic evaluation and stream processing. Stream
   processing uses lazy evaluation to decouple the time when the
   stream of possible answers is assembled from the time when the
   actual stream elements are produced. The evaluator supports the
   illusion that all the possible answers are laid out before us in a
   timeless sequence. With nondeterministic evaluation, an expression
   represents the exploration of a set of possible worlds, each
   determined by a set of choices. Some of the possible worlds lead to
   dead ends, while others have useful values. The nondeterministic
   program evaluator supports the illusion that time branches, and
   that our programs have different possible execution histories. When
   we reach a dead end, we can revisit a previous choice point and
   proceed along a different branch.

   The nondeterministic program evaluator implemented below is called
   the amb evaluator because it is based on a new special form called
   amb. We can type the above definition of prime-sum-pair at the amb
   evaluator driver loop (along with definitions of prime?,
   an-element-of, and require) and run the procedure as follows:

   #+BEGIN_SRC scheme
   ;;; Amb-Eval input: 
   (prime-sum-pair '(1 3 5 8) '(20 35 110))
   ;;; Starting a new problem
   ;;; Amb-Eval value:
   (3 20)
   #+END_SRC
   
   The  value returned was obtained after the evaluator repeatedly
   chose elements from each of the lists, until a successful choice
   was made. 

   Section 4.3.1 introduces amb and explains how it supports
   nondeterminism through the evaluator's automatic search
   mechanism. Section 4.3.2 presents examples of nondeterministic
   programs, and Section 4.3.3 gives the details of how to implement
   the amb evaluator by modifying the ordinary Scheme evaluator.

*** 4.3.1 Amb and Search
    To extend Scheme to support nondeterminism, we introduce a new
    special form called amb. The expression

    #+BEGIN_SRC scheme
    (amb <e1> <e2> ... <en>)
    #+END_SRC

    return the value of one of the n expressions <e1> "ambiguously."
    For example, the expression

    #+BEGIN_SRC scheme
    (list (amb 1 2 3) (amb 'a 'b))
    #+END_SRC

    can have six possible values:

    #+BEGIN_SRC scheme
    (1 a) (1 b) (2 a ) (2 b) (3 a) (3 b)
    #+END_SRC

    amb with a single choice produces an ordinary (single) value. 

    amb with no choices - the expression (amb) - is an expression with
    no acceptable values. Operationally, we can think of (amb) as an
    expression that when evaluated causes the computation to "fail":
    The computation aborts and no value is produced. Using this idea,
    we can express the requirement that a particular predicate
    expression p must be true as follows:

    #+BEGIN_SRC scheme
    (define (require p) (if (not p) (amb)))
    #+END_SRC

    With amb and require, we can implement the an-element-of procedure
    used above:

    #+BEGIN_SRC scheme
    (define (an-element-of items)
     (require (not (null? items)))
     (amb (car items) (an-element-of (cdr items))))
    #+END_SRC

    an-element-of fails if the list is empty. Otherwise it ambiguously
    returns either the first element of the list or an element chosen
    from the rest of the list.

    We can also express infinite ranges of choices. The following
    procedure potentially returns any integer greater than or equal to
    some given n:

    #+BEGIN_SRC scheme
    (define (an-integer-starting-from n)
     (amb n (an-integer-starting-from (+ n 1))))
    #+END_SRC

    This is like the stream procedure integers-starting-from described
    in Section 3.5.2, but with an important difference: The stream
    procedure returns an object that represents the sequence of all
    integers beginning with n, whereas amb returns a single integer.

    Abstractly, we can imagine that evaluating an amb expression
    causes time to split into branches, where the computation
    continues on each branch with one of the possible values of the
    expression. We say that amb represents a _nondeterministic choice
    point._ If we had a machine with a sufficient number of processors
    that could be dynamically allocated, we could implement the search
    in a straightforward way. Execution would proceed as in a
    sequential machine, until an amb expression is encoutered. At this
    point, more processors would be allocated and initialized to
    continue all of the parallel executions implied by the
    choice. Each processor would proceed sequentially as if it were
    the only choice, until it either terminates by encountering a
    failure, or it further subdivides, or it finishes.

    On the other hand, if we have a machine that can execute only one
    process (or a few concurrent processes), we must consider the
    alternatives sequentially. One could imagine modifying an
    evaluator to pick at random a branch to follow whenever it
    encounteres a choice point.

    Random choice, however, can easily lead to failing values. We
    might try running the evaluator over and over, making random
    choices and hoping to find a non-failing value, but it is better
    to _systematically search_ all possible execution paths. This amb
    evaluator that we will develop and work with in this section
    implements a systematic search as follows: When the evaluator
    encounters an application of amb, it initially selects the first
    alternative. This selection may itself lead to a further
    choice. The evaluator will always initially choose the first
    alternative at each choice point. If a choice results in a
    failure, then the evaluator automatically _backtracks_ to the most
    recent choice point and tries the next alternative. If it runs out
    of alternatives at any choice point, the evaluator will back up
    to the previous choice point and resume from there. This process
    leads to a search strategy known as _depth-first search_ or
    _chronological backtracking_. 

    
**** Driver loop
     The driver loop for the amb evaluator has some unusual
     properties. It reads an expression and prints the value of the
     first non-failing execution, as in the prime-sum-pair example
     shown above. If we want to see the value of the next successful
     execution, we can ask the interpreter to backtrack and attempt to
     generate a second non-failing execution. This is signaled by
     typing the symbol try-again. If any expression except try-again
     is given, the interpreter will start a new problem, discarding
     the unexplored alternatives in the previous problem. Here is a
     sample interaction:

     #+BEGIN_SRC scheme
     ;;; Amb-Eval input:
     (prime-sum-pair '(1 3 5 8) '(20 35 110))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (3 20)

     ;;; Amb-Eval input:
     try-again
     ;;; Amb-Eval value:
     (3 110)

     ;;; Amb-Eval input:
     try-again
     ;;; Amb-Eval value:
     (8 35)

     ;;; Amb-Eval input:
     try-again
     ;;; There are no more values of
     (prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))

     ;;; Amb-Eval input:
     (prime-sum-pair '(19 27 30) '(11 36 58))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (30 11)
     #+END_SRC

     - Exercise 4.35: Write a procedure an-integer-between that
       returns an integer between two given bounds. This can be used
       to implement a procedure that finds Pythagorean triples, i.e.,
       triples of integers (i, j, k) between the given bounds such
       that i <= j and i^2 + j^2 = k^2, as follows:

       #+BEGIN_SRC scheme
       (define (a-pythagorean-triple-between low high)
        (let ((i (an-integer-between low high))
              (hsq (* high high)))
         (let ((j (an-integer-between i high)))
          (let ((ksq (+ (* i i) (* j j))))
           (require (>= hsq ksq))
           (let ((k (sqrt ksq)))
            (require (integer? k))
            (list i j k))))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (an-integer-after n)
        (amb n (an-integer-after (+ 1 n))))
       (define (an-integer-between low high)
        (let ((x (an-integer-after low)))
         (require (< x high))
         x))
       #+END_SRC

*** 4.3.2 Examples of Nondeterministic Programs

    Section 4.3.3 describes the implementation of the amb
    evaluator. First, however, we give some examples of how it can be
    used. The advantage of nondeterministic programming is that we can
    suppress the details of how search is carried out, thereby
    expressing our programs at a higher level of abstraction.
    
**** Logic Puzzles

     The following puzzle (taken from Dinesman 1968) is typical of a
     large class of simple logic puzzles:

     Baker, Cooper, Fletcher, Miller, and Smith live on different
     floors of an apartment house that contains only five floors. Baker
     does not live on the top floor. Cooper does not live on the
     bottom floor. Fletcher does not live on either the top or the
     bottom floor. Miller lives on a higher floor than does
     Cooper. Smith does not live on a floor adjacent to
     Cooper's. Where does everyone live?

     We can determine who lives on each floor in a straightforward way
     by enumerating all the possibilities and imposing the given
     restrictions:

     #+BEGIN_SRC scheme
     (define (multiple-dwelling)
      (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
            (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
            (smith    (amb 1 2 3 4 5)))
       (require 
        (distinct? (list baker cooper fletcher miller smith)))
       (require
        (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (> miller cooper))
       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))
       (list (list 'baker baker)       (list 'cooper cooper)
             (list 'fletcher fletcher) (list 'miller miller)
             (list 'smith smith))))
     #+END_SRC 
    
     Evaluating the expression (multiple-dwelling) produces the result

     ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))

     Although this simple procedure works, it is very slow. Exercise
     4.39 and Exercise 4.40 discuss some possible improvements.

     - Exercise 4.38: Modify the multiple-dwelling procedure to omit
       the requirement that Smith and Fletcher do not live on adjacent
       floors. How many solutions are there to this modified puzzle?

       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
              (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
              (smith    (amb 1 2 3 4 5)))
         (require 
          (distinct? (list baker cooper fletcher miller smith)))
         (require
          (not (= baker 5)))
         (require (not (= cooper 1)))
         (require (not (= fletcher 5)))
         (require (not (= fletcher 1)))
         (require (> miller cooper))
         (require (not (= (abs (- fletcher cooper)) 1)))
         (list (list 'baker baker)       (list 'cooper cooper)
               (list 'fletcher fletcher) (list 'miller miller)
               (list 'smith smith))))
       #+END_SRC

       There are now five solutions.

     - Exercise 4.39: Does the order of the restrictions in the
       multiple-dwelling procedure affect the answer? If you think it
       matters, demonstrate a faster program obtained from the given
       one by reordering the restrictions. If you think it does not
       matter, argue your case.

       It should affect run time, but not the actual result. If we can
       remove a large number of options quickly without imposing other
       restrictions that eliminate fewer options, we should have many
       fewer steps to make.
   
       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
              (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
              (smith    (amb 1 2 3 4 5)))

         (require (> miller cooper))
         (require (not (<= (abs (- fletcher cooper)) 1)))
         (require (not (<= (abs (- smith fletcher)) 1)))
         (require
          (not (= baker 5)))
         (require (not (= cooper 1)))
         (require (not (= fletcher 5)))
         (require (not (= fletcher 1)))
         (require 
          (distinct? (list baker cooper fletcher miller smith)))
         (list (list 'baker baker)       (list 'cooper cooper)
               (list 'fletcher fletcher) (list 'miller miller)
               (list 'smith smith))))
       #+END_SRC

       This eliminates more possibilities quicker. (require (not (=
       baker 5))) only examines one item, baker, and doesn't actually
       eliminate many possibilities. But (require (> miller cooper))
       eliminates quite a few that would pass other requirements
       quickly, but without taking more runtime than a simple =
       call. So does the adjacency rule, since they affect more than
       just one list of possibilities. Additionally, distinct? is very
       slow, so we move it last, and make sure we eliminate as many
       'low-hanging-fruit' possibilities as possible before calling
       it.

     - Exercise 4.40: In the multiple dwelling problem, how many sets
       of assignments are there of people to floors, both before and
       after the requirement that floor assignments be distinct? It is
       very inefficient to generate all possible assignments of people
       to floors and then leave it to backtracking to eliminate
       them. For example, most of the restrictions depend on only one
       or two of the person-floor variables, and can thus be imposed
       before floors have been selected for all the people. Write and
       demonstrate a much more efficient nondeterministic procedure
       that solves this problem based upon generating only those
       possibilities that are not already ruled out by previous
       restrictions. (Hint: This will require a nest of let
       expressions.)

       Before we do any operations, we have 5 * 5 * 5 * 5 * 5 = 3125
       different floor assignments that we have to sort through with
       distinct? in the way it's written originally. After, it's 5! =
       120 unique sets of floor assignments, still a lot, before we
       eliminate things that were easy to eliminate in the first
       place, for example, all the floor assignments where miller is on 1. 

       #+BEGIN_SRC scheme
       (define (multiple-dwelling)
        (let ((baker (amb 1 2 3 4 5)))
         (require (not (= baker 5)))
         (let ((cooper (amb 1 2 3 4 5)))
          (require (not (= cooper 1)))
          (let ((miller (amb 1 2 3 4 5)))
           (require (> miller cooper))
           (let ((fletcher (amb 1 2 3 4 5)))
            (require (not (= fletcher 1)))
            (require (not (= fletcher 5)))
            (require (not (= (abs (- cooper fletcher)) 1)))
            (let ((smith (amb 1 2 3 4 5)))
             (require (not (= (abs (- smith fletcher)) 1)))
             (require 
              (distinct? (list baker cooper miller fletcher smith)))
             (list (list 'baker baker) (list 'cooper cooper)
                   (list 'fletcher fletcher) (list 'miller miller)
                   (list 'smith smith))))))))     
       #+END_SRC

     - Exercise 4.41: Write an ordinary Scheme program to solve the
       multiple dwelling puzzle.

       #+BEGIN_SRC scheme
       (define (distinct? a-list)
        (cond ((null? a-list) true)
              ((member (car a-list) (cdr a-list))
               false)
              (else 
               (distinct? (cdr a-list)))))
       (define (satisfies? baker cooper smith fletcher miller)
        (and
         (> miller cooper)
         (> (abs (- cooper fletcher)) 1)
         (> (abs (- smith fletcher)) 1)
         (not (= cooper 1))
         (not (= baker 5))
         (not (= fletcher 1))
         (not (= fletcher 5))
         (distinct? (list baker cooper smith fletcher miller))))

       (define (permute-one start max proc list-of-lists)
        (cond
         ((= start max) '())
         (else
          (append
           (map (lambda (alist) (proc start alist))
                list-of-lists)
           (permute-one (+ start 1) max proc list-of-lists)))))

       (define (count-up start max)
        (if (= start max) '()
            (cons (list start) (count-up (+ start 1) max))))
       (define (permutations start max in)
        (if (= in 1)
            (count-up start max)
            (permute-one
             start max
             (lambda (i alist)
              (cons i alist))
              (permutations start max (- in 1)))))
              
       (define (initial-floor-listing) 
         (permutations 1 6 5))

       (define (generate-next-floor-listing listof-floors)
         (cdr listof-floors))
       (define (bakers-floor floor-list) (list-ref (car floor-list) 0))
       (define (smiths-floor floor-list) (list-ref  (car floor-list) 1))
       (define (millers-floor floor-list) (list-ref  (car floor-list) 2))
       (define (fletchers-floor floor-list) (list-ref  (car floor-list) 3))
       (define (coopers-floor floor-list) (list-ref  (car floor-list) 4))

       (define (multiple-dwelling listof-floors)
        (cond 
           ((null? listof-floors) (error "No solution")) 
           ((satisfies? 
             (bakers-floor listof-floors)
             (coopers-floor listof-floors)
             (smiths-floor listof-floors)
             (fletchers-floor listof-floors)
             (millers-floor listof-floors))
            (list 
             (list 'miller (millers-floor listof-floors))
             (list 'smith (smiths-floor listof-floors))
             (list 'fletcher (fletchers-floor listof-floors))
             (list 'baker (bakers-floor listof-floors))
             (list 'cooper (coopers-floor listof-floors))))
            (else (multiple-dwelling (generate-next-floor-listing listof-floors)))))
       #+END_SRC

     - Exercise 4.42: Solve the following "Liars" puzzle (from
       Phillips 1934):

       Five schoolgirls sat for examination. Their parents -- so they
       thought -- showed an undue degree of interest in the
       result. They therefore agreed that, in writing home about the
       examination, each girl should make one true statement and one
       untrue one. The following are the relevant passages from their
       letters:

       - Betty: "Kitty was second in the examination. I was only third."

       - Ethel: "You'll be glad to hear that I was on top. Joan was 2nd."

       - Joan: "I was third, and poor old Ethel was bottom."

       - Kitty: "I came out second. Mary was only fourth."

       - Mary: "I was fourth. Top place was taken by Betty."

	 What in fact was the order in which the five girls were
         placed?


	 To write a program, we can use amb or just a normal scheme
         program. For an amb program, we can generate all possible
         permutations of statements. For example,

	 For betty: Kitty was second, Betty was third.

	 For Ethel: Ethel was first, Joan was second.

	 Then we examine for contradictions -- No statements must say
         that someone was in two places at once, or that one place was
         occupied by two people. We can represent statements:

	 #+BEGIN_SRC scheme
         (define (make-statement person place)
          (list person place))
         (define (statement-person a-statement) (car a-statement))
         (define (statement-place a-statement) (cadr a-statement))
	 #+END_SRC

	 OUr initial statements may look like this:
	 
	 #+BEGIN_SRC scheme
         (define betty-statements (list
                                    (make-statement 'betty 3)
                                    (make-statement 'kitty 2)))
         (define ethel-statements (list
                                   (make-statement 'ethel 1)
                                   (make-statement 'joan 2)))
         (define joan-statements (list
                                  (make-statement 'joan 3)
                                  (make-statement 'ethel 5)))
         (define kitty-statements (list
                                   (make-statement 'kitty 2)
                                   (make-statement 'mary 4)))
         (define mary-statements (list
                                  (make-statement 'betty 1)
                                  (make-statement 'mary 4)))  
	 #+END_SRC
	 
	 #+BEGIN_SRC scheme
           (define (make-statement-with-truth statement truthvalue)
             (cons statement truthvalue))
           (define (statement-with-truth-statement statement-with-truth)
             (car statement-with-truth))
           (define (statement-with-truth-truth statement-with-truth)
             (cdr statement-with-truth))
           (define (statement-with-truth-person statement-with-truth)
             (statement-person (statement-with-truth-statement statement-with-truth)))
           (define (statement-with-truth-place statement-with-truth)
             (statement-place (statement-with-truth-statement statement-with-truth)))
           (define (one-amb-statement a-statement)
             (amb (list (make-statement-with-truth (car a-statement) true)
                        (make-statement-with-truth (cadr a-statement) false))
                  (list (make-statement-with-truth (car a-statement) false)
                        (make-statement-with-truth (cadr a-statement) true))))
           (define (generate-statement-set statements)
             (if (null? statements)
                 '()
                 (append (one-amb-statement (car statements)) 
                       (generate-statement-set (cdr statements)))))

           (define (get-true-statements statements)
             (if (null? statements)
                 '()
                 (if (statement-with-truth-truth (car statements))
                     (cons (car statements) (get-true-statements (cdr statements)))
                     (get-true-statements (cdr statements)))))

           (define (require-no-same-place statements)
             (define (is-other-in-same-place? statement statements)
               (cond
                ((null? statements) false)
                ((and (= (statement-with-truth-place statement)
                         (statement-with-truth-place (car statements)))
                      (not (eq? (statement-with-truth-person statement)
                                (statement-with-truth-person (car statements)))))
                 true)
                (else (is-other-in-same-place? statement (cdr statements)))))
             (let ((true-statements (get-true-statements statements)))
               (define (iter-statements current-statement-list)
                 (if (null? current-statement-list) true
                     (begin
                       (require (not (is-other-in-same-place? (car current-statement-list)
                                                              (cdr current-statement-list))))
                       (iter-statements (cdr current-statement-list)))))
               (iter-statements true-statements)))

           (define (no-true-and-false statements)
             (define (no-duplicates a-statement statement-list)
               (if (null? statement-list)
                   true
                   (let ((statement-from-list (car statement-list)))
                     (and (or
                           (not (eq? (statement-with-truth-person statement-from-list)
                                     (statement-with-truth-person a-statement)))
                           (and (=
                                 (statement-with-truth-place a-statement)
                                 (statement-with-truth-place statement-from-list))
                                (eq?
                                 (statement-with-truth-truth a-statement)
                                 (statement-with-truth-truth statement-from-list)))
                           (and (false? (statement-with-truth-truth a-statement))
                                (false? (statement-with-truth-truth statement-from-list)))
                           (and (not (= (statement-with-truth-place a-statement)
                                        (statement-with-truth-place statement-from-list)))
                                (not (eq?
                                      (statement-with-truth-truth a-statement)
                                      (statement-with-truth-truth statement-from-list)))))
                          (no-duplicates a-statement (cdr statement-list))))))
             (if (null? statements)
                 true
                 (begin
                    (and (no-duplicates (car statements) (cdr statements))
                         (no-true-and-false (cdr statements))))))

           (define (require-no-contradictions statements)
             (require (no-true-and-false statements))
             (require-no-same-place statements)
             statements)

	 #+END_SRC

	 #+BEGIN_SRC scheme
         (define all-statements (list betty-statements
                                      ethel-statements
                                      joan-statements
                                      kitty-statements
                                      mary-statements))
         (define (get-placings)
          (let ((statement-set (generate-statement-set all-statements)))
           (require-no-contradictions statement-set)))
	 #+END_SRC

	 Our program tells us that the order is
	 kitty joan betty mary ethel

       - Exercise 4.43; use the amb evaluator to solve the following
         puzzle:
	 
	 Mary Ann Moore's father has a yacht and so has each of his
         four friends: Colonel Downing, Mr. Hall, Sir Barnacle Hood,
         and Dr. Parker. Each of the five also has one daughter and
         each has named his yacht after a daughter of one of the
         others. Sir Barnacle's yacht is the Gabrielle, Mr. Moore owns
         the Lorna; Mr. Hall the Rosalind. The Melissa, owned by
         Colonel Downing, is named after Sir Barnacle's
         daughter. Gabrielle's father owns the yacht that is named
         after Dr. Parker's daughter. Who's Lorna's father?

	 #+BEGIN_SRC scheme
         (define (make-relation father daughter boat-name)
          (list father daughter boat-name))
         (define (relation-father r)
          (car relation))
         (define (relation-daughter r)
          (cadr relation))
         (define (relation-boat-name r)
          (caddr r))
         
         (define (require-sane-single relation)
          (require (not (eq? (relation-daughter relation)
                             (relation-boat-name relation)))))
         (define (require-no-multi-fathers relation relations)
          (let ((father (relation-father relation)))
           (require (null? (filter 
                            (lambda (r) (eq? (relation-father r) father)))))))
         (define (require-no-multi-daughters relation relations)
          (let ((daughter relation-daughter relation))
           (require (null? (filter 
                            (lambda (r) (eq? (relation-daughter r) daughter)))))))
         (define (require-sane-relations relation-list)
           (cond
            ((null? relation-list) true)
            (else
             (require-sane-single (car relation-list))
             (require-no-multi-fathers (car relation-list) (cdr relation-list))
             (require-no-multi-daughters (car relation-list) (cdr relation-list)))))

         (let ((base-relations
                (list (make-relation 'mr-moore 'mary-ann 'lorna)
                      (make-relation 'cd 
                                     'melissa 
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'mr-hall
                                     'rosalind
                                     (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'dr-parker
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa)
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa))
                      (make-relation 'sir-barnacle
                                      (amb 'mary-ann 'lorna 'gabrielle 'rosalind 'melissa)
                                      'melissa))))
            (require-sane-relations base-relations)
            base-relations)
	 #+END_SRC

       - Exercise 4.44: Exercise 2.42 described the "eight-queens
         puzzle" of placing queens on a chessboard so that no two
         attack each other. Write a nondeterministic program to solve
         this puzzle.

	 #+BEGIN_SRC scheme
           (define (require x) (if (not x) (amb)))
           (define (make-queen x y)
             (list x y))
           (define (queen-row q) (car q))
           (define (queen-col q) (cadr q))
           (define (queen-endangers? q1 q2)
             (or
              (= (abs (- (queen-row q1)
                         (queen-row q2)))
                 (abs (- (queen-col q1)
                         (queen-col q2))))
              (= (queen-row q1) (queen-row q2))
              (= (queen-col q1) (queen-col q2))))

           (define (possible-queen-rows rowsize)
             (if (= rowsize 1) (amb 1)
                 (amb rowsize (possible-queen-rows (- rowsize 1)))))

           (define (possible-queen-cols colsize)
             (if (= colsize 1) (amb 1)
                 (amb colsize (possible-queen-cols (- colsize 1)))))

           (define NQUEENS 8)

           (define (require-no-identical-positions listof-queens)
             (define (require-positions-different
                      a-queen
                      other-queens)
               (if (null? other-queens) true
                   (let ((other-queen (car other-queens)))
                     (require
                      (not (= (queen-row other-queen)
                              (queen-row a-queen))))
                     (require
                      (not (= (queen-col other-queen)
                              (queen-col a-queen))))
                     (require
                      (not (queen-endangers? a-queen other-queen)))
                     (require-positions-different
                      a-queen
                      (cdr other-queens)))))
             (if
              (null? listof-queens) true
              (begin
                (require-positions-different
                 (car listof-queens)
                 (cdr listof-queens))
                (require-no-identical-positions
                 (cdr listof-queens)))))

           (define (gen-queens nqueens)
             (if (= nqueens 0) '()
                 (cons (make-queen (possible-queen-rows nqueens)
                                   (possible-queen-cols nqueens))
                       (gen-queens (- nqueens 1)))))

           (let ((listof-queens (gen-queens NQUEENS)))
             (require-no-identical-positions listof-queens)
             listof-queens)
	 #+END_SRC
**** Parsing natural language
     Programs designed to accept natural language as input usually
     start by attempting to _parse_ the input, that is, to match the
     input against some grammatical structure. For example, we might
     try to recognize simple sentences consisting of an article
     followed by a noun followed by a verb, such as "The cat eats." To
     accomplish such an analysis, we must be able to identify the
     parts of speech of individual words. We could start with some
     lists that classify various words:

     #+BEGIN_SRC scheme
     (define nouns '(noun student professor cat class))
     (define verbs '(verb studies lectures eats sleeps))
     (define articles '(article the a))
     #+END_SRC

     We also need a _grammar_, that is, a set of rules describing how
     grammatical elements are composed from simpler elements. A very
     simple grammar might stipulate that a sentence always consists of
     two pieces -- a noun phrase followed by a verb -- and that a noun
     phrase consists of an article followed by a noun. WIth this
     grammar, the sentence "The cat eats" is parsed as follows:

     #+BEGIN_SRC scheme
     (sentence (noun-phrase (article the) (noun cat)) (verb eats))
     #+END_SRC

     We can generate such a parse with a simple program that has
     separate procedures for each of the grammatical rules. To parse a
     sentence, we identify its two constituent pieces and return a
     list of these two elements, tagged with the symbol sentence:

     #+BEGIN_SRC scheme
     (define (parse-sentence)
      (list 'sentence
            (parse-noun-phrase)
            (parse-word verbs)))
     #+END_SRC

     A noun phrase, similarly, is parsed by finding an article
     followed by a noun:

     #+BEGIN_SRC scheme
     (define (parse-noun-phrase)
      (list 'noun-phrase
            (parse-word articles)
            (parse-word nouns)))
     #+END_SRC

     At the lowest level, parsing boils down to repeatedly checking
     that the next unparsed word is a member of the list of words for
     the required part of speech. To implement this, we maintain a
     global variable \*unparsed\*, which is the input that has not yet
     been parsed. Each time we check a word, we require that
     \*unparsed\* must be non-empty and that it should begin with a
     word from the designated list. If so, we remove that word from
     \*unparsed\* and return the word together with its part of speech
     (which is found at the head of the list):

     #+BEGIN_SRC scheme
     (define (parse-word word-list)
      (require (not (null? *unparsed*)))
      (require (memq (car *unparsed*) (cdr word-list)))
      (let ((found-word (car *unparsed*)))
       (set! *unparsed* (cdr *unparsed*))
       (list (car word-list) found-word)))
     #+END_SRC

     To start the parsing, all we need to do is set \*unparsed\* to be
     the entire input, try to parse a sentence, and check that nothing
     is left over:

     #+BEGIN_SRC scheme
     (define *unparsed* '())
     (define (parse input)
      (set! *unparsed* input)
      (let ((sent (parse-sentence)))
       (require (null? *unparsed*)) sent))
     #+END_SRC

     We can now try the parser and verify that it works for our simple
     test sentence:

     #+BEGIN_SRC scheme
     ;;; Amb-Eval input:
     (parse '(the cat eats))
     ;;; Starting a new problem
     ;;; Amb-Eval value:
     (sentence (noun-phrase (article the) (noun cat)) (verb eats))
     #+END_SRC

     The amb evaluator is useful here because it is convenient to
     express the parsing constraints with the aid of
     require. Automatic search and backtracking really pay off,
     however, when we consider more complex grammars where there are
     choices for how the units can be decomposed.

     Let's add to our grammar a list of prepositions:

     #+BEGIN_SRC scheme
     (define prepositions '(prep for to in by with))
     #+END_SRC

     and define a prepositional phrase (e.g., "for the cat") to be a
     preposition followed by a noun phrase:

     #+BEGIN_SRC scheme
     (define (parse-prepositional-phrase)
      (list 'prep-phrase
            (parse-word prepositions)
            (parse-noun-phrase)))
     #+END_SRC

     Now we can define a sentence to be a noun phrase followed by a
     verb phrase, where a verb phrase can be either a verb or a verb
     phrase extended by a prepositional phrase:

     #+BEGIN_SRC scheme
     (define (parse-sentence)
      (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
     (define (parse-verb-phrase)
      (define (maybe-extend verb-phrase)
       (amb verb-phrase
            (maybe-extend
             (list 'verb-phrase 
                   verb-phrase
                   (parse-prepositional-phrase)))))
      (maybe-extend (parse-word verbs)))
     #+END_SRC

     While we're at it, we can also elaborate the definition of noun
     phrases to permit such things as "a cat in the class". What we
     used to call a noun phrase, we'll now call a simple noun phrase,
     and a noun phrase will now be either a simple noun phrase or a
     noun phrase extended by a prepositional phrase:

     #+BEGIN_SRC scheme
     (define (parse-simple-noun-phrase)
      (list 'simple-noun-phrase
            (parse-word articles)
            (parse-word nouns)))
     (define (parse-noun-phrase)
      (define (maybe-extend noun-phrase)
       (amb noun-phrase
            (maybe-extend
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
      (maybe-extend (parse-simple-noun-phrase)))
     #+END_SRC

     Our new grammar lets us parse more complex sentences. For example

     #+BEGIN_SRC scheme
     (parse '(the student with the cat sleeps in the class))
     #+END_SRC

     produces

     #+BEGIN_SRC scheme
     (sentence
      (noun-phrase
       (simple-noun-phrase (article the) (noun student))
       (prep-phrase
        (prep with)
        (simple-noun-phrase (article the) (noun cat))))
      (verb-phrase
       (verb sleeps)
       (prep-phrase
        (prep in)
        (simple-noun-phrase (article the) (noun class)))))
     #+END_SRC

     Observe that a given input may have more than one legal parse. In
     the sentence "The professor lectures to the student with the
     cat", it may be that the professor is lecturing with the cat, or
     the student has the cat. Our nondeterministic program finds both
     possibilities:

     (parse '(the professor lectures to the student with the cat))

     produces

     #+BEGIN_SRC scheme
     (sentence
      (simple-noun-phrase (article the) (noun professor))
      (verb-phrase
       (verb-phrase
        (verb lectures)
        (prep-phrase
         (prep to)
         (simple-noun-phrase (article the) (noun student))))
       (prep-phrase
        (prep with)
        (simple-noun-phrase (article the) (noun cat)))))
     #+END_SRC

     Asking the evaluator to try again yields

     #+BEGIN_SRC scheme
     (sentence
      (simple-noun-phrase (article the) (noun professor))
      (verb-phrase
       (verb lectures)
       (prep-phrase
        (prep to)
        (noun-phrase
         (simple-noun-phrase (article the) (noun student))
         (prep-phrase
          (prep with)
          (simple-noun-phrase (article the) (noun cat)))))))   
     #+END_SRC

     - Exercise 4.45: With the grammar given above, the following
       sentence can be parsed in five different ways: "The professor
       lectures to the student in the class with the cat." Give the
       five parses and explain the differences in shades of meaning
       among them.

       1: 
       #+BEGIN_SRC scheme
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb-phrase
          (verb-phrase (verb lectures)
       		(prep-phrase (prep to)
       			     (simple-noun-phrase (article the) (noun student))))
          (prep-phrase (prep in)
       		(simple-noun-phrase (article the) (noun class))))
         (prep-phrase (prep with)
       	       (simple-noun-phrase (article the) (noun cat)))))
       #+END_SRC

       In this case, the professor is lecturing a student, the lecture
       is taking place in the class with the cat. That is, the core verb phrase
       'lectures to the student' is extended by the prepositional phrases 'in the
       class', and 'with the cat'. So the lecture itself is what is
       taking place in a class with a cat, neither the student or
       professor are in this particular sense, 'with a cat' or 'in a
       class', although because they are party to a lecture it would
       seem they must be.

       2:
       #+BEGIN_SRC scheme
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb-phrase (verb lectures)
       	       (prep-phrase (prep to)
       			    (simple-noun-phrase (article the) (noun student))))
         (prep-phrase (prep in)
       	       (noun-phrase
       		(simple-noun-phrase (article the) (noun class))
       		(prep-phrase (prep with)
       			     (simple-noun-phrase (article the) (noun cat)))))))
       #+END_SRC

       The professor is lecturing the student, the lecture is in the
       class and the class is with the cat. So the verb lectures,
       which is being done by the noun professor, is being done to the
       student. It is also being done in the class, and the class is
       with the cat.

       3:
       #+BEGIN_SRC scheme
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb-phrase (verb lectures)
       	       (prep-phrase (prep to)
       			    (noun-phrase
       			     (simple-noun-phrase (article the) (noun student))
       			     (prep-phrase (prep in)
       					  (simple-noun-phrase (article the) (noun class))))))
         (prep-phrase (prep with)
       	       (simple-noun-phrase (article the) (noun cat)))))
       #+END_SRC

       The professor is lecturing. The lecture is being done to the
       student, the student is in the class. The lecture is done with
       the cat. There is no implied ownership of the cat. The lecture
       itself, the verb, is taking place in the class which heavily
       implies botht he subject and object are in the class also.

       4:
       #+BEGIN_SRC scheme
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase (verb lectures)
       	      (prep-phrase (prep to)
       			   (noun-phrase
       			    (noun-phrase
       			     (simple-noun-phrase (article the) (noun student))
       			     (prep-phrase (prep in)
       					  (simple-noun-phrase (article the) (noun class))))
       			    (prep-phrase (prep with)
       					 (simple-noun-phrase (article the) (noun cat)))))))
       #+END_SRC

       The professor is lecturing. The lecture is done to the student,
       the student is in the class and the student is with the
       cat. This implies ownership of the cat by the student, and that
       the student is sitting in the class, the professor could be anywhere.

       5:
       #+BEGIN_SRC scheme
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase (verb lectures)
       	      (prep-phrase (prep to)
       			   (noun-phrase
       			    (simple-noun-phrase (article the) (noun student))
       			    (prep-phrase (prep in)
       					 (noun-phrase
       					  (simple-noun-phrase (article the) (noun class))
       					  (prep-phrase (prep with)
       						       (simple-noun-phrase (article the) (noun cat)))))))))
       #+END_SRC
       
       The professor is lecturing to the student, the student is in
       the class, and the class is with the cat.

     - Exercise 4.46: The evaluators in Section 4.1 and Section 4.2 do
       not determine what order operands are evaluated in. We will see
       that the amb evaluator evaluates them from left to
       right. Explain why our parsing program wouldn't work if the
       operands were evaluated in some other order.

       If the operands were evaluated from right to left, The amb
       evaluator would get stuck on expressions like
       
       #+BEGIN_SRC scheme
       (define (maybe-extend verb-phrase)
         (amb verb-phrase
              (maybe-extend
     	  (list 'verb-phrase
     		verb-phrase
     		(parse-prepositional-phrase))))
       #+END_SRC

       But the reason is not so clear. It loops through several
       functions, here they are:

       #+BEGIN_SRC scheme
         (define (parse-simple-noun-phrase)
           (list 'simple-noun-phrase
                 (parse-word articles)
                 (parse-word nouns)))

         (define (parse-noun-phrase)
           (define (maybe-extend noun-phrase)
             (amb noun-phrase
                  (maybe-extend
                   (list 'noun-phrase
                         noun-phrase
                         (parse-prepositional-phrase)))))
           (maybe-extend (parse-simple-noun-phrase)))

         (define (parse-prepositional-phrase)
           (list 'prep-phrase
                 (parse-word prepositions)
                 (parse-noun-phrase)))
       #+END_SRC

       So if we were evaluating something and tried to evaluate a
       noun-phrase, and supposing that a noun was successfully found
       in the input, we would the proceed to evaluate:

       #+BEGIN_SRC scheme
       (amb noun-phrase
                  (maybe-extend
                   (list 'noun-phrase
                         noun-phrase
                         (parse-prepositional-phrase))))
       #+END_SRC

       Which would lead us to evaluate parse-prepositional-phrase
       first, since we evalute everything right-to-left:

       #+BEGIN_SRC scheme
       (list 'prep-phrase
              (parse-word prepositions)
              (parse-noun-phrase))
       #+END_SRC

       Which would in turn parse noun-phrase, which we have already
       gone through -- it's an infinite recursion.

     - Exercise 4.47: Louis Reasoner suggests that, since a verb
       phrase is either a verb or a verb phrase followed by a
       prepositional phrase, it would be much more straightforward to
       define the procedure parse-verb-phrase as follows (and
       similarly for noun phrases):

       #+BEGIN_SRC scheme
       (define (parse-verb-phrase)
        (amb (parse-word verbs)
             (list 'verb-phrase
                   (parse-verb-phrase)
                   (parse-prepositional-phrase))))
       #+END_SRC

       Does this work? Does the program's behavior change if we
       interchange the order of expressions in the amb?

       This does not really work, because we will eventually, if we
       try all solutions to a sentence, hit infinite recursion. It is
       possible to successfully parse the sentence right away, which
       is our first solution. 

       If we parse the sentence '(the student runs) for example, we
       will initially get the simplest parse, 

       (sentence (simple-noun-phrase (article the) (noun student))
                 (verb runs))

       There was no issue getting this parse, because The first
       argument to amb worked. But if we try again we are specifically
       trying other solutions; so we try the second argument to amb,
       (list 'verb-phrase (parse-verb-phrase)
       (parse-prepositional-phrase)). (parse-verb-phrase) proceeds
       okay, we get 'runs again. But then we try to get a
       preposition. The prepositional phrase doesn't work because the
       stack is empty. So it fails. So we backtrack and try
       (parse-verb-phrase) again, using the second amb argument, which
       is the exact same one we just evaluated (list 'verb-phrase
       (parse-verb-phrase) (parse-prepositional-phrase)). And the
       exact same thing happens because when we re-tried
       parse-verb-phrase, we restored the state of the computation,
       'unparsing', runs again. So whenever you run out of correct
       solutions or in general try to parse a prepositional phrase
       after a verb that isn't there, it will recurse infinitely.

       In general, this solution will still come up with solutions for
       sentences. The issue is for sentences you can't parse or have
       done all valid parses for. I tried

       '(the student runs to the shed)

       which also resulted in an infinite recursion, because the
       evaluator didn't know that 'shed was a noun.

     - Exercise 4.48: Extend the grammar given above to handle more
       complex sentences. For example, you could extend noun phrases
       and verb phrases to include adjectives and adverbs, or you
       could handle compound sentences.

     - Exercise 4.49: Alyssa P. Hacker is more interested in
       generating interesting sentences than in parsing them. She
       reasons that by simply changing the procedure parse-word so
       that it ignores the "input sentence" and instead always
       succeeds and generates an appropriate word, we can use the
       programs we had built for parsing to do generation
       instead. Implement Alyssa's idea, and show the first half-dozen
       or so sentences generated.

       THe modification was very simple:
       #+BEGIN_SRC scheme
       (define (amb-word word-list)
         (amb (car word-list)
              (amb-word (cdr word-list))))
       
       (define (parse-word word-list)
         (let ((found-word (amb-word (cdr word-list))))
           (require (not (null? found-word)))
           (list (car word-list) found-word)))
       #+END_SRC

       We just change parse-word to generate a word and give a null
       input.

       Here are some outputs:

       #+BEGIN_SRC scheme
       ;;; Amb-Eval input:
       (parse '())
       
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       ok
       
       ;;; Amb-Eval input:
       
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))
       
       ;;; Amb-Eval input:
       try-again
       
       ;;; Amb-Eval value:
       (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
       
       ;;; Amb-Eval input:
       try-again
       
       ;;; Amb-Eval value:
       (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
       
       ;;; Amb-Eval input:
       try-again
       
       ;;; Amb-Eval value:
       (compound-sentence (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
       
       ;;; Amb-Eval input:
       try-again
       
       ;;; Amb-Eval value:
       (compound-sentence (compound-sentence (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
       
       ;;; Amb-Eval input:
       try-again
       
       ;;; Amb-Eval value:
       (compound-sentence (compound-sentence (compound-sentence (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
       #+END_SRC

       The sentences are:

       The student studies.
       The student studies and the student studies and the student studies.
       The student studies and the student studies and the student
       studies 

       (...)

       The problem is that it just creates multiple conjunction
       sentences with 'the student studies', which is the simplest
       earliest phrase. Since you can have infinite conjunctive
       sentences, this is all it will ever say, it will never get
       around to more interesting things. Even if we remove
       conjunctions, it will do the same things with prepositions,
       because there are many places in language where you can
       recurse infinitely and it will hit a groove like this, although
       all its sentences will be totally grammatical.
       

       
       
*** 4.3.3 Implementing the amb Evaluator

    The evaluation of an ordinary Scheme expression may return a
    value, may never terminate, or may signal an error. In
    nondeterministic Scheme the evaluation of an expression may in
    addition result in the discovery of a dead end, in which case
    evaluation must backtrack to a previous choice point. The
    interpretation of nondeterministic Scheme is complicated by this
    extra case. 

    We will construct the amb evaluator for nondeterministic Scheme by
    modifying the analyzing evaluator of Section 4.1.7. As in the
    analyzing evaluator, evaluation of an expression is accomplished
    by calling an execution procedure produced by analysis of that
    expression. The difference between the interpretation of ordinary
    Scheme and the interpretation of nondeterministic Scheme will be
    entirely in the execution procedures. 

**** Execution procedures and continuations
     Recall that the execution procedures for the ordinary evaluator
     take one argument: the environment of execution. In contrast, the
     execution procedures in the amb evaluator take three arguments:
     the environment, and two procedures called _continuation
     procedures_. The evaluation of an expression will finish by
     calling one of these two continuations: If the evaluation results
     in a value, the _success continuation_ is called with that value;
     if the evaluation results in the discovery of a dead end, the
     _failure continuation_ is called. Constructing and calling
     appropriate continuations is the mechanism by which the
     nondeterministic evaluator implements backtracking. 

     It is the job of the success continuation to receive a value and
     proceed with the computation. Along with that value, the success
     continuation is passed another failure continuation, which is to
     be called subsequently if the use of that value leads to a dead
     end.

     It is the job of the failure continuation to try another branch
     of the nondeterministic process. The essence of the
     nondeterministic language is in the fact that the expressions may
     represent choices among alternatives. The evaluation of such an
     expression must proceed with one of the indicated alternative
     choices, even though it is not known in advance which choices
     will lead to acceptable results. To deal with this, the evaluator
     picks one of the alternatives and passes this value to the
     success continuation. Together with this value, the evaluator
     constructs and passes along a failure continuation that can be
     called later to choose a different alternative.

     A failure is triggered during evaluation (that is, a failure
     continuation is called) when a user program explicitly rejects
     the current line of attack (for example, a call to require may
     result in the execution of (amb), an expression that always fails
     -- see Section 4.3.1). The failure continuation in hand at that
     point will cause the most recent choice point to choose another
     alternative. If there are no more alternatives to be considered
     at that choice point, a failure at an earlier choice point is
     triggered, and so on. Failure continuations are also invoked by
     the driver loop in response to a try-again request, to find
     another value of the expression. Failure continuations are also
     invoked by the driver loop in response to a try-again request, to
     find another value of the expression.

     In addition, if a side-effect operation (such as assignment to a
     variable) occurs on a branch of the process resulting from a
     choice, it may be necessary, when the process finds a dead end,
     to undo the side effect before making a new choice. This is
     accomplished by having the side-effect operation produce a
     failure continuation that undoes the side effect and propagates
     the failure. 

     In summary, failure continuations are constructed by

     - amb expressions -- to provide a mechanism to make alternative
       choices if the current choice made by the amb expression leads
       to a dead end;
     - the top-level driver -- to provide a mechanism to report
       failure when the choices are exhausted;
     - assignments -- to intercept failures and undo assignments
       during backtracking.

       
     Failures are initiated only when a dead end is encountered. This
     occurs

     - If the user program executes (amb);
     - If the user types try-again and the top-level driver.


     Failure continuations are also called during the processing of a
     failure:

     - When the failure continuation created by an assignment finishes
       undoing a side effect, it calls the failure continuation it
       intercepted, in order to propagate the failure back to the
       choice point that led to this assignment or to the top level.
     - When the failure continuation for an amb runs out of choices,
       it calls the failure continuation that was originally given to
       the amb, in order to propagate the failure back to the previous
       choice point or to the top level.

**** Structure of the evaluator

     The syntax-and-data representation procedures for the amb
     evaluator, and also the basic analyze procedure, are identical to
     those in the evaluator of section 4.1.7, except for the fact that
     we need additional syntax procedures to recognize the amb
     expecial form:

     #+BEGIN_SRC scheme
     (define (amb? exp) (tagged-list? exp 'amb))
     (define (amb-choices exp) (cdr exp))
     #+END_SRC

     We must also add to the dispatch in analyze a clause that will
     recognize this special form and generate an appropriate execution
     procedure:

     #+BEGIN_SRC scheme
     ((amb? exp) (analyze-amb exp))
     #+END_SRC

     The top-level procedure ambeval (similar to the version of eval
     given in Section 4.1.7) analyzes the given expression and applies
     the resulting execution procedure to the given environment,
     together with the two given continuations:

     #+BEGIN_SRC scheme
     (define (ambeval exp env succeed fail)
      ((analyze exp) env succeed fail))
     #+END_SRC

     A success continuation is a procedure of two arguments: the value
     just obtained and another failure continuation to be used if that
     value leads to a subsequent failure. A failure continuation is a
     procedure of no arguments. So the general form of an execution
     procedure is

     #+BEGIN_SRC scheme
     (lambda (env succeed fail)
      ;; succeeded is (lambda (value fail) ...)
      ;; fail is (lambda () ...)
      ...)
     #+END_SRC

     For example, executing 

     #+BEGIN_SRC scheme
     (ambeval <exp>
              the-global-environment
              (lambda (value fail) value)
              (lambda () 'failed))
     #+END_SRC

     will attempt to evaluate the given expression and will return
     either the expression's value (if the evaluation succeeds) or the
     symbol failed (if the evaluation fails). The call to ambeval in
     the driver loop shown below uses much more complicated
     continuation procedures, which continue the loop and support the
     try-again request.

     Most of the complexity of the amb evaluator results from the
     mechanics of passing the continuations around as the execution
     procedures call each other. In going through the following code,
     you should compare each of the execution procedures with the
     corresponding procedure for the ordinary evaluator given in
     Section 4.1.7.

**** Simple expressions

     The execution procedures for the simplest kinds of expressions
     are essentially the same as those for the ordinary evaluator,
     except for the need to manage the continuations. The execution
     procedures simply succeed with the value of the expression,
     passing along the failure continuation that was passed to them.

     #+BEGIN_SRC scheme
     (define (analyze-self-evaluating exp)
      (lambda (env succeed fail)
       (succeed exp fail)))
     (define (analyze-quoted exp)
      (let ((qval (text-of-quotation exp)))
       (lambda (env succeed fail)
        (succeed qval fail))))
     (define (analyze-variable exp)
      (lambda (env succeed fail)
       (succeed (lookup-variable-value exp env) fail)))
     (define (analyze-lambda exp)
      (let ((vars (lambda-parameters exp))
            (bproc (analyze-sequence (lambda-body exp))))
       (lambda (env succeed fail) 
         (succeed (make-proceedure vars bproc env) fail))))
     #+END_SRC

     Notice that looking up a variable always 'succeeds'. If
     lookup-variable-value fails to find the variable, it signals an
     error, as usual. Such a "failure" indicates a program bug -- a
     reference to an unbound variable; it is not an indication that we
     should try another nondeterministic choice instead of the one
     that is currently being tried.

**** Conditionals and sequences

     Conditionals are also handled in a similar way as in the ordinary
     evaluator. The execution procedure generated by analyze-if
     invokes the predicate execution procedure pproc with a success
     continuation that checks whether the predicate value is true and
     goes on to execute either the consequent or the alternative. If
     the execution of pproc fails, the original failure continuation
     for the if expression is called.

     #+BEGIN_SRC scheme
     (define (analyze-if exp)
      (let ((pproc (analyze (if-predicate exp)))
            (cproc (analyze (if-consequent exp)))
            (aproc (analyze (if-alternative exp))))
      (lambda (env succeed fail)
       (pproc env
             (lambda (pred-value fail2)
              (if (true? pred-value)
                  (cproc env succeed fail2)
                  (aproc env succeed fail2)))
             fail))))
     #+END_SRC

     Sequences are also handled in the same way as in the previous
     evaluator, except for the machinations in the subprocedure
     sequentially that are required for passing the
     continuations. Namely, to sequentially execute a and then b, we
     call a with a success continuation that calls b.

     #+BEGIN_SRC scheme
     (define (analyze-sequence exps)
      (define (sequentially a b)
       (lambda (env succeed fail)
        (a env
           (lambda (a-val fail2)
            (b succeed fail2))
          fail)))
      (define (loop first-proc rest-procs)
       (if (null? rest-procs) 
           first-proc
           (loop (sequentially first-proc (car rest-procs))
                 (cdr rest-procs))))
      (let ((procs (map analyze exps)))
       (if (null? procs)
           (error "Empty sequence: ANALYZE"))
       (loop (car procs) (cdr procs))))
     #+END_SRC

**** Definitions and assignments
     Definitions are another case where we must go to some trouble to
     manage the continuations, because it is necessary to evaluate the
     definition value expression before actually defining the new
     variable. To accomplish this, the definition-value execution
     procedure vproc is called with the environment, a success
     continuation, and the failure continuation. If the execution of
     vproc succeeds, obtaining a value val for the defined variable,
     the variable is defined and the success is propagated:

     #+BEGIN_SRC scheme
     (define (analyze-definition exp)
      (let ((var (definition-variable exp))
            (vproc (definition-value exp)))
       (lambda (env succeed fail)
        (vproc env
               (lambda (val fail2)
                (define-variable! var val env)
                (succeed 'ok fail2))
              fail))))
     #+END_SRC

     Assignments are more interesting. This is the first place where
     we really use the continuations, rather than just passing them
     around. The execution procedure for assignments starts out like
     the one for definitions. It first attempts to obtain the new
     value to be assigned to the variable. If this evaluation of vproc
     fails, the assignment fails.

     If vproc succeeds, however, and we go on to make the assignment,
     we must consider the possibility that this branch of the
     computation might later fail, which will require us to backtrack
     out of the assignment. Thus, we must arrange to undo the
     assignment as part of the backtracking process.

     This is accomplished by giving vproc a success continuation
     (marked with the comment "\*1\*" below) that saves the old value
     of the variable before assigning the new value to the variable
     and proceeding from the assignment. The failure continuation that
     is passed along with the new value of the assignment (marked with
     the comment "\*2\*" below) restores the old value of the variable
     before continuing the failure. That is, a successful assignment
     provides a failure continuation that will intercept a subsequent
     failure; whatever failure would otherwise have called fail2 calls
     this procedure instead, to undo the assignment before actually
     calling fail2. 

     #+BEGIN_SRC scheme
       (define (analyze-assignment exp)
        (let ((var (assignment-variable exp))
              (vproc (analyze (assignment-value exp))))
         (lambda (env succeed fail)
          (vproc env
                 (lambda (val fail2) ; *1*
                   (let ((old-value
                          (lookup-variable-value var env)))
                     (set-variable-value! var val env)
                     (succeed 'ok
                              (lambda () ; *2* 
                                (set-variable-value!
                                 var old-value env)
                                (fail2)))))
                 fail))))
     #+END_SRC


**** Procedure applications

     The execution procedure for applications contains no new ideas
     except for the technical complexity of managing the
     continuations. This complexity arises in analyze-application, due
     to the need to keep track of the success and failure
     continuations as we evaluate the operands. We use a procedure
     get-args to evaluate the list of operands, rather than a simple
     map as in the ordinary evaluator.

     #+BEGIN_SRC scheme
     (define (analyze-application exp)
      (let ((fproc (analyze (operator exp)))
            (aprocs (map analyze operands exp)))
       (lambda (env succeed fail)
        (fproc env
               (lambda (proc fail2)
                (get-args aprocs
                          env
                          (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                          fail2))
        fail))))
     #+END_SRC

     In get-args, notice how cdr-ing down the list of aproc execution
     procedures and consing up the resulting list of args is
     accomplished by calling each aproc in the list with a success
     continuation that recursively calls get-args. Each of these
     recursive calls to get-args has a success continuation whose
     value is the cons of the newly obtained argument onto the list of
     accumulated arguments:

     #+BEGIN_SRC scheme
     (define (get-args aprocs env succeed fail)
      (if (null? aprocs)
          (succeed '() fail)
          ((car aprocs)
           env
           (lambda (arg fail2)
            (get-args 
             (cdr aprocs)
             env
             (lambda (args fail3)
              (succeed (cons arg args) fail3))
             fail2))
           fail)))
     #+END_SRC

     The actual procedure application, which is performed by
     execute-application, is accomplished in the same way as for the
     ordinary evaluator, except for the need to manage the
     continuations. 

     #+BEGIN_SRC scheme
     (define (execute-application proc args succeed fail)
      (cond ((primitive-procedure? proc)
             (succeed (apply-primitive-procedure proc args) 
                      fail))
            ((compound-procedure? proc)
             ((procedure-body proc)
              (extend-environment
               (procedure-parameters proc)
               args
               (procedure-environment proc))
             succeed
             fail))
            (else (error "Unknown procedure type: EXECUTE-APPLICATION"
                         proc))))
     #+END_SRC

**** Evaluating amb expressions

     The amb special form is the key element in the nondeterministic
     language. Here we see the essence of the interpretation process
     and the reason for keeping track of the continuations. The
     execution procedure for amb defines a loop try-next that cycles
     through the execution procedures for all the possible values of
     the amb expression. Each execution procedure is called with a
     failure continuation that will try the next one. When there are
     no more alternatives to try, the entire amb expression fails.

     #+BEGIN_SRC scheme
     (define (analyze-amb exp)
      (let ((cprocs (map analyze (amb-choices exp))))
       (lambda (env succeed fail)
        (define (try-next choices)
         (if (null? choices)
             (fail)
             ((car choices)
              env
              succeed
              (lambda () (try-next (cdr choices))))))
          (try-next cprocs))))
     #+END_SRC

**** Driver loop

     The driver loop for the amb evaluator is complex, due to the
     mechanism that permits the user to try again in evaluating an
     expression. The driver uses a procedure called internal-loop,
     which takes as argument a procedure try-again. The intent is that
     calling try-again should go on to the next untried alternative in
     the nondeterministic evaluation. internal-loop either calls
     try-again in response to the user typing try-again at the driver
     loop, or else starts a new evaluation by calling ambeval.

     The failure continuation for this call to ambeval informs the
     user that there are no more values and re-invokes the driver
     loop.

     The success continuation for the call to ambeval is more
     subtle. We print the obtained value and then invoke the internal
     loop again with a try-again procedure that will be able to try
     the next alternative. This next-alternative procedure is the
     second argument that was passed to the success
     continuation. Ordinarily, we think of this second argument as a
     failure continuation to be used if the current evaluation branch
     later fails. In this case, however, we have completed a
     successful evaluation, so we can invoke the "failure" alternative
     branch in order to search for additional successful evaluations.

     #+BEGIN_SRC scheme
       (define input-prompt ";;; Amb-Eval input:")
       (define output-prompt ";;; Amb-Eval value:")

       (define (driver-loop)
        (define (internal-loop try-again)
         (prompt-for-input input-prompt)
         (let ((input (read)))
          (if (eq? input 'try-again)
              (try-again)
              (begin
               (newline) (display ";;; Starting a new problem ")
               (ambeval
                input
                the-global-environmnent
                ;; ambeval success
                (lambda (val next-alternative)
                  (announce-output output-prompt)
                  (user-print val)
                  (internal-loop next-alternative))
                ;; ambeval failure
                (lambda ()
                  (announce-output
                   ";;; There are no more values of")
                  (user-print input)
                  (driver-loop)))))))
        (internal-loop
         (lambda ()
           (newline) (display ";;; There is no current problem")
           (driver-loop))))
     #+END_SRC

     The initial call to internal-loop uses a try-again procedure that
     complains that there is no current problem and restarts the
     driver loop. This is the behavior that will happen if the user
     types try-again when there is no evaluation in progress.

     - Exercise 4.50: Implement a new special form ramb that is like
       amb except that it searches alternatives in a random order,
       rather than from left to right. Show how this can help with
       Alyssa's problem in Exercise 4.49.

       #+BEGIN_SRC scheme
         ;; This doesn't preserve order.
         ;; We don't need it to though.
         (define (list-before lst index)
           (define (iter result lst index)
             (if (= index 0)
                 result
                 (iter (cons (car lst) result)
                       (cdr lst)
                       (- index 1))))
           (iter '() lst index))

         (define (list-after lst index)
           (define (iter lst index)
             (if (= index 0)
                 lst
                 (iter (cdr lst) (- index 1))))
           (iter lst index))
                    

         (define (get-random-choice listof-choices)
           (let* ((idx (random (length listof-choices)))
                  (before (list-before listof-choices idx))
                  (after (list-after listof-choices idx)))
             (cons (car after)
                   (append before (cdr after)))))

         (define (analyze-ramb exp)
           (let ((cprocs (map analyze (amb-choices exp))))
             (lambda (env succeed fail)
               (define (try-next choices)
                 (if (null? choices)
                     (fail)
                     (let* ((chosen-pair (get-random-choice choices))
                            (chosen (car chosen-pair))
                            (others (cdr chosen-pair)))
                       (chosen
                        env
                        succeed
                        (lambda () (try-next others))))))
               (try-next cprocs))))
       #+END_SRC

       We can help Aylssa's program by doing this:
       
       #+BEGIN_SRC scheme
         (define (amb-word word-list)
           (require (not (null? word-list)))
           (ramb (car word-list)
                 (amb-word (cdr word-list))))

         (define (parse-word word-list)
           (let ((found-word (amb-word (cdr word-list))))
             (require (not (null? found-word)))
             (list (car word-list) found-word)))
       #+END_SRC

       This makes it so at least the words are random. However, due to
       the recursive nature of the language, we still end up with
       problems because once amb-word succeeds once, the interpreter
       will extend the sentence using a conjunction or preposition
       since it's recursive. Here are some example sentences:

       #+BEGIN_SRC scheme
         ;;; Starting a new problem
         ;;; Amb-Eval value:
         (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb lectures))
         ;; The student lectures.
         ;;; Amb-Eval input:
         try-again

         ;;; Amb-Eval value:
         (compound-sentence
          (simple-sentence (simple-noun-phrase
                            (article the) (noun student)) (verb lectures))
          (conjunction-sentence (conjunction and)
                                (simple-sentence (simple-noun-phrase (article a) (noun cat)) (verb eats))))
         ;; The student lectures and a cat eats.
         ;;; Amb-Eval input:
         try-again 

         ;;; Amb-Eval value:
         (compound-sentence
          (compound-sentence
           (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb lectures))
           (conjunction-sentence (conjunction and)
                                 (simple-sentence (simple-noun-phrase (article a) (noun cat)) (verb eats))))
          (conjunction-sentence (conjunction but)
                                (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb eats))))
         ;; The student lectures and a cat eats but the student eats. (nonsense)
         ;;; Amb-Eval input:
         try-again

         ;;; Amb-Eval value:
         (compound-sentence (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb lectures)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article a) (noun cat)) (verb eats)))) (conjunction-sentence (conjunction but) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb eats)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article a) (noun class)) (verb studies))))
         ;; The student lectures and a cat eats but the student eats and a class studies
         ;;; Amb-Eval input:
         try-again

         ;;; Amb-Eval value:
         (compound-sentence (compound-sentence (compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb lectures)) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article a) (noun cat)) (verb eats)))) (conjunction-sentence (conjunction but) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb eats)))) (conjunction-sentence (conjunction and) (simple-sentence (simple-noun-phrase (article a) (noun class)) (verb studies)))) (conjunction-sentence (conjunction but) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb lectures))))
         ;; The student lectures and a cat eats but the student eats and a class studies but the student lectures.
       #+END_SRC

       The sentences are slightly less repetitive, since after each
       conjunction, we get a new sentence. But the problem is just
       that when we try again, the ambeval will go back to the last
       successful amb and retry the next alternative. But the next
       alternative will just be to extend the current sentence with a
       conjunction and make a simple sentence, so that's what it
       does. Since you can infinitely extend sentences with
       conjunctions, that's all it will do, never going back to a
       point before (since it is a depth-first search). If we didn't
       have conjunctions, it would be prepositions.

     - Exercise 4.51: Implement a new kind of assignment called
       permanent-set! that is not undone upon failure. For example, we
       can choose two distinct elements from a list and count the
       number of trials required to make a successful choice as
       follows:

       #+BEGIN_SRC scheme
       (define count 0)
       (let ((x (an-element-of '(a b c)))
             (y (an-element-of '(a b c))))
        (permanent-set! count (+ count 1))
        (require (not (eq? x y)))
        (list x y count))
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       (a b 2)
       ;;; Amb-Eval input:
       try-again
       ;;; Amb-Eval value:
       (a c 3)
       #+END_SRC

       What values would have been displayed if we had used set! here
       rather than permanent-set!?

       #+BEGIN_SRC scheme
       (define (permanent-set? exp) (tagged-list? exp 'permanent-set))
       (define (analyze-permanent-set exp)
        (let ((exp-var (assignment-variable exp))
              (vproc (analyze (assignment-value exp))))
        (lambda (env succeed fail)
         (vproc
          (lambda (value fail2)
           (set-variable-value! exp-var value)
           (succeed 'ok fail2))
          fail))))
       #+END_SRC

       If you just used set! it would always be 1, because the choice
       points for amb are both before the set! occurs.

       #+BEGIN_SRC scheme
         (define count 0)
         (define (require x) (if (not x) (amb)))
         (define (an-element-of alist)
           (if (null? alist) (amb)
               (amb (car alist)
                    (an-element-of (cdr alist)))))
         (let ((x (an-element-of '(a b c)))
               (y (an-element-of '(a b c))))
          (set! count (+ count 1))
          (require (not (eq? x y)))
          (list x y count))
         ;;; Starting a new problem
         ;;; Amb-Eval value:
         (a b 1)
         ;;; Amb-Eval input:
         try-again
         ;;; Amb-Eval value:
         (a c 1)
       #+END_SRC

     - Exercise 4.52: Implement a new construct called if-fail that
       permits the user to catch the failure of an expression. if-fail
       takes two expressions. It evaluates the first expression as
       usual and returns as usual if the evaluation succeeds. If the
       evaluation fails, however, the value of the second expression
       is returned, as in the following example:

       #+BEGIN_SRC scheme
       ;;; Amb-Eval input:
       (if-fail (let ((x (an-element-of '(1 3 5))))
                 (require (even? x))
                 x)
                'all-odd)
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       all-odd

       ;;; Amb-Eval input:
       (if-fail (let ((x (an-element-of '(1 3 5 8))))
                 (require (even? x))
                 x)
                'all-odd)
       ;;; Starting a new problem
       ;;; Amb-Eval value:
       8
       #+END_SRC

       #+BEGIN_SRC scheme
         (define (analyze-if-fail exp)
           (let ((tryexp (analyze (if-fail-try exp)))
                 (failexp (analyze (if-fail-fail exp))))
             (lambda (env succeed fail)
               (tryexp
                env
                succeed
                (lambda () (failexp env succeed fail))))))
         (define (if-fail? exp) (tagged-list? exp 'if-fail))
         (define (if-fail-try exp) (cadr exp))
         (define (if-fail-fail exp) (caddr exp))
       #+END_SRC

     - Exercise 4.53: With permanent-set! as described in Exercise
       4.51 and if-fail as in Exercise 4.52, what will be the result
       of evaluating

       #+BEGIN_SRC sheme
       (let ((pairs '()))
        (if-fail
         (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
          (permanent-set! pairs (cons p pairs))
          (amb))
         pairs))
       #+END_SRC

       This will keep searching the list, even when we find
       prime-sum-pairs, until there are none left and the entire set
       of solutions is exhausted, returning a list of all prime sum
       pairs. So it will return the list of all possible prime sum
       pairs that can be made from the two lists.
       
       The output is

       #+BEGIN_SRC scheme
       ((8 . 35) (3 . 110) (3 . 20))
       #+END_SRC

     - Exercise 4.54: If we had not realized that require could be
       implemented as an ordinary procedure that uses amb, to be
       defined by the user as part of a nondeterministic program, we
       would have had to implement it as a special form. This would
       require syntax procedures

       #+BEGIN_SRC scheme
       (define (require? exp)
        (tagged-list? exp 'require))
       (define (require-predicate exp)
        (cadr exp))
       #+END_SRC

       and a new clause in the dispatch in analyze

       #+BEGIN_SRC scheme
       ((require? exp) (analyze-require exp))
       #+END_SRC

       as well the procedure analyze-require that handles require
       expressions. Complete the following definition of
       analyze-require.

       #+BEGIN_SRC scheme
       (define (analyze-require exp)
        (let ((pproc (analyze (require-predicate exp))))
         (lambda (env succeed fail)
          (pproc env
                 (lambda (pred-value fail2)
                  (if <??>
                      <??>
                      (succeed 'ok fail2)))
                 fail))))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (analyze-require exp)
        (let ((pproc (analyze (require-predicate exp))))
         (lambda (env succeed fail)
          (pproc env
                 (lambda (pred-value fail2)
                  (if (not (true? pred-value))
                      (fail2)
                      (succeed 'ok fail2)))
                 fail))))
       #+END_SRC       

** 4.4 Logic Programming

   In Chapter 1 we stressed that computer science deals with
   imperative (how to) knowledge, whereas mathematics deals with
   declarative (what is) knowledge. Indeed, programming languages
   require that the programmer express knowledge in a form that
   indicates the step-by-step methods for solving particular
   problems. On the other hand, high-level languages provide, as part
   of the language implementation, a substantial amount of
   methodological knowledge that frees the user from concern with
   numerous details of how a specified computation will progress. 

   Most programming languages, including lisp, are organized around
   computing the values of mathematical functions. Expression-oriented
   languages (such as Lisp, Fortran, and Algol) capitalize on the
   "pun" that an expression that describes the value of a function may
   also be interpreted as a means of computing that value. Because of
   this, most programming languages are strongly biased toward
   unidirectional computations (computations with well-defined inputs
   and outputs). There are, however, radically different programming
   languages that relax this bias. We saw one such example in Section
   3.3.5, where the objects of computation were arithmetic
   constraints. In a constraint system the direction and the order of
   computation are not so well specified; in carrying out a
   computation the system must therefore provide more detailed "how
   to" knowledge than would be the case with an ordinary arithmetic
   computation. This does not mean, however, that the user is released
   altogether from the responsibility of providing imperative
   knowledge. There are many constraint networks that implement the
   same set of constraints, and the user must choose from the set of
   mathematically equivalent networks a suitable network to specify a
   particular computation.

   The nondeterministic program evaluator of Section 4.3 also moves
   away from the view that programming is about constructing
   algorithms for computing unidirectional functions. In a
   nondeterministic language, expressions can have more than one
   value, and, as a result, the computation is dealing with relations
   rather than with single-valued functions. Logic programming extends
   this idea by combining a relational vision of programming with a
   powerful kind of symbolic pattern matching called _unification_. 

   This approach, when it works, can be a very powerful way to write
   programs. Part of the power comes from the fact that a single "what
   is" fact can be used to solve a number of different problems that
   would have different "how to" components. As an example, consider
   the append operation, which takes two lists as arguments and
   combines their elements to form a single list. In a procedural
   language such as Lisp, we could define append in terms of the basic
   list constructor cons, as we did in Section 2.2.1:

   #+BEGIN_SRC scheme
   (define (append x y)
    (if (null? x) y (cons (car x) (append (cdr x) y))))
   #+END_SRC

   This procedure can be regarded as a translation into Lisp of the
   following two rules, the first of which covers the case where the
   first list is empty and the second of which handles the case of a
   nonempty list, which is a cons of two parts:

   - For any list y, the empty list and y append to form y.
   - For any u, v, y, and z, (cons u v) and y append to form (cons u
     z) if v and y append to form z.

     
   Using the append procedure, we can answer questions such as

   Find the append of (a b) and (c d).

   But the same two rules are also sufficient for answering the
   following sorts of questions, which the procedure can't answer:

   Find a list y that appends with (a b) to produce (a b c d).

   Find all x and y that append to form (a b c d).

   In a logic programming language, the programmer writes an append
   "procedure" by stating the two rules about append given above. "How
   to" knowledge is provided automatically by the interpreter to allow
   this single pair of rules to be used to answer all three types of
   questions about append.

   Contemporary logic programming languages (including the one we
   implement here) have substantial deficiencies, in that their
   general "how to" methods can lead them into spurious infinite loops
   or other undesirable behavior. Logic programming is an active field
   of research in computer science.

   Earlier in this chapter we explored the technology of implementing
   interpreters and described the elements that are essential to an
   interpreter for a Lisp-like language (indeed, to an interpreter for
   any conventional language). Now we will apply these ideas to
   discuss an interpreter for a logic programming language. We call
   this language the _query language_, because it is very useful for
   retrieving information from databases by formulating _queries_, or
   questions, expressed in the language. Even though the query
   language is different from Lisp, we will find it convenient to
   describe the language in terms of the same general framework we
   have been using all along: as a collection of primitive elements,
   together with means of combination that enable us to combine simple
   elements to create more complex elements and means of abstraction
   that enable us to regard complex elements as single conceptual
   units. An interpreter for a logic programming language is
   considerably more complex than an interpreter for a language like
   Lisp. Nevertheless, we will see that our query-language interpreter
   contains many of the same elements found in the interpreter of
   Section 4.1. In particular, there will be an "eval" part that
   classifies expressions according to type and an "apply" part that
   implements the language's abstraction mechanism (procedures in the
   case of Lisp, and _rules_ in the case of logic programming). Also,
   a central role is played in the implementation by a frame data
   structure, which determines the correspondence between symbols and
   their associated values. One additional interesting aspect of our
   query-language implementation is that we make substantial use of
   streams, which were introduced in Chapter 3.

*** 4.4.1 Deductive Information Retrieval
    Logic programming excels in providing interfaces to data bases for
    information retrieval. The query language we shall implement in
    this chapter is designed to be used in this way.

    In order to illustrate what the query system does, we will show
    how it can be used to manage the data base of personnel records
    for Microshaft, a thriving high-technology company in the Boston
    area. The language provides pattern-directed access to personnel
    information and can also take advantage of general rules in order
    to make logical deductions.

**** A sample data base

     The personnel data base for Microsoft contains _assertions_ about
     company personnel. Here is the information about Ben Bitdiddle,
     the resident computer wizard:
     
     #+BEGIN_SRC scheme
     (address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
     (job (Bitdiddle Ben) (computer wizard))
     (salary (Bitdiddle Ben) 60000)
     #+END_SRC

     Each assertion is a list (in this case a triple) whose elements
     can themselves be lists.

     As resident wizard, Ben is in charge of the company's computer
     division, and he supervises two programmers and one
     technician. Here is the information about them:

     #+BEGIN_SRC scheme
     (address (Hacker Alyysa P) (Cambridge (Mass Ave) 78))
     (job (Hacker Alyssa P) (computer programmer))
     (salary (Hacker Alyssa P) 40000)
     (supervisor (Hacker Alyssa P) (Bitdiddle Ben))

     (address (Fect Cy D) (Cambridge (Ames Street) 3))
     (job (Fect Cy D) (computer programmer))
     (salary (Fect Cy D) 35000)
     (supervisor (Fect Cy D) (Bitdiddle Ben))

     (address (Tweakit Lem E) (Boston (Bay State Road) 22))
     (job (Tweakit Lem E) (computer technician))
     (salary (Tweakit Lem E) 25000)
     (supervisor (Tweakit Lem E) (Bitdiddle Ben))
     #+END_SRC

     There is also a programmer trainee, who is supervised by Alyssa:

     #+BEGIN_SRC scheme
     (address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
     (job (Reasoner Louis) (computer programmer trainee))
     (salary (Reasoner Louis) 30000)
     (supervisor (Reasoner Louis) (Hacker Alyssa P))
     #+END_SRC

     All of these people are in the computer division, as indicated by
     the word computer as the first item in their job descriptions.

     Ben is a high-level employee. His supervisor is the company's big
     wheel himself:

     #+BEGIN_SRC scheme
     (supervisor (Bitdiddle Ben) (Warbucks Oliver))
     (address (Warbucks Oliver) (Swellesley (Top Head Road)))
     (job (Warbucks Oliver) (administration big wheel))
     (salary (Warbucks Oliver) 150000)
     #+END_SRC

     Besides the computer division supervised by Ben, the company has
     an accounting division, consisting of a chief accountant and his
     assistant:

     #+BEGIN_SRC scheme
     (address (Scrooge Eben) (Weston (Shady Lane) 10))
     (job (Scrooge Eben) (accounting chief accountant))
     (salary (Scrooge Eben) 75000)
     (supervisor (Scrooge Eben) (Warbucks Oliver))

     (address (Cratchet Robert) (Allston (N Harvard Street) 16))
     (job (Cratchet Robert) (accounting scrivener))
     (salary (Cratchet Robert) 18000)
     (supervisor (Cratchet Robert) (Scrooge Eben))
     #+END_SRC

     There is also a secretary for the big wheel:

     #+BEGIN_SRC scheme
     (address (Aull DeWitt) (Slumerville (Onion Square) 5))
     (job (Aull DeWitt) (administration secretary))
     (supervisor (Aull DeWitt) (Warbucks Oliver))
     #+END_SRC

     The data base also contains assertions about which kinds of jobs
     can be done by people holding other kinds of jobs. For instance,
     a computer wizard can do the jobs of both a computer programmer
     and a computer technician:

     #+BEGIN_SRC scheme
     (can-do-job (computer wizard) (computer programmer))
     (can-do-job (computer wizard) (computer technician))
     #+END_SRC

     A computer programmer could fill in for a trainee:

     #+BEGIN_SRC scheme
     (can-do-job (computer programmer)
                 (computer programmer trainee))
     #+END_SRC

     Also, as is well known,

     #+BEGIN_SRC scheme
     (can-do-job (administration secretary)
                 (administration big wheel))
     #+END_SRC

**** Simple queries

     The query language allows users to retrieve information from the
     data base by posing queries in response to the system's
     prompt. For example, to find all computer programmers one can say

     #+BEGIN_SRC scheme
     ;;; Query input:
     (job ?x (computer programmer))
     #+END_SRC

     The system will respond with the following items:

     #+BEGIN_SRC scheme
     ;;; Query results:
     (job (Hacker Alyssa P) (computer programmer))
     (job (Fect Cy D) (computer programmer))
     #+END_SRC

     The input query specifies that we are looking for entries in the
     data base that match a certain _pattern_. In this example, the
     pattern specifies entries consisting of three items, of which the
     first is the literal symbol job, the second can be anything, and
     the third is the literal list (computer programmer). The
     "anything" that can be the second item in the matching list is
     specified by a _pattern variable_, ?x. The general form of a
     pattern variable is a symbol, taken to be the name of the
     variable, preceded by a question mark. We will see below why it
     is useful to specify names for pattern variables rather than just
     putting ? into patterns to represent "anything". The system
     responds to a simple query by showing all entries in the data
     base that match the specified pattern.
     
     A pattern can have more than one variable. For example, the query

     #+BEGIN_SRC scheme
     (address ?x ?y)
     #+END_SRC

     will list all the employees' addresses.

     A pattern can have more than one variable. For example, the query
     (address ?x ?y)

     will list all the employees' addresses.

     A pattern can have no variables, in which case the query simply
     determines whether that pattern is an entry in the data base. If
     so, there will be one match; if not, there will be no matches.

     The same pattern variable can appear more than once in a query,
     specifying that the same "anything" must appear in each
     position. This is why variables have names. For example,

     #+BEGIN_SRC scheme
     (supervisor ?x ?x)
     #+END_SRC

     finds all people who supervise themselves (though there are no
     such assertions in our sample data base).

     The query

     #+BEGIN_SRC scheme
     (job ?x (computer ?type))
     #+END_SRC

     matches all job entries whose third item is a two-element list
     whose first item is computer:

     #+BEGIN_SRC scheme
     (job (Bitdiddle Ben) (computer wizard))
     (job (Hacker Alyssa P) (computer programmer))
     (job (Fect Cy D) (computer programmer))
     (job (Tweakit Lem E) (computer technician))
     #+END_SRC

     This same pattern does _not_ match

     #+BEGIN_SRC scheme
     (job (Reasoner Louis) (computer programmer trainee))
     #+END_SRC

     because the third item in the entry is a list of three elements,
     and the pattern's third item specifies that there should be two
     elements. If we wanted to change the pattern so that the third
     item could be any list beginning with computer, we could specify

     #+BEGIN_SRC scheme
     (job ?x (computer . ?type))
     #+END_SRC

     For example,

     #+BEGIN_SRC scheme
     (computer . ?type)
     #+END_SRC

     matches the data

     #+BEGIN_SRC scheme
     (computer programmer trainee)
     #+END_SRC

     with ?type as the list (programmer trainee). It also matches the
     data

     #+BEGIN_SRC scheme
     (computer programmer)
     #+END_SRC

     with ?type as the list (programmer), and matches the data

     #+BEGIN_SRC scheme
     (computer)
     #+END_SRC

     with ?type as the empty list ().

     We can describe the query language's processing of simple queries
     as follows:

     - The system finds all assignments to variables in the query
       pattern that _satisfy_ the pattern -- that is, all sets of
       values for the variables such that if the pattern variables are
       _instantiated with_ (replaced by) the values, the result is in
       the data base.
     - The system responds to the query by listing all instantiations
       of the query pattern with the variable assignments that satisfy
       it.

       
     Note that if the pattern has no variables, the query reduces to a
     determination of whether the pattern is in the data base. If so,
     the empty assignment, which assigns no values to variables,
     satisfies that pattern for that data base.

     - Exercise 4.55: Give simple queries that retrieve the following
       information from the data base:

       1. all people supervised by Ben Bitdiddle.

       2. the names and jobs of all people in the accounting division;

       3. the names and addresses of all people who live in
          Slumerville.

       1. (supervisor ?x (Bitdiddle Ben))

       2. (job ?x (accounting . ?jobname))
	  
       3. (address ?name (Slumerville . ?address)) 

**** Compound queries

     Simple queries form the primitive operations of the query
     language. In order to form compound operations, the query
     language provides means of combination. One thing that makes the
     query language a logic programming language is that the means of
     combination mirror the means of combination used in forming
     logical expressions: and, or, and not. (Here and, or, and not are
     not the Lisp primitives, but rather operations built into the
     query language.)

     We can use and as follows to find the addresses of all the
     computer programmers:

     #+BEGIN_SRC scheme
     (and (job ?person (computer programmer))
          (address ?person ?where))
     #+END_SRC

     The resulting output is

     #+BEGIN_SRC scheme
     (and (job (Hacker Alyssa P) (computer programmer))
          (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
     (and (job (Fect Cy D) (computer programmer))
          (address (Fect Cy D) (Cambridge (Ames Street) 3)))
     #+END_SRC

     In general,

     #+BEGIN_SRC scheme
     (and <query1> <query2> ... <queryn>)
     #+END_SRC

     is satisfied by all sets of values for the pattern variables that
     simultaneously satisfy <query1>...<queryn>

     As for simple queries, the system processes a compound query by
     finding all assignments to the pattern variables that satisfy the
     query, then displaying instantiations of the query with those
     values.

     Another means of constructing compound queries is through or. For
     example,

     #+BEGIN_SRC scheme
     (or (supervisor ?x (Bitdiddle Ben))
         (supervisor ?x (Hacker Alyssa P)))
     #+END_SRC

     will find all employees supervised by Ben Bitdiddle or Alyssa
     P. Hacker:

     #+BEGIN_SRC scheme
     (or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
         (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
     (or (supervisor (Fect Cy D) (Bitdiddle Ben))
         (supervisor (Fect Cy D) (Hacker Alyssa P)))
     (or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
         (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
     (or (supervisor (Reasoner Louis) (Bitdiddle Ben))
         (supervisor (Reasoner Louis) (Hacker Alyssa P)))
     #+END_SRC

     In general,

     #+BEGIN_SRC scheme
     (or <query1> <query2> ... <queryn>)
     #+END_SRC

     is satisfied by all sets of values for the pattern variables that
     satisfy at least one of <query1>...<queryn>.

     Compound queries can also be formed with not. For example,

     #+BEGIN_SRC scheme
     (and (supervisor ?x (Bitdiddle Ben))
          (not (job ?x (computer programmer))))
     #+END_SRC

     finds all people supervised by Ben Bitdiddle who are not computer
     programmers. In general, 

     #+BEGIN_SRC scheme
     (not <query1>)
     #+END_SRC
     
     is satisfied by all assignments to the pattern variables that do
     not satisfy <query1>.

     The final combining form is called lisp-value. When lisp-value is
     the first element of a pattern, it specifies that the next
     element is a Lisp predicate to be applied to the rest of the
     (instantiated) elements as arguments. In general,

     #+BEGIN_SRC scheme
     (lisp-value <predicate> <arg1> ... <argn>)
     #+END_SRC

     will be satisfied by assignments to the pattern variables for
     which the <predicate> applied to the instantiated <arg1>
     ... <argn> is true. For example, to find all people whose salary
     is greater than $30,000 we could write:

     #+BEGIN_SRC scheme
     (and (salary ?person ?amount) (lisp-value > ?amount 30000))
     #+END_SRC

     - Exercise 4.56: Formulate compound queries that retrieve the
       following information:

       a. the names of all people who are supervised by Ben Bitdiddle,
       together with their addresses;

       #+BEGIN_SRC scheme
       (and (supervisor ?person (Bitdiddle Ben))
            (address ?person ?address))
       #+END_SRC

       b. all people whose salary is less than Ben Bitdiddle's,
       together with their salary and Ben Bitdiddle's salary; 

       #+BEGIN_SRC scheme
       (and (salary (Bitdiddle Ben) ?bensalary) 
            (salary ?person ?amount) 
            (lisp-value < ?amount ?bensalary))
       #+END_SRC

       c. all people who are supervised by someone who is not in the
       computer division, together with the supervisor's name and job.

       #+BEGIN_SRC scheme
       (and (supervisor ?person ?supervisor)
            (not (job ?supervisor (computer . ?computerjob)))
            (job ?supervisor ?job))
       #+END_SRC

**** Rules
     In addition to primitive queries and compound queries, the query
     language provides means for abstracting queries. These are given
     by _rules_. The rule

     #+BEGIN_SRC scheme
     (rule (lives-near ?person-1 ?person-2)
           (and (address ?person-1 (?town . ?rest-1))
                (address ?person-2 (?town . ?rest-2))
                (not (same ?person-1 ?person-2))))
     #+END_SRC

     specifies that two people live near each other if they live in
     the same town. The final not clause prevents the rule from saying
     that all people live near themselves. The same relation is
     defined by a very simple rule:

     #+BEGIN_SRC scheme
     (rule (same ?x ?x))
     #+END_SRC

     The following rule declares that a person is a "wheel" in an
     organization if he supervises someone who is in turn a
     supervisor:

     #+BEGIN_SRC scheme
     (rule (wheel ?person)
           (and (supervisor ?middle-manager ?person)
                (supervisor ?x ?middle-manager)))
     #+END_SRC

     The general form of a rule is
     
     #+BEGIN_SRC scheme
     (rule <conclusion> <body>)
     #+END_SRC

     where <conclusion> is a pattern and <body> is any query. We can
     think of a rule as representing a large (even infinite) set of
     assertions, namely all instantiations of the rule conclusion with
     variable assignments that satisfy the rule body. When we
     described simple queries (patterns), we said that an assignment
     to variables satisfies a pattern if the instantiated pattern is
     in the data base. But the pattern needn't be explicitly in the
     data base as an assertion. It can be an implicit assertion
     implied by a rule. For example, the query

     #+BEGIN_SRC scheme
     (lives-near ?x (Bitdiddle Ben))
     #+END_SRC

     results in

     #+BEGIN_SRC scheme
     (lives-near (Reasoner Louis) (Bitdiddle Ben))
     (lives-near (Aull DeWitt) (Bitdiddle Ben))
     #+END_SRC

     To find all computer programmers who live near Ben Bitdiddle, we
     can ask

     #+BEGIN_SRC scheme
     (and (job ?x (computer programmer))
          (lives-near ?x (Bitdiddle Ben)))
     #+END_SRC

     As in the case of compound procedures, rules can be used as parts
     of other rules (as we saw in the lives-near rule above) or even
     be defined recursively. For instance, the rule

     #+BEGIN_SRC scheme
     (rule (outranked-by ?staff-person ?boss)
           (or (supervisor ?staff-person ?boss)
               (and (supervisor ?staff-person ?middle-manager)
                    (outranked-by ?middle-manager ?boss))))
     #+END_SRC

     says that a staff person is outranked by a boss in the
     organization if the boss is the person's supervisor or
     (recursively) if the person's supervisor is outranked by the
     boss.

     - Exercise 4.57: Define a rule that says that person 1 can
       replace person 2 if either person 1 does the same job as person
       2 or someone who does person 1's job can also do person 2's
       job, and if person 1 and person 2 are not the same person. 

       #+BEGIN_SRC scheme
         (rule (replaceable-by ?person1 ?person2)
               (and
                (or
                 (and
                  (job ?person1 . ?jobdescr)
                  (job ?person2 . ?jobdescr))
                 (and
                  (can-do-job ?jobdesc1 ?jobdesc2)
                  (job ?person1 ?jobdesc1)
                  (job ?person2 ?jobdesc2)))
                (not (same ?person1 ?person2))))
       #+END_SRC

       Using your rule, give queries that find the following:

       a. All people who can replace Cy D Fect. 
       #+BEGIN_SRC scheme
       (replaceable-by ?x (Fect Cy D))
       #+END_SRC
       
       b. All people who can replace someone who is being paid more
       than they are, together with the two salaries.
       #+BEGIN_SRC scheme
       (and (replaceable-by ?p1 ?p2) 
            (salary ?p1 ?salary1)
            (salary ?p2 ?salary2)
            (lisp-value < ?salary1 ?salary2))
       #+END_SRC

     - Exercise 4.58: Define a rule that says that a person is a "big
       shot" in a division if the person works in the division but
       does not have a supervisor who works in the division.

       #+BEGIN_SRC scheme
       (rule (big-shot ?person)
        (and
         (supervisor ?person ?super)
         (job ?person (?persondepartment . ?rest1))
         (job ?super (?superdepartment . ?rest2))
         (not (same ?persondepartment ?superdepartment))))
       #+END_SRC

     - Exercise 4.59: Ben Bitdiddle has missed one meeting too
       any. Fearing that his habit of forgetting meetings could cost
       him his job, Ben decides to do something about it. He adds all
       the weekly meetings of the firm to the Microshaft data base by
       asserting the following:

       #+BEGIN_SRC scheme
       (meeting accounting (Monday 9am))
       (meeting administration (Monday 10am))
       (meeting computer (Wednesday 3pm))
       (meeting administration (Friday 1pm))
       #+END_SRC

       Each of the above assertions is for a meeting of an entire
       division. Ben also adds an entry for the company-wide meeting
       that spans all the divisions. All of the company's employees
       attend this meeting.

       #+BEGIN_SRC scheme
       (meeting whole-company (Wednesday 4pm))
       #+END_SRC

       a. On a Friday morning, Ben wants to query the data base for
       all the meetings that occur that day. What query should he use?

       #+BEGIN_SRC scheme
       (meeting ?meeting-who (Friday ?time))
       #+END_SRC

       b. Alyssa P. Hacker is unimpressed. She thinks it would be much
       more useful to be able to ask for her meetings by specifying
       her name. So she designs a rule that says that a person's
       meetings include all whole-company meetings plus all meetings
       of that person's division. Fill in the body of Alyssa's rule.

       #+BEGIN_SRC scheme
       (rule (meeting-time ?person ?day-and-time)
             <rule-body>)
       #+END_SRC

       #+BEGIN_SRC scheme
       (rule (meeting-time ?person ?day-and-time)
             (or 
              (meeting whole-company ?day-and-time)
              (and
               (job ?person (?department . ?rest))
               (meeting  ?department ?day-and-time))))
       #+END_SRC

       This one works better:

       #+BEGIN_SRC scheme
         (rule (meeting-time ?person ?day-and-time)
               (and
                (job ?person (?department . ?rest))
                (or (meeting whole-company ?day-and-time)
                    (meeting  ?department ?day-and-time))))
       #+END_SRC
       
       c. Alyssa arrives at work on Wednesday morning and wonders what
       meetings she has to attend that day. Having defined the above
       rule, what query should she make to find this out?

       #+BEGIN_SRC scheme
       (meeting-time (hacker alyssa p) (Wednesday ?time))
       #+END_SRC

     - Exercise 4.60: By giving the query

       #+BEGIN_SRC scheme
       (lives-near ?person (Hacker Alyssa P))
       #+END_SRC

       Alyssa P. Hacker is able to find people who live near her, with
       whom she can ride to work. On the other hand, when she tries to
       find all pairs of people who live near each other by querying

       #+BEGIN_SRC scheme
       (lives-near ?person-1 ?person-2)
       #+END_SRC

       she notices that each pair of people who live near each other
       is listed twice; for example,

       #+BEGIN_SRC scheme
       (lives-near (Hacker Alyssa P) (Fect Cy D))
       (lives-near (Fect Cy D) (Hacker Alyssa P))
       #+END_SRC
       
       Why does this happen? Is there a way to find a list of people
       who live near each other, in which each pair appears only once?
       Explain.

       When you query with two wildcards then it goes through the
       database once for each wildcard, the pattern is instantiated
       with every possible pairing of people, so you get both
       ways. You can stop it by locking one person in place:

       #+BEGIN_SRC scheme
       (lives-near (Hacker Alyssa P) ?person2)
       #+END_SRC

       This will make sure Cy D. Fect is only listed once, since in
       the pattern person1 is locked to (Hacker Alyssa P). But if you
       query with both wildcards, the system will fill in every
       possible pattern that satisfies the rules and they both do. You
       could attempt to order the lists (Hacker Alyssa P) and (Cy D
       Fect), if we had that lisp function:

       #+BEGIN_SRC scheme
       (rule (lives-near ?person-1 ?person-2)
             (and (address ?person-1 (?town . ?rest-1))
                  (address ?person-2 (?town . ?rest-2))
                  (not (same ?person-1 ?person-2))
                  (lisp-value symbol-list< ?person-1 ?person2)))
       #+END_SRC

       We would need to first define symbol-list< :
       
       #+BEGIN_SRC scheme
       (define (symbol-list< list1 list2)
        (cond
         ((and (null? list1) (null? list2)) false)
         ((null? list1) true)
         ((null? list2) false)
         ((string<? (symbol->string (car list1))
                    (symbol->string (car list2)))
          true)
         ((string>? (symbol->string (car list1))
                   (symbol->string (car list2)))
          false)
        (else (symbol-list< (cdr list1) (cdr list2)))))
       #+END_SRC

**** Logic as programs

     We can regard a rule as a kind of logical implication: If an
     assignment of values to pattern variables satisfies the body,
     _then_ it satisfies the conclusion. Consequently, we can regard
     the query language as having the ability to perform _logical
     deductions_ based upon the rules. As an example, consider the
     append operation described at the beginning of Section 4.4. As we
     said, append can be characterized by the following two rules:

     - For any list y, the empty list and y append to form y.
     - For any u, v, y, and z, (cons u v) and y append to form (cons u
       z) if v and y append to form z.


     To express this in our query language, we define two rules for a
     relation

     #+BEGIN_SRC scheme
     (append-to-form x y z)
     #+END_SRC

     which we can interpret to mean "x and y append to form z":

     #+BEGIN_SRC scheme
     (rule (append-to-form () ?y ?y))
     (rule (append-to-form (?u . ?v) ?y (?u . ?z))
           (append-to-form ?v ?y ?z))
     #+END_SRC

     The first rule has no body, which means that the conclusion holds
     for any value of ?y. Note how the second rule makes use of the
     dotted-tail notation to name the car and cdr of a list.

     Given these two rules, we can formulate queries that compute the
     append of two lists:

     #+BEGIN_SRC scheme
     ;;; Query input:
     (append-to-form (a b) (c d) ?z)
     ;;; Query results:
     (append-to-form (a b) (c d) (a b c d))
     #+END_SRC

     What is more striking, we can use the same rules to ask the
     question "Which list, when appended to (a b), yields (a b c d)?"
     This is done as follows:

     #+BEGIN_SRC scheme
     ;;; Query input:
     (append-to-form (a b) ?y (a b c d))
     ;;; Query results:
     (append-to-form (a b) (c d) (a b c d))
     #+END_SRC

     We can also ask for all pairs of lists that append to form (a b c
     d):

     #+BEGIN_SRC scheme
     ;;; Query input:
     (append-to-form ?x ?y (a b c d))
     ;;; Query results:
     (append-to-form () (a b c d) (a b c d))
     (append-to-form (a) (b c d) (a b c d))
     (append-to-form (a b) (c d) (a b c d))
     (append-to-form (a b c) (d) (a b c d))
     (append-to-form (a b c d) () (a b c d))
     #+END_SRC

     The query system may seem to exhibit quite a bit of intelligence
     in using the rules to deduce the answers to the queries
     above. Actually, as we will see in the next section, the system
     is following a well-determined algorithm in unraveling the
     rules. Unfortunately, although the system works impressively in
     the append case, the general methods may break down in more
     complex cases, as we will see in Section 4.4.3.

     - Exercise 4.61: The following rules implement a next-to relation
       that finds adjacent elements of a list:

       #+BEGIN_SRC scheme
       (rule (?x next-to ?y in (?x ?y . ?u)))
       (rule (?x next-to ?y in (?v . ?z))
             (?x next-to ?y in ?z))
       #+END_SRC

       What will the responses be to the following queries?

       #+BEGIN_SRC scheme
       (?x next-to ?y in (1 (2 3) 4))
       (?x next-to 1 in (2 1 3 1))
       #+END_SRC

       #+BEGIN_SRC scheme
       (1 next-to (2 3) in (1 (2 3) 4))
       ((2 3) next-to 4 in (1 (2 3) 4))
       #+END_SRC

       #+BEGIN_SRC scheme
       (3 next-to 1 in (2 1 3 1))
       (2 next-to 1 in (2 1 3 1))
       #+END_SRC

     - Exercise 4.62: Define rules to implement the last-pair
       operation of Exercise 2.17, which returns a list containing the
       last element of a nonempty list. Check your rules on queries
       such as (last-pair (3) ?x), (last-pair (1 2 3) ?x) and
       (last-pair (2 ?x) (3)). 

       #+BEGIN_SRC scheme
       (rule (last-pair (?x) (?x)))
       (rule (last-pair ?p (?x . ?y))
             (last-pair ?p ?y))
       #+END_SRC

     - Exercise 4.63: The following data base (see Genesis 4) traces
       the genealogy of the descendents of Ada back to Adam, by way of
       Cain:

       #+BEGIN_SRC scheme
       (son Adam Cain)
       (son Cain Enoch)
       (son Enoch Irad)
       (son Irad Mehujael)
       (son Mehujael Methushael)
       (son Methushael Lamech)
       (wife Lamech Ada)
       (son Ada Jabal)
       (son Ada Jubal)
       #+END_SRC

       Formulate rules such as "If S is the son of f, and f is the son
       of G, then S is the grandson of G" and "If W is the wife of M,
       and S is the son of W, then S is the son of M" (which was
       supposedly more true in biblical times than today) that will
       enable the query system to find the grandson of Cain; the sons
       of Lamech; the grandsons of Methushael. 

       #+BEGIN_SRC scheme
       (rule (grandson ?x ?y)
        (and (a-son-of ?x ?s)
             (a-son-of ?s ?y)))
       (rule (a-son-of ?x ?y)
        (or (son ?x ?y)
            (and (wife ?x ?w)
                 (son ?w ?y))))
       #+END_SRC

       #+BEGIN_SRC scheme
       ;;; Query input:
       
       (a-son-of ?x Jubal)
       
       ;;; Query results:
       (a-son-of ada jubal)
       (a-son-of lamech jubal)
       
       ;;; Query input:
       (a-son-of Cain ?y)
       
       ;;; Query results:
       (a-son-of cain enoch)
       
       ;;; Query input:
       (grandson Cain ?x)
       
       ;;; Query results:
       (grandson cain irad)
       
       ;;; Query input:
       (graindson Methushael ?x)
       
       ;;; Query results:
       
       ;;; Query input:
       (grandson Methushael ?x)
       
       ;;; Query results:
       (grandson methushael jubal)
       (grandson methushael jabal)
       #+END_SRC

       
*** 4.4.2 How the Query System Works

    In Section 4.4.4 we will presentan implementation of the query
    interpreter as a collection of procedures. In this section we give
    an overview that explains the general structure of the system
    independent of lowlevel implementation details. After describing
    the implementation of the interpreter, we will be in a position to
    understand some of its limitations and some of the subtle ways in
    which the query language's logical operations differ from the
    operations of mathematical logic. 

    It should be apparent that the query evaluator must perform some
    kind of search in order to match queries against facts and rules
    in the data base. One way to do this would be to implement the
    query system as a nondeterministic program, using the amb
    evaluator of Section 4.3 (see Exercise 4.78). Another possibility
    is ot manage the search with the aid of streams. Our
    implementation follows this second approach.

    The query system is organized around two central operations called
    _pattern matching_ and _unification_. We first describe pattern
    matching and explain how this operation, together with the
    organization of information in terms of streams of frames, enables
    us to implement both simple and compound queries. We next discuss
    unification, a generalization of pattern matching needed to
    implement rules. Finally, we show how the entire query interpreter
    fits together through a procedure that classifies expressions in a
    manner analogous to the way eval classifies expressions for the
    interpreter described in Section 4.1.

**** Pattern matching

     A _pattern matcher_ is a program that tests whether some datum
     fits a specified pattern. For example, the data list ((a b) c (a
     b)) matches the pattern (?x c ?x) with the pattern variable ?x
     bound to (a b). The same data list matches the pattern (?x ?y ?z)
     with ?x and ?z both bound to (a b) and ?y bound to c. It also
     matches the pattern ((?x ?y) c (?x ?y)) with ?x bound to a and ?y
     bound to b. However, it does not match the pattern (?x a ?y),
     since that pattern specifies a list whose second element is the
     symbol a.

     The pattern matcher used by the query system takes as inputs a
     pattern, a datum, and a _frame_ that specifies bindings for
     various pattern variables. It checks whether the datum matches
     the pattern in a way that is consistent with the bindings already
     in the frame. If so, it returns the given frame augmented by any
     bindings that may have been determined by the match. Otherwise,
     it indicates that the match has failed.

     For example, using the pattern (?x ?y ?x) to match (a b a) given
     an empty frame will return a frame specifying that ?x is bound to
     a and ?y is bound to b. Trying to match with the same pattern,
     the same datum, and a frame specifying that ?y is bound to a will
     fail. Trying the match with the same pattern, the same datum, and
     a frame in which ?y is bound to b and ?x is unbound will return
     the given frame augmented by a binding of ?x to a.

     The pattern matcher is all the mechanism that is needed to
     process simple queries that don't involve rules. For instance, to
     process the query 

     #+BEGIN_SRC scheme
     (job ?x (computer programmer))
     #+END_SRC

     we scan through all assertions in the data base and select those
     that match the pattern with respect to an initially empty
     frame. For each match we find, we use the frame returned by the
     match to instantiate the pattern with a value for ?x.

**** Streams of frames

     The testing of patterns against frames is organized through the
     use of streams. Given a single frame, the matching process runs
     through the data-base entries one by one. For each data-base
     entry, the matcher generates either a special symbol indicating
     that the match has failed or an extension to the frame. The
     results for all the data-base entries are collected into a
     stream, which is passed through a filter to weed out the
     failures. The result is a stream of all the frames that extend
     the given frame via a match to some assertion in the data base.

     In our system a query takes an input stream of frames and
     performs the above matching operation for every frame in the
     stream, as indicated in Figure 4.4. That is, for each frame in
     the input stream, the query generates a new stream consisting of
     all extensions to that frame by matches to assertions in the data
     base. All these streams are then combined to form one huge
     stream, which contains all possible extensions of every frame in
     the input system. This stream is the output of the query.

     To answer a simple query, we use the query with an input stream
     consisting of a single empty frame. The resulting output stream
     contains all extensions to the empty frame (that is, all answers
     to our query). This stream of frames is then used to generate a
     stream of copies of the original query pattern with the variables
     instantiated by the values in each frame, and this is the stream
     that is finally printed.

**** Compound queries

     The real elegance of the stream-of-frames implementation is
     evident when we deal with compound queries. The processing of
     compound queries makes use of the ability of our matcher to
     demand that a match be consistent with a specified frame. For
     example, to handle the and of two queries, such as

     #+BEGIN_SRC scheme
     (and (can-do-job ?x (computer programmer trainee))
          (job ?person ?x))
     #+END_SRC

     (informally, "Find all people who can do the job of a computer
     programmer trainee"), we first find all entries that match the
     pattern

     #+BEGIN_SRC scheme
     (can-do-job ?x (computer programmer trainee))
     #+END_SRC

     This produces a stream of frames, each of which contains a
     binding for ?x. Then for each frame in the stream we find all
     entries that match

     #+BEGIN_SRC scheme
     (job ?person ?x)
     #+END_SRC

     in a way that is consistent with the given binding for ?x. Each
     such match will produce a frame containing bindings for ?x and
     ?person. The and of two queries can be viewed as a series
     combination of the two component queries, as shown in Figure
     4.5. The frames that pass through the first query filter are
     filtered and further extended by the second query.

     Figure 4.6 shows the analogous method for computing the or of two
     queries as a parallel combination of the two component
     queries. The input stream of frames is extended separately by
     each query. The two resulting streams are then merged to produce
     the final output stream.

     Even from this high-level description, it is apparent that the
     processing of compound queries can be slow. For example, since
     a query may produce more than one output frame for each input
     frame, and each query in an and gets its input frames from the
     previous query, an and query could, in the worst case, have to
     perform a number of matches that is exponential in the number of
     queries (See Exercise 4.76). Though systems for handling only
     simple queries are quite pratcial, dealing with complex queries
     is extremely difficult.

     From the stream-of-frames viewpoint, the not of some query acts
     as a filter that removes all frames for which the query can be
     satisfied. For instance, given the pattern

     #+BEGIN_SRC scheme
     (not (job? x (computer programmer)))
     #+END_SRC

     we attempt, for each frame in the input stream, to produce
     extention frames that satisfy (job ?x (computer programmer)). We
     remove from the input stream all frames for which such extensions
     exist. The result is a stream oconsisting only of those frames in
     which the binding for ?x does not satisfy (job ?x (computer
     programmer)). For example, in processing the query

     #+BEGIN_SRC scheme
     (and (supervisor ?x ?y)
          (not (job ?x (computer programmer))))
     #+END_SRC

     the first clause will generate frames with bindings for ?x and
     ?y. The not clause will then filter these by removing all frames
     in which the binding for ?x satisfies the restriction that ?x is
     a computer programmer.

     The lisp-value special form is implemented as a similar filter on
     frame streams. We use each frame in the stream to instantiate any
     variables in the pattern, then apply the Lisp predicate. We
     remove from the input stream all frames for which the predicate
     fails.

**** Unification

     In order to handle rules in the query language, we must be able
     to find the rules whose conclusions match a given query
     pattern. Rule conclusions are like assertions except that they
     can contain variables, so we will need a generalization of
     pattern matching -- called _unification_ -- in which both the
     "pattern" and the "datum" may contain variables.

     A unifier takes two patterns, each containing constants and
     variables, and determines whether it is possible to assign values
     to the variables that will make the two patterns equal. If so, it
     returns a frame containing these bindings. For example, unifying
     (?x a ?y) and (?y ?z a) will specify a frame in which ?x, ?y, and
     ?z must all be bound to a. On the other hand, unifying (?x ?y a)
     and (?x b ?y) will fail, because there is no value for ?y that
     can make the two patterns equal. (For the second elements of the
     patterns to be equal, ?y would have to be b; however, for the
     third elements to be equal, ?y would have to be a.) The unifier
     used in the query system, like the pattern matcher, takes a frame
     as input and performs unifications that are consistent with this
     frame. 

     The unification algorithm is the most technically difficult part
     of the query system. With complex patterns, performing
     unification may seem to require deduction. To unify (?x ?x) and
     ((a ?y c) (a b ?z)), for example, the algorithm must infer that
     ?x should be (a b c), ?y should be b, and ?z should be c. We may
     think of this process as solving a set of equations among the
     pattern components. In general, these are simultaneous equations,
     which may require substantial manipulation to solve. For example,
     unifying (?x ?x) and ((a ?y c) (a b ?z)) may be thought of as
     specifying the simultaneous equations

     ?x = (a ?y c)
     ?x = (a b ?z)

     These equations imply that

     (a ?y c) = (a b ?z)

     which in turn implies that

     a = a,
     ?y = b,
     c = ?z,

     and hence that

     ?x = (a b c)

     In a successful pattern match, all pattern variables become
     bound, and the values to which they are bound contain only
     constants. This is also true of all the examples of unification
     we have seen so far. In general, however, a successful
     unification may not completely determine the variable values;
     some variables may remain unbound and others may be bound to
     values that contain variables.

     In a successful pattern match, all pattern variables become
     bound, and the values to which they are bound contain only
     constants. This is also true of all the examples of unification we
     have seen so far. In general, however, a successful unification
     may not completely determine the variable values; some variables
     may remain unbound and others may be bound to values that contain
     variables. 

     Consider the unification of (?x a) and ((b ?y) ?z). We can deduce
     that ?x = (b ?y) and a = ?z, but we cannot further solve for ?x
     or ?y. The unification doesn't fail, since it is certainly
     possible to make the two patterns equal by assigning values to ?x
     and ?y. Since this match in no way restricts the values ?y can
     take on, no binding for ?y is put into the result frame. The
     match does, however, restrict the value of ?x. Whatever value ?y
     has, ?x must be (b ?y). A binding of ?x to the pattern (b ?y) is
     thus put into the frame. If a value for ?y is later determined
     and added to the frame (by a pattern match or unification that is
     required to be consistent with this frame) the previously bound
     ?x will refer to this value.

     
**** Applying rules

     Unification is the key to the component of the query system that
     makes inference from rules. To see how this is accomplished,
     consider processing a query that involves applying a rule, such
     as

     #+BEGIN_SRC scheme
     (lives-near ?x (Hacker Alyssa P))
     #+END_SRC

     To process this query, we first use the ordinary pattern-match
     procedure described above to see if there are any assertions in
     the data base that match this pattern. (There will not be any in
     this case, since our data base includes no direct assertions
     about who lives near whom.) The next step is to attempt to unify
     the query pattern with the conclusion of each rule. We find that
     the pattern unifies with the conclusion of the rule

     #+BEGIN_SRC scheme
     (rule (lives-near ?person-1 ?person-2)
           (and (address ?person-1 (?town . ?rest-1))
                (address ?person-2 (?town . ?rest-2))
                (not (same ?person-1 ?person-2))))
     #+END_SRC

     resulting in a frame specifying that ?person-2 is bound to
     (Hacker Alyssa P) and that ?x should be bound to (have the same
     value as) ?person-1. Now, relative to this frame, we evaluate the
     compound query given by the body of the rule. Successful matches
     will extend this frame by providing a binding for ?person-1, and
     consequently a value for ?x, which we can use to instantiate the
     original query pattern.

     In general, the query evaluator uses the following method to
     apply a rule when trying to establish a query pattern in a frame
     that specifies bindings for some of the pattern variables:

     - Unify the query with the conclusion of the rule to form, if
       successful, an extension of the original frame.
     - Relative to the extended frame, evaluate the query formed by
       the body of the rule.


     Notice how similar this is to the method for applying a procedure
     in the eval/apply evaluator for Lisp:

     - Bind the procedure's parameters to its arguments to form a
       frame that extends the original procedure environment.
     - Relative to the extended environment, evaluate the expression
       formed by the body of the procedure.

       
     The similarity between the two evaluators should come as no
     surprise. Just as procedure definitions are the means of
     abstraction in Lisp, rule definitions are the means of
     abstraction in the query language. In each case, we unwind the
     abstraction by creating appropriate bindings and evaluating the
     rule or procedure body relative to these.

**** Simple queries

     We saw earlier in this section how to evaluate simple queries in
     the absence of rules. Now that we have seen how to apply rules,
     we can describe how to evaluate simple queries by using both
     rules and assertions. 

     Given the query pattern and a stream of frames, we produce, for
     each frame in the put stream, two streams:

     - a stream of extended frames obtained by matching the pattern
       against all assertions in the data base (using the pattern
       matcher), and
     - a stream of extended frames obtained by applying all possible
       rules (using the unifier).

       
     Appending these two streams procedures produces a stream that
     consists of all the ways that a given pattern can be satisfied
     consistent with the original frame. These streams (one for each
     frame in the input stream) are now all combined to fom one large
     stream, which therefore consists of all the ways that any of the
     frames in the original input stream can be extended to produce a
     match with the given pattern.

**** The query evaluator and the driver loop

     Despite the complexity of the underlying matching operations, the
     system is organized much like an evaluator for any language. The
     procedure that coordinates the matching operations is called
     qeval, and it plays a role analogous to that of the eval
     procedure for Lisp. qeval takes as inputs a query and a stream of
     frames. Its output is a stream of frames, corresponding to
     successful matches to the query pattern, that extend some frame
     in the input system, as indicated in Figure 4.4. Like eval, qeval
     classifies the different types of expressions (queries) and
     dispatches to an appropriate procedure for each. There is a
     procedure for each special form (and, or, not, and lisp-value)
     and one for simple queries. 

     The driver loop, which is analogous to the driver-loop procedure
     for the other evaluators in this chapter, reads queries from the
     terminal. For each query, it calls qeval with the query and a
     stream that consists of a single empty frame. This will produce a
     stream of all possible matches (all possible extensions to the
     emtpy frame). For each frame in the resulting stream, it
     instantiates the original query using the values of the variables
     found in the frame. This stream of instantiated queries is then
     printed.

     The driver also checks for the special command assert!, which
     signals that the input is not a query but rather an assertion or
     rule to be added to the data base. For instance,

     #+BEGIN_SRC scheme
     (assert! (job (Bitdiddle Ben) (computer wizard)))
     (assert! (rule (wheel ?person)
                    (and (supervisor ?middle-manager ?person)
                         (supervisor ?x ?middle-manager))))
     #+END_SRC

*** 4.4.3 Is Logic Programming Mathematical Logic?

    The means of combination used in the query language may at first
    seem identical to the operations and, or, and not of mathematical
    logic, and the application of query-langauge rules is in fact
    accomplished through a legitimate method of inference. This
    identification of the query language with mathematical logic is
    not really valid, though, because the query language provides a
    _control structure_ that interprets the logical statements
    procedurally. We can often take advantage of this control
    structure. For example, to find all the supervisors of programmers
    we could formulate a query in either of two logically equivalent
    forms:

    #+BEGIN_SRC scheme
    (and (job ?x (computer programmer)) (supervisor ?x ?y))
    #+END_SRC

    or
    
    #+BEGIN_SRC scheme
    (and (supervisor ?x ?y) (job ?x (computer programmer)))
    #+END_SRC

    If a company has many more supervisors than programmers (the usual
    case), it is better to use the first form rather than the second
    because the data base must be scanned for each intermediate result
    (frame) produced by the first clause of the and.

    The aim of logic programming is to provide the programmer with
    techniques for decomposing a computation problem into two separate
    problems: "what" is to be computed, and "how" this should be
    computed.

    This is accomplished by selecting a subset of the statements of
    mathematical logic that is powerful enough to be able to describe
    anything one might want to compute, yet weak enough to have a
    controllable procedural interpretation. The intention here is
    that, on the one hand, a program specified in a logic programming
    language should be an effective program that can be carried out by
    a computer. Control ("how" to compute) is effected by using the
    order of evaluation of the language. We should be able to arrange
    the order of clauses and the order of subgoals within each clause
    so that the computation is done in an order deemed to be effective
    and efficient. At the same time, we should be able to view the
    result of the computation ("what" to compute) as a simple
    consequence of the laws of logic.

    Our query language can be regarded as just such a procedurally
    interpretable subset of mathematical logic. An assertion
    represents a simple fact (an atomic proposition). A rule
    represents the implication that the rule conclusion holds for
    those cases where the rule body holds. A rule has a natural
    procedural interpretation: To establish the conclusion of the
    rule, establish the body of the rule. Rules, therefore, specify
    computations. However, because rules can also be regarded as
    statements of mathematical logic, we can justify any "inference"
    accomplished by a logic program by asserting that the same result
    could be obtained by working entirely within mathematical logic.

    Our query language can be regarded as just such a procedurally
    interpretable subset of mathematical logic. An assertion
    represents a simple fact (an atomic proposition). A rule
    represents the implication that the rule conclusion holds for
    those cases where the rule body holds. A rule has a natural
    procedural interpretation: To establish the conclusion of the
    rule, establish the body of the rule. Rules, therefore, specify
    computaitons. However, because rules can also be regarded as
    statements of mathematical logic, we can justify any "inference"
    accomplished by a logic program by asserting that the same result
    could be obtained by working entirely within mathematical logic.

**** Infinite loops

     A consequence of the procedural interpretation of logic programs
     is that it is possible to construct hopelessly inefficient
     programs for solving certian problems. An extreme case of
     inefficiency occurs when the system falls into infinite loops in
     making deductions. As a simple example, suppose we are setting
     up a data base of famous marriages, including

     #+BEGIN_SRC scheme
     (assert! (married Minnie Mickey))
     #+END_SRC

     If we now ask

     #+BEGIN_SRC scheme
     (married Mickey ?who)
     #+END_SRC

     we will get no response, because the system doesn't know that if A
     is married to B, then B is married to A. So we assert the rule

     #+BEGIN_SRC scheme
     (assert! (rule (married ?x ?y) (married ?y ?x)))
     #+END_SRC

     and again query

     #+BEGIN_SRC scheme
     (married Mickey ?who)
     #+END_SRC

     Unfortunately, this will drive the system into an infinite loop,
     as follows:

     - The system finds that the married rule is applicable; that is,
       the rule conclusion (married ?x ?y) successfully unifies with
       the query pattern (married Mickey ?who) to produce a frame in
       which ?x is bound to Mickey and ?y is bound to ?who. So the
       interpreter proceeds to evaluate the rule body (married ?y ?x)
       in this frame -- in effect, to process the query (married ?who Mickey).
     - One answer appears directly as an assertion in the data base:
       (married Minnie Mickey).
     - The married rule is also applicable, so the interpreter again
       evaluates the rule body, which this time is equivalent to
       (married Mickey ?who).


     The system is now in an infinite loop. Indeed, whether the system
     will find the simple answer (married Minnie Mickey) before it
     goes into the loop depends on implementation details concerning
     the order in which the system checks items in the data base. This
     is a very simple example of the kinds of loops that can
     occur. Collections of interrelated rules can lead to loops that
     are much harder to anticipate, and the appearance of a loop can
     depend on the order of clauses in an and (see Exercise 4.64 or on
     low-level details concerning the order in which the system
     processes queries.

**** Problems with not

     Another quirk in the query system concerns not. Given the data
     base of Section 4.4.1, consider the following two queries:

     #+BEGIN_SRC scheme
     (and (supervisor ?x ?y)
          (not (job ?x (computer programmer))))
     (and (not (job ?x (computer programmer)))
          (supervisor ?x ?y))
     #+END_SRC

     These two queries do not produce the same result. The first
     query begins by finding all entries in the data base that match
     (supervisor ?x ?y), and then filters the resulting frames by
     removing the ones in which the value of ?x satisfies (job ?x
     (computer programmer)). The second query begins by filtering the
     incoming frames to remove those that can satisfy (job ?x
     (computer programmer)). Since the only incoming frame is empty,
     it checks the data base to see if there are any patterns that
     satisfy (job ?x (computer programmer)). Since there generally are
     entries of this form, the not clause filters out the empty frame
     and returns an empty stream of frames. Consequently, the entire
     compound query returns an empty stream.

     The trouble is that our implementation of not really is meant to
     serve as a filter on values for the variables. If a not clause is
     processed with a frame in which some of the variables remain
     unbound (as does ?x in the example above), the system will
     produce unexpected results. Similar problems occur with the use
     of lisp-value -- the Lisp predicate can't work if some of its
     arguments are unbound. See Exercise 4.77.

     There is also a much more serious way in which the not of the
     query language differs from the not of mathematical logic. In
     logic, we interpret the statement "not P" to mean that P is not
     true. In the query system, however, "not P" means that P is not
     deducible from the knowledge in the data base. For example, given
     the personnel data base of Section 4.4.1, the system would
     happily deduce all sorts of nto statements, such as that Ben
     Bitdiddle is not a baseball fan, that it is not raining outside,
     and that 2 + 2 is not 4. In other words, the not of logic
     programming languages reflects the so-called _closed world
     assumption_ that all relevant information has been included in
     the data base.

     - Exercise 4.64: Louis Reasoner mistakenly deletes the
       outranked-by rule (Section 4.4.1) from the data base. When he
       realizes this, he quickly reinstalls it. Unfortunately, he
       makes a slight change in the rule, and types it in as

       #+BEGIN_SRC scheme
       (rule (outranked-by ?staff-person ?boss)
             (or (supervisor ?staff-person ?boss)
                 (and (outranked-by ?middle-manager ?boss)
                      (supervisor ?staff-person
                                  ?middle-manager))))
       #+END_SRC

       Just after Louis types this information into the system, DeWitt
       Aull comes by to find out who outranks Ben Bitdiddle. He issues
       the query

       #+BEGIN_SRC scheme
       (outranked-by (Bitdiddle Ben) ?who)
       #+END_SRC
     
       After answering, the system goes into an infinite loop. Explain
       why.

       The system will get both clauses of the or. So first it will
       match the pattern (supervisor ?staff-person ?boss). Ben
       Bitdiddle's boss is Oliver Warbucks so it answers (supervisor
       (Warbucks Oliver) (Bitdiddle Ben)). However, after that it then
       proceeds to evaluate the and clause. It first tries to find all
       patterns matching (outranked-by ?middle-manager ?boss). This
       will then recurse into the first clause of the or statement for
       a new invokation of outranked-by, this time with two variables,
       basically an empty frame. The (supervisor ?staff-person ?boss)
       will unify with ?middle-manager ?boss, and match all supervisor
       frames, and we do the same thing again.

     - Exercise 4.65: Cy D. Fect, looking forward to the day when he
       will rise in the organization, gives a query to find all the
       wheels (using the wheel rule of Section 4.4.1):

       #+BEGIN_SRC scheme
       (wheel ?who)
       #+END_SRC

       To his surprise, the system responds

       #+BEGIN_SRC scheme
       (wheel (Warbucks Oliver))
       (wheel (Bitdiddle Ben))
       (wheel (Warbucks Oliver))
       (wheel (Warbucks Oliver))
       (wheel (Warbucks Oliver))
       #+END_SRC

       Why is Oliver Warbucks listed four times?

       He's listed for every time he's two levels above anyone. So
       Alyssa, Cy, Lem, and Robert all are exactly two levels below
       Oliver Warbucks, which satisfies the rule. The system matches
       against all the records in the data base so this is the result.

     - Exercise 4.66: Ben has been generalizing the query system to
       provide statistics about the company. For example, to find the
       total salaries of all the computer programmers one will be able
       to say

       #+BEGIN_SRC scheme
       (sum ?amount (and (job ?x (computer programmer))
                         (salary ?x ?amount)))
       #+END_SRC

       In general, Ben's new system allows expressions of the form

       #+BEGIN_SRC scheme
       (accumulation-function <variable> <query pattern>)
       #+END_SRC

       where accumulation-function can be things like sum, average, or
       maximum. Ben reasons that it should be a cinch to implement
       this. He will simply feed the query pattern to queval. This
       will produce a stream of frames. He will then pass this stream
       through a mapping function that extracts the value of the
       designated variable from each frame in the stream and feed the
       resulting stream of values to the accumulation function. Just
       as Ben completes the implementation and is about to try it out,
       Cy walks by, still puzzling over the wheel query result in
       Exercise 4.65. When Cy shows Ben the system's response, Ben
       groans, "Oh, no, my simple accumulation scheme won't work!"

       What has Ben just realized? Outline a method he can use to
       salvage the situation.

       Ben has realized that there will be duplicate records in his
       query, and this will inflate the sum. Basically for many
       queries you can't know how many duplicate matches you will get
       which makes accumulation functions useless, unless you can
       filter for duplicates. Comparing two matching frames should be
       easy, since you just see if the variables are the same. So you
       can do a O(n^2) filter function that takes each variable from
       the stream and removes duplicates, one by one.

     - Exercise 4.67: Devise a way to install a loop detector in the
       query system so as to avoid the kinds of simple loops
       illustrated in the text and in Exercise 4.64. The general idea
       is that the system should maintain some sort of history of its
       current chain of deductions and should not begin processing a
       query that it is already working on. Describe what kind of
       information (patterns and frames) is included in this history,
       and how the check should be made. (After you study the details
       of the query-system implementation in Section 4.4.4, you may
       want to modify the system to include your loop detector.)

       Well you already are providing a list of output frames. But the
       issue is we still probably want queries like in 4.64 to return
       multiple duplicates, we just don't want to be asking the exact
       same question with the exact same record or rule and patterns
       filling in the frame.

       The kinds of loops we're talking about only happen with
       rules. So for each rule, we can keep a list of previous
       instantiations per query. We need something like an environment
       structure where at the beginning of each query we extend an
       empty 'frame' with rule invocation histories. This will be a
       list of frames. Since we know that all these frames belong to
       this rule, if any of them are exactly the same, we know we're
       in a loop.

     - Exercise 4.68: Define rules to implement the reverse operation
       of Exercise 2.18, which returns a list containing the same
       elements as a given list in reverse order. (Hint: Use
       append-to-form.) Can your rules answer both (reverse (1 2 3)
       ?x) and (reverse ?x (1 2 3)) ?

       #+BEGIN_SRC scheme
       (rule (append-to-form () ?x ?x))
       (rule (append-to-form (?u . ?v) ?x (?u . ?y))
             (append-to-form ?v ?x ?y))
       #+END_SRC

       #+BEGIN_SRC scheme
       (rule (reverse (?x . ()) (?x)))
       (rule (reverse (?x . ?y) ?z)
             (and
              (reverse ?y ?yrev)
              (append-to-form
               ?yrev (?x) ?z))) 
       ;; OR:
       (rule (reverse ?v (?x . ?y))
             (and
              (reverse ?y ?yrev)
              (append-to-form
               ?yrev (?x) ?v)))
       #+END_SRC

       I can't come up with a solution that works both ways. You have
       to use one or the other. If you use the first rule you can
       reverse lists like (reverse (1 2 3 4) ?x), but not (reverse ?x
       (4 3 2 1)) (this results in an infinite loop). The second rule
       is the other way around.

     - Exercise 4.69: Beginning with the data base and the rules you
       formulated in Exercise 4.63, devise a rule for adding "greats"
       to a grandson relationship. This should enable the system to
       deduce that Irad is the great-grandson of Adam, or that Jabal
       and Jubal are the great-great-great-great-great-grandsons of
       Adam (Hint: Represent the fact about Irad, for example, as
       ((great grandson) Adam Irad). Write rules that determine if a
       list ends in the word grandson. Use this to express a rule that
       allows one to derive the relationship ((great . ?rel) ?x ?y),
       where ?rel is a list ending in grandson.) Check your rules on
       queries such as ((great grandson) ?g ?ggs) and (?relationship
       Adam Irad).

       #+BEGIN_SRC scheme
       (rule (ason ?x ?y)
        (or (son ?x ?y)
            (and (wife ?x ?awife)
                 (son ?awife ?y))))
       (rule (grandson ?x ?y)
        (and (ason ?x ?father)
             (ason ?father ?y)))

       (rule ((great grandson) ?x ?y) 
         (and 
          (grandson ?x ?thegrandson)
          (ason ?thegrandson ?y)))
       (rule (ends-in-grandson (grandson . ())))
       (rule (ends-in-grandson (?x . ?alist))
             (ends-in-grandson ?alist))

       (rule ((great . ?rel) ?x ?y)
        (and
         (ason ?x ?agreat)
         (?rel ?agreat ?y)
         (ends-in-grandson ?rel)
         (not (ason ?x ?y))
         (not (grandson ?x ?y))))
       #+END_SRC

*** 4.4.4 Implementing the Query System 

    Section 4.4.2 described how the query system works. Now we fill in
    the details by presenting a complete implementation of the system.

**** 4.4.4.1 The Driver Loop and Instantiation

     The driver loop for the query system repeatedly reads input
     expressions. If the expression is a rule or assertion to be added
     to the data base, then the information is added. Otherwise the
     expression is assumed to be a query. The driver passes this query
     to the evaluator qeval together with an initial frame stream
     consisting of a single empty frame. The result of the evaluation
     is a stream of frames generated by satisfying the query with
     variable values found in the data base. These frames are used to
     form a new stream consisting of copies of the original query in
     which the variables are instantiated with values supplied by the
     stream of frames, and this final stream is printed at the
     terminal:

     #+BEGIN_SRC scheme
     (define input-prompt ";;; Query input:")
     (define output-prompt ";;; Query results:")

     (define (query-driver-loop)
      (prompt-for-input input-prompt)
      (let ((q (query-syntax-process (read))))
       (cond ((assertion-to-be added? q)
              (add-rule-or-assertion! (add-assertion-body q))
              (newline)
              (display ";;; Assertion added to the data base")
              (query-driver-loop))
             (else
              (newline)
              (display output-prompt)
              (display-stream
               (stream-map
                (lambda (frame)
                 (instantiate 
                  q
                  frame
                  (lambda (v f)
                   (contract-question-mark v))))
                (qeval q (singleton-stream '()))))
              (query-driver-loop)))))
     #+END_SRC

     Here, as in the other evaluators in this chapter, we use an
     abstract syntax for the expressions of the query language. The
     implementation of the expression syntax, including the predicate
     assertion-to-be-added? and the selector add-assertin-body, is
     given in Section 4.4.4.7. add-rule-or-assertion! is defined in
     Section 4.4.4.5. 

     Before doing any processing on an input expression, the driver
     loop transforms it syntactically into a form that makes the
     processing more efficient. This involves changing the
     representation of pattern variables. When ther query is
     instantiated, any variables that remain unbound are transformed
     back to the input representation before being printed. These
     transformations are performed by the two procedures
     query-syntax-process and contract-question-mark (Section
     4.4.4.7).

     To instantiate an expression, we copy it, replacing any variables
     in the expression by their values in a given frame. The values
     are themselves instantiated, since they could contain variables
     (for example, if ?x in exp is bound to ?y as the result of
     unification and ?y is in turn bound to 5). The action to take if
     a variable cannot be instantiated is given by a procedure
     argument to instantiate.

     #+BEGIN_SRC scheme
       (define (instantiate exp frame unbound-var-handler)
        (define (copy exp)
         (cond ((var? exp)
                (let ((binding (binding-in-frame exp frame)))
                 (if binding
                     (copy (binding-value binding))
                     (unbound-var-handler exp frame))))
               ((pair? exp)
                (cons (copy (car exp)) (copy (cdr exp))))
               (else exp)))
        (copy exp))
     #+END_SRC

     The procedures that manipulate bindings are defined in Section
     4.4.4.8.

**** 4.4.4.2 The Evaluator

     The qeval procedure, called by the query-driver-loop, is the
     basic evaluator of the query system. It takes as inputs a query
     and a streawm of frames, and it returns a stream of extended
     frames. It identifies special forms by a data-directed dispatch
     using get and put, just as we did in implementing generic
     operations in Chapter 2. Any query that is not identified as a
     special form is assumed to be a simple query, to be processed by
     simple-query.

     #+BEGIN_SRC scheme
     (define (qeval query frame-stream)
      (let ((qproc (get (type query) 'qeval)))
       (if qproc
           (qproc (contents query) frame-stream)
           (simple-query query frame-stream))))
     #+END_SRC

     type and contents, defined in Section 4.4.4.7, implement the
     abstract syntax of the special forms.

***** Simple queries

      The simple-query procedure handles simple queries. It takes as
      arguments a simple query (a pattern) together with a stream of
      frames, and it returns the stream formed by extending each frame
      by all data-base matches of the query.

      #+BEGIN_SRC scheme
      (define (simple-query query-pattern frame-stream)
       (stream-flatmap
        (lambda (frame)
         (stream-append-delayed
          (find-assertions query-pattern frame)
          (delay (apply-rules query-pattern frame))))
        frame-stream))
      #+END_SRC

      For each frame in the input stream, we use find-assertions
      (Section 4.4.4.3) to match the pattern against all assertions in
      the data base, producing a stream of extended frames, and we use
      apply-rules (Section 4.4.4.4) to apply all possible rules,
      producing another stream of extended frames. These two streams
      are combined (using stream-append-delayed, Section 4.4.4.6) to
      make a stream of all the ways that the given pattern can be
      satisfied consistent with the original frame (see Exercise
      4.71). The streams for the individual input frames are combined
      using stream-flatmap (Section 4.4.4.6) to form one large stream
      of all the ways that any of the frames in the original input
      stream can be extended to produce a match with the given
      pattern.

***** Compound queries

      and queries are handled as illustrated in Figure 4.5 by the
      conjoin procedure. conjoin takes as inputs the conjuncts and the
      frame stream and returns the stream of extended frames. First,
      conjoin processes the stream of frames to find the stream of all
      possible frame extensions that satisfy the first query in the
      conjunction. Then, using this as the new frame stream, it
      recursively applies conjoin to the rest of the queries.

      #+BEGIN_SRC scheme
      (define (conjoin conjuncts frame-stream)
       (if (empty-conjunction? conjuncts)
           frame-stream
           (conjoin (rest-conjuncts conjuncts)
                    (qeval (first-conjunct conjuncts) frame-stream))))
      #+END_SRC

      The expression

      #+BEGIN_SRC scheme
      (put 'and 'qeval conjoin)
      #+END_SRC

      sets up qeval to dispatch to conjoin when an and form is
      encountered. or queries are handled similarly, as shown in
      Figure 4.6. The output streams for the various disjuncts of the
      or are computed separately and merged using the
      interleave-delayed procedure from Section 4.4.4.6. (See Exercise
      4.71 and Exercise 4.72). 

      #+BEGIN_SRC scheme
      (define (disjoin disjuncts frame-stream)
       (if (empty-disjunction? disjuncts)
           the-empty-stream
           (interleave-delayed
            (qeval (first-disjunct disjuncts) frame-stream)
            (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
      (put 'or 'qeval disjoin)
      #+END_SRC

      The predicates and selectors for the syntax of conjuncts and
      disjuncts are given in Section 4.4.4.7.

***** Filters

      not is handled by the method outlined in Section 4.4.2. We
      attempt to extend each frame in the input stream to satisfy the
      query being negated, and we include a given frame in the output
      stream only if it cannot be extended.

      #+BEGIN_SRC scheme
      (define (negate operands frame-stream)
       (stream-flatmap
        (lambda (frame)
         (if (stream-null?
              (qeval (negated-query operands)
                     (singleton-stream frame)))
             (singleton-stream frame)
             the-empty-stream))
        frame-stream))
      (put 'not 'qeval negate)
      #+END_SRC

      lisp-value is a filter similar to not. Each frame in the stream
      is used to instantiate the values in the pattern, the indicated
      predicate is applied, and the frames for which the predicate
      returns false are filtered out of the input stream. An error
      results if there are unbound pattern variables.

      #+BEGIN_SRC scheme
      (define (lisp-value call frame-stream)
       (stream-flatmap
        (lambda (frame)
         (if (execute
              (instantiate
               call
               frame
               (lambda (v f)
                (error "Unknown pat var: LISP-VALUE" v))))
              (singleton-stream frame)
              the-empty-stream))
         frame-stream))
      (put 'lisp-value 'qeval lisp-value)
      #+END_SRC

      execute, which applies the predicate to the arguments, must eval
      the predicate expression to get the procedure to apply. However,
      it must not evaluate the arguments, since they are already
      actual arguments, not expressions whose evaluation (in Lisp)
      will produce the arguments. Note that execute is implemented
      using eval and apply from the underlying Lisp system.

      #+BEGIN_SRC scheme
      (define (execute exp)
       (apply (eval (predicate exp) user-initial-environment)
              (args exp)))
      #+END_SRC

      The always-true special form provides for a query that is always
      satisfied. It ignores its contents (normally empty) and simply
      passes through all the frames in the input stream. always-true
      is used by the rule-body selector (Section 4.4.4.7) to provide
      bodies for rules that were defined without bodies (that is,
      rules whose conclusions are always satisfied).

      #+BEGIN_SRC scheme
      (define (always-true ignore frame-stream) frame-stream)
      (put 'always-true 'qeval always-true)
      #+END_SRC

      The selectors that define the syntax of not and lisp-value are
      given in Section 4.4.4.7.

**** 4.4.4.3 Finding Assertions by Pattern Matching

     find-assertions, called by simple-query (Section 4.4.4.2) takes
     as input a pattern and a frame. It returns a stream of frames,
     each extending the given one by a data-base match of the given
     pattern. It uses fetch-assertions (Section 4.4.4.5) to get a
     stream of all the assertions in the data base that should be
     checked for a match against the pattern and the frame. The reason
     for fetch-assertions here is that we can often apply simple tests
     that will eliminate many of the entries in the data base from the
     pool of candidates for a successful match. The system would still
     work if we eliminated fetch-assertions and simply checked a
     stream of all assertions in the data base, but the computation
     would be less efficient because we would need to make many more
     calls to the matcher.

     #+BEGIN_SRC scheme
     (define (find-assertions pattern frame)
      (stream-flatmap
       (lambda (datum) (check-an-assertion datum pattern frame))
       (fetch-assertions pattern frame)))
     #+END_SRC

     check-an-assertion takes as arguments a pattern, a data object
     (assertion), and a frame and returns either a one-element stream
     containing the extended frame or the empty-stream if the match
     fails.

     #+BEGIN_SRC scheme
     (define (check-an-assertion assertion query-pat query-frame)
      (let ((match-result
             (pattern-match query-pat assertion query-frame)))
       (if (eq? match-result 'failed)
           the-empty-stream
           (singleton-stream match-result))))
     #+END_SRC

     check-an-assertion takes as arguments a pattern, a data object
     (assertion), and a frame and returns either a one-element stream
     containing the extended frame or the-empty-stream if the match
     fails.

     #+BEGIN_SRC scheme
     (define (check-an-assertion assertion query-pat query-frame)
      (let ((match-result
             (pattern-match query-pat assertion query-frame)))
       (if (eq? match-result 'failed)
           the-empty-stream
           (singleton-stream match-result))))
     #+END_SRC

     The basic pattern match returns either the symbol failed or an
     extension of the given frame. The basic idea of the matcher is to
     check the pattern against the data, element by element,
     accumulating bindings for the pattern variables. If the pattern
     and the data object are the same, the match succeeds and we
     return the frame of bindings accumulated so far. Otherwise, if
     the pattern is a variable we extend the current frame by binding
     the variable to the data, so long as this is consistent with the
     bindings already in the frame. If the pattern and the data are
     both pairs, we (recursively) match the car of the pattern against
     the car of the data to produce a frame; in this frame we then
     match the cdr of the pattern against the cdr of the data. If none
     of these cases are applicable, the match fails and we return the
     symbol failed.

     #+BEGIN_SRC scheme
     (define (pattern-match pat dat frame)
      (cond ((eq? frame 'failed) 'failed)
            ((equal? pat dat) frame)
            ((var? pat) (extend-if-consistent pat dat frame))
            ((and (pair? pat) (pair? dat))
             (pattern-match
              (cdr pat)
              (cdr dat)
              (pattern-match (car pat) (car dat) frame)))
            (else 'failed)))
     #+END_SRC

     Here is the procedure that extends a frame by adding a new
     binding, if this is consistent with the bindings already in the
     frame:

     #+BEGIN_SRC scheme
     (define (extend-if-consistent var dat frame)
      (let ((binding (binding-in-frame var frame)))
       (if binding
           (pattern-match (binding-value binding) dat frame)
           (extend var dat frame))))
     #+END_SRC

     If there is no binding for the variable in the frame, we simply
     add the binding of the variable to the data. Otherwise we match,
     in the frame, the data against the value of the variable in the
     frame. If the stored value contains only constants, as it must if
     it was stored during pattern matching by extend-if-consistent,
     then the match simply tests whether the stored and new values are
     the same. If so, it returns the unmodified frame; if not, it
     returns a failure indication. The stored value may, however,
     contain pattern variables if it was stored during unification
     (see Section 4.4.4.4). The recursive match of the stored pattern
     against the new data will add or check bindings for the variables
     in this pattern. For example, suppose we have a frame in which ?x
     is bound to (f ?y) and ?y is unbound, and we wish to augment this
     frame by a binding of ?x to (f b). We look up ?x and find that it
     is bound to (f ?y). This leads us to match (f ?y) against the
     proposed new value (f b) in the same frame. Eventually this match
     extends the frame by adding a binding of ?y to b. ?X remains
     bound to (f ?y). We never modify a stored binding and we never
     store more than one binding for a given variable. 

     The procedures used by extend-if-consistent to manipulate
     bindings are defined in Section 4.4.4.8.

***** Patterns with dotted tails

      If a pattern contains a dot followed by a pattern variable, the
      pattern variable matches the rest of the data list (rather than
      the next element of the data list), just as one would expect
      with the dotted-tail notation described in Exercise
      2.20. Although the pattern matcher we have just implemented
      doesn't look for dots, it does behave as we want. This is bcause
      the Lisp read primitive, which is used by query-driver-loop to
      read the query and represent it as a list structure, treats dots
      in a special way.

      When read sees a dot, instead of making the next item be the
      next element of a list (the car of a cons whose cdr will be the
      rest of the list) it makes the next item be the cdr of the list
      structure. For example, the list structure produced by read for
      the pattern (computer ?type) could be constructed by evaluating
      the expression (cons 'computer (cons '?type '())), and that for
      (computer . ?type) could be constructed by evaluating the
      expression (cons 'computer '?type).

      Thus, as pattern-match recursively compares cars and cdrs of a
      data list and a pattern that had a dot, it eventually matches
      the variable after the dot (which is a cdr of the pattern)
      against a sublist of the data list, binding the variable to that
      list. For example, matching the pattern (computer . ?type)
      against (computer programmer trainee) will match ?type against
      the list (programmer trainee).

**** 4.4.4.4 Rules and Unification 
     
     apply-rules is the rule analog of find-assertions (Section
     4.4.4.3). It takes as input a pattern and a frame, and it forms a
     stream of extension frames by applying rules from the data
     base. stream-flatmap maps apply-a-rule down the stream of
     possibly applicable rules (selected by fetch-rules, Section
     4.4.4.5) and combines the resulting streams of frames.

     #+BEGIN_SRC scheme
     (define (apply-rules pattern frame)
      (stream-flatmap (lambda (rule)
                       (apply-a-rule rule pattern frame))
                      (fetch-rules pattern frame)))
     #+END_SRC

     apply-a-rule applies rules using the method outlined in Section
     4.4.2. It first augments its arguments frame by unifying rule
     conclusion with the pattern in the given frame. If this succeeds,
     it evaluates the rule body in this new frame.

     Before any of this happens, however, the program renames all the
     variables in the rule with unique new names. The reason for this
     is to prevent the variables for different rule applications from
     becoming confused with each other. For instance, if two rules
     both use a variable named ?x, then each one may add a binding for
     ?x to the frame when it is applied. These two ?x's have nothing
     to do with each other, and we should not be fooled into thinking
     that the two bindings must be consistent. Rather than rename
     variables, we could devise a more clever environment structure;
     however, the renaming approach we have chosen here is the most
     straightforward, even if not the most efficient. (See Exercise
     4.79.) Here is the apply-a-rule procedure:

     #+BEGIN_SRC scheme
       (define (apply-a-rule rule query-pattern query-frame)
        (let ((clean-rule (rename-variables-in rule)))
         (let ((unify-result (unify-match query-pattern
                                          (conclusion clean-rule)
                                          query-frame)))
           (if (eq? unify-result 'failed)
               the-empty-stream
               (qeval (rule-body clean-rule)
                      (singleton-stream unify-result))))))
     #+END_SRC

     The selectors rule-body and conclusion that extract parts of a
     rule are defined in Section 4.4.4.7. 

     We generate unique variable names by associating a unique
     identifier (such as a number) with each rule application and
     combining this identifier with the original variable names. For
     example, if the rule-application identifier is 7, we might change
     each ?x in the rule to ?x-7 and each ?y in the rule to
     ?y-7. (make-new-variable and new-rule-application-id are included
     with the syntax procedures in Section 4.4.4.7.)

     #+BEGIN_SRC scheme
     (define (rename-variables-in rule)
      (let ((rule-application-id (new-rule-application-id)))
       (define (tree-walk exp)
        (cond ((var? exp)
               (make-new-variable exp rule-application-id))
              ((pair? exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (else exp)))
        (tree-walk rule)))
     #+END_SRC

     The unification algorithm is implemented as a procedure that
     takes as inputs two patterns and a frame and returns either the
     extended frame or the symbol failed. The unifier is like the
     pattern matcher except that it is symmetrical -- variables are
     allowed on both sides of the match. unify-match is basically the
     same as pattern-match, except that there is extra code (marked
     "***" below) to handle the case where the object on the right
     side of the match is a variable.

     #+BEGIN_SRC scheme
     (define (unify-match p1 p2 frame)
      (cond ((eq? frame 'failed) 'failed)
            ((equal? p1 p2) frame)
            ((var? p1) (extend-if-possible p1 p2 frame))
            ((var? p2) (extend-if-possible p2 p1 frame))
            ((and (pair? p1) (pair? p2))
             (unify-match (cdr p1)
                          (cdr p2)
                          (unify-match (car p1)
                                       (car p2)
                                       frame)))
           (else 'failed)))
     #+END_SRC

     In unification, as in one-sided pattern matching, we want to
     accept a proposed extension of the frame only if it is consistent
     with existing bindings. The procedure extend-if-possible used in
     unification is the same as the extend-if-consistent used in
     pattern matching except for two special checks, marked "***" in
     the program below. In the first case, if the variable we are
     trying to match is not bound, but the value we are trying to
     match it with is itself a (different) variable, it is necessary
     to check to see if the value is bound, and if so, to match its
     value. If both parties to the match are unbound, we may bind
     either to the other.

     The second check deals with attempts to bind a variable to a
     pattern that includes that variable. Such a situation can occur
     whenever a variable is repeated in both patterns. Consider, for
     example, unifying the two patterns (?x ?x) and (?y <expression
     involving ?y>) in a frame where both ?x and ?y are unbound. First
     ?x is matched against ?y, making a binding of ?x to ?y. Next, the
     same ?x is matched against the given expression involving
     ?y. Since ?x is already bound to ?y, this results in matching ?y
     against the expression. If we think of the unifier as finding a
     set of values for the pattern variables that make the patterns
     the same, then these patterns imply instructions to find a ?y
     such that ?y is equal to the expression involving ?y. There is no
     general method for solving such equations, so we reject such
     bindings; these cases are recognized by the predicate
     depends-on?. On the other hand, we do not want to reject attempts
     to bind a variable to itself. For example, consider unifying (?x
     ?x) and (?y ?y). The second attempt to bind ?x to ?y matches ?y
     (the stored value of ?x) against ?y (the new value of ?x). This
     is taken care of by the equal? clause of unify-match.

     #+BEGIN_SRC scheme
     (define (extend-if-possible var val frame)
      (let ((binding (binding-in-frame var frame)))
       (cond (binding (unify-match (binding-value binding) val frame))
             ((var? val)
              (let ((binding (binding-in-frame val frame)))
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                   (extend var val frame))))
             ((depends-on? val var frame)
              'failed)
             (else (extend var val frame)))))
     #+END_SRC
     
     depends-on? is a predicate that tests whether an expression
     proposed to be the value of a pattern variable depends on the
     variable. This must be done relative to the current frame because
     the expression may contain occurrences of a variable that already
     has a value that depends on our test variable. The structure of
     depends-on? is a simple recursive tree walk in which we
     substitute for the values of variables whenever necessary.

     #+BEGIN_SRC scheme
     (define (depends-on? exp var frame)
      (define (tree-walk e)
       (cond ((var? e)
              (if (equal? var e)
                  true
                  (let ((b (binding-in-frame e frame)))
                   (if b
                       (tree-walk (binding-value b))
                       false))))
             ((pair? e)
              (or (tree-walk (car e))
                  (tree-walk (cdr e))))
             (else false)))
      (tree-walk exp))
     #+END_SRC

**** 4.4.4.5 Maintaining the Data Base     
     
     One important problem in designing logic programming languages is
     that of arranging things so that as few irrelevant data-base
     entries as possible will be examined in checking a given
     pattern. In our system, in addition to storing all assertions in
     one big stream, we store all assertions whose cars are constant
     symbols in separate streams, in a table indexed by the symbol. To
     fetch an assertion that may match a pattern, we first check to
     see if the car of the pattern is a constant symbol. If so, we
     return (to be tested using the matcher) all the stored assertions
     that have the same car. If the pattern's car is not a constant
     symbol, we return all the stored assertions. Cleverer methods
     could also take advantage of information in the frame, or try
     also to optimize the case where the car of the pattern is not a
     constant symbol. We avoid building our criteria for indexing
     (using the car, handling only the case of constant symbols) in
     our program; instead we call on predicates and selectors that
     embody our criteria.

     #+BEGIN_SRC scheme
     (define THE-ASSERTIONS the-empty-stream)
     (define (fetch-assertions pattern frame)
      (if (use-index? pattern)
          (get-indexed-assertions pattern)
          (get-all-assertions)))
     (define (get-all-assertions) THE-ASSERTIONS)
     (define (get-indexed-assertions pattern)
      (get-stream (index-key-of pattern) 'assertion-stream))
     #+END_SRC

     get-stream looks up a stream in the table and returns an empty
     stream if nothing is stored there.

     #+BEGIN_SRC scheme
     (define (get-stream key1 key2)
      (let ((s (get key1 key2)))
       (if s s the-empty-stream)))
     #+END_SRC
     
     Rules are stored similarly, using the car of the rule
     conclusion. Rule conclusions are arbitrary patterns, however, so
     they differ from assertions in that they can contain variables. A
     pattern whose car is a constant symbol can match rules whose
     conclusions start with a variable as well as rules whose
     conclusions have the same car. Thus, when fetching rules that
     might match a pattern whose car is a constant symbol we fetch all
     rules whose conclusions start with a variable as well as those
     whose conclusions have the same car as the pattern. For this
     purpose we store all rules whose conclusions start with a
     variable in a separate stream in our table, indexed by the symbol
     ?.

     #+BEGIN_SRC scheme
     (define THE-RULES the-empty-stream)
     (define (fetch-rules pattern frame)
      (if (use-index? pattern)
          (get-indexed-rules pattern)
          (get-all-rules)))
     (define (get-all-rules) THE-RULES)
     (define (get-indexed-rules pattern)
      (stream-append
       (get-stream (index-key-of pattern) 'rule-stream)
       (get-stream '? 'rule-stream)))
     #+END_SRC

     add-rule-or-assertion! is used by query-driver-loop to add
     assertions and rules to the data base. Each item is stored in the
     index, if appropriate, and in a stream of all assertions or rules
     in the data base.

     #+BEGIN_SRC scheme
     (define (add-rule-or-assertion! assertion)
      (if (rule? assertion)
          (add-rule! assertion)
          (add-assertion! assertion)))
     (define (add-assertion! assertion)
      (store-assertion-in-index assertion)
      (let ((old-assertions THE-ASSERTIONS))
       (set! THE-ASSERTIONS
             (cons-stream assertion old-assertions))
       'ok))
     (define (add-rule! rule)
      (store-rule-in-index rule)
      (let ((old-rules THE-RULES))
       (set! THE-RULES (cons-stream rule old-rules))
       'ok))
     #+END_SRC

     To actually store an assertion or a rule, we check to see if it
     can be indexed. If so, we store it in the appropriate stream.

     #+BEGIN_SRC scheme
     (define (store-assertion-in-index assertion)
      (if (indexable? assertion)
          (let ((key (index-key-of assertion)))
           (let ((current-assertion-stream 
                  (get-stream key 'assertion-stream)))
            (put key
                 'assetion-stream
                 (cons-stream
                  assertion
                  current-assertion-stream))))))
     (define (store-rule-in-index rule)
      (let ((pattern (conclusion rule)))
       (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
         (let ((current-rule-stream
                (get-stream key 'rule-stream)))
          (put key
               'rule-stream
               (cons-stream rule
                            current-rule-stream)))))))
     #+END_SRC

     The following procedures define how the data-base index is
     used. A pattern (an assertion or a rule conclusion) will be
     stored in the table if it starts with a variable or constant
     symbol.

     #+BEGIN_SRC scheme
     (define (indexable? pat)
      (or (constant-symbol? (car pat))
          (var? (car pat))))
     #+END_SRC

     The key under which a pattern is stored in the table is either ?
     (if it starts with a variable) or the constant symbol with which
     it starts.

     #+BEGIN_SRC scheme
     (define (index-key-of pat)
      (let ((key (car pat)))
       (if (var? key) '? key)))
     #+END_SRC

     The index will be used to retrieve items that might match a
     pattern if the pattern starts with a constant symbol.

     #+BEGIN_SRC scheme
     (define (use-index? pat) (constant-symbol? (car pat)))
     #+END_SRC

     - Exercise 4.70: What is the purpose of the let bindings in the
       procedures add-assertion! and add-rule!? What would be wrong
       with the following implementation of add-assertion!? Hint:
       Recall the definition of the infinite stream of ones in Section
       3.5.2: (define ones (cons-stream 1 ones)).

       #+BEGIN_SRC scheme
       (define (add-assertion! assertion)
        (store-assertion-in-index assertion)
        (set! THE-ASSERTIONS
              (cons-stream assertion THE-ASSERTIONS))
        'ok)
       #+END_SRC

       The problem is that the actual expression THE-ASSERTIONS is
       delayed and not evaluated. According to our model of delays as
       thunks, what is written there is similar to:

       #+BEGIN_SRC
       (define (add-assertion! assertion)
        (store-assertion-in-index assertion)
        (set! THE-ASSERTIONS
              (cons-stream assertion (lambda () THE-ASSERTIONS)))
        'ok)
       #+END_SRC

       where (lambda () THE-ASSERTIONS) is evaluated later. The problem
       is that by the time you force this, THE-ASSERTIONS will be
       equal to (cons-stream assertion (lambda () THE-ASSERTIONS)) so
       you will just get back the first assertion every time you try
       to car the stream. If instead you write

       #+BEGIN_SRC
       (define (add-assertion! assertion)
        (store-assertion-in-index assertion)
        (let ((old-assertions THE-ASSERTIONS))
          (set! THE-ASSERTIONS
                (cons-stream assertion (lambda () old-assertions)))
        'ok))
       #+END_SRC       

       then we will capture the current environment and look up
       old-assertions in the captured environment, which will actually
       have the old assertion stream.

**** 4.4.4.6 Stream Operations

     The query system uses a few stream operations that were not
     presented in Chapter 3. stream-append-delayed and
     interleave-delayed are just like stream-append and interleave
     (Section 3.5.3), except that they take a delayed argument (like
     the integral procedure in Section 3.5.4). This postpones looping
     in some cases (see Exercise 4.71).

     #+BEGIN_SRC scheme
     (define (stream-append-delayed s1 delayed-s2)
      (if (stream-null? s1)
          (force delayed-s2)
          (cons-stream
           (stream-car s1)
           (stream-append-delayed
            (stream-cdr s1)
            delayed-s2))))

     (define (interleave-delayed s1 delayed-s2)
      (if (stream-null? s1)
          (force delayed-s2)
          (cons-stream
           (stream-car s1)
           (interleave-delayed
            (force delayed-s2)
            (delay (stream-cdr s1))))))
     #+END_SRC

     stream-flatmap, which is used throughout the query evaluator to
     map a procedure over a stream of frames and combine the resulting
     streams of frames, is the stream analog of the flatmap procedure
     introduced for ordinary lists in Section 2.2.3. Unlike ordinary
     flatmap, however, we accumulate the streams with an interleaving
     process, rather than simply appending them (see Exercise 4.72 and
     Exercise 4.73).

     #+BEGIN_SRC scheme
     (define (stream-flatmap proc s)
      (flatten-stream (stream-map proc s)))
     (define (flatten-stream stream)
      (if (stream-null? stream)
          the-empty-stream
          (interleave-delayed
           (stream-car stream)
           (delay (flatten-stream (stream-cdr stream))))))
     #+END_SRC

     The evaluator also uses the following simple procedure to
     generate a stream consisting of a single element:

     #+BEGIN_SRC scheme
     (define (singleton-stream x)
      (cons-stream x the-empty-stream))
     #+END_SRC

**** 4.4.4.7 Query Syntax Procedures
     type and contents, used by qeval (Section 4.4.4.2), specify that
     a special form is identified by the symbol in its car. They are
     the same as the type-tag and contents procedures in Section
     2.4.2, except for the error message.

     #+BEGIN_SRC scheme
     (define (type exp)
      (if (pair? exp)
          (car exp)
          (error "Unknown expression TYPE" exp)))
     (define (contents exp)
      (if (pair? exp)
          (cdr exp)
          (error "Unknown expression CONTENTS" exp)))
     #+END_SRC

     The following procedures, used by query-driver-loop (in Section
     4.4.4.1), specify the rules and assertions are added to the data
     base by expressions of the form (assert! <rule-or-assertion>):

     #+BEGIN_SRC scheme
     (define (assertion-to-be-added? exp)
      (eq? (type exp) 'assert!))
     (define (add-assertion-body exp) (car (contents exp)))
     #+END_SRC

     Here are the syntax definitions for the and, or, not, and
     lisp-value special forms (Section 4.4.4.2):

     #+BEGIN_SRC scheme
     (define (empty-conjunction? exps) (null? exps))
     (define (first-conjunct exps) (car exps))
     (define (rest-conjuncts exps) (cdr exps))
     (define (empty-disjunction? exps) (null? exps))
     (define (first-disjunct exps) (car exps))
     (define (rest-disjuncts exps) (cdr exps))
     (define (negated-query exps) (car exps))
     (define (predicate exps) (car exps))
     (define (args exps) (cdr exps))
     #+END_SRC

     The following three procedures define the syntax of rules:

     #+BEGIN_SRC scheme
     (define (rule? statement)
      (tagged-list? statement 'rule))
     (define (conclusion rule) (cadr rule))
     (define (rule-body rule)
      (if (null? (cddr rule)) '(always-true) (caddr rule)))
     #+END_SRC

     query-driver-loop (Section 4.4.4.1) calls query-syntax-process to
     transform pattern variables in the expression, which have the
     form ?symbol, into the internal format (? symbol). That is to
     say, a pattern such as (job ?x ?y) is actually represented
     internally by the system as (job (? x) (? y)). This increases the
     efficiency of query processing, since it means that the system
     can check to see if an expression is the symbol ?, rather than
     having to extract characters from the symbol. The syntax
     transformation is accomplished by the following procedure:

     #+BEGIN_SRC scheme
     (define (query-syntax-process exp)
      (map-over-symbols expand-question-mark exp))
     (define (map-over-symbols proc exp)
      (cond ((pair? exp)
             (cons (map-over-symbols proc (car exp))
                   (map-over-symbols proc (cdr exp))))
            ((symbol? exp) (proc exp))
            (else exp)))

     (define (expand-question-mark symbol)
      (let ((chars (symbol->string symbol)))
       (if (string=? (substring chars 0 1) "?")
           (list '?
                  (string->symbol
                   (substring chars 1 (strengh-length chars))))
           symbol)))
     #+END_SRC

     Once variables are transformed in this way, the variables in a
     pattern are lists starting with ?, and the constant symbols
     (which need to be recognized for data-base indexing, Section
     4.4.4.5) are just the symbols.

     #+BEGIN_SRC scheme
     (define (var? exp) (tagged-list? exp '?))
     (define (constant-symbol? exp) (symbol? exp))
     #+END_SRC

     Unique variables are constructed during rule application (in
     Section 4.4.4.4) by means of the following procedures. The unique
     identifier for a rule application is a number, which is
     incremented each time a rule is applied.

     #+BEGIN_SRC scheme
     (define rule-counter 0)

     (define (new-rule-application-id)
      (set! rule-counter (+ 1 rule-counter))
      rule-counter)
     (define (make-new-variable var rule-application-id)
      (cons '? (cons rule-application-id (cdr var))))
     #+END_SRC

     When query-driver-loop instantiates the query to print the
     answer, it converts any unbound pattern variables back to the
     right form for printing, using

     #+BEGIN_SRC scheme
     (define (contract-question-mark variable)
      (string->symbol
       (string-append "?"
        (if (number? (cadr variable))
            (string-append (symbol->string (caddr variable))
                           "-"
                           (number->string (cadr variable)))
            (symbol->string (cadr variable))))))
     #+END_SRC

**** 4.4.4.8 Frames and Bindings

     Frames are represented as lists of bindings, which are
     variable-value pairs:

     #+BEGIN_SRC scheme
     (define (make-binding variable value)
      (cons variable value))
     (define (binding-variable binding) (car binding))
     (define (binding-value binding) (cdr binding))
     (define (binding-in-frame variable frame)
      (assoc variable frame))
     (define (extend variable value frame)
      (cons (make-binding variable value) frame))
     #+END_SRC

     - Exercise 4.71: Louis Reasoner wonders why the simple-query and
       disjoin procedures (Section 4.4.4.2) are implemented using
       explicit delay operations, rather than being defined as
       follows:

       #+BEGIN_SRC scheme
       (define (simple-query query-pattern frame-stream)
        (stream-flatmap
         (lambda (frame)
          (stream-append
           (find-assertions query-pattern frame)
           (apply-rules query-pattern frame)))
         frame-stream))
       (define (disjoin disjuncts frame-stream)
        (if (empty-disjunction? disjuncts)
            the-empty-stream
            (interleave
             (qeval (first-disjunct disjuncts)
                    frame-stream)
             (disjoin (rest-disjuncts disjuncts)
                      frame-stream))))
       #+END_SRC

       Can you give examples of queries where these simpler
       definitions would lead to undesirable behavior?
       
       If you disjoin this way, we evaluate both arguments before
       calling interleave. So, we end up calling disjoin basically in
       a loop until we end up with empty disjuncts, qeval-ing the
       first disjunct every time. So if there is going to be a loop,
       you're going to loop continually and not get any output
       stream. It's a difference between no results and some results,
       although the potential loop is there regardless.

       For example:
       #+BEGIN_SRC scheme
       (rule (recurse ?x ?y)
        (or (job ?x (computer . ?y))
            (recurse ?x ?y)))
       #+END_SRC

       This rule deliberately loops infinitely. If we delay the
       disjoin argument of interleave in disjoin, we get a repeating
       stream of outputs. If we don't, the program doesn't print
       anything and eventually blows its stack.

       This doesn't affect non-looping rules though, although it does
       basically defeat the purpose of using streams. If we wrote a
       construct to just take the first N results, not using a delayed
       disjunction would defeat the purpose of this construct.

       A similar problem happens with apply-rules. Although
       apply-rules will return a stream, it will apply the first rule
       it gets before delaying the stream-cdr. If that particular rule
       loops, we won't get any output, even of assertions. Here is an
       example, which we went over earlier:

       #+BEGIN_SRC scheme
       (assert! (married mickey minnie))
       (assert! (rule (married ?x ?y) (married ?y ?x)))
       (married mickey ?x)
       #+END_SRC

       If we use the delayed evaluation for simple-query, this prints
       (maried mickey minnie) infinitely. Given that we gave the
       interpreter something that was an infinite loop, this is
       'desirable' behavior, the program doesn't crash and prints
       these results. We only need to add a construct like 'take-n' to
       the program and this will be a workable solution. However, if
       we don't use delayed evaluatin and use the simple-query given
       above, the program doesn't print any output as it churns away
       trying to find the solution, and eventually blows the stack.

     - Exercise 4.72: Why do disjoin and stream-flatmap interleave the
       streams rather than simply append them? Give examples that
       illustrate why interleaving works better. (Hint: Why did we use
       interleave in Section 3.5.3?)

       It is for infinite streams. If the first clause of a disjoin is
       infinite, it will never display any results of the second
       clause, if we don't interleave.

       Here is one example:       

       #+BEGIN_SRC scheme
       (assert! (rule (deconstruct (?t . ?v) ?t)))
       (assert! (fill (1 2 3 4) 2))
       (assert! (rule (fill ?x ?y)
        (or (fill ?x ?y)
            (deconstruct ?x ?y))))
       (fill (1 2 3 4) ?y)
       #+END_SRC

       This has to be complicated because even though we interleave,
       the first item in a stream is always evaluated. The interpreter
       does a normal evaluation first. There is no special syntax in
       the rule conclusion, which is also stored as an assertion.

       #+BEGIN_SRC scheme
       (qeval (fill ?x ?y) (()))
       #+END_SRC

       This is not syntax so we do a simple query, where we first find
       normal DB assertions:

       #+BEGIN_SRC scheme
       (define (simple-query query-pattern frame-stream)
        (stream-flatmap
         (lambda (frame)
          (stream-append-delayed
           (find-assertions query-pattern frame)
           (delay (apply-rules query-pattern frame))))
         frame-stream))
       #+END_SRC

       WHen we 'find-asssertions', we find (fill (1 2 3 4) 2), and
       this becomes the first element of the stream. Then, because we
       are using 'stream-append-delayed', we stop evaluating and
       return the stream with (fill (1 2 3 4) 2) as its first
       element. We then try to apply the rule, since there is no
       stream we are interleaved with. We unify with the rule for fill
       and call disjoin:
       
       #+BEGIN_SRC scheme
       (define (disjoin disjuncts frame-stream)
        (if (empty-disjunction? disjuncts)
            the-empty-stream
            (interleave-delayed
             (qeval (first-disjunct disjuncts) frame-stream)
             (delay (disjoin (rest-disjuncts disjuncts) frame-stream)))))
       #+END_SRC
       
       Which in this case ends in evaluating
       
       #+BEGIN_SRC scheme
       (qeval (first-disjunct disjuncts) frame-stream)
       #+END_SRC

       attempt to match (fill ?x ?y), and, in
       this case, get one assertion. It then matches that assertion,
       and does

       #+BEGIN_SRC scheme
       (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame)))
       #+END_SRC

       This finds the assertion (fill (1 2 3 4) 2), and puts it second
       in the stream, since the first item is not delayed (this is the
       body of (cons-stream (stream-car s1) ...)  That's the only
       matching assertion in this case. Now we are in
       stream-append-delayed:

       #+BEGIN_SRC scheme
       (define (stream-append-delayed s1 delayed-s2)
        (if (stream-null? s1)
            (force delayed-s2)
            (cons-stream
             (stream-car s1)
             (stream-append-delayed
   	      (stream-cdr s1)
	      delayed-s2))))
       #+END_SRC

       The second argument to cons-stream is delayed and we return
       without forcing it. Now we're on to the second item of the
       disjunction, which uses deconstruct to print

       (fill (1 2 3 4) 1).

       Then, after printing that, we try to continue through the
       stream where we are applying rules, and loop infinitely. But if
       we didn't have the delay argument, we wouldn't print anything
       because nothing would be delayed, we would constantly be
       recursively applying the rule and finding the assertion. And if
       we didn't interleave, in this case, we'd be printing infinitely
       the results of (fill ?x ?y), which in this case would only be
       finding the assertions since we'd never try to apply the rule.

     - Exercise 4.73: Why does flatten-stream use delay explicitly?
       What would be wrong if we defined it as follows:

       #+BEGIN_SRC scheme
       (define (flatten-stream stream)
        (if (stream-null? stream)
            the-empty-stream
            (interleave
             (stream-car stream)
             (flatten-stream (stream-cdr stream)))))
       #+END_SRC

       The same thing as in the other questions. flatten-stream would
       not be delayed. So you would actually go ahead and force all
       the arguments of the entire stream before invoking interleave,
       which defeats the purpose of using streams altogether. It would
       loop infinitely without printing any results on any queries
       with loops that call interleave.

     - Exercise 4.74: Alyssa P. Hacker proposes to use a simpler
       version of stream-flatmap in negate, lisp-value, and
       find-assertions. She observes that the procedure that is mapped
       over the frame stream in these cases always produces either the
       empty stream or a singleton stream, so no interleaving is
       needed when combining these streams.

       a. Fill in the missing expression in Alyssa's program.

       #+BEGIN_SRC scheme
       (define (simple-stream-flatmap proc s)
        (simple-flatten (stream-map proc s)))
       (define (stream-flatten stream)
        (stream-map <??>
                    (stream-filter <??> stream)))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (simple-stream-flatmap proc s)
        (simple-flatten (stream-map proc s)))
       (define (stream-flatten stream)
        (stream-map (lambda (x) (stream-car x))
                    (stream-filter 
                     (lambda (s) (not (empty-stream? s)))
                     stream)))
       #+END_SRC

       b. Does the query system's behavior change if we change it this
       way?

       No. In the case of just singleton and empty strings, it works
       the same.

     - Exercise 4.75: Implement for the query language a new special
       form called unique. unique should succeed if there is precisely
       one item in the data base satisfying a specified query. For
       example,

       #+BEGIN_SRC scheme
       (unique (job ?x (computer wizard)))
       #+END_SRC

       should print the one-item stream

       #+BEGIN_SRC scheme
       (unique (job (Bitdiddle Ben) (computer wizard)))
       #+END_SRC

       since Ben is the only computer wizard, and

       #+BEGIN_SRC scheme
       (unique (job ?x (computer programmer)))
       #+END_SRC

       should print the empty stream, since there is more than one
       computer programmer. Moreover,

       #+BEGIN_SRC scheme
       (and (job ?x ?j) (unique (job ?anyone ?j)))
       #+END_SRC

       should list all the jobs that are filled by only one person,
       and the people who fill them.

       There are two parts to implementing unique. The first is to
       write a procedure that handles this special form, and the
       second is to make qeval dispatch to that procedure. The second
       part is trivial, since qeval does its dispatching in a
       data-directed way. If your procedure is called
       uniquely-asserted, all you need to do is

       #+BEGIN_SRC scheme
       (put 'unique 'qeval uniquely-asserted)
       #+END_SRC

       and qeval will dispatch to this procedure for every query whose
       type (car) is the symbol unique.

       The real problem is to write the procedure
       uniquely-asserted. This should take as input the contents (cdr)
       of the unique query, together with a stream of frames. For each
       frame in the stream, it should use qeval to find the stream of
       all extensions to the frame that satisfy the given query. Any
       stream that does not have exactly one item in it should be
       eliminated. The remaining streams should be passed back to be
       accumulated into one big stream that is the result of the
       unique query. This is similar to the implementation of the not
       special form. Test your implementation by forming a query that
       lists all people who supervise precisely one person.

       #+BEGIN_SRC scheme
         (define (unique-body call) (car call))

         (define (uniquely-asserted call frame-stream)
           (stream-flatmap
            (lambda (frame)
              (let ((evaled (qeval (unique-body call) (singleton-stream frame))))
                (if (stream-null? (stream-cdr evaled))
                    evaled
                    the-empty-stream)))
            frame-stream))
         (put 'unique 'qeval uniquely-asserted)
       #+END_SRC

       #+BEGIN_SRC scheme
       (and (supervisor ?x ?y) (unique (supervisor ?anyone ?y)))
       #+END_SRC

     - Exercise 4.76: Our implementation of and as a series
       combination of queries (Figure 4.5) is elegant, but it is
       inefficient because in processing the second query of the and
       we must scan the data base for each frame produced by the first
       query. If the data base has _n_ elements, and a typical query
       produces a number of output frames proportional to _n_ (say
       _n/k_), then scanning the data base for each frame produced by
       the first query will require n^2/k calls to the pattern
       matcher. Another approach would be to process the two clauses
       of the and separately, and then look for all pairs of output
       frames that are compatible. If each query produces n/k output
       frames, then this means that we must perform n^2/k^2
       compatibility checks -- a factor of _k_ fewer than the number
       of matches required in our current method.

       #+BEGIN_SRC scheme
	 (define (extend-if-not-failed
		  var
		  val
		  frame)
	   (if (eq? frame 'failed)
	       'failed
	       (extend var val frame)))

	 (define (extend-bindings
		  b1
		  b2
		  frame)
	   (let* ((var (binding-variable b1))
		  (val (binding-value b1))
		  (var2 (binding-variable b2))
		  (val2 (binding-value b2)))
	     (cond
	      ((and (not (var? val))
		    (not (var? val2))
		    (equal? val val2))
	       (extend var val frame))
	      ((and (var? val2) (not (var? val)))
	       (extend-if-not-failed var2 val2
				     (extend-if-binding-possible
				      b1
				      (binding-in-frame val2 frame)
				      frame)))
	      ((and (var? val) (not (var? val2)))
	       (extend-if-not-failed var val
				     (extend-if-not-failed
				      (binding-in-frame val frame)
				      b2
				      frame)))
	      ((and (var? val) (var? val2))
	       (extend-if-not-failed var val
				     (extend-if-not-failed
				      var2
				      val2
				      (extend-if-binding-possible
				       (binding-in-frame val frame)
				       (binding-in-frame val2 frame)
				       frame))))
	      (else 'failed))))

	 (define (extend-if-binding-possible
		  b1
		  b2
		  frame)
	   (cond ((false? b1) 'failed)
		 ((false? b2)
		  (extend (binding-variable b1)
			  (binding-value b2)
			  frame))
		 (else (extend-bindings b1 b2))))

	 (define (bindings-unify
		  frame1
		  frame2)
	   (cond ((null? frame1) frame2)
		 ((null? frame2) frame1)
		 (else
		  (let* ((b1 (first-binding frame1))
			 (b2 (binding-in-frame (binding-variable b1) frame2))
			 (rest-unified
			  (bindings-unify
			   (rest-bindings frame1)
			   (remove-binding (binding-variable b1) frame2))))
		    (extend-if-binding-possible
		     b1
		     b2
		     rest-unified)))))



	 (define (join-frames stream1 stream2)
	   (cond ((empty-stream? stream1)
		  the-empty-stream)
		 ((empty-stream? stream2)
		  stream1)
		 (else
		  (stream-filter (lambda (f)
				   (not (eq? f 'failed)))
				 (interleave-delayed
				  (stream-map (lambda (f)
						(bindings-unify
						 (stream-car stream1)
						 f))
					      stream2)
				  (delay (join-frames (stream-cdr stream1) stream2)))))))

	 (define (conjoin conjuncts frame-stream)
	   (if (empty-conjunction? conjuncts)
	       the-empty-stream
	       (join-frames
		(qeval (first-conjunct conjuncts) frame-stream)
		(conjoin (rest-conjuncts conjuncts) frame-stream))))
       #+END_SRC

       The code above works for most simple queries and
       rules. However, it doesn't work for recursive rules or queries
       with a not clause. 

       - Recursive queries don't work because any invocation of a
         recursive query that references bindings inside the
         conjoin/and statement will effectively just be a recursive
         call with the exact same bindings as the one we're in. It
         will have a different frame because of unification but the
         effect is the same. So if you call a query like 

	 #+BEGIN_SRC scheme
         (outranked-by ?x ?y)
	 #+END_SRC

	 it will just spin.

       - Not queries won't work because of the issues we discussed
         earlier -- they are effectively a filter on
         previously-created frames, and so we need a way to give the
         not query the results of the clauses before it.

       - lisp-value queries won't work because they also operate on a
         stream of frames with expected bindings. For example, if I
         run

	 #+BEGIN_SRC scheme
         (and (salary ?person ?amount) (lisp-value > ?amount 30000))
	 #+END_SRC

	 I get an error because lisp-value is being run before ?amount
         is bound. 

       The only available solution is to scan a disjoin clause for
       recursive queries, recursions, or lisp-values, execute the
       statements before in the way we've just done, and _then_
       execute that query as you would have before. This involves
       partitioning and query into parts that can an cannot be
       evaluated in parallel.

       Our interpreter has:
       #+BEGIN_SRC scheme
       (define (conjoin conjuncts frame-stream)
        (if (empty-conjunction? conjuncts)
            the-empty-stream
            (join-frames
             (qeval (first-conjunct conjuncts) frame-stream)
             (conjoin (rest-conjuncts conjuncts) frame-stream))))
       #+END_SRC

       The original was:
       #+BEGIN_SRC scheme
       (define (conjoin conjuncts frame-stream)
        (if (empty-conjunction? conjuncts)
             the-empty-stream
             (conjoin (rest-conjuncts conjuncts)
                      (qeval (first-conjunct conjuncts) frame-stream))))
       #+END_SRC

       So if we create a function called dependent-clause?, which is a
       predicate indicating that a clause is dependent on the clause
       before it, we can modify our conjoin:

       #+BEGIN_SRC scheme
       (define (dependent-clause? a-clause)
        (or (tagged-list? a-clause 'lisp-value)
            (tagged-list? a-clause 'not)))

       (define (condense-frames listof-frames)
        (if (null? listof-frames) 
            the-empty-stream
            (join-frames (car listof-frames)
                         (condense-frames (cdr listof-frames)))))

       (define (conjoin conjuncts frame-stream)
        (define (conjoin-iter conjuncts current-frame-stream frame-streams)
         (cond
          ((empty-conjunction? conjuncts) (condense-frames frame-streams))
          ((dependent-clause? (first-conjunct conjuncts))
           (let ((eval-result (qeval (first-conjunct conjuncts) 
                                (condense-frames frame-streams))))
           (conjoin-iter (rest-conjuncts conjuncts)
                          eval-result
                          (list eval-result))))
          (else
           (conjoin-iter (rest-conjuncts conjuncts)
                         current-frame-stream
                         (cons (qeval (first-conjunct conjuncts)
                                      current-frame-stream)
                               frame-streams)))))
         (conjoin-iter conjuncts frame-stream '()))
       #+END_SRC

       This doesn't add support for recursion, but it alows us to
       use not and lisp-value expressions. The next thing to do is add
       support for recursion. This is a little difficult because we
       have no way of passing the current rule to our interpreter. One
       way of doing it is modifying how we interpret rules, for
       example, to replace recursions in a rule body with the symbol
       recurse. However, this requires us modifying the entire
       interpreter.

     - Exercise 4.78: Redesign the query language as a
       nondeterministic program to be implemented using the evaluator
       of Section 4.3, rather than as a stream process. In this
       approach, each query will produce a single answer (rather than
       the stream of all answers) and the user can type try-again to
       see more answers. You should find that much of the mechanism we
       built in this section is subsumed by nondeterministic search
       and backtracking. You will probably also find, however, that
       your new query language has subtle differences in behavior from
       the one implemented here. Can you find examples that illustrate
       this difference?

       
