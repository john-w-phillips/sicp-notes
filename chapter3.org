* Chapter 3
** Modularity Objects and State
   The preceding chapters introduced the basic elements from which
   programs are made. We saw how primitive procedures and primitive
   data are combined to construct compound entities, and we learned
   that abstraction is vital in helping us to cope with the complexity
   of large systems. But these tools are not sufficient for designing
   programs. Effective program synthesis also requires organizational
   principles that can guide us in formulating the overall design of a
   program. In particular, we need strategies to help us structure
   large systems so that they will be _modular_, that is, so that they
   can be divided "naturally" into coherent parts that can be
   separately developed and maintained.
   
   One powerful design strategy, which is particularly appropriate to
   the construction of programs for modeling physical systems, is to
   base the structure of our programs on the structure of the system
   being modeled. For each object in the system, we construct a
   corresponding computational object. For each system action, we
   define a symbolic operation in our computational model. Our hope in
   using this strategy is that extending the model to accommodate new
   objects or new actions will require no strategic changes to the
   program, only the addition of the new symbolic analogs of those
   objects or actions. If we have been successful in our system
   organization, then to add a new feature or debug an old one we will
   have to work on only a localized part of the system. 

   To a large extent, then, the way we organize a large program is
   dictated by our perception of the system to be modeled. In this
   chapter we will investigate two prominent organizational strategies
   arising from two rather different "world views" of the structure of
   systems. The first organizational strategy concentrates on
   _objects_, viewing a large system as a collection of distinct
   objects whose behaviors may change over time. An alternative
   organizational strategy concetrates on the _streams_ of information
   that flow in the system, much as an electrical engineer views a
   signal-processing system.

   Both the object-based approach and the stream-processing approach
   raise significant linguistic issues in programming. With objects,
   we must be concerned with how a computational object can change and
   yet maintain its identity. This will force us to abandon our old
   substitution model of computation in favor of a more mechanistic
   but less theoretically tractable _environment model_ of
   computation. The difficulties of dealing with objects, change, and
   identity are fundamental consequences of the need to grapple with
   time in our computational models. These difficulties become even
   greater when we allow the possibility of concurrent execution of
   programs. The stream approach can be most fully exploited when we
   decouple simulated time in our model from the order of the events
   that take place in the computer during evaluation. We will
   accomplish this using a technique known as _delayed evaluation_.

** 3.1 Assignment and Local State

   We ordinarily view the world as populated by independent objects,
   each of which has a state that changes over timne. An object is
   said to "have state" if its behavior is influenced by its
   history. A bank account, for example, has a state in that the
   answer to the question "Can I withdraw $100?" depends upon the
   history of deposit and withdrawal transactions. We can characterize
   an object's state by one or more _state variables_, which among
   them maintain enough information about history to determine the
   object's current behavior. In a simple banking system, we could
   characterize the state of an account by a balance rather than by
   remembering the entire history of account transactions.
   
   In a system composed of many objects, the objects are rarely
   completely independent. Each may influence the states of others
   through interactions, which serve to couple the state variables of
   one object to those of other objects. Indeed, the view that a
   system is composed of separate objects is most useful when the
   state variables of the system can be grouped into closely coupled
   subsystems that are only loosely coupled to other subsystems. 
   
   This view of a system can be a powerful framework for organizing
   computational models of the system. For such a model to be modular,
   it should be decomposed into computational objects that model the
   actual objects in the system. Each computational object must have
   its own _local state variables_ describing the actual object's
   state. Since the states of objects in the system being modeled
   change over time, the state variables of the corresponding
   computational objects must also change. If we choose to model the
   flow of time in the system by the elapsed time in the computer,
   then we must have a way to construct computational objects whose
   behaviors change as our programs run. In particular, if we wish to
   model state variables by ordinary symbolic names in the programming
   language, then the language must provide an _assignment operator_
   to enable us to change the value associated with a name. 

*** 3.1.1. Local State Variables

    To illustarate what we mean by having a computational object with
    time-varying state, let us model the situation of withdrawing
    money from a bank account. We will do this using a procedure
    withdraw, which takes as argument an amount to be withdrawn. If
    there is enough money in the account to accommodate the
    withdrawal, then withdraw should return the balance remaining
    after the withrdrawal. Otherwise, withdraw should return the
    message _Insufficient funds_. For example, if we begin with $100
    in the account, we should obtain the following sequence of
    responses using withdraw:

    #+BEGIN_SRC scheme
    (withdraw 25)
    75
    (withdraw 25)
    50
    (withdraw 60)
    "Insufficient funds"
    (withdraw 15)
    35
    #+END_SRC

    Observe that the expression (withdraw 25), evaluated twice, yields
    different values. This is a new kind of behavior for a
    procedure. Until now, all our procedures could be viewed as
    specifications for computing mathematical functions. A call to a
    procedure computed the value of the function applied to the given
    arguments, and two calls to the same procedure with the same
    arguments always produced the same result. To implement withdraw,
    we can use a variable balance to indicate the balance of money in
    the account and define withdraw as a procedure that accesses
    balance. The withdraw procedure checks to see if balance is at
    least as large as the requested amount. If so, withdraw decrements
    balance by amount and returns the new value of balance. Otherwise,
    withdraw returns the _Insufficient Funds_ message. Here are the
    definitions of balance and withdraw:

    #+BEGIN_SRC scheme
    (define balance 100)
    (define (withdraw amount)
     (if (>= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds"))
    #+END_SRC

    Decrementing balance is accomplished by the expression 

    #+BEGIN_SRC scheme
    (set! balance (- balance amount))
    #+END_SRC

    This uses the set! special form, whose syntax is

    #+BEGIN_SRC scheme
    (set! <name> <new-value>)
    #+END_SRC

    Here <name> is a symbol and <new-value> is any expression. set!
    changes <name> so that its value is the result obtained by
    evaluating <new-value>. In the case at hand, we are changing
    balance so that its new value will be the result of subtracting
    amount from the previous value of balance. 
    
    withdraw also uses the begin special form to cause two expressions
    to be evaluated in the case where the if test is true: first
    decrementing balance and then returning the value of balance. In
    general, evaluating the expression

    #+BEGIN_SRC scheme
    (begin <exp1> <exp2> ... <expk>)
    #+END_SRC

    causes the expression <exp1> through <expk> to be evaluated in
    sequence and the value of the final expression <expk> to be
    returned as the value of the entire begin form.

    Although withdraw works as desired, the variable balance presents
    a problem. As specified above, balance is a name defined in the
    global environment and is freely accessible to be examined or
    midified by any procedure. It would be much better if we could
    somehow make balance internal to withdraw, so that withdraw would
    be the only procedure that could access balance directly and any
    other procedure could access balance directly and any other
    procedure could access balance only indirectly (through calls to
    withdraw). This would more accurately model the notion that
    balance is a local state variable used by withdraw to keep track
    of the state of the account.

    We can make balance internal to withdraw by rewriting the
    definition as follows:

    #+BEGIN_SRC scheme
    (define new-withdraw
     (let ((balance 100))
      (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount))
                  balance)
           "Insufficient funds"))))
    #+END_SRC

    What we have done here is use let to establish an environment with
    a locla variable balance, bound to the initial value 100. Within
    this local environment, we use lambda to create a procedure that
    takes amount as an argument and behaves like our previous withdraw
    procedure. This procedure -- returned as the result of evaluating
    the let expression -- is new-withdraw, which behaves in precisely
    the same way as withdraw but whose variable balance is not
    accessible by any other procedure. 

    Combining set! with local variables is the general programming
    technique we will use for constructing computational objects with
    local-state. Unfortunately, using this technique raises a serious
    problem: When we first introduced procedures, we also introduced
    the substitution model of evaluation (Section 1.1.5) to provide an
    interpretation of what procedure application means. We said that
    applying a procedure should be interpreted as evaluating the body
    of the procedure with the formal parameters replaced by their
    values. The trouble is that, as soon as we introduce assignment
    into our language, substitution is no longer an adequate model of
    procedure application. (We will see why this is so in section
    3.1.3). As a consequence, we technically have at this point no way
    to understand why the new-withdraw procedure behaves as claimed
    above. In order to really understand a procedure such as
    new-withdraw, we will need to develop a new model of procedure
    application. In section 3.2 we will introduce such a model,
    together with an explanation of set! and local variables. First,
    however, we examine some variations on the theme established by
    new-withdraw.

    The following procedure, make-withdraw, creates "withdrawal
    processors." The formal parameter balance in make-withdraw
    specifies the initial amount of money in the account

    
    
