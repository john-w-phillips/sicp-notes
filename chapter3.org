* Chapter 3
** Modularity Objects and State
   The preceding chapters introduced the basic elements from which
   programs are made. We saw how primitive procedures and primitive
   data are combined to construct compound entities, and we learned
   that abstraction is vital in helping us to cope with the complexity
   of large systems. But these tools are not sufficient for designing
   programs. Effective program synthesis also requires organizational
   principles that can guide us in formulating the overall design of a
   program. In particular, we need strategies to help us structure
   large systems so that they will be _modular_, that is, so that they
   can be divided "naturally" into coherent parts that can be
   separately developed and maintained.
   
   One powerful design strategy, which is particularly appropriate to
   the construction of programs for modeling physical systems, is to
   base the structure of our programs on the structure of the system
   being modeled. For each object in the system, we construct a
   corresponding computational object. For each system action, we
   define a symbolic operation in our computational model. Our hope in
   using this strategy is that extending the model to accommodate new
   objects or new actions will require no strategic changes to the
   program, only the addition of the new symbolic analogs of those
   objects or actions. If we have been successful in our system
   organization, then to add a new feature or debug an old one we will
   have to work on only a localized part of the system. 

   To a large extent, then, the way we organize a large program is
   dictated by our perception of the system to be modeled. In this
   chapter we will investigate two prominent organizational strategies
   arising from two rather different "world views" of the structure of
   systems. The first organizational strategy concentrates on
   _objects_, viewing a large system as a collection of distinct
   objects whose behaviors may change over time. An alternative
   organizational strategy concetrates on the _streams_ of information
   that flow in the system, much as an electrical engineer views a
   signal-processing system.

   Both the object-based approach and the stream-processing approach
   raise significant linguistic issues in programming. With objects,
   we must be concerned with how a computational object can change and
   yet maintain its identity. This will force us to abandon our old
   substitution model of computation in favor of a more mechanistic
   but less theoretically tractable _environment model_ of
   computation. The difficulties of dealing with objects, change, and
   identity are fundamental consequences of the need to grapple with
   time in our computational models. These difficulties become even
   greater when we allow the possibility of concurrent execution of
   programs. The stream approach can be most fully exploited when we
   decouple simulated time in our model from the order of the events
   that take place in the computer during evaluation. We will
   accomplish this using a technique known as _delayed evaluation_.

** 3.1 Assignment and Local State

   We ordinarily view the world as populated by independent objects,
   each of which has a state that changes over timne. An object is
   said to "have state" if its behavior is influenced by its
   history. A bank account, for example, has a state in that the
   answer to the question "Can I withdraw $100?" depends upon the
   history of deposit and withdrawal transactions. We can characterize
   an object's state by one or more _state variables_, which among
   them maintain enough information about history to determine the
   object's current behavior. In a simple banking system, we could
   characterize the state of an account by a balance rather than by
   remembering the entire history of account transactions.
   
   In a system composed of many objects, the objects are rarely
   completely independent. Each may influence the states of others
   through interactions, which serve to couple the state variables of
   one object to those of other objects. Indeed, the view that a
   system is composed of separate objects is most useful when the
   state variables of the system can be grouped into closely coupled
   subsystems that are only loosely coupled to other subsystems. 
   
   This view of a system can be a powerful framework for organizing
   computational models of the system. For such a model to be modular,
   it should be decomposed into computational objects that model the
   actual objects in the system. Each computational object must have
   its own _local state variables_ describing the actual object's
   state. Since the states of objects in the system being modeled
   change over time, the state variables of the corresponding
   computational objects must also change. If we choose to model the
   flow of time in the system by the elapsed time in the computer,
   then we must have a way to construct computational objects whose
   behaviors change as our programs run. In particular, if we wish to
   model state variables by ordinary symbolic names in the programming
   language, then the language must provide an _assignment operator_
   to enable us to change the value associated with a name. 

*** 3.1.1. Local State Variables

    To illustarate what we mean by having a computational object with
    time-varying state, let us model the situation of withdrawing
    money from a bank account. We will do this using a procedure
    withdraw, which takes as argument an amount to be withdrawn. If
    there is enough money in the account to accommodate the
    withdrawal, then withdraw should return the balance remaining
    after the withrdrawal. Otherwise, withdraw should return the
    message _Insufficient funds_. For example, if we begin with $100
    in the account, we should obtain the following sequence of
    responses using withdraw:

    #+BEGIN_SRC scheme
    (withdraw 25)
    75
    (withdraw 25)
    50
    (withdraw 60)
    "Insufficient funds"
    (withdraw 15)
    35
    #+END_SRC

    Observe that the expression (withdraw 25), evaluated twice, yields
    different values. This is a new kind of behavior for a
    procedure. Until now, all our procedures could be viewed as
    specifications for computing mathematical functions. A call to a
    procedure computed the value of the function applied to the given
    arguments, and two calls to the same procedure with the same
    arguments always produced the same result. To implement withdraw,
    we can use a variable balance to indicate the balance of money in
    the account and define withdraw as a procedure that accesses
    balance. The withdraw procedure checks to see if balance is at
    least as large as the requested amount. If so, withdraw decrements
    balance by amount and returns the new value of balance. Otherwise,
    withdraw returns the _Insufficient Funds_ message. Here are the
    definitions of balance and withdraw:

    #+BEGIN_SRC scheme
    (define balance 100)
    (define (withdraw amount)
     (if (>= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds"))
    #+END_SRC

    Decrementing balance is accomplished by the expression 

    #+BEGIN_SRC scheme
    (set! balance (- balance amount))
    #+END_SRC

    This uses the set! special form, whose syntax is

    #+BEGIN_SRC scheme
    (set! <name> <new-value>)
    #+END_SRC

    Here <name> is a symbol and <new-value> is any expression. set!
    changes <name> so that its value is the result obtained by
    evaluating <new-value>. In the case at hand, we are changing
    balance so that its new value will be the result of subtracting
    amount from the previous value of balance. 
    
    withdraw also uses the begin special form to cause two expressions
    to be evaluated in the case where the if test is true: first
    decrementing balance and then returning the value of balance. In
    general, evaluating the expression

    #+BEGIN_SRC scheme
    (begin <exp1> <exp2> ... <expk>)
    #+END_SRC

    causes the expression <exp1> through <expk> to be evaluated in
    sequence and the value of the final expression <expk> to be
    returned as the value of the entire begin form.

    Although withdraw works as desired, the variable balance presents
    a problem. As specified above, balance is a name defined in the
    global environment and is freely accessible to be examined or
    midified by any procedure. It would be much better if we could
    somehow make balance internal to withdraw, so that withdraw would
    be the only procedure that could access balance directly and any
    other procedure could access balance directly and any other
    procedure could access balance only indirectly (through calls to
    withdraw). This would more accurately model the notion that
    balance is a local state variable used by withdraw to keep track
    of the state of the account.

    We can make balance internal to withdraw by rewriting the
    definition as follows:

    #+BEGIN_SRC scheme
    (define new-withdraw
     (let ((balance 100))
      (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount))
                  balance)
           "Insufficient funds"))))
    #+END_SRC

    What we have done here is use let to establish an environment with
    a locla variable balance, bound to the initial value 100. Within
    this local environment, we use lambda to create a procedure that
    takes amount as an argument and behaves like our previous withdraw
    procedure. This procedure -- returned as the result of evaluating
    the let expression -- is new-withdraw, which behaves in precisely
    the same way as withdraw but whose variable balance is not
    accessible by any other procedure. 

    Combining set! with local variables is the general programming
    technique we will use for constructing computational objects with
    local-state. Unfortunately, using this technique raises a serious
    problem: When we first introduced procedures, we also introduced
    the substitution model of evaluation (Section 1.1.5) to provide an
    interpretation of what procedure application means. We said that
    applying a procedure should be interpreted as evaluating the body
    of the procedure with the formal parameters replaced by their
    values. The trouble is that, as soon as we introduce assignment
    into our language, substitution is no longer an adequate model of
    procedure application. (We will see why this is so in section
    3.1.3). As a consequence, we technically have at this point no way
    to understand why the new-withdraw procedure behaves as claimed
    above. In order to really understand a procedure such as
    new-withdraw, we will need to develop a new model of procedure
    application. In section 3.2 we will introduce such a model,
    together with an explanation of set! and local variables. First,
    however, we examine some variations on the theme established by
    new-withdraw.

    The following procedure, make-withdraw, creates "withdrawal
    processors." The formal parameter balance in make-withdraw
    specifies the initial amount of money in the account.

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    make-withdraw can be used as follows to create two objects W1 and
    W2:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    (define W2 (make-withdraw 100))
 
    (W1 50)
     50
    (W2 70)
    30
    (W2 40)
    "Insufficient funds"
    (W1 40)
    10
    #+END_SRC

    Observe that W1 and W2 are completely independent objects, each
    with its own local state variable balance. Withdrawals from one do
    not affect the other.

    We can also create objects that handle deposits as well as
    withdrawals, and thus we can represent simple bank accounts. Here
    is a procedure that returns a "bank-accoutn object" with a
    specified initial balance:

    #+BEGIN_SRC scheme
    (define (make-account balance)
     (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
     (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
     (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
     dispatch)
    #+END_SRC

    Each call to make-account sets up an environment with a local
    state variable balance. Within this environment, make-account
    defines procedures deposit and withdraw that access balance and an
    additional procedure dispatch that takes a "message" as input and
    returns one of the two local procedures. The dispatch procedure
    itself is returned as the value that represents the bank-account
    object. This is precisely the _message-passing_ style of
    programming that we saw in section 2.4.3, although here we are
    using it in conjunction with the ability to modify local
    variables. make-account can be used as follows:

    #+BEGIN_SRC scheme
    (define acc (make-account 100))
    ((acc 'withdraw) 50)
    50
    ((acc 'withdraw) 60)
    "Insufficient funds"
    ((acc 'deposit) 40)
    90
    ((acc 'withdraw) 60)
    30
    #+END_SRC

    Each call to acc returns the locally defined deposit or withdraw
    procedure, which is then applied to the specified amount. As was
    the case with make-withdraw, another call to make-account

    #+BEGIN_SRC scheme
    (define acc2 (make-account 100))
    #+END_SRC

    will produce a completely separate account object, which maintains
    its own local balance. 

    - Exercise 3.1 An _accumulator_ is a procedure that is called
      repeatedly with a single numeric argument and accumulates its
      arguments into a sum. Each time it is called, it returns the
      currently accumulated sum. Write a procedure make-accumulator
      that generates accumulators, each maintaining an independent
      sum. The input to make-accumulator should specify the initial
      value of the sum; for example 

      #+BEGIN_SRC scheme
      (define A (make-accumulator 5))
      (A 10)
      15
      (A 10)
      25
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-accumulator value)
       (lambda (amount) 
        (begin
         (set! value (+ value amount))
         value)))
      #+END_SRC

    - Exercise 3.2: In software-testing applications, it is useful to
      be able to count the number of times a given procedure is called
      during the course of a computation. Write a procedure
      make-monitored that takes as input a procedure, f, that itself
      takes one input. The result returned by make-monitored is a
      third procedure, say mf, that keeps track of the number of times
      it has been called by maintaining an internal counter. If the
      input to mf is the special symbol how-many-calls? then mf
      returns the value of the counter. If the input is the special
      symbol reset-count, then mf resets the counter to zero. For any
      other input, mf returns the result of calling f on that input
      and increments the counter. For instance, we could make a
      monitored version of the sqrt procedure:

      #+BEGIN_SRC scheme
      (define s (make-monitored sqrt))
      (s 100)
      10
      (s 'how-many-calls?)
      1
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-monitored f)
       (let ((counter 0))
        (define (count-call param)
         (begin (set! counter (+ counter 1))
                (f param)))
        (define (get-calls)
         counter)
        (define (reset-calls)
         (begin
          (set! counter 0)
          counter))
        (define (dispatch value)
         (cond
          ((eq? value 'how-many-calls?)
           (get-calls))
          ((eq? value 'reset-count)
           (reset-calls))
          (else
           (count-call value))))
        dispatch))
      #+END_SRC

    - Exercise 3.3: Modify the make-account procedure so that it
      creates password-protected accounts. That is, make-account
      sohould take a symbol as an additional argument, as in 

      #+BEGIN_SRC scheme
      (define acc (make-account 100 'secret-password))
      #+END_SRC

      The resulting account object should process a request only if it
      is accompanied by the password with which the account was
      created, and should otherwise return a complaint:

      #+BEGIN_SRC scheme
      ((acc 'secret-password 'withdraw) 40)
      60
      ((acc 'some-other-password 'deposit) 50)
      "Incorrect password"
      #+END_SRC
      
      #+BEGIN_SRC scheme
      (define (make-account password balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (incorrect-password amount)
        "Incorrect password")
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request: MAKE-ACCOUNT"
                           m))))

       (define (dispatch-check-password password-attempt m)
        (if (eq? password-attempt password)
            (dispatch m)
            incorrect-password))
       dispatch-check-password)
      #+END_SRC

    - Exercise 3.4 Modify the make-account procedure of Exercise 3.3
      by adding another local state variable so that, if an account is
      accessed more than seven consecutive times with an incorrect
      password, it invokes the procedure call-the-cops.

      #+BEGIN_SRC scheme
      (define (call-the-cops)
       (display "Calling the cops!"))
      (define (make-account password balance)
       (let ((incorrect-password-counter 0))
        (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
        (define (deposit amount)
         (begin
          (set! balance (+ balance amount))
           balance))
        (define (invalid-password amount)
         "Invalid password")
        (define (handle-incorrect-password)
         (cond
          ((>= incorrect-password-counter 7)
           (begin
            (call-the-cops)
            invalid-password))
          (else
           (begin
            (set! incorrect-password-counter (+ 1 incorrect-password-counter))
            invalid-password))))
        (define (dispatch m)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request: MAKE-ACCOUNT"
                            m))))
        (define (dispatch-check-password password-attempt m)
         (if (eq? password-attempt password)
             (begin
              (set! incorrect-password-counter 0)
              (dispatch m))
             (handle-incorrect-password)))
        dispatch-check-password))
      #+END_SRC

*** 3.1.2 The Benefits of Introducing Assignment

    As we shall see, introducing assignment into our programming
    language leads us into a thicket of difficult conceptual
    issues. Nevertheless, viewing systems as collections of objects
    with local state is a powerful technique for maintaining a modular
    design. As a simple example, consider the design of a procedure
    rand that, whenever it is called, returns an integer chosen at
    random.

    It is not at all clear what is meant by "chosen at random." What
    we presumably want is for successive calls to rand to produce a
    sequence of numbers that has statistical properties of uniform
    distribution. We will not discuss methods for generating suitable
    sequences here. Rather, let us assume that we have a procedure
    rand-update that has the property that if we start with a given
    number x_1 and form

    x_2 = (rand-update x_1)
    x_3 = (rand-update x_2)

    then the sequence of values x_1, x_2, x_3,... will have the
    desired statistical properties.

    We can implement rand as a procedure with a local state variable x
    that is initialized to some fixed value random-init. Each call to
    rand computes rand-update of the current value of x, returns this
    as the random number, and also stores this as the new value of x.

    #+BEGIN_SRC scheme
    (define rand (let ((x random-init))
                  (lambda ()
                   (set! x (rand-update x))
                   x)))
    #+END_SRC
      
    Of course, we could generate the same sequence of random numbers
    without using assignment by simply calling rand-update
    directly. However, this would mean that any part of our program
    that used random numbers would have to explicitly remember the
    current value of x to be passed as an argument to rand-update. To
    realize what an annoyance this would be, consider using random
    numbers to implement a technique called _Monte Carlo simulation_. 

    The Monte Carlo method consists of choosing sample experiments at
    random from a large set and then making deductions on the basis of
    the probabilities estimated from tabulating the results of those
    experiments. For example, we an approximate pi using the fact that
    6/\pi^2 is the probability that two integers chosen at random will
    have no factors in common; that is, that their greatest common
    divisor will be 1. To obtain the approximation to \pi, we perform
    a large number of experiments. In each experiment we choose two
    integers at random and perform a test to see if their GCD
    is 1. The fraction of times that the test is passed gives us our
    estimate of 6/\pi^2, and from this we obtain our approximation to
    \pi.

    The heart of our program is a procedure monte-carlo, which takes
    as arguments the number of times to try an experiment, together
    with the experiment, represented as a no-argument procedure that
    will return either true or false each time it is run. monte-carlo
    runs the experiment for the designated number of trials and
    returns a number telling the fraction of the trials in which the
    experiment was found to be true.

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (monte-carlo trials cesaro-test))))
    (define (cesaro-test)
     (= (gcd (rand) (rand)) 1))
    (define (monte-carlo trials experiment)
     (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1)
                   (+ trials-passed 1)))
            (else (iter (- trials-remaining 1)
                        trials-passed))))
     (iter trials 0))
    #+END_SRC

    Now let us try the same computation using rand-update directly
    rather than rand, the way we would be forced to proceed if we did
    not use assignment to model local state:

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (random-gcd-test trials random-init))))
    (define (random-gcd-test trials initial-x)
     (define (iter trials-remaining trials-passed x)
      (let ((x1 (rand-update x)))
       (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trails-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trails-remaining 1)
                     trials-passed
                     x2))))))
     (iter trials 0 initial-x)) 
    #+END_SRC

    While the program is still simple, it betrays some painful
    breaches of modularity. In our first version of the program, using
    rand, we can express the Monte Carlo method directly as a general
    monte-carlo procedure that takes as an argument an arbitrary
    experiment procedure. In our second version of the program, with
    no local state for the random-number generator, random-gcd-test
    must explicitly manipulate the random numbers x1 and x2 and
    recycle x2 throguh the iterative loop as the new input to
    rand-update. This explicit handling of the random numbers
    intertwines the structure of accumulating test results with the
    fact that our particular experiment uses two random numbers,
    whereas other Monte Carlo experiments might use one random number
    or three. Even the top-level procedure estimate-pi has to be
    concerned with supplying an initial random number. The fact that
    the random-number generator's insides are leaking out into other
    parts of the program makes it difficult for us to isolate the
    Monte Carlo idea so that it can be applied to other tasks. In the
    first version of the program, assignment encapsulates the state of
    the random-number generator within the rand procedure, so that the
    details of random-number generation remain independent of the rest
    of the program. 

    The general phenomenon illustrated by the Monte Carlo example is
    this: From the point of view of one part of a complex process, the
    other parts appear to change with time. They have hidden
    time-varying local state. If we wish to write computer programs
    whose structure reflects this decomposition, we make computational
    objects (such as bank accounts and random-number generators) whose
    behavior changes with time. We model state with local state
    variables, and we model the changes of state with assignments to
    those variables.

    It is tempting to conclude this discussion by saying that, by
    introducing assignment and the technique of hiding state in local
    variables, we are able to structure systems in a more modular
    fashion than if all state had to be manipulated explicitly, by
    passing additional parameters. Unfortunately, as we shall see, the
    story is not so simple.

    - Exercise 3.5. _Monte Carlo integration_ is a method of
      estimating definite integrals by means of Monte Carlo
      simulation. Consider computing the area of a region of space
      described by a predicate P(x, y) that is true for points (x, y)
      in the region and false for points not in the region. For
      example, the region contained within a circle of radius 3
      centered at (5, 7) is described by the predicate that tests
      whether (x - 5)^2 + (y-7)^2 <= 3^2. To estimate the area of the
      region described by such a predicate, begin by choosing a
      rectangle that contains the region. For example, a rectangle
      with diagonally opposite corners at (2, 4) and (8, 10) contains
      the circle above. The desired integral is the area of that
      portion of the rectangle that lies in the region. We can
      estimate the integral by picking, at random, points (x, y) that
      lie in the rectangle, and testing P(x, y) for each point to
      determine whether the point lies in the region. If we try this
      with many points, then the fraction of points that fall in the
      region should give an estimate of the proportion of the
      rectangle that lies in the region. If we try this with many
      points, then the fraction of points that fall in the region
      should give an estimate of the proportion of the rectangle that
      lies in the region. Hence, multiplying this fraction by the area
      of the entire rectangle should produce an estimate of the
      integral.

      Implement Monte Carlo integration as a procedure
      estimate-integral that takes as arguments a predicate P, upper
      and lower bounds x1, x2, y1, and y2 for the rectangle, and the
      number of trials to perform in order to produce the
      estimate. Your procedure should use the same monte-carlo
      procedure that was used above to estimate pi. Use your
      estimate-integral to produce an estimate4 of pi by measuring the
      area of a unit circle.

      You will find it useful to have a procedure that returns a
      number chosen at random from a given range. The following
      random-in-range procedure implements this in terms of the random
      procedure used in section 1.2.6, which returns a nonnegative
      number less than its input.

      #+BEGIN_SRC scheme
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (estimate-pi ntrials)
       (estimate-integral (lambda (x y) (<= (+ (square x)
                                               (square y))
                                             1))
                          -1.0 1.0 -1.0 1.0 ntrials))
      (define (estimate-integral P x1 x2 y1 y2 ntrials)
       (* (monte-carlo ntrials
                    (lambda ()
                     (let ((p-x (random-in-range x1 x2))
                           (p-y (random-in-range y1 y2)))
                      (P p-x p-y))))
          (* (- x2 x1) (- y2 y1))))
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))

      (define (monte-carlo trials experiment)
       (define (iter trials-remaining trials-passed)
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((experiment)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)))
              (else (iter (- trials-remaining 1)
                          trials-passed))))
       (iter trials 0))
      #+END_SRC

    - Exercise 3.6 It is useful to be able to reset a random-number
      generator to produce a sequence starting from a given
      value. Design a new rand procedure that is called with an
      argument that is either the symbol generate or the symbol reset
      and behaves as follows: (rand 'generate) produces a new random
      number; ((rand 'reset) <new-value>) resets the internal state
      variable to the designated <new-value>. Thus, by resetting the
      state, one can generate repeatable sequences. These are very
      handy to have when testing and debugging programs that use
      random numbers.

      #+BEGIN_SRC scheme
      (define SEED 0)
      (define (rand param)
       (let ((last-value SEED))
        (cond ((eq? param 'generate)
               (let ((val (rand-update last-value)))
                (set! last-value val)
                val))
              (else
               (lambda (new-value)
                (set! last-value new-value)
                new-value)))))
      #+END_SRC

*** 3.1.3 The Costs of Introducing Assignment

    As we have seen, the set! operation enables us to model objects
    that have local state. However, this advantage comes at a
    price. Our programming language can no longer be interpreted in
    terms of the substitution model of procedure application that we
    introduced in Section 1.1.5. Moreover, no simple model with "nice"
    mathematical properties can be an adequate framework for dealing
    with objects and assignment in programming languages. 

    So long as we do not use assignments, two evaluations of the same
    procedure with the same arguments will produce the same result, so
    that procedures can be viewed as computing mathematical
    functions. Programming without any use of assignments, as we did
    throughout the first two chapters of this book, is accordingly
    known as _functional programming_. 

    To understand how assignment complicates matters, consider a
    simplified version of the make-withdraw procedure of Section 3.1.1
    that does not bother to check for an insufficient amount:

    #+BEGIN_SRC scheme
    (define (make-simplified-withdraw balance)
     (lambda (amount)
      (set! balance (- balance amount))
      balance))
    (define W (make-simplified-withdraw 25))
    (W 20)
    5
    (W 10)
    -5
    #+END_SRC

    Compare this procedure with the following make-decrementer
    procedure, which does not use set!:

    #+BEGIN_SRC scheme
    (define (make-decrementer balance)
     (lambda (amount)
      (- balance amount)))
    #+END_SRC

    make-decrementer returns a procedure that subtracts its input from
    a designated amount balance, but there is no accumulated effect
    over successive calls, as with make-simplified-withdraw:

    #+BEGIN_SRC scheme
    (define D (make-decrementer 25))
    (D 20)
    5
    (D 10)
    15
    #+END_SRC

    We can use the substitution model to explain how make-decrementer
    works. For instance, let us analyze the evaluation of the
    expression

    #+BEGIN_SRC scheme
    ((make-decrementer 25) 20)
    #+END_SRC

    We first simplify the operator of the combination by substituting
    25 for balance in the body of make-decrementer. This reduces the
    expression to

    #+BEGIN_SRC scheme
    ((lambda (amount) (- 25 amount)) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (- 25 20)
    #+END_SRC
    
    The final answer is 5. Observe, however, what happens if we
    attempt a similar substitution analysis with
    make-simplified-withdraw:

    #+BEGIN_SRC scheme
    ((make-simplified-withdraw 25) 20)
    #+END_SRC

    We first simplify the operator by substituting 25 for balance in
    the body of make-simplified-withdraw. This reduces the expression
    to
    
    #+BEGIN_SRC scheme
    ((lambda (amount) (set! balance (- 25 amount)) 25) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (set! balance (- 25 20)) 25
    #+END_SRC

    If we adhered to the substitution model, we would have to say that
    the meaning of the procedure application is to first set balance
    to 5 and then return 25 as the value of the expression. This gets
    the wrong answer. In order to get the correct answer, we would
    have to somehow distinguish the first occurrence of balance
    (before the effect of the set!) from the second occurrence of
    balance (after the effect of the set!), and the substitution model
    cannot do this.

    The trouble here is that substitution is based ultimately on the
    notion that the symbols in our language are essentially names for
    values. But as soon as we introduce set! and the idea that the
    value of a variable can change, a variable can no longer be simply
    a name. Now a variable somehow refers to a place where a value can
    be stored, and the value stored at this place can change. In
    section 3.2 we will see how environments play this role of "place"
    in our computational model.

**** Sameness and change

     The issue surfacing here is more profound than the mere breakdown
     of a particular model of computation. As soon as we introduce
     change into our computational models, many notions that were
     previously straightforward become problematical. Consider the
     concept of two things being "the same."

     Suppose we call make-decrementer twice with the same argument to
     create two procedures:

     #+BEGIN_SRC scheme
     (define D1 (make-decrementer 25))
     (define D2 (make-decrementer 25))
     #+END_SRC

     Are D1 and D2 the same? An acceptable answer is yes, because D1
     and D2 have the same computational behavior -- each is a
     procedure that subtracts its input from 25. In fact, D1 could be
     substituted for D2 in any computation without changing the
     result.
     
     Contrast this with making two calls to make-simplified-withdraw:

     #+BEGIN_SRC scheme
     (define W1 (make-simplified-withdraw 25))
     (define W2 (make-simplified-withdraw 25))
     #+END_SRC

     Are W1 and W2 the same? Surely not, because calls to W1 and W2
     have distinct effects, as shown by the following sequence of
     interactions:

     #+BEGIN_SRC scheme
     (W1 20)
     5
     (W1 20)
     -15
     (W2 20)
     5
     #+END_SRC

     Even though W1 and W2 are "equal" in the sense that they are both
     created by evaluating the same expression,
     (make-simplified-withdraw 25), it is not true that W1 could be
     substituted for W2 in any expression without changing the result
     of evaluating the expression. 

     A language that supports the concept that "equals can be
     substituted for equals" in an expression without changing the
     value of the expression is said to be _referentially
     transparent._ Referential transparency is violated when we
     include set! in our computer language. This makes it tricky to
     determine when we can simplify expressions by substituting
     equivalent expressions. Consequently, reasoning about programs
     that use assignment becomes drastically more difficult.

     Once we forgo referential transparency, the notion of what it
     means for computational objects to be "the same" becomes
     difficult to capture in a formal way. Indeed, the meaning of
     "same" in the real world that our programs model is hardly clear
     in itself. In general, we can determine that two apparently
     identical objects are indeed "the same one" only by modifying one
     object and then observing whether the other object has changed in
     the same way. But how can we tell if an object has "changed"
     other than by observing the "same" object twice and seeing
     whether some property of the object differs from one observation
     to the next? Thus, we cannot determine "change" without some _a
     priori_ notion of "sameness," and we cannot determine sameness
     without observing the effects of change.

     As an example of how this issue arises in programming, consider
     the situation where Peter and Paul have a bank account with $100
     in it. There is a substantial difference between modeling this as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc (make-account 100))
     #+END_SRC

     and modeling it as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc peter-acc)
     #+END_SRC

     In the first situation, the two bank accounts are
     distinct. Transactions made by Peter will not affect Paul's
     account, and vice versa. In the second situation, however, we
     have defined paul-acc to be _the same thing_ as peter-acc. In
     effect, Peter and Paul now have a joint bank account, and if
     Peter makes a withdrawal from peter-acc Paul will observe less
     money in paul-acc. In effect, Peter and Paul now have a joint
     bank account, and if Peter makes a withdrawal from peter-acc Paul
     will observe less money in paul-acc. These two similar but
     distinct situations can cause confusion in building computational
     models. With the shared account, in particular, it can be
     especially confusing that there is one object (the bank account)
     that has two different names (peter-acc and paul-acc); if we are
     searching for all the places in our program where paul-acc can be
     changed, we must remember to look also at things that change
     peter-acc.

     With reference to the above remarks on "sameness" and "change,"
     observe that if Peter and Paul could only examine their bank
     balances, and could not perform operations that changed the
     balance, then the issue of whether the two accounts are distinct
     would be moot. In general, so long as we never modify data
     objects, we can regard a compound data object to be precisely the
     totality of its pieces. For example, a rational number is
     determined by giving its numerator and its denominator. But this
     view is no longer valid in the presence of change, where a
     compound data object has an "identity" that is something
     different from the pieces of which it is composed. A bank account
     is still "the same" bank account even if we change the balance by
     making a withdrawal; conversely, we could have two different bank
     accounts with the same state information. This complication is a
     consequence, not of our programming language, but of our
     perception of a bank account as an object. We do not, for
     example, ordinarily regard a rational number as a changeable
     object with identity, such that we could change the numerator and
     still have "the same" rational number.

**** Pitfalls of imperative programming

     In contrast to functional programming, programming that makes
     extensive use of assignment is known as _imperative programming._
     In addition to raising complications about computational models,
     programs written in imperative style are susceptible to bugs that
     cannot occur in functional programs. For example, recall the
     iterative factorial program from section 1.2.1:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product) (+ counter 1))))
      (iter 1 1))
     #+END_SRC

     Instead of passing arguments in the internal iterative loop, we
     could adopt a more imperative style by using explicit assignment
     to update the values of the variables product and counter:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (let ((product 1)
            (counter 1))
       (define (iter)
        (if (> counter n)
            product
            (begin (set! product (* counter product))
                   (set! counter (+ counter 1))
                   (iter))))
       (iter)))
     #+END_SRC

     This does not change the results produced by the program, but it
     does introduce a subtle trap. How do we decide the order of the
     assignments? As it happens, the program is correct as
     written. But writing the assignments in the opposite order

     #+BEGIN_SRC scheme
     (set! counter (+ counter 1))
     (set! product (* counter product))
     #+END_SRC

     would have produced a different, incorrect result. In general,
     programming with assignment forces us to carefully consider the
     relative orders of the assignments to make sure that each
     statement is using the correct version of the variables that have
     been changed. This issue simply does not arise in functional
     programs.

     The complexity of imperative programs becomes even worse if we
     consider applications in which several processes execute
     concurrently. We will return to this in section 3.4. First,
     however, we will address the issue of providing a computational
     model for expressions that involve assignment, and explore the
     uses of objects with local state in designing simulations.

     - Exercise 3.7: Consider the bank account objects created by
       make-account, with the password modification described in
       Exercise 3.3. Suppose that our banking system requires the
       ability to make joint accounts. Define a procedure make-joint
       that accomplishes this. make-joint should take three
       arguments. The first is a password-protected account. The
       second argument must match the password with which the account
       was defined in order for the make-joint operation to
       proceed. The third argument is a new password. make-joint is to
       create an additional access to the original account using the
       new password. For example, if peter-acc is a bank account with
       password open-sesame, then

       #+BEGIN_SRC scheme
       (define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))
       #+END_SRC
       
       will allow one to make transactions on peter-acc using the name
       paul-acc and the password rosebud. You may wish to modify your
       solution in Exercise 3.3 to accommodate this new feature.

       #+BEGIN_SRC scheme
       (define (make-joint account old-pass new-pass)
        (define (joint-account pass m)
         (if (eq? new-pass pass)
             (account old-pass m)
             (account old-pass 'incorrect-password)))
        (if (account old-pass 'password-matches?)
            joint-account
            "Incorrect password"))

       (define (call-the-cops)
        (display "Calling the cops!"))

       (define (make-account password balance)
        (let ((incorrect-password-counter 0))
         (define (password-matches? pass)
          (if (eq? password pass)
              true
              (begin (handle-incorrect-password)
                     false)))
         (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds"))
         (define (deposit amount)
          (begin
           (set! balance (+ balance amount))
            balance))
         (define (invalid-password amount)
          "Invalid password")
         (define (handle-incorrect-password)
          (cond
           ((>= incorrect-password-counter 7)
            (begin
             (call-the-cops)
             invalid-password))
           (else
            (begin
             (set! incorrect-password-counter (+ 1 incorrect-password-counter))
             invalid-password))))
         (define (dispatch m)
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                ((eq? m 'password-matches?) password-matches?)
                ((eq? m 'incorrect-password) invalid-password)
                (else (error "Unknown request: MAKE-ACCOUNT"
                             m))))
         (define (dispatch-check-password password-attempt m)
          (cond ((eq? m 'password-matches?)
                 (password-matches? password-attempt))
                ((eq? m 'incorrect-password)
                 (begin (handle-incorrect-password)
                        invalid-password))
                ((eq? password-attempt password)
                 (begin
                  (set! incorrect-password-counter 0)
                  (dispatch m)))
                (else
                 (handle-incorrect-password))))
         dispatch-check-password))
       #+END_SRC

     - Exercise 3.8: When we defined the evaluation model in Section
       1.1.3, we said that the first step in evaluating an expression
       is to evaluate its subexpressions. But we never specified the
       order in which the subexpressions should be evaluated
       (e.g. left to right or right to left). When we introduce
       assignment, the order in which the arguments to a procedure are
       evaluated can make a difference to the result. Define a simple
       procedure f such that evaluating

       #+BEGIN_SRC scheme
       (+ (f 0) (f 1))
       #+END_SRC

       will return 0 if the arguments to + are evaluated from left to
       right but will return 1 if the arguments are evaluated from
       right to left.

       #+BEGIN_SRC scheme
       (define f 
        (let ((zero-found false))
         (lambda (x)
          (cond 
           (zero-found 0)
           ((= 0 x) 
            (begin (set! zero-found true)
                   x))
           (else x)))))
       #+END_SRC

       It turns out MIT scheme is right-left for + at least. It is
       left-to-right for or.

** 3.2 The Environment Model of Evaluation

   When we introduced compound procedures in Chapter 1, we used the
   substitution model of evaluation (Section 1.1.5) to define what is
   meant by applying a procedure to arguments: 

   * To apply a compound procedure to arguments, evaluate the body of
     the procedure with each formal parameter replaced by the
     corresponding argument.

     
   Once we admit assignment into our programming language, such a
   definition is no longer adequate. In particular, Section 3.1.3
   argued that, in the presence of assignment, a variable can no
   longer be considered to be merely the name for a value. Rather, a
   variable must somehow designate a "place" in which values can be
   stored. In our new model of evaluation, these places will be
   maintained in structures called _environments_. 

   An environment is a sequence of _frames_. Each frame is a table
   (possibly empty) of _bindings_, which associate variable names with
   their corresponding values. (A single frame may contain at most one
   binding for any variable.) Each frame also has a pointer to its
   _enclosing environment_, unless, for the purposes of discussion,
   the frame is considered to be _global_. The _value of a variable_
   with respect to an environment is the value given by the binding of
   the variable in the first frame in the environment that contains a
   binding for that variable. If no frame in the sequence specifies a
   binding for the variable, then the variable is said to be _unbound_
   in the environment. 

   Figure 3.1 shows a simple environment structure consisting of three
   frames, labeled I, II, and III. In the diagram, A, B, C, and D are
   pointers to environments. C and D point to the same
   environment. The variables z and x are bound in frame II, while y
   and x are bound in frame I. The value of x in environment D
   is 3. The value of x with respect to environment B is also 3. This
   is determined as follows: We examine the first frame in the
   sequence (frame III) and do not find a binding for x, so we proceed
   to the enclosing environment D and find the binding in frame I. On
   the other hand, the value of x in environment A is 7, because the
   first frame in the sequence (Frame II) contains a binding of x
   to 7. With respect to environment A, the binding of x to 7 in frame
   II is said to _shadow_ the binding of x to 3 in frame I.

   The environment is crucial to the evaluation process, because it
   determines the context in which an expression should be
   evaluated. Indeed, one could say that expressions in a programming
   language do not, in themselves, have any meaning. Rather, an
   expression acquires a meaning only with respect to some environment
   in which it is evaluated. Even the interpretation of an expression
   as straightforward as (+ 1 1) depends on an understanding that one
   is operating in a context in which + is the symbol for
   addition. Thus, in our model of evaluation we will always speak of
   evaluating an expression with respect to some environment. To
   describe interactions with the interpreter, we will suppose that
   there is a global environment, consisting of a single frame (with
   no enclosing environment) that includes values for the symbols
   associated with the primitive procedures. For example, the idea
   that + is the symbol for addition is captured by saying that the
   symbol + is bound in the global environment to the primitive
   addition procedure. 

*** 3.2.1 The Rules for Evaluation

    The overall specification of how the interpreter evaluates a
    combination remains the same as when we first introduced it in
    section 1.1.3:

    * To evaluate a combination:

      1. Evaluate the subexpressions of the combination.

      2. Apply the value of the operator subexpression to the values
         of the operand subexpressions.

	 
    The environment model of evaluation replaces the substitution
    model in specifying what it means to apply a compound procedure to
    arguments. 
    
    In the environment model of evaluation, a procedure is always a
    pair consisting of some code and a pointer to an
    environment. Procedures are created in one way only: by evaluating
    a lambda-expression. This produces a procedure whose code is
    obtained from the text of the lambda-expression and whose
    environment is the environment in which the lambda-expression was
    evaluated to produce the procedure. For example, consider the
    procedure definition

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    #+END_SRC

    evaluated in the global environment. The procedure definition
    syntax is just syntactic sugar for an underlying implicit
    lambda-expression. It would have been equivalent to have used

    #+BEGIN_SRC scheme
    (define square
     (lambda (x) (* x x)))
    #+END_SRC

    which evaluates (lambda (x) (* x x)) and binds square to the
    resulting value, all in the global environment.

    Figure 3.2 shows the result of evaluating this define
    expression. The procedure object is a pair whose code specifies
    that the procedure has one formal parameter, namely x, and a
    procedure body (* x x). The environment part of the procedure is a
    pointer to the global environment, since that is the environment
    in which the lambda-expression was evaluated to produce the
    procedure. A new binding, which associates the procedure object
    with the symbol square, has been added to the global frame. In
    general, define creates definitions by adding bindings to frames.

    Now that we have seen how procedures are created, we can describe
    how procedures are applied. The environment model specifies: To
    apply a procedure to arguments, create a new environment
    containing a frame that binds the parameters to the values of the
    arguments. The enclosing environment in this frame is the
    environment specified by the procedure. Now, within this new
    environment, evaluate the procedure body. 

    To show how this rule is followed, Figure 3.3 illustrates the
    environment structure created by evaluating the expression
    (square 5) in the global environment, where square is the
    procedure generated in figure 3.2. Applying the procedure results
    in the creation of a new environment, labeled E1 in the figure,
    that begins with a frame in which x, the formal parameter for the
    procedure, is bound to the argument 5. The pointer leading upward
    from this frame shows that the frame's enclosing environment is
    the global environment. The global environment is chosen here,
    because this is the environment that is indicated as part of the
    square procedure object. Within E1, we evaluate the body of the
    procedure, (* x x). Since the value of x in E1 is 5, the result is
    (* 5 5), or 25. 

    The environment model of procedure application can be summarized
    by two rules:


    * A procedure object is applied to a set of arguments by
      constructing a frame, binding the formal parameters of the
      procedure to the arguments of the call, and then evaluating the
      body of the procedure in the context of the new environment
      constructed. The new frame has as its enclosing environment the
      environment part of the procedure object being applied.
    * A procedure is created by evaluating a lambda-expression
      relative to a given environment. The resulting procedure object
      is a pair consisting of the text with the lambda-expression and
      a pointer to the environment in which the procedure was created.


    We also specify that defining a symbol using define creates a
    binding in the current environment frame and assigns to the symbol
    the indicated value. Finally, we specify the behavior of set!, the
    operation that forced us to introduce the environment model in the
    first place. Evaluating the expression (set! <variable> <value>)
    in some environment locates the binding of the variable in the
    environment and changes that binding to indicate the new
    value. That is, one finds the first frame in the environment that
    contains a binding for the variable and modifies that frame. If
    the variable is unbound in the environment, then set! signals an
    error. 

    These evaluation rules, though considerably more complex than the
    substitution model, are still reasonably
    straightforward. Moreover, the evaluation model, though abstract,
    provides a correct description of how the interpreter evaluates
    expressions. In chapter 4 we shall see how this model can serve as
    a blueprint for implementing a working interpreter. The following
    sections elaborate the details of the model by analyzing some
    illustrative programs.

*** 3.2.2 Applying Simple Procedures

    When we introduced the substitution model in Section 1.1.5 we
    showed how the combination (f 5) evaluates to 136, given the
    following procedure definitions:

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    (define (sum-of-squares x y)
     (+ (square x) (square y)))
    (define (f a)
     (sum-of-squares (+ a 1) (* a 2)))
    #+END_SRC

    We can analyze the same example using the environment
    model. Figure 3.4 shows the three procedure objects created by
    evaluating the definitions of f, square, and sum-of-squares in the
    global environment. Each procedure object consists of some code,
    together with a pointer to the global environment. 

    In figure 3.5 we see the environment structure created by
    evaluating the expression (f 5). The call to f creates a new
    environment E1 beginning with a frame in which a, the formal
    parameter of f, is bound to the argument 5. In E1, we evaluate the
    body of f:

    #+BEGIN_SRC scheme
    (sum-of-squares (+ a 1) (* a 2))
    #+END_SRC

    To evaluate this combination, we first evaluate the
    subexpressions. The first subexpression, sum-of-squares, has a
    value that is a procedure object. (Notice how this value is found:
    We first look into the first frame of E1, which contains no
    binding for sum-of-squares. Then we proceed to the enclosing
    environment, i.e. the global environment, and find the binding
    shown in figure 3.4.) The other two subexpressions are evaluated
    by applying the primitive operations + and * to evaluate the two
    combinations (+ a 1) and (* a 2) to obtain 6 and 10, respectively.

    Now we apply the procedure object sum-of-squares to the arguments
    6 and 10. This results in a new environment E2 in which the formal
    parameters x and y are bound to the arguments. Within E2 we
    evaluate the combination (+ (square x) (square y)). This leads us
    to evaluate (square x), where square is found in the global frame
    and x is 6. Once again, we set up a new environment, E3, in which
    x is bound to 6, and within this we evaluate the body of square,
    which is (* x x). Also as part of applying sum-of-squares, we must
    evaluate the subexpression (square 6), where y is 10. This second
    call to square creates another environment, E4, in which x, the
    formal parameter of square, is bound to 10. And within E4 we must
    evaluate (* x x).

    The important point to observe is that each call to square creates
    a new environment containing a binding for x. We can see here how
    the different frames serve to keep separate the different local
    variables all named x. Notice that each frame created by square
    points to the global environment, since this is the environment
    indicated by the square procedure object.

    After the subexpressions are evaluated, the results are
    returned. The values generated by the two calls to square are
    added by sum-of-squares, and this result is returned by f. Since
    our focus here is on the environment structures, we will not dwell
    on how these returned values are passed from call to call;
    however, this is also an important aspect of the evaluation
    process, and we will return to it in detail in chapter 5. 

    - Exercise 3.9: In Section 1.2.1 we used the substitution model
      to analyze two procedures for computing factorials, a recursive
      version

      #+BEGIN_SRC scheme
      (define (factorial n)
       (if (= n 1) 1 (* n (factorial (- n 1)))))
      #+END_SRC

      and an iterative version

      #+BEGIN_SRC scheme
      (define (factorial n) (fact-iter 1 1 n))
      (define (fact-iter product counter max-count)
       (if (> counter max-count)
           product
           (fact-iter (* counter product)
                      (+ counter 1)
                      max-count)))
      #+END_SRC

      Show the environment structures created by evaluating
      (factorial 6) using each version of the factorial procedure.

*** 3.2.3 Frames as the Repository of Local State

    We can turn to the environment model to see how procedures and
    assignment can be used to represent objects with local state. As
    an example, consider the "withdrawal processor" from Section 3.1.1
    created by calling the procedure

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    Let us describe the evaluation of

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    followed by

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    Figure 3.6 shows the result of defining the make-withdraw
    procedure in the global environment. This produces a procedure
    object that contains a pointer to the global environment. So far,
    this is no different from the examples we have already seen,
    except that the body of the procedure is itself a
    lambda-expression.

    The interesting part of the computation happens when we apply the
    procedure make-withdraw to an argument:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    We begin, as usual, by setting up an environment E1 in which the
    formal parameter balance is bound to the argument 100. Within this
    environment, we evaluate the body of make-withdraw, namely the
    lambda-expression. This constructs a new procedure object, whose
    code is as specified by the lambda and whose environment is E1,
    the environment in which the lambda was evaluated to produce the
    procedure. The resulting procedure object is the value returned by
    the call to make-withdraw. This is bound to W1 in the global
    environment, since the define itself is being evaluated in the
    global environment. Figure 3.7 shows the resulting environment
    structure.

    Now we can analyze what happens when W1 is applied to an argument:

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    We begin by constructing a frame in which amount, the formal
    parameter of W1, is bound to the argument 50. The crucial point to
    observe is that this frame has as its enclosing environment not
    the global environment, but rather the environment E1, because
    this is the environment that is specified by the W1 procedure
    object. Within this new environment, we evaluate the body of the
    procedure:

    #+BEGIN_SRC scheme
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
    #+END_SRC

    The resulting environment structure is shown in Figure 3.8. The
    expression being evaluated references both amount and
    balance. amount will be found in the first frame in the
    environment, while balance will be found by following the
    enclosing-environment pointer to E1.

    When the set! is executed, the binding of balance in E1 is
    changed. At the completion of the call to W1, balance is 50, and
    the frame that contains balance is still pointed to by the
    procedure object W1. The frame that binds amount (in which we
    executed the code that changed balance) is no longer relevant,
    since the procedure call that constructed it has terminated, and
    there are no pointers to that frame from other parts of the
    environment. The next time W1 is called, this will build a new
    frame that binds amount and whose enclosing environment is E1. We
    see that E1 serves as the "place" that holds the local state
    variable for the procedure object W1. Figure 3.9 shows the
    situation after the call to W1. 

    Observe what happens when we create a second "withdraw" object by
    making another call to make-withdraw:

    #+BEGIN_SRC scheme
    (define W2 (make-withdraw 100))
    #+END_SRC

    This produces the environment structure of Figure 3.10, which
    shows that W2 is a procedure object, that is, a pair with some
    code and an environment. The environment E2 for W2 was created by
    the call to make-withdraw. It contains a frame with its own local
    binding for balance. On the other hand, W1 and W2 have the same
    code: the code specified by the lambda-expression in the body of
    make-withdraw. We see here why W1 and W2 behave as independent
    objects. Calls to W1 reference the state variable balance stored
    in E1, whereas calls to W2 reference the balance stored in
    E2. Thus, changes to the local state of one object do not affect
    the other object.

    - Exercise 3.10: In the make-withdraw procedure, the local
      variable balance is created as a parameter of make-withdraw. We
      could also create the local state variable explicitly, using
      let, as follows:

      #+BEGIN_SRC scheme
      (define (make-withdraw initial-amount)
       (let ((balance initial-amount))
        (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))))
      #+END_SRC
      Recall from Section 1.3.2 that let is simply syntactic sugar for
      a procedure call:

      #+BEGIN_SRC scheme
      (let ((<var> <exp>)) <body>)
      #+END_SRC

      is interpreted as an alternate syntax for
      
      #+BEGIN_SRC scheme
      ((lambda (<var>) <body>) <exp>)
      #+END_SRC

      Use the environment model to analyze this alternate version of
      make-withdraw, drawing figures like the ones above to illustrate
      the interactions

      #+BEGIN_SRC scheme
      (define W1 (make-withdraw 100))
      (W1 50)
      (define W2 (make-withdraw 100))
      #+END_SRC

      Show that the two versions of make-withdraw create objects with
      the same behavior. How do the environment structures differ for
      the two versions?

      In the end, the frame holding the balance has the exact same
      value. The only difference in the environment structures is that
      an extra (and mostly unused) frame is created before the final
      frame that holds the balance. 

*** 3.2.4. Internal Definitions
    Section 1.1.8 introduced the idea that procedures can have
    internal definitions, thus leading to a block structure as in the
    following procedure to compute square roots:

    #+BEGIN_SRC scheme
    (define (sqrt x)
     (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))
     (define (improve guess)
      (average guess (/ x guess)))
     (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
     (sqrt-iter 1.0))
    #+END_SRC

    Now we can use the environment model to see why these internal
    definitions behave as desired. Figure 3.11 shows the point in the
    evaluation of the expression (sqrt 2) where the internal procedure
    good-enough? has been called for the first time with guess equal
    to 1. 

    Observe the structure of the environment. sqrt is a symbol in the
    global environment that is bound to a procedure object whose
    associated environment is the global environment. When sqrt was
    called, a new environment E1 was formed, subordinate to the global
    environment, in which the parameter x is bound to 2. The body of
    sqrt was then evaluated in E1. Since the first expression in the
    body of sqrt is

    #+BEGIN_SRC scheme
    (define (good-enough? guess)
     (< (abs (- (square guess) x)) 0.001))
    #+END_SRC

    evaluating this expression defined the procedure good-enough? in
    the environment E1. To be more precise, the symbol good-enough?
    was added to the first frame of E1, bound to a procedure object
    whose associated environment is E1. Similarly, improve and
    sqrt-iter were defined as procedures in E1. For conciseness,
    figure 3.11 shows only the procedure object for good-enough?.

    After the local procedures were defined, the expression (sqrt-iter
    1.0) was evaluated, still in the environment E1. So the procedure
    object bound to sqrt-iter in E1 was called with 1 as an
    argument. This created an environment E2 in which guess, the
    parameter of sqrt-iter, is bound to 1. sqrt-iter in turn called
    good-enough? with the value of guess (from E2) as the argument
    for good-enough?. This set up another environment, E3, in which
    guess (the parameter of good-enough?) is bound to 1. Although
    sqrt-iter and good-enough? both have a parameter named guess,
    these are two distinct local variables located in different
    frames. Also, E2 and E3 both have E1 as their enclosing
    environment, because the sqrt-iter and good-enough? procesures
    both have E1 as their environment part. One consequence of this is
    that the symbol x that appears in the body of good-enough? will
    reference the binding of x that appears in E1, namely the value of
    x with which the original sqrt procedure was called.

    The environment model thus explains the two key properties that
    make local procedure definitions a useful technique for
    modularizing programs:

    * The names of the local procedures do not interfere with names
      external to the enclosing procedure, because the local procedure
      names will be bound in the frame that the procedure creates when
      it is run, rather than being bound in the global environment.
    * The local procedures can access the arguments of the enclosing
      procedure, simply by using parameter names as free
      variables. This is because the body of the local procedure is
      evaluated in an environment that is subordinate to the
      evaluation environment for the enclosing procedure.

      

    - Exercise 3.11: In section 3.2.3 we saw how the environment model
      described the behavior of procedures with local state. Now we
      have seen how internal definitions work. A typical
      message-passing procedure contains both of these
      aspects. Consider the bank account procedure of Section 3.1.1:

      #+BEGIN_SRC scheme
      (define (make-account balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else
               (error "Unknown request: MAKE-ACCOUNT" 
                      m))))
       dispatch)
      #+END_SRC

      Show the environment structure generated by the sequence of
      interactions

      #+BEGIN_SRC scheme
      (define acc (make-account 50))
      ((acc 'deposit) 40)
      90
      ((acc 'withdraw) 60)
      30
      #+END_SRC

      Where is the local state for acc kept? Suppose we define another
      account

      #+BEGIN_SRC scheme
      (define acc2 (make-account 100))
      #+END_SRC
      
      How are the local states for the two accounts kept distinct?
      Which parts of the environment structure are shared between acc
      and acc2?
      


    



    

