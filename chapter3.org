* Chapter 3
** Modularity Objects and State
   The preceding chapters introduced the basic elements from which
   programs are made. We saw how primitive procedures and primitive
   data are combined to construct compound entities, and we learned
   that abstraction is vital in helping us to cope with the complexity
   of large systems. But these tools are not sufficient for designing
   programs. Effective program synthesis also requires organizational
   principles that can guide us in formulating the overall design of a
   program. In particular, we need strategies to help us structure
   large systems so that they will be _modular_, that is, so that they
   can be divided "naturally" into coherent parts that can be
   separately developed and maintained.
   
   One powerful design strategy, which is particularly appropriate to
   the construction of programs for modeling physical systems, is to
   base the structure of our programs on the structure of the system
   being modeled. For each object in the system, we construct a
   corresponding computational object. For each system action, we
   define a symbolic operation in our computational model. Our hope in
   using this strategy is that extending the model to accommodate new
   objects or new actions will require no strategic changes to the
   program, only the addition of the new symbolic analogs of those
   objects or actions. If we have been successful in our system
   organization, then to add a new feature or debug an old one we will
   have to work on only a localized part of the system. 

   To a large extent, then, the way we organize a large program is
   dictated by our perception of the system to be modeled. In this
   chapter we will investigate two prominent organizational strategies
   arising from two rather different "world views" of the structure of
   systems. The first organizational strategy concentrates on
   _objects_, viewing a large system as a collection of distinct
   objects whose behaviors may change over time. An alternative
   organizational strategy concetrates on the _streams_ of information
   that flow in the system, much as an electrical engineer views a
   signal-processing system.

   Both the object-based approach and the stream-processing approach
   raise significant linguistic issues in programming. With objects,
   we must be concerned with how a computational object can change and
   yet maintain its identity. This will force us to abandon our old
   substitution model of computation in favor of a more mechanistic
   but less theoretically tractable _environment model_ of
   computation. The difficulties of dealing with objects, change, and
   identity are fundamental consequences of the need to grapple with
   time in our computational models. These difficulties become even
   greater when we allow the possibility of concurrent execution of
   programs. The stream approach can be most fully exploited when we
   decouple simulated time in our model from the order of the events
   that take place in the computer during evaluation. We will
   accomplish this using a technique known as _delayed evaluation_.

** 3.1 Assignment and Local State

   We ordinarily view the world as populated by independent objects,
   each of which has a state that changes over timne. An object is
   said to "have state" if its behavior is influenced by its
   history. A bank account, for example, has a state in that the
   answer to the question "Can I withdraw $100?" depends upon the
   history of deposit and withdrawal transactions. We can characterize
   an object's state by one or more _state variables_, which among
   them maintain enough information about history to determine the
   object's current behavior. In a simple banking system, we could
   characterize the state of an account by a balance rather than by
   remembering the entire history of account transactions.
   
   In a system composed of many objects, the objects are rarely
   completely independent. Each may influence the states of others
   through interactions, which serve to couple the state variables of
   one object to those of other objects. Indeed, the view that a
   system is composed of separate objects is most useful when the
   state variables of the system can be grouped into closely coupled
   subsystems that are only loosely coupled to other subsystems. 
   
   This view of a system can be a powerful framework for organizing
   computational models of the system. For such a model to be modular,
   it should be decomposed into computational objects that model the
   actual objects in the system. Each computational object must have
   its own _local state variables_ describing the actual object's
   state. Since the states of objects in the system being modeled
   change over time, the state variables of the corresponding
   computational objects must also change. If we choose to model the
   flow of time in the system by the elapsed time in the computer,
   then we must have a way to construct computational objects whose
   behaviors change as our programs run. In particular, if we wish to
   model state variables by ordinary symbolic names in the programming
   language, then the language must provide an _assignment operator_
   to enable us to change the value associated with a name. 

*** 3.1.1. Local State Variables

    To illustarate what we mean by having a computational object with
    time-varying state, let us model the situation of withdrawing
    money from a bank account. We will do this using a procedure
    withdraw, which takes as argument an amount to be withdrawn. If
    there is enough money in the account to accommodate the
    withdrawal, then withdraw should return the balance remaining
    after the withrdrawal. Otherwise, withdraw should return the
    message _Insufficient funds_. For example, if we begin with $100
    in the account, we should obtain the following sequence of
    responses using withdraw:

    #+BEGIN_SRC scheme
    (withdraw 25)
    75
    (withdraw 25)
    50
    (withdraw 60)
    "Insufficient funds"
    (withdraw 15)
    35
    #+END_SRC

    Observe that the expression (withdraw 25), evaluated twice, yields
    different values. This is a new kind of behavior for a
    procedure. Until now, all our procedures could be viewed as
    specifications for computing mathematical functions. A call to a
    procedure computed the value of the function applied to the given
    arguments, and two calls to the same procedure with the same
    arguments always produced the same result. To implement withdraw,
    we can use a variable balance to indicate the balance of money in
    the account and define withdraw as a procedure that accesses
    balance. The withdraw procedure checks to see if balance is at
    least as large as the requested amount. If so, withdraw decrements
    balance by amount and returns the new value of balance. Otherwise,
    withdraw returns the _Insufficient Funds_ message. Here are the
    definitions of balance and withdraw:

    #+BEGIN_SRC scheme
    (define balance 100)
    (define (withdraw amount)
     (if (>= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds"))
    #+END_SRC

    Decrementing balance is accomplished by the expression 

    #+BEGIN_SRC scheme
    (set! balance (- balance amount))
    #+END_SRC

    This uses the set! special form, whose syntax is

    #+BEGIN_SRC scheme
    (set! <name> <new-value>)
    #+END_SRC

    Here <name> is a symbol and <new-value> is any expression. set!
    changes <name> so that its value is the result obtained by
    evaluating <new-value>. In the case at hand, we are changing
    balance so that its new value will be the result of subtracting
    amount from the previous value of balance. 
    
    withdraw also uses the begin special form to cause two expressions
    to be evaluated in the case where the if test is true: first
    decrementing balance and then returning the value of balance. In
    general, evaluating the expression

    #+BEGIN_SRC scheme
    (begin <exp1> <exp2> ... <expk>)
    #+END_SRC

    causes the expression <exp1> through <expk> to be evaluated in
    sequence and the value of the final expression <expk> to be
    returned as the value of the entire begin form.

    Although withdraw works as desired, the variable balance presents
    a problem. As specified above, balance is a name defined in the
    global environment and is freely accessible to be examined or
    midified by any procedure. It would be much better if we could
    somehow make balance internal to withdraw, so that withdraw would
    be the only procedure that could access balance directly and any
    other procedure could access balance directly and any other
    procedure could access balance only indirectly (through calls to
    withdraw). This would more accurately model the notion that
    balance is a local state variable used by withdraw to keep track
    of the state of the account.

    We can make balance internal to withdraw by rewriting the
    definition as follows:

    #+BEGIN_SRC scheme
    (define new-withdraw
     (let ((balance 100))
      (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount))
                  balance)
           "Insufficient funds"))))
    #+END_SRC

    What we have done here is use let to establish an environment with
    a locla variable balance, bound to the initial value 100. Within
    this local environment, we use lambda to create a procedure that
    takes amount as an argument and behaves like our previous withdraw
    procedure. This procedure -- returned as the result of evaluating
    the let expression -- is new-withdraw, which behaves in precisely
    the same way as withdraw but whose variable balance is not
    accessible by any other procedure. 

    Combining set! with local variables is the general programming
    technique we will use for constructing computational objects with
    local-state. Unfortunately, using this technique raises a serious
    problem: When we first introduced procedures, we also introduced
    the substitution model of evaluation (Section 1.1.5) to provide an
    interpretation of what procedure application means. We said that
    applying a procedure should be interpreted as evaluating the body
    of the procedure with the formal parameters replaced by their
    values. The trouble is that, as soon as we introduce assignment
    into our language, substitution is no longer an adequate model of
    procedure application. (We will see why this is so in section
    3.1.3). As a consequence, we technically have at this point no way
    to understand why the new-withdraw procedure behaves as claimed
    above. In order to really understand a procedure such as
    new-withdraw, we will need to develop a new model of procedure
    application. In section 3.2 we will introduce such a model,
    together with an explanation of set! and local variables. First,
    however, we examine some variations on the theme established by
    new-withdraw.

    The following procedure, make-withdraw, creates "withdrawal
    processors." The formal parameter balance in make-withdraw
    specifies the initial amount of money in the account.

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    make-withdraw can be used as follows to create two objects W1 and
    W2:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    (define W2 (make-withdraw 100))
 
    (W1 50)
     50
    (W2 70)
    30
    (W2 40)
    "Insufficient funds"
    (W1 40)
    10
    #+END_SRC

    Observe that W1 and W2 are completely independent objects, each
    with its own local state variable balance. Withdrawals from one do
    not affect the other.

    We can also create objects that handle deposits as well as
    withdrawals, and thus we can represent simple bank accounts. Here
    is a procedure that returns a "bank-accoutn object" with a
    specified initial balance:

    #+BEGIN_SRC scheme
    (define (make-account balance)
     (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
     (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
     (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
     dispatch)
    #+END_SRC

    Each call to make-account sets up an environment with a local
    state variable balance. Within this environment, make-account
    defines procedures deposit and withdraw that access balance and an
    additional procedure dispatch that takes a "message" as input and
    returns one of the two local procedures. The dispatch procedure
    itself is returned as the value that represents the bank-account
    object. This is precisely the _message-passing_ style of
    programming that we saw in section 2.4.3, although here we are
    using it in conjunction with the ability to modify local
    variables. make-account can be used as follows:

    #+BEGIN_SRC scheme
    (define acc (make-account 100))
    ((acc 'withdraw) 50)
    50
    ((acc 'withdraw) 60)
    "Insufficient funds"
    ((acc 'deposit) 40)
    90
    ((acc 'withdraw) 60)
    30
    #+END_SRC

    Each call to acc returns the locally defined deposit or withdraw
    procedure, which is then applied to the specified amount. As was
    the case with make-withdraw, another call to make-account

    #+BEGIN_SRC scheme
    (define acc2 (make-account 100))
    #+END_SRC

    will produce a completely separate account object, which maintains
    its own local balance. 

    - Exercise 3.1 An _accumulator_ is a procedure that is called
      repeatedly with a single numeric argument and accumulates its
      arguments into a sum. Each time it is called, it returns the
      currently accumulated sum. Write a procedure make-accumulator
      that generates accumulators, each maintaining an independent
      sum. The input to make-accumulator should specify the initial
      value of the sum; for example 

      #+BEGIN_SRC scheme
      (define A (make-accumulator 5))
      (A 10)
      15
      (A 10)
      25
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-accumulator value)
       (lambda (amount) 
        (begin
         (set! value (+ value amount))
         value)))
      #+END_SRC

    - Exercise 3.2: In software-testing applications, it is useful to
      be able to count the number of times a given procedure is called
      during the course of a computation. Write a procedure
      make-monitored that takes as input a procedure, f, that itself
      takes one input. The result returned by make-monitored is a
      third procedure, say mf, that keeps track of the number of times
      it has been called by maintaining an internal counter. If the
      input to mf is the special symbol how-many-calls? then mf
      returns the value of the counter. If the input is the special
      symbol reset-count, then mf resets the counter to zero. For any
      other input, mf returns the result of calling f on that input
      and increments the counter. For instance, we could make a
      monitored version of the sqrt procedure:

      #+BEGIN_SRC scheme
      (define s (make-monitored sqrt))
      (s 100)
      10
      (s 'how-many-calls?)
      1
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-monitored f)
       (let ((counter 0))
        (define (count-call param)
         (begin (set! counter (+ counter 1))
                (f param)))
        (define (get-calls)
         counter)
        (define (reset-calls)
         (begin
          (set! counter 0)
          counter))
        (define (dispatch value)
         (cond
          ((eq? value 'how-many-calls?)
           (get-calls))
          ((eq? value 'reset-count)
           (reset-calls))
          (else
           (count-call value))))
        dispatch))
      #+END_SRC

    - Exercise 3.3: Modify the make-account procedure so that it
      creates password-protected accounts. That is, make-account
      sohould take a symbol as an additional argument, as in 

      #+BEGIN_SRC scheme
      (define acc (make-account 100 'secret-password))
      #+END_SRC

      The resulting account object should process a request only if it
      is accompanied by the password with which the account was
      created, and should otherwise return a complaint:

      #+BEGIN_SRC scheme
      ((acc 'secret-password 'withdraw) 40)
      60
      ((acc 'some-other-password 'deposit) 50)
      "Incorrect password"
      #+END_SRC
      
      #+BEGIN_SRC scheme
      (define (make-account password balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (incorrect-password amount)
        "Incorrect password")
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request: MAKE-ACCOUNT"
                           m))))

       (define (dispatch-check-password password-attempt m)
        (if (eq? password-attempt password)
            (dispatch m)
            incorrect-password))
       dispatch-check-password)
      #+END_SRC

    - Exercise 3.4 Modify the make-account procedure of Exercise 3.3
      by adding another local state variable so that, if an account is
      accessed more than seven consecutive times with an incorrect
      password, it invokes the procedure call-the-cops.

      #+BEGIN_SRC scheme
      (define (call-the-cops)
       (display "Calling the cops!"))
      (define (make-account password balance)
       (let ((incorrect-password-counter 0))
        (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
        (define (deposit amount)
         (begin
          (set! balance (+ balance amount))
           balance))
        (define (invalid-password amount)
         "Invalid password")
        (define (handle-incorrect-password)
         (cond
          ((>= incorrect-password-counter 7)
           (begin
            (call-the-cops)
            invalid-password))
          (else
           (begin
            (set! incorrect-password-counter (+ 1 incorrect-password-counter))
            invalid-password))))
        (define (dispatch m)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request: MAKE-ACCOUNT"
                            m))))
        (define (dispatch-check-password password-attempt m)
         (if (eq? password-attempt password)
             (begin
              (set! incorrect-password-counter 0)
              (dispatch m))
             (handle-incorrect-password)))
        dispatch-check-password))
      #+END_SRC

*** 3.1.2 The Benefits of Introducing Assignment

    As we shall see, introducing assignment into our programming
    language leads us into a thicket of difficult conceptual
    issues. Nevertheless, viewing systems as collections of objects
    with local state is a powerful technique for maintaining a modular
    design. As a simple example, consider the design of a procedure
    rand that, whenever it is called, returns an integer chosen at
    random.

    It is not at all clear what is meant by "chosen at random." What
    we presumably want is for successive calls to rand to produce a
    sequence of numbers that has statistical properties of uniform
    distribution. We will not discuss methods for generating suitable
    sequences here. Rather, let us assume that we have a procedure
    rand-update that has the property that if we start with a given
    number x_1 and form

    x_2 = (rand-update x_1)
    x_3 = (rand-update x_2)

    then the sequence of values x_1, x_2, x_3,... will have the
    desired statistical properties.

    We can implement rand as a procedure with a local state variable x
    that is initialized to some fixed value random-init. Each call to
    rand computes rand-update of the current value of x, returns this
    as the random number, and also stores this as the new value of x.

    #+BEGIN_SRC scheme
    (define rand (let ((x random-init))
                  (lambda ()
                   (set! x (rand-update x))
                   x)))
    #+END_SRC
      
    Of course, we could generate the same sequence of random numbers
    without using assignment by simply calling rand-update
    directly. However, this would mean that any part of our program
    that used random numbers would have to explicitly remember the
    current value of x to be passed as an argument to rand-update. To
    realize what an annoyance this would be, consider using random
    numbers to implement a technique called _Monte Carlo simulation_. 

    The Monte Carlo method consists of choosing sample experiments at
    random from a large set and then making deductions on the basis of
    the probabilities estimated from tabulating the results of those
    experiments. For example, we an approximate pi using the fact that
    6/\pi^2 is the probability that two integers chosen at random will
    have no factors in common; that is, that their greatest common
    divisor will be 1. To obtain the approximation to \pi, we perform
    a large number of experiments. In each experiment we choose two
    integers at random and perform a test to see if their GCD
    is 1. The fraction of times that the test is passed gives us our
    estimate of 6/\pi^2, and from this we obtain our approximation to
    \pi.

    The heart of our program is a procedure monte-carlo, which takes
    as arguments the number of times to try an experiment, together
    with the experiment, represented as a no-argument procedure that
    will return either true or false each time it is run. monte-carlo
    runs the experiment for the designated number of trials and
    returns a number telling the fraction of the trials in which the
    experiment was found to be true.

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (monte-carlo trials cesaro-test))))
    (define (cesaro-test)
     (= (gcd (rand) (rand)) 1))
    (define (monte-carlo trials experiment)
     (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1)
                   (+ trials-passed 1)))
            (else (iter (- trials-remaining 1)
                        trials-passed))))
     (iter trials 0))
    #+END_SRC

    Now let us try the same computation using rand-update directly
    rather than rand, the way we would be forced to proceed if we did
    not use assignment to model local state:

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (random-gcd-test trials random-init))))
    (define (random-gcd-test trials initial-x)
     (define (iter trials-remaining trials-passed x)
      (let ((x1 (rand-update x)))
       (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trails-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trails-remaining 1)
                     trials-passed
                     x2))))))
     (iter trials 0 initial-x)) 
    #+END_SRC

    While the program is still simple, it betrays some painful
    breaches of modularity. In our first version of the program, using
    rand, we can express the Monte Carlo method directly as a general
    monte-carlo procedure that takes as an argument an arbitrary
    experiment procedure. In our second version of the program, with
    no local state for the random-number generator, random-gcd-test
    must explicitly manipulate the random numbers x1 and x2 and
    recycle x2 throguh the iterative loop as the new input to
    rand-update. This explicit handling of the random numbers
    intertwines the structure of accumulating test results with the
    fact that our particular experiment uses two random numbers,
    whereas other Monte Carlo experiments might use one random number
    or three. Even the top-level procedure estimate-pi has to be
    concerned with supplying an initial random number. The fact that
    the random-number generator's insides are leaking out into other
    parts of the program makes it difficult for us to isolate the
    Monte Carlo idea so that it can be applied to other tasks. In the
    first version of the program, assignment encapsulates the state of
    the random-number generator within the rand procedure, so that the
    details of random-number generation remain independent of the rest
    of the program. 

    The general phenomenon illustrated by the Monte Carlo example is
    this: From the point of view of one part of a complex process, the
    other parts appear to change with time. They have hidden
    time-varying local state. If we wish to write computer programs
    whose structure reflects this decomposition, we make computational
    objects (such as bank accounts and random-number generators) whose
    behavior changes with time. We model state with local state
    variables, and we model the changes of state with assignments to
    those variables.

    It is tempting to conclude this discussion by saying that, by
    introducing assignment and the technique of hiding state in local
    variables, we are able to structure systems in a more modular
    fashion than if all state had to be manipulated explicitly, by
    passing additional parameters. Unfortunately, as we shall see, the
    story is not so simple.

    - Exercise 3.5. _Monte Carlo integration_ is a method of
      estimating definite integrals by means of Monte Carlo
      simulation. Consider computing the area of a region of space
      described by a predicate P(x, y) that is true for points (x, y)
      in the region and false for points not in the region. For
      example, the region contained within a circle of radius 3
      centered at (5, 7) is described by the predicate that tests
      whether (x - 5)^2 + (y-7)^2 <= 3^2. To estimate the area of the
      region described by such a predicate, begin by choosing a
      rectangle that contains the region. For example, a rectangle
      with diagonally opposite corners at (2, 4) and (8, 10) contains
      the circle above. The desired integral is the area of that
      portion of the rectangle that lies in the region. We can
      estimate the integral by picking, at random, points (x, y) that
      lie in the rectangle, and testing P(x, y) for each point to
      determine whether the point lies in the region. If we try this
      with many points, then the fraction of points that fall in the
      region should give an estimate of the proportion of the
      rectangle that lies in the region. If we try this with many
      points, then the fraction of points that fall in the region
      should give an estimate of the proportion of the rectangle that
      lies in the region. Hence, multiplying this fraction by the area
      of the entire rectangle should produce an estimate of the
      integral.

      Implement Monte Carlo integration as a procedure
      estimate-integral that takes as arguments a predicate P, upper
      and lower bounds x1, x2, y1, and y2 for the rectangle, and the
      number of trials to perform in order to produce the
      estimate. Your procedure should use the same monte-carlo
      procedure that was used above to estimate pi. Use your
      estimate-integral to produce an estimate4 of pi by measuring the
      area of a unit circle.

      You will find it useful to have a procedure that returns a
      number chosen at random from a given range. The following
      random-in-range procedure implements this in terms of the random
      procedure used in section 1.2.6, which returns a nonnegative
      number less than its input.

      #+BEGIN_SRC scheme
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (estimate-pi ntrials)
       (estimate-integral (lambda (x y) (<= (+ (square x)
                                               (square y))
                                             1))
                          -1.0 1.0 -1.0 1.0 ntrials))
      (define (estimate-integral P x1 x2 y1 y2 ntrials)
       (* (monte-carlo ntrials
                    (lambda ()
                     (let ((p-x (random-in-range x1 x2))
                           (p-y (random-in-range y1 y2)))
                      (P p-x p-y))))
          (* (- x2 x1) (- y2 y1))))
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))

      (define (monte-carlo trials experiment)
       (define (iter trials-remaining trials-passed)
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((experiment)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)))
              (else (iter (- trials-remaining 1)
                          trials-passed))))
       (iter trials 0))
      #+END_SRC

    - Exercise 3.6 It is useful to be able to reset a random-number
      generator to produce a sequence starting from a given
      value. Design a new rand procedure that is called with an
      argument that is either the symbol generate or the symbol reset
      and behaves as follows: (rand 'generate) produces a new random
      number; ((rand 'reset) <new-value>) resets the internal state
      variable to the designated <new-value>. Thus, by resetting the
      state, one can generate repeatable sequences. These are very
      handy to have when testing and debugging programs that use
      random numbers.

      #+BEGIN_SRC scheme
      (define SEED 0)
      (define (rand param)
       (let ((last-value SEED))
        (cond ((eq? param 'generate)
               (let ((val (rand-update last-value)))
                (set! last-value val)
                val))
              (else
               (lambda (new-value)
                (set! last-value new-value)
                new-value)))))
      #+END_SRC

*** 3.1.3 The Costs of Introducing Assignment

    As we have seen, the set! operation enables us to model objects
    that have local state. However, this advantage comes at a
    price. Our programming language can no longer be interpreted in
    terms of the substitution model of procedure application that we
    introduced in Section 1.1.5. Moreover, no simple model with "nice"
    mathematical properties can be an adequate framework for dealing
    with objects and assignment in programming languages. 

    So long as we do not use assignments, two evaluations of the same
    procedure with the same arguments will produce the same result, so
    that procedures can be viewed as computing mathematical
    functions. Programming without any use of assignments, as we did
    throughout the first two chapters of this book, is accordingly
    known as _functional programming_. 

    To understand how assignment complicates matters, consider a
    simplified version of the make-withdraw procedure of Section 3.1.1
    that does not bother to check for an insufficient amount:

    #+BEGIN_SRC scheme
    (define (make-simplified-withdraw balance)
     (lambda (amount)
      (set! balance (- balance amount))
      balance))
    (define W (make-simplified-withdraw 25))
    (W 20)
    5
    (W 10)
    -5
    #+END_SRC

    Compare this procedure with the following make-decrementer
    procedure, which does not use set!:

    #+BEGIN_SRC scheme
    (define (make-decrementer balance)
     (lambda (amount)
      (- balance amount)))
    #+END_SRC

    make-decrementer returns a procedure that subtracts its input from
    a designated amount balance, but there is no accumulated effect
    over successive calls, as with make-simplified-withdraw:

    #+BEGIN_SRC scheme
    (define D (make-decrementer 25))
    (D 20)
    5
    (D 10)
    15
    #+END_SRC

    We can use the substitution model to explain how make-decrementer
    works. For instance, let us analyze the evaluation of the
    expression

    #+BEGIN_SRC scheme
    ((make-decrementer 25) 20)
    #+END_SRC

    We first simplify the operator of the combination by substituting
    25 for balance in the body of make-decrementer. This reduces the
    expression to

    #+BEGIN_SRC scheme
    ((lambda (amount) (- 25 amount)) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (- 25 20)
    #+END_SRC
    
    The final answer is 5. Observe, however, what happens if we
    attempt a similar substitution analysis with
    make-simplified-withdraw:

    #+BEGIN_SRC scheme
    ((make-simplified-withdraw 25) 20)
    #+END_SRC

    We first simplify the operator by substituting 25 for balance in
    the body of make-simplified-withdraw. This reduces the expression
    to
    
    #+BEGIN_SRC scheme
    ((lambda (amount) (set! balance (- 25 amount)) 25) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (set! balance (- 25 20)) 25
    #+END_SRC

    If we adhered to the substitution model, we would have to say that
    the meaning of the procedure application is to first set balance
    to 5 and then return 25 as the value of the expression. This gets
    the wrong answer. In order to get the correct answer, we would
    have to somehow distinguish the first occurrence of balance
    (before the effect of the set!) from the second occurrence of
    balance (after the effect of the set!), and the substitution model
    cannot do this.

    The trouble here is that substitution is based ultimately on the
    notion that the symbols in our language are essentially names for
    values. But as soon as we introduce set! and the idea that the
    value of a variable can change, a variable can no longer be simply
    a name. Now a variable somehow refers to a place where a value can
    be stored, and the value stored at this place can change. In
    section 3.2 we will see how environments play this role of "place"
    in our computational model.

**** Sameness and change

     The issue surfacing here is more profound than the mere breakdown
     of a particular model of computation. As soon as we introduce
     change into our computational models, many notions that were
     previously straightforward become problematical. Consider the
     concept of two things being "the same."

     Suppose we call make-decrementer twice with the same argument to
     create two procedures:

     #+BEGIN_SRC scheme
     (define D1 (make-decrementer 25))
     (define D2 (make-decrementer 25))
     #+END_SRC

     Are D1 and D2 the same? An acceptable answer is yes, because D1
     and D2 have the same computational behavior -- each is a
     procedure that subtracts its input from 25. In fact, D1 could be
     substituted for D2 in any computation without changing the
     result.
     
     Contrast this with making two calls to make-simplified-withdraw:

     #+BEGIN_SRC scheme
     (define W1 (make-simplified-withdraw 25))
     (define W2 (make-simplified-withdraw 25))
     #+END_SRC

     Are W1 and W2 the same? Surely not, because calls to W1 and W2
     have distinct effects, as shown by the following sequence of
     interactions:

     #+BEGIN_SRC scheme
     (W1 20)
     5
     (W1 20)
     -15
     (W2 20)
     5
     #+END_SRC

     Even though W1 and W2 are "equal" in the sense that they are both
     created by evaluating the same expression,
     (make-simplified-withdraw 25), it is not true that W1 could be
     substituted for W2 in any expression without changing the result
     of evaluating the expression. 

     A language that supports the concept that "equals can be
     substituted for equals" in an expression without changing the
     value of the expression is said to be _referentially
     transparent._ Referential transparency is violated when we
     include set! in our computer language. This makes it tricky to
     determine when we can simplify expressions by substituting
     equivalent expressions. Consequently, reasoning about programs
     that use assignment becomes drastically more difficult.

     Once we forgo referential transparency, the notion of what it
     means for computational objects to be "the same" becomes
     difficult to capture in a formal way. Indeed, the meaning of
     "same" in the real world that our programs model is hardly clear
     in itself. In general, we can determine that two apparently
     identical objects are indeed "the same one" only by modifying one
     object and then observing whether the other object has changed in
     the same way. But how can we tell if an object has "changed"
     other than by observing the "same" object twice and seeing
     whether some property of the object differs from one observation
     to the next? Thus, we cannot determine "change" without some _a
     priori_ notion of "sameness," and we cannot determine sameness
     without observing the effects of change.

     As an example of how this issue arises in programming, consider
     the situation where Peter and Paul have a bank account with $100
     in it. There is a substantial difference between modeling this as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc (make-account 100))
     #+END_SRC

     and modeling it as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc peter-acc)
     #+END_SRC

     In the first situation, the two bank accounts are
     distinct. Transactions made by Peter will not affect Paul's
     account, and vice versa. In the second situation, however, we
     have defined paul-acc to be _the same thing_ as peter-acc. In
     effect, Peter and Paul now have a joint bank account, and if
     Peter makes a withdrawal from peter-acc Paul will observe less
     money in paul-acc. In effect, Peter and Paul now have a joint
     bank account, and if Peter makes a withdrawal from peter-acc Paul
     will observe less money in paul-acc. These two similar but
     distinct situations can cause confusion in building computational
     models. With the shared account, in particular, it can be
     especially confusing that there is one object (the bank account)
     that has two different names (peter-acc and paul-acc); if we are
     searching for all the places in our program where paul-acc can be
     changed, we must remember to look also at things that change
     peter-acc.

     With reference to the above remarks on "sameness" and "change,"
     observe that if Peter and Paul could only examine their bank
     balances, and could not perform operations that changed the
     balance, then the issue of whether the two accounts are distinct
     would be moot. In general, so long as we never modify data
     objects, we can regard a compound data object to be precisely the
     totality of its pieces. For example, a rational number is
     determined by giving its numerator and its denominator. But this
     view is no longer valid in the presence of change, where a
     compound data object has an "identity" that is something
     different from the pieces of which it is composed. A bank account
     is still "the same" bank account even if we change the balance by
     making a withdrawal; conversely, we could have two different bank
     accounts with the same state information. This complication is a
     consequence, not of our programming language, but of our
     perception of a bank account as an object. We do not, for
     example, ordinarily regard a rational number as a changeable
     object with identity, such that we could change the numerator and
     still have "the same" rational number.

**** Pitfalls of imperative programming

     In contrast to functional programming, programming that makes
     extensive use of assignment is known as _imperative programming._
     In addition to raising complications about computational models,
     programs written in imperative style are susceptible to bugs that
     cannot occur in functional programs. For example, recall the
     iterative factorial program from section 1.2.1:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product) (+ counter 1))))
      (iter 1 1))
     #+END_SRC

     Instead of passing arguments in the internal iterative loop, we
     could adopt a more imperative style by using explicit assignment
     to update the values of the variables product and counter:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (let ((product 1)
            (counter 1))
       (define (iter)
        (if (> counter n)
            product
            (begin (set! product (* counter product))
                   (set! counter (+ counter 1))
                   (iter))))
       (iter)))
     #+END_SRC

     This does not change the results produced by the program, but it
     does introduce a subtle trap. How do we decide the order of the
     assignments? As it happens, the program is correct as
     written. But writing the assignments in the opposite order

     #+BEGIN_SRC scheme
     (set! counter (+ counter 1))
     (set! product (* counter product))
     #+END_SRC

     would have produced a different, incorrect result. In general,
     programming with assignment forces us to carefully consider the
     relative orders of the assignments to make sure that each
     statement is using the correct version of the variables that have
     been changed. This issue simply does not arise in functional
     programs.

     The complexity of imperative programs becomes even worse if we
     consider applications in which several processes execute
     concurrently. We will return to this in section 3.4. First,
     however, we will address the issue of providing a computational
     model for expressions that involve assignment, and explore the
     uses of objects with local state in designing simulations.

     - Exercise 3.7: Consider the bank account objects created by
       make-account, with the password modification described in
       Exercise 3.3. Suppose that our banking system requires the
       ability to make joint accounts. Define a procedure make-joint
       that accomplishes this. make-joint should take three
       arguments. The first is a password-protected account. The
       second argument must match the password with which the account
       was defined in order for the make-joint operation to
       proceed. The third argument is a new password. make-joint is to
       create an additional access to the original account using the
       new password. For example, if peter-acc is a bank account with
       password open-sesame, then

       #+BEGIN_SRC scheme
       (define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))
       #+END_SRC
       
       will allow one to make transactions on peter-acc using the name
       paul-acc and the password rosebud. You may wish to modify your
       solution in Exercise 3.3 to accommodate this new feature.

       #+BEGIN_SRC scheme
       (define (make-joint account old-pass new-pass)
        (define (joint-account pass m)
         (if (eq? new-pass pass)
             (account old-pass m)
             (account old-pass 'incorrect-password)))
        (if (account old-pass 'password-matches?)
            joint-account
            "Incorrect password"))

       (define (call-the-cops)
        (display "Calling the cops!"))

       (define (make-account password balance)
        (let ((incorrect-password-counter 0))
         (define (password-matches? pass)
          (if (eq? password pass)
              true
              (begin (handle-incorrect-password)
                     false)))
         (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds"))
         (define (deposit amount)
          (begin
           (set! balance (+ balance amount))
            balance))
         (define (invalid-password amount)
          "Invalid password")
         (define (handle-incorrect-password)
          (cond
           ((>= incorrect-password-counter 7)
            (begin
             (call-the-cops)
             invalid-password))
           (else
            (begin
             (set! incorrect-password-counter (+ 1 incorrect-password-counter))
             invalid-password))))
         (define (dispatch m)
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                ((eq? m 'password-matches?) password-matches?)
                ((eq? m 'incorrect-password) invalid-password)
                (else (error "Unknown request: MAKE-ACCOUNT"
                             m))))
         (define (dispatch-check-password password-attempt m)
          (cond ((eq? m 'password-matches?)
                 (password-matches? password-attempt))
                ((eq? m 'incorrect-password)
                 (begin (handle-incorrect-password)
                        invalid-password))
                ((eq? password-attempt password)
                 (begin
                  (set! incorrect-password-counter 0)
                  (dispatch m)))
                (else
                 (handle-incorrect-password))))
         dispatch-check-password))
       #+END_SRC

     - Exercise 3.8: When we defined the evaluation model in Section
       1.1.3, we said that the first step in evaluating an expression
       is to evaluate its subexpressions. But we never specified the
       order in which the subexpressions should be evaluated
       (e.g. left to right or right to left). When we introduce
       assignment, the order in which the arguments to a procedure are
       evaluated can make a difference to the result. Define a simple
       procedure f such that evaluating

       #+BEGIN_SRC scheme
       (+ (f 0) (f 1))
       #+END_SRC

       will return 0 if the arguments to + are evaluated from left to
       right but will return 1 if the arguments are evaluated from
       right to left.

       #+BEGIN_SRC scheme
       (define f 
        (let ((zero-found false))
         (lambda (x)
          (cond 
           (zero-found 0)
           ((= 0 x) 
            (begin (set! zero-found true)
                   x))
           (else x)))))
       #+END_SRC

       It turns out MIT scheme is right-left for + at least. It is
       left-to-right for or.

** 3.2 The Environment Model of Evaluation

   When we introduced compound procedures in Chapter 1, we used the
   substitution model of evaluation (Section 1.1.5) to define what is
   meant by applying a procedure to arguments: 

   * To apply a compound procedure to arguments, evaluate the body of
     the procedure with each formal parameter replaced by the
     corresponding argument.

     
   Once we admit assignment into our programming language, such a
   definition is no longer adequate. In particular, Section 3.1.3
   argued that, in the presence of assignment, a variable can no
   longer be considered to be merely the name for a value. Rather, a
   variable must somehow designate a "place" in which values can be
   stored. In our new model of evaluation, these places will be
   maintained in structures called _environments_. 

   An environment is a sequence of _frames_. Each frame is a table
   (possibly empty) of _bindings_, which associate variable names with
   their corresponding values. (A single frame may contain at most one
   binding for any variable.) Each frame also has a pointer to its
   _enclosing environment_, unless, for the purposes of discussion,
   the frame is considered to be _global_. The _value of a variable_
   with respect to an environment is the value given by the binding of
   the variable in the first frame in the environment that contains a
   binding for that variable. If no frame in the sequence specifies a
   binding for the variable, then the variable is said to be _unbound_
   in the environment. 

   Figure 3.1 shows a simple environment structure consisting of three
   frames, labeled I, II, and III. In the diagram, A, B, C, and D are
   pointers to environments. C and D point to the same
   environment. The variables z and x are bound in frame II, while y
   and x are bound in frame I. The value of x in environment D
   is 3. The value of x with respect to environment B is also 3. This
   is determined as follows: We examine the first frame in the
   sequence (frame III) and do not find a binding for x, so we proceed
   to the enclosing environment D and find the binding in frame I. On
   the other hand, the value of x in environment A is 7, because the
   first frame in the sequence (Frame II) contains a binding of x
   to 7. With respect to environment A, the binding of x to 7 in frame
   II is said to _shadow_ the binding of x to 3 in frame I.

   The environment is crucial to the evaluation process, because it
   determines the context in which an expression should be
   evaluated. Indeed, one could say that expressions in a programming
   language do not, in themselves, have any meaning. Rather, an
   expression acquires a meaning only with respect to some environment
   in which it is evaluated. Even the interpretation of an expression
   as straightforward as (+ 1 1) depends on an understanding that one
   is operating in a context in which + is the symbol for
   addition. Thus, in our model of evaluation we will always speak of
   evaluating an expression with respect to some environment. To
   describe interactions with the interpreter, we will suppose that
   there is a global environment, consisting of a single frame (with
   no enclosing environment) that includes values for the symbols
   associated with the primitive procedures. For example, the idea
   that + is the symbol for addition is captured by saying that the
   symbol + is bound in the global environment to the primitive
   addition procedure. 

*** 3.2.1 The Rules for Evaluation

    The overall specification of how the interpreter evaluates a
    combination remains the same as when we first introduced it in
    section 1.1.3:

    * To evaluate a combination:

      1. Evaluate the subexpressions of the combination.

      2. Apply the value of the operator subexpression to the values
         of the operand subexpressions.

	 
    The environment model of evaluation replaces the substitution
    model in specifying what it means to apply a compound procedure to
    arguments. 
    
    In the environment model of evaluation, a procedure is always a
    pair consisting of some code and a pointer to an
    environment. Procedures are created in one way only: by evaluating
    a lambda-expression. This produces a procedure whose code is
    obtained from the text of the lambda-expression and whose
    environment is the environment in which the lambda-expression was
    evaluated to produce the procedure. For example, consider the
    procedure definition

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    #+END_SRC

    evaluated in the global environment. The procedure definition
    syntax is just syntactic sugar for an underlying implicit
    lambda-expression. It would have been equivalent to have used

    #+BEGIN_SRC scheme
    (define square
     (lambda (x) (* x x)))
    #+END_SRC

    which evaluates (lambda (x) (* x x)) and binds square to the
    resulting value, all in the global environment.

    Figure 3.2 shows the result of evaluating this define
    expression. The procedure object is a pair whose code specifies
    that the procedure has one formal parameter, namely x, and a
    procedure body (* x x). The environment part of the procedure is a
    pointer to the global environment, since that is the environment
    in which the lambda-expression was evaluated to produce the
    procedure. A new binding, which associates the procedure object
    with the symbol square, has been added to the global frame. In
    general, define creates definitions by adding bindings to frames.

    Now that we have seen how procedures are created, we can describe
    how procedures are applied. The environment model specifies: To
    apply a procedure to arguments, create a new environment
    containing a frame that binds the parameters to the values of the
    arguments. The enclosing environment in this frame is the
    environment specified by the procedure. Now, within this new
    environment, evaluate the procedure body. 

    To show how this rule is followed, Figure 3.3 illustrates the
    environment structure created by evaluating the expression
    (square 5) in the global environment, where square is the
    procedure generated in figure 3.2. Applying the procedure results
    in the creation of a new environment, labeled E1 in the figure,
    that begins with a frame in which x, the formal parameter for the
    procedure, is bound to the argument 5. The pointer leading upward
    from this frame shows that the frame's enclosing environment is
    the global environment. The global environment is chosen here,
    because this is the environment that is indicated as part of the
    square procedure object. Within E1, we evaluate the body of the
    procedure, (* x x). Since the value of x in E1 is 5, the result is
    (* 5 5), or 25. 

    The environment model of procedure application can be summarized
    by two rules:


    * A procedure object is applied to a set of arguments by
      constructing a frame, binding the formal parameters of the
      procedure to the arguments of the call, and then evaluating the
      body of the procedure in the context of the new environment
      constructed. The new frame has as its enclosing environment the
      environment part of the procedure object being applied.
    * A procedure is created by evaluating a lambda-expression
      relative to a given environment. The resulting procedure object
      is a pair consisting of the text with the lambda-expression and
      a pointer to the environment in which the procedure was created.


    We also specify that defining a symbol using define creates a
    binding in the current environment frame and assigns to the symbol
    the indicated value. Finally, we specify the behavior of set!, the
    operation that forced us to introduce the environment model in the
    first place. Evaluating the expression (set! <variable> <value>)
    in some environment locates the binding of the variable in the
    environment and changes that binding to indicate the new
    value. That is, one finds the first frame in the environment that
    contains a binding for the variable and modifies that frame. If
    the variable is unbound in the environment, then set! signals an
    error. 

    These evaluation rules, though considerably more complex than the
    substitution model, are still reasonably
    straightforward. Moreover, the evaluation model, though abstract,
    provides a correct description of how the interpreter evaluates
    expressions. In chapter 4 we shall see how this model can serve as
    a blueprint for implementing a working interpreter. The following
    sections elaborate the details of the model by analyzing some
    illustrative programs.

*** 3.2.2 Applying Simple Procedures

    When we introduced the substitution model in Section 1.1.5 we
    showed how the combination (f 5) evaluates to 136, given the
    following procedure definitions:

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    (define (sum-of-squares x y)
     (+ (square x) (square y)))
    (define (f a)
     (sum-of-squares (+ a 1) (* a 2)))
    #+END_SRC

    We can analyze the same example using the environment
    model. Figure 3.4 shows the three procedure objects created by
    evaluating the definitions of f, square, and sum-of-squares in the
    global environment. Each procedure object consists of some code,
    together with a pointer to the global environment. 

    In figure 3.5 we see the environment structure created by
    evaluating the expression (f 5). The call to f creates a new
    environment E1 beginning with a frame in which a, the formal
    parameter of f, is bound to the argument 5. In E1, we evaluate the
    body of f:

    #+BEGIN_SRC scheme
    (sum-of-squares (+ a 1) (* a 2))
    #+END_SRC

    To evaluate this combination, we first evaluate the
    subexpressions. The first subexpression, sum-of-squares, has a
    value that is a procedure object. (Notice how this value is found:
    We first look into the first frame of E1, which contains no
    binding for sum-of-squares. Then we proceed to the enclosing
    environment, i.e. the global environment, and find the binding
    shown in figure 3.4.) The other two subexpressions are evaluated
    by applying the primitive operations + and * to evaluate the two
    combinations (+ a 1) and (* a 2) to obtain 6 and 10, respectively.

    Now we apply the procedure object sum-of-squares to the arguments
    6 and 10. This results in a new environment E2 in which the formal
    parameters x and y are bound to the arguments. Within E2 we
    evaluate the combination (+ (square x) (square y)). This leads us
    to evaluate (square x), where square is found in the global frame
    and x is 6. Once again, we set up a new environment, E3, in which
    x is bound to 6, and within this we evaluate the body of square,
    which is (* x x). Also as part of applying sum-of-squares, we must
    evaluate the subexpression (square 6), where y is 10. This second
    call to square creates another environment, E4, in which x, the
    formal parameter of square, is bound to 10. And within E4 we must
    evaluate (* x x).

    The important point to observe is that each call to square creates
    a new environment containing a binding for x. We can see here how
    the different frames serve to keep separate the different local
    variables all named x. Notice that each frame created by square
    points to the global environment, since this is the environment
    indicated by the square procedure object.

    After the subexpressions are evaluated, the results are
    returned. The values generated by the two calls to square are
    added by sum-of-squares, and this result is returned by f. Since
    our focus here is on the environment structures, we will not dwell
    on how these returned values are passed from call to call;
    however, this is also an important aspect of the evaluation
    process, and we will return to it in detail in chapter 5. 

    - Exercise 3.9: In Section 1.2.1 we used the substitution model
      to analyze two procedures for computing factorials, a recursive
      version

      #+BEGIN_SRC scheme
      (define (factorial n)
       (if (= n 1) 1 (* n (factorial (- n 1)))))
      #+END_SRC

      and an iterative version

      #+BEGIN_SRC scheme
      (define (factorial n) (fact-iter 1 1 n))
      (define (fact-iter product counter max-count)
       (if (> counter max-count)
           product
           (fact-iter (* counter product)
                      (+ counter 1)
                      max-count)))
      #+END_SRC

      Show the environment structures created by evaluating
      (factorial 6) using each version of the factorial procedure.

*** 3.2.3 Frames as the Repository of Local State

    We can turn to the environment model to see how procedures and
    assignment can be used to represent objects with local state. As
    an example, consider the "withdrawal processor" from Section 3.1.1
    created by calling the procedure

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    Let us describe the evaluation of

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    followed by

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    Figure 3.6 shows the result of defining the make-withdraw
    procedure in the global environment. This produces a procedure
    object that contains a pointer to the global environment. So far,
    this is no different from the examples we have already seen,
    except that the body of the procedure is itself a
    lambda-expression.

    The interesting part of the computation happens when we apply the
    procedure make-withdraw to an argument:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    We begin, as usual, by setting up an environment E1 in which the
    formal parameter balance is bound to the argument 100. Within this
    environment, we evaluate the body of make-withdraw, namely the
    lambda-expression. This constructs a new procedure object, whose
    code is as specified by the lambda and whose environment is E1,
    the environment in which the lambda was evaluated to produce the
    procedure. The resulting procedure object is the value returned by
    the call to make-withdraw. This is bound to W1 in the global
    environment, since the define itself is being evaluated in the
    global environment. Figure 3.7 shows the resulting environment
    structure.

    Now we can analyze what happens when W1 is applied to an argument:

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    We begin by constructing a frame in which amount, the formal
    parameter of W1, is bound to the argument 50. The crucial point to
    observe is that this frame has as its enclosing environment not
    the global environment, but rather the environment E1, because
    this is the environment that is specified by the W1 procedure
    object. Within this new environment, we evaluate the body of the
    procedure:

    #+BEGIN_SRC scheme
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
    #+END_SRC

    The resulting environment structure is shown in Figure 3.8. The
    expression being evaluated references both amount and
    balance. amount will be found in the first frame in the
    environment, while balance will be found by following the
    enclosing-environment pointer to E1.

    When the set! is executed, the binding of balance in E1 is
    changed. At the completion of the call to W1, balance is 50, and
    the frame that contains balance is still pointed to by the
    procedure object W1. The frame that binds amount (in which we
    executed the code that changed balance) is no longer relevant,
    since the procedure call that constructed it has terminated, and
    there are no pointers to that frame from other parts of the
    environment. The next time W1 is called, this will build a new
    frame that binds amount and whose enclosing environment is E1. We
    see that E1 serves as the "place" that holds the local state
    variable for the procedure object W1. Figure 3.9 shows the
    situation after the call to W1. 

    Observe what happens when we create a second "withdraw" object by
    making another call to make-withdraw:

    #+BEGIN_SRC scheme
    (define W2 (make-withdraw 100))
    #+END_SRC

    This produces the environment structure of Figure 3.10, which
    shows that W2 is a procedure object, that is, a pair with some
    code and an environment. The environment E2 for W2 was created by
    the call to make-withdraw. It contains a frame with its own local
    binding for balance. On the other hand, W1 and W2 have the same
    code: the code specified by the lambda-expression in the body of
    make-withdraw. We see here why W1 and W2 behave as independent
    objects. Calls to W1 reference the state variable balance stored
    in E1, whereas calls to W2 reference the balance stored in
    E2. Thus, changes to the local state of one object do not affect
    the other object.

    - Exercise 3.10: In the make-withdraw procedure, the local
      variable balance is created as a parameter of make-withdraw. We
      could also create the local state variable explicitly, using
      let, as follows:

      #+BEGIN_SRC scheme
      (define (make-withdraw initial-amount)
       (let ((balance initial-amount))
        (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))))
      #+END_SRC
      Recall from Section 1.3.2 that let is simply syntactic sugar for
      a procedure call:

      #+BEGIN_SRC scheme
      (let ((<var> <exp>)) <body>)
      #+END_SRC

      is interpreted as an alternate syntax for
      
      #+BEGIN_SRC scheme
      ((lambda (<var>) <body>) <exp>)
      #+END_SRC

      Use the environment model to analyze this alternate version of
      make-withdraw, drawing figures like the ones above to illustrate
      the interactions

      #+BEGIN_SRC scheme
      (define W1 (make-withdraw 100))
      (W1 50)
      (define W2 (make-withdraw 100))
      #+END_SRC

      Show that the two versions of make-withdraw create objects with
      the same behavior. How do the environment structures differ for
      the two versions?

      In the end, the frame holding the balance has the exact same
      value. The only difference in the environment structures is that
      an extra (and mostly unused) frame is created before the final
      frame that holds the balance. 

*** 3.2.4. Internal Definitions
    Section 1.1.8 introduced the idea that procedures can have
    internal definitions, thus leading to a block structure as in the
    following procedure to compute square roots:

    #+BEGIN_SRC scheme
    (define (sqrt x)
     (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))
     (define (improve guess)
      (average guess (/ x guess)))
     (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
     (sqrt-iter 1.0))
    #+END_SRC

    Now we can use the environment model to see why these internal
    definitions behave as desired. Figure 3.11 shows the point in the
    evaluation of the expression (sqrt 2) where the internal procedure
    good-enough? has been called for the first time with guess equal
    to 1. 

    Observe the structure of the environment. sqrt is a symbol in the
    global environment that is bound to a procedure object whose
    associated environment is the global environment. When sqrt was
    called, a new environment E1 was formed, subordinate to the global
    environment, in which the parameter x is bound to 2. The body of
    sqrt was then evaluated in E1. Since the first expression in the
    body of sqrt is

    #+BEGIN_SRC scheme
    (define (good-enough? guess)
     (< (abs (- (square guess) x)) 0.001))
    #+END_SRC

    evaluating this expression defined the procedure good-enough? in
    the environment E1. To be more precise, the symbol good-enough?
    was added to the first frame of E1, bound to a procedure object
    whose associated environment is E1. Similarly, improve and
    sqrt-iter were defined as procedures in E1. For conciseness,
    figure 3.11 shows only the procedure object for good-enough?.

    After the local procedures were defined, the expression (sqrt-iter
    1.0) was evaluated, still in the environment E1. So the procedure
    object bound to sqrt-iter in E1 was called with 1 as an
    argument. This created an environment E2 in which guess, the
    parameter of sqrt-iter, is bound to 1. sqrt-iter in turn called
    good-enough? with the value of guess (from E2) as the argument
    for good-enough?. This set up another environment, E3, in which
    guess (the parameter of good-enough?) is bound to 1. Although
    sqrt-iter and good-enough? both have a parameter named guess,
    these are two distinct local variables located in different
    frames. Also, E2 and E3 both have E1 as their enclosing
    environment, because the sqrt-iter and good-enough? procesures
    both have E1 as their environment part. One consequence of this is
    that the symbol x that appears in the body of good-enough? will
    reference the binding of x that appears in E1, namely the value of
    x with which the original sqrt procedure was called.

    The environment model thus explains the two key properties that
    make local procedure definitions a useful technique for
    modularizing programs:

    * The names of the local procedures do not interfere with names
      external to the enclosing procedure, because the local procedure
      names will be bound in the frame that the procedure creates when
      it is run, rather than being bound in the global environment.
    * The local procedures can access the arguments of the enclosing
      procedure, simply by using parameter names as free
      variables. This is because the body of the local procedure is
      evaluated in an environment that is subordinate to the
      evaluation environment for the enclosing procedure.

      

    - Exercise 3.11: In section 3.2.3 we saw how the environment model
      described the behavior of procedures with local state. Now we
      have seen how internal definitions work. A typical
      message-passing procedure contains both of these
      aspects. Consider the bank account procedure of Section 3.1.1:

      #+BEGIN_SRC scheme
      (define (make-account balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else
               (error "Unknown request: MAKE-ACCOUNT" 
                      m))))
       dispatch)
      #+END_SRC

      Show the environment structure generated by the sequence of
      interactions

      #+BEGIN_SRC scheme
      (define acc (make-account 50))
      ((acc 'deposit) 40)
      90
      ((acc 'withdraw) 60)
      30
      #+END_SRC

      Where is the local state for acc kept? Suppose we define another
      account

      #+BEGIN_SRC scheme
      (define acc2 (make-account 100))
      #+END_SRC
      
      How are the local states for the two accounts kept distinct?
      Which parts of the environment structure are shared between acc
      and acc2?
      
      The states are kept distinct because distinct frames are created
      for each account, acc points to a procedure whose environment
      pointer points to a different frame than acc2. Each state is
      kept around in a frame created by the make-account
      procedure. acc and acc2 only share their parent environment, the
      global environment. Also, in our current model, the body
      pointers for all the methods they define would be shared, just
      not the environments.

** 3.3 Modeling with Mutable Data
   Chapter 2 dealt with compound data as a means for constructing
   computational objects that have several parts, in order to model
   real-world objects that have several aspects. In that chapter we
   introduced the discipline of data abstraction, according to which
   data structures are specified in terms of constructors, which
   create data objects, and selectors, which access the parts of
   compound data objects. But we now know that there is another aspect
   of data that chapter 2 did not address. The desire to model systems
   composed of objects that have changing state leads us to the need
   to modify compound data objects, as well as to construct and select
   from them. In order to model compound objects with changing state,
   we will design data abstractions to include, in addition to
   selectors and constructors, operations called _mutators_, which
   modify data objects. For instance, modeling a banking system
   requires us to change account balances. Thus, a data structure for
   representing bank accounds might admit an operation

   #+BEGIN_SRC scheme
   (set-balance! <account> <new-value>)
   #+END_SRC

   that changes the balance of the designated account to the
   designated new value. Data objects for which mutators are defined
   are known as _mutable data objects_. 

   Chapter2 introduced pairs as a general-purpose "glue" for
   synthesizing compound data. We begin this section by defining basic
   mutators for pairs, so that pairs can serve as building blocks for
   constructing mutable data objects. These mutators greatly enhance
   the representational power of pairs, enabling us to build data
   structures other than the sequences and trees that we worked with
   in Section 2.2. We also present some examples of simulations in
   which complex systems are modeled as collections of objects with
   local state.

*** 3.3.1 Mutable List Structure
    The basic operations on pairs -- cons, car, and cdr -- can be sued
    to construct list structure and to select parts from list
    structure, but they are incapable of modifying list structure. The
    same is true of the list operations we have used so far, such as
    append and list, since these can be defined in terms of cons, car,
    and cdr. To modify list structures we need new operations.

    The primitive mutators for pairs are set-car! and
    set-cdr!. set-car! takes two arguments, the first of which must be
    a pair. It modifies this pair, replacing the car pointer by a
    pointer to the second argument of set-car!.

    As an example, suppose that x is bound to the list ((a b) c d) and
    y to the list (e f) as illustrated in Figure 3.12. Evaluating the
    expression (set-car! x y) modifies the pair to which x is bound,
    replacing its car by the value of y. The result of the operation
    is shown in figure 3.13. The structure x has been modified and
    would now be printed as ((e f) c d). The pairs representing the
    list (a b), identified by the pointer that was replaced, are now
    detached from the original structure.

    Compare figure 3.13 with figure 3.14, which illustrates the result
    of executing (define z (cons y (cdr x))) with x and y bound to the
    original lists of Figure 3.12. The variable z is now bound to a
    new pair created by the cons operation; the list to which x is
    bound is unchanged. The set-cdr! operation is similar to
    set-car!. The only difference is that the cdr pointer of the pair,
    rather than the car pointer, is replaced. The effect of executing
    (set-cdr! x y) on the lists of Figure 3.12 is shown in Figure
    3.15. Here the cdr pointer of x has been replaced by the pointer
    to (e f). Also, the list (c d), which used to be the cdr of x, is
    now detached from the structure. 

    cons builds new list structure by creating new pairs, while
    set-car! and set-cdr! modify existing pairs. Indeed, we could
    implement cons in terms of the two mutators, together with a
    procedure get-new-pair, which returns a new pair that is not part
    of any existing list structure. We obtain the new pair, set its
    car and cdr pointers to the designated objects, and return the new
    pair as the result of cons.
    
    #+BEGIN_SRC scheme
    (define (cons x y)
     (let ((new (get-new-pair)))
      (set-car! new x)
      (set-cdr! new y)
      new))
    #+END_SRC

    - Exercise 3.12: The following procedure for appending lists was
      introduced in Section 2.2.1:

      #+BEGIN_SRC scheme
      (define (append x y)
       (if (null? x)
           y
           (cons (car x) (append (cdr x) y))))
      #+END_SRC

      append forms a new list by successively consing the elements of
      x onto y. The procedure append! is similar to append, but it is
      a mutator rather than a constructor. It appends the lists by
      splicing them together, modifying the final pair of x so that
      its cdr is now y. (It is an error to call append! with an empty
      x.)

      #+BEGIN_SRC scheme
      (define (append! x y)
       (set-cdr! (last-pair x) y)
       x)
      #+END_SRC

      Here last-pair is a procedure that returns the last pair in its
      argument:

      #+BEGIN_SRC scheme
      (define (last-pair x)
       (if (null? (cdr x)) x (last-pair (cdr x))))
      #+END_SRC

      Consider the interaction

      #+BEGIN_SRC scheme
      (define x (list 'a 'b))
      (define y (list 'c 'd))
      (define z (append x y))
      z
      ; => (a b c d)
      (cdr x)
      <response>

      (define w (append! x y))
      w
      ; => (a b c d)
      (cdr x)
      <response>  
      #+END_SRC
    
      What are the missing <response>s? Draw box-and-pointer diagrams
      to explain your answer.

      #+BEGIN_SRC scheme
      (define x (list 'a 'b))
      (define y (list 'c 'd))
      (define z (append x y))
      z
      ; => (a b c d)
      (cdr x)
      (b)

      (define w (append! x y))
      w
      ; => (a b c d)
      (cdr x)
      (b c d) 
      #+END_SRC

    - Exercise 3.13: Consider the following make-cycle procedure,
      which uses the last-pair procedure defined in Exercise 3.12:

      #+BEGIN_SRC scheme
      (define (make-cycle x)
       (set-cdr! (last-pair x) x)
       x)
      #+END_SRC

      Draw a box-and-pointer diagram that shows the structure z
      created by

      #+BEGIN_SRC scheme
      (define z (make-cycle (list 'a 'b 'c)))
      #+END_SRC

      What happens if we try to compute (last-pair z)?

      If you try to evaluate last-pair z it hangs forever, because you
      removed null from the list. The list is an infinite loop and you
      never stop cdr-ing.

    - Exercise 3.14: The following procedure is quite useful, although
      obscure:

      #+BEGIN_SRC scheme
      (define (mystery x)
       (define (loop x y)
        (if (null? x)
            y
            (let ((temp (cdr x)))
             (set-cdr! x y)
             (loop temp x))))
       (loop x '()))
      #+END_SRC

      loop uses the "temporary" variable temp to hold the old value of
      the cdr of x, since the set-cdr! on the next line destroys the
      cdr. Explain what mystery does in general. Suppose v is defined
      by (define v (list 'a 'b 'c 'd)). Draw the box-and-pointer
      diagram that represents the list to which v is bound. Suppose
      that we now evaluate (define w (mystery v)). Draw
      box-and-pointer diagrams that show the structures v and w after
      evaluating this expression. What would be printed as the values
      of v and w?

      This is a procedure that reverses the list. It reverses its
      parameter, so that the return value has the reversed list. But
      the input parameter is turned into only its first element. If
      you alter the last pair of the output list, you will alter the
      input value.

       
**** Sharing and identity

     We mentioned in Section 3.13 the theoretical issues of "sameness"
     and "change" raised by the introduction of assignment. These
     issues arise in practice when individual pairs are _shared_ among
     different data objects. For example, consider the structure
     formed by

     #+BEGIN_SRC scheme
     (define x (list 'a 'b))
     (define z1 (cons x x))
     #+END_SRC

     As shown in Figure 3.16, is a pair whose car and cdr both point
     to the same pair x. This sharing of x by the car and cdr of z1 is
     a consequence of the straightforward way in which cons is
     implemented. In general, using cons to construct lists will
     result in an interlinked structure of pairs in which many
     individual pairs are shared by many different structures.

     In contrast to Figure 3.16, Figure 3.17 shows the structure
     created by

     #+BEGIN_SRC scheme
     (define z2 (cons (list 'a 'b) (list 'a 'b)))
     #+END_SRC

     In this structure, the pairs in the two (a b) lists are distinct,
     although the actual symbols are shared.

     When thought of as a list, z1 and z2 represent "the same" list,
     ((a b) a b). In general, sharing is completely undetectable if we
     operate on lists using only cons, car, and cdr. However, if we
     allow mutators on list structure, sharing becomes significant. As
     an example of the difference that sharing can make, consider the
     following procedure, which modifies the car of the structure to
     which it is applied:

     #+BEGIN_SRC scheme
     (define (set-to-wow! x) (set-car! (car x) 'wow) x)
     #+END_SRC

     Even though z1 and z2 are "the same" structure, applying
     set-to-wow! to them yields different results. With z1, altering
     the car also changes the cdr, because in z1 the car and the cdr
     are the same pair. With z2, the car and cdr are distinct, so
     set-to-wow! modifies only the car:

     #+BEGIN_SRC scheme
     z1
     ((a b) a b)
     (set-to-wow! z1)
     ((wow b) wow b)
     z2
     ((a b) a b)
     (set-to-wow! z2)
     ((wow b) a b)
     #+END_SRC
     
     One way to detect sharing in list structures is to use the
     predicate eq?, which we introduced in Section 2.3.1 as a way to
     test whether two symbols are equal. More generally, (eq? x y)
     tests whether x and y are the same object (that is, whether x and
     y are equal as pointers). Thus, with z1 and z2 as defined in
     Figure 3.16 and Figure 3.17, (eq? (car z1) (cdr z1)) is true and
     (eq? (car z2) (cdr z2)) is false.

     As will be seen in the following sections, we can exploit sharing
     to greatly extend the repertoire of data structures that can be
     represented by pairs. On the other hand, sharing can also be
     dangerous, since modifications made to structures will also
     affect other structures that happen to share the modified
     parts. The mutation operations set-car! and set-cdr! should be
     used with care; unless we have a good understanding of how our
     data objects are shared, mutation can have unanticipated results.

     - Exercise 3.15: Draw box-and-pointer diagrams to explain the
       effect of set-to-wow! on the structures z1 and z2 above.

     - Exercise 3.16: Ben Bitdiddle decides to write a procedure to
       count the number of pairs in any list structure. "It's easy,"
       he reasons. "The number of pairs in any structure is the number
       in the car plus the number in the cdr plus one more to count
       the current pair." So ben writes the following procedure:

       #+BEGIN_SRC scheme
       (define (count-pairs x)
        (if (not (pair? x))
            0
            (+ (count-pairs (car x))
               (count-pairs (cdr x))
               1)))
       #+END_SRC

       Show that this procedure is not correct. In particular, draw
       box-and-pointer diagrams representing list structures made up
       of exactly three pairs for w hich Ben's procedure would return
       3, 4, 7, and never at all.

       #+BEGIN_SRC scheme
       ;; 3
       (define x1 (list 'a 'b 'c))
       ;; 4
       (define b '(b))
       (define a (cons 'a b))
       (define x2 (cons a b))
       ;; 7
       (define a '(a))
       (define b (cons a a))
       (define x3 (cons b b))
       ;; never
       (define x4 (list 1 2 3))
       (set-cdr! (last-pair x4) x4)
       #+END_SRC

     - Exercise 3.17 Devise a correct version of the count-pairs
       procedure of Exercise 3.16 that returns the number of distinct
       pairs in any structure (Hint: Traverse the structure,
       maintaining an auxiliary data structure that is used to keep
       track of which pairs have already been counted.)

       #+BEGIN_SRC scheme
       (define (count-pairs pairs)
        (define (empty-pairset) '())
        (define (adjoin-to-pairs x pairset) (cons x pairset))
        (define (already-seen? x pairset)
         (if (null? pairset) 
             false
             (or (eq? x (car pairset)) (already-seen? x (cdr pairset)))))
        (define (union-already-seen set1 set2)
          (append set1 set2))

        (define (make-result n found-pairs) (list n found-pairs))
        (define (already-seen result) (cadr result))
        (define (npairs result) (car result))
        (define (add-pair results)
         (make-result (+ 1 (npairs results)) (already-seen results)))
        (define (join-results result1 result2)
         (list (+ (npairs result1)
                  (npairs result2))
               (union-already-seen 
                (already-seen result1)
                (already-seen result2))))

        (define (count-pairs-iter seen-pairs x)
         (cond 
          ((not (pair? x)) (make-result 0 seen-pairs))
          ((already-seen? x seen-pairs)
           (make-result 0 seen-pairs))
          (else
           (let ((new-pairs (adjoin-to-pairs x seen-pairs)))
            (let ((results-car (count-pairs-iter 
                                new-pairs
                                (car x))))
             (add-pair
              (join-results
                results-car
                (count-pairs-iter
                  (already-seen results-car)
                 (cdr x)))))))))
        (npairs (count-pairs-iter (empty-pairset) pairs)))
       #+END_SRC

     - Exercise 3.18: Write a procedure that examines a list and
       determines whether it contains a cycle, that is, whether a
       program that tried to find the end of the list by taking
       successive cdrs would go into an infinite loop. Exercise 3.13
       constructed such lists.

       #+BEGIN_SRC scheme
       (define (is-cycle? a-list)
        (define (empty-pairset) '())
        (define (adjoin-to-pairs x pairset) (cons x pairset))
        (define (already-seen? x pairset)
         (if (null? pairset) 
             false
             (or (eq? x (car pairset)) (already-seen? x (cdr pairset)))))
        (define (union-already-seen set1 set2)
          (append set1 set2))

        (define (is-cycle-iter found-nodes a-list)
         (cond
          ((null? a-list) false)
          ((already-seen? a-list found-nodes) true)
          (else (is-cycle-iter (adjoin-to-pairs a-list found-nodes)
                               (cdr a-list)))))
        (is-cycle-iter (empty-pairset) a-list))
       #+END_SRC

     - Redo Exercise 3.18 using an algorithm that takes only a
       constant amount of space. (This requires a very clever idea).

       What you could potentially do is destruct the list by setting
       cdrs as you go to known values; and if you ever hit a 'marked'
       node, you know that you found a cycle.

       #+BEGIN_SRC scheme
       (define (is-cycle2? a-list)
        (define HAS-BEEN-TOUCHED 'touched)
        (define (get-next-item a-list)
         (let ((saved (cdr a-list)))
          (set-cdr! a-list HAS-BEEN-TOUCHED)
          saved))
        (define (is-cycle-iter a-list)
         (cond
          ((null? a-list) false)
          ((eq? (cdr a-list) HAS-BEEN-TOUCHED)
           true)
          (else (is-cycle-iter (get-next-item a-list)))))
        (is-cycle-iter a-list))
       #+END_SRC

       This works without extra space but it destroys the list. So you
       need to copy the list if you want it afterwards, which is
       similar to having a O(n) space requirement except
       offloaded. You could save the old CDR by making the list a pair
       whose car is 'touched and whose cdr is the old cdr, but this
       involves creating O(n) pairs; you just store them in the data
       structure instead of in a parameter, so it is also O(n) space
       requirement effectively.

       The Floyd algorithm would be:

       (define (is-cycle-floyd? a-list)
        (define (get-n-cdrs-or-null n a-list)
         (cond
          ((null? a-list) '())
          ((= 0 n) a-list)
          (else (get-n-cdrs-or-null (- n 1) (cdr a-list)))))

        (define (hare-next a-list)
         (get-n-cdrs-or-null 2 a-list))

        (define (tortoise-next a-list)
         (get-n-cdrs-or-null 1 a-list))

        (define (is-cycle-floyd-iter hare tortoise)
         (let ((hareplace (hare-next hare))
               (tortoiseplace (tortoise-next tortoise)))
          (cond
           ((or (null? hareplace)
                (null? tortoiseplace))
            false)
           ((eq? hareplace tortoiseplace)
            true)
           (else (is-cycle-floyd-iter hareplace tortoiseplace)))))
        (is-cycle-floyd-iter a-list (hare-next a-list)))


**** Mutation is just assignment

     When we introduced compound data, we observed in Section 2.1.3
     that pairs can be represented purely in terms of procedures:

     #+BEGIN_SRC scheme
     (define (cons x y)
      (define (dispatch m)
       (cond ((eq? m 'car) x)
             ((eq? m 'cdr) y)
             (else (error "Undefined operation: CONS" m))))
      dispatch)
     (define (car z) (z 'car))
     (define (cdr z) (z 'cdr))
     #+END_SRC

     The same observation is true for mutable data. We can implement
     mutable data objects as procedures using assignment and local
     state. For instance, we can extend the above pair implementation
     to handle set-car! and set-cdr! in a manner analogous to the way
     we implemented bank accounts using make-account in Section 3.1.1:

     #+BEGIN_SRC scheme
     (define (cons x y)
      (define (set-x! v) (set! x v))
      (define (set-y! v) (set! y v))
      (define (dispatch m)
       (cond ((eq? m 'car) x)
             ((eq? m 'cdr) y)
             ((eq? m 'set-car!) set-x!)
             ((eq? m 'set-cdr!) set-y!)
             (else
              (error "Undefined operation: CONS" m))))
      dispatch)
     (define (car z) (z 'car))
     (define (cdr z) (z 'cdr))
     (define (set-car! z new-value)
      ((z 'set-car!) new-value)
      z)
     (define (set-cdr! z new-value)
      ((z 'set-cdr!) new-value)
      z)
     #+END_SRC

     Assignment is all that is needed, theoretically, to account for
     the behavior of mutable data. As soon as we admit set! to our
     language, we raise all of the issues, not only of assignment, but
     of mutable data in general.

     - Exercise 3.20 Draw environment diagrams to illustrate the
       evaluation of the sequence of expressions

       #+BEGIN_SRC scheme
       (define x (cons 1 2))
       (define z (cons x x))
       (set-car! (cdr z) 17)
       (car x)
       17
       #+END_SRC
     
       using the procedural implementation of pairs given
       above. (Compare Exercise 3.11).

*** 3.3.2 Representing Queues

    The mutators set-car! and set-cdr! enable us to use pairs to
    construct data structures that cannot be built with cons, car, and
    cdr alone. This section shows how to use pairs to represent a data
    structure called a queue. Section 3.3.3 will show how to represent
    data structures called tables.

    A _queue_ is a sequence in which items are inserted at one end
    (called the _rear_ of the queue) and deleted from the other end
    (the _front_). Figure 3.18 shows an initially empty queue in which
    items a and b are inserted. Then a is removed, c and d are
    inserted, and b is removed. Because items are always removed in
    the order in which they are inserted, a queue is sometimes called
    a FIFO (first in, first out) buffer.

    #+BEGIN_SRC scheme
    Operation                    Resulting Queue
    (define q (make-queue))
    (insert-queue! q 'a)         a
    (insert-queue! q 'b)         a b
    (delete-queue! q)            b
    (insert-queue! q 'c)         b c
    (insert-queue! q 'd)         b c d
    (delete-queue! q)            c d
    #+END_SRC

    In terms of data abstraction, we can regard a queue as defined by
    the following set of operations:

    - A constructor: (make-queue) returns an empty queue (a queue
      containing no items).
    - two selectors:

      (empty-queue? <queue>) tests if the queue is empty.
      (front-queue <queue>) returns the object at the front of the
      queue, signaling an error if the queue is empty; it does not
      modify the queue.
    - Two mutators:
      
      (insert-queue! <queue> <item>) inserts the item at the rear of
      the queue and returns the modified queue as its value.

      (delete-queue! <queue>) removes the item at the front of the
      queue and returns the modified queue as its value, signaling an
      error if the queue is empty before the deletion.


    Because a queue is a sequence of items, we could certainly
    represent it as an ordinary list; the front of the queue would be
    the car of the list, inserting an item in the queue would amount
    to appending a new element at the end of the list, and deleting an
    item would amount to appending a new element at the end of the
    list, and deleting an item from the queue would just be taking the
    cdr of the list. However, this representation is inefficient,
    because in order to insert an item we must scan the list until we
    reach the end. Since the only method we have for scanning a list
    is by successive cdr operations, this scanning requires O(n) steps
    for a list of _n_ items. A simple modification to the list
    representation overcomes this disadvantage by allowing the queue
    operations to be implemented so that they require O(1) steps; that
    is, so that the number of steps needed is independent of the
    length of the queue.

    The difficulty with the list representation arises from the need
    to scan to find the end of the list. The reason we need to scan is
    that, although the standard way of representing a list as a chain
    of pairs readily provides us with a pointer to the beginning of
    the list, it gives us no easily accessible pointer to the end. The
    modification that avoids the drawback is to represent the queue as
    a list, it gives us no easily accessible pointer to the end. The
    modification that avoids the drawback is to represent the queue as
    a list, together with an additional pointer that indicates the
    final pair in the list. That way, when we go to insert an item, we
    can consult the rear pointer and so avoid scanning the list.

    A queue is represented, then, as a pair of pointers, front-ptr and
    rear-ptr, which indicate, respectively, the first and last pairs
    in an ordinary list. Since we would like the queue to be an
    identifiable object, we can use cons to combine the two
    pointers. Thus, the queue itself will be the cons of two
    pointers. 

    To define the queue operations we use the following procedures,
    which enable us to select and to modify the front and rear
    pointers of a queue:

    #+BEGIN_SRC scheme
    (define (front-ptr queue) (car queue))
    (define (rear-ptr queue) (cdr queue))
    (define (set-front-ptr! queue item)
     (set-car! queue item))
    (define (set-rear-ptr! queue item)
     (set-cdr! queue item))
    #+END_SRC

    Now we can implement the actual queue operations. We will consider
    a queue to be empty if its front pointer is the empty list:

    #+BEGIN_SRC scheme
    (define (empty-queue? queue)
     (null? (front-ptr queue)))
    #+END_SRC

    The make-queue constructor returns, as an initially empty queue, a
    pair whose car and cdr are both the empty list:

    #+BEGIN_SRC scheme
    (define (make-queue) (cons '() '()))
    #+END_SRC

    To select the item at the front of the queue, we return the car of
    the pair indicated by the front pointer:

    #+BEGIN_SRC scheme
    (define (front-queue queue)
     (if (empty-queue? queue)
         (error "FRONT called with an empty queue" queue)
         (car (front-ptr queue))))
    #+END_SRC

    To insert an item in a queue, we follow the method whose result is
    indicated in Figure 3.20. We first create a new pair whose car is
    the item to be inserted and whose cdr is the empty list. If the
    queue was initially empty, we set the front and rear pointers of
    the queue to this new pair. Otherwise, we modify the final pair in
    the queue to point to the new pair, and also set the rear pointer
    to the new pair.

    #+BEGIN_SRC scheme
    (define (insert-queue! queue item)
     (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else 
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
    #+END_SRC

    To delete the item at the front of the queue, we merely modify the
    front pointer so that it now poitns to the second item in the
    queue, which can be found by following the cdr pointer of the
    first item (see Figure 3.21):

    #+BEGIN_SRC scheme
    (define (delete-queue! queue)
     (cond ((empty-queue? queue)
            (error "DELETE! called with an empty queue" queue))
           (else (set-front-ptr! queue (cdr (front-ptr queue)))
                 queue)))
    #+END_SRC

    - Exercise 3.21: Ben Bitdiddle decides to test the queue
      implementation described above. He types in the procedures to
      the Lisp interpreter and proceeds to try them out:

      #+BEGIN_SRC scheme
      (define q1 (make-queue))
      (insert-queue! q1 'a)
      ((a) a)
      (insert-queue! q1 'b)
      ((a b) b)
      (delete-queue! q1)
      ((b) b)
      (delete-queue! q1)
      (() b)
      #+END_SRC

      "It's all wrong!" he complains. "The interpreter's response
      shows that the last item is inserted into the queue twice. And
      when I delete both items, the second b is still there, so the
      queue isn't empty, even though it's supposed to be." Eva Lu Ator
      suggests that Ben has misunderstood what is happening. "It's 
      just that the standard Lisp printer doesn't know how to make
      sense of the queue representation. If you want to see the queue
      printed correctly, you'll have to define your own print
      procedure for queues." Explain what Eva Lu is talking about. In
      particular, show why Ben's examples produce the printed results
      that they do. Define a procedure print-queue that takes a queue
      as input and prints the sequence of items in the queue.

      The interpreter prints cons cells as lists, where the car is the
      first element and the cdr is the rest. So the car of the cons
      cell points to the front of the queue as a list, (a b) in this
      case. And the rear pointer points to the last element, which is
      (cons b '()). So it will always print ((<entire-queue>)
      <last-element>). When we delete all elements in the queue, we
      only update the front-ptr and never rear-ptr. The result is that
      rear-ptr is left alone and still points to the element that was
      the rear, even when we deleted it.

      #+BEGIN_SRC scheme
      (define (print-queue queue)
        (map (lambda (x) (begin (display x) (display " "))) (front-ptr queue))
        (newline))
      #+END_SRC

    - Exercise 3.22: Instead of representing a queue as a pair of
      pointers, we can build a queue as a procedure with local
      state. The local state will consist of pointers to the beginning
      and the end of an ordinary list. Thus, the make-queue procedure
      will have the form

      #+BEGIN_SRC scheme
      (define (make-queue)
       (let ((front-ptr ...)
             (rear-ptr ...))
        <definitions of internal procedures>
        (define (dispatch m) ...)
        dispatch))
      #+END_SRC

      Complete the definition of make-queue and provide
      implementations of the queue operations using this
      representation.

      #+BEGIN_SRC scheme
      (define (make-queue)
       (let ((front-ptr '())
             (rear-ptr '()))
        (define (insert-queue! item)
         (let ((new-pair (cons item '())))
          (cond ((null? front-ptr)
                 (set! front-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr))))
        (define (delete-queue!)
          (set! front-ptr (cdr front-ptr))
          front-ptr)
        (define (front-queue)
         (car front-ptr))
        (define (empty-queue?)
         (null? front-ptr))
        (define (dispatch m)
         (cond
          ((eq? m 'insert-queue!) insert-queue!)
          ((eq? m 'delete-queue!) delete-queue!)
          ((eq? m 'empty-queue?) empty-queue?)
          ((eq? m 'front-queue) front-queue)
          (else
           (error "Unknown message -- DISPATCH" m))))
        dispatch))
      (define (empty-queue? q)
       ((q 'empty-queue?)))
      (define (front-queue q)
       ((q 'front-queue)))
      (define (insert-queue! q item)
       ((q 'insert-queue!) item))
      (define (delete-queue! q)
       ((q 'delete-queue!)))
      #+END_SRC

    - Exercise 3.23: A _dequeue_ ("double-ended queue") is a sequence
      in which items can be inserted and deleted at either the front
      or the rear. Operations on deques are the constructor
      make-deque, the predicate empty-deque?, selectors front-deque
      and rear-deque, mutators front-insert-deque!,
      rear-insert-deque!, front-delete-deque!, and
      rear-delete-deque!. Show how to represent deques using pairs,
      and give implementations of the operations. All operations
      should be accomplished in O(1) steps.

      We already have a front-and-rear pointer system, but the problem
      is that if we want to delete items from the back of the queue,
      the oldest items, we won't know where to put our pointer,
      because we can't find out what pointed to it. So instead each
      item needs to hold: 

      - the item

      - The item before (towards the front)

      - The item after (towards the back).

      And we keep the front and rear pointers. 

      #+BEGIN_SRC scheme
      (define (make-deque-item value next prev)
       (define (set-next! new-next)
        (set! next new-next)
        next)
       (define (set-prev! new-prev)
        (set! prev new-prev)
        prev)
       (define (dispatch m)
        (cond
         ((eq? m 'value) value)
         ((eq? m 'next) next)
         ((eq? m 'prev) prev)
         ((eq? m 'set-next!) set-next!)
         ((eq? m 'set-prev!) set-prev!)
         (else
          (error "Unknown message -- DISPATCH" m))))
       dispatch)
      (define (make-deque)
       (let ((front-ptr '())
             (back-ptr '()))
        (define (insert-front! item)
         (let ((new-node (make-deque-item item '() '())))
          (cond
           ((null? front-ptr)
            (set! front-ptr new-node)
            (set! back-ptr new-node)
            front-ptr)
          (else
           ((new-node 'set-next!) front-ptr)
           ((front-ptr 'set-prev!) new-node)
           (set! front-ptr new-node)
           front-ptr))))
        (define (insert-back! item)
         (let ((new-node (make-deque-item item '() '())))
          (cond
           ((null? front-ptr)
            (set! front-ptr new-node)
            (set! back-ptr new-node)
            front-ptr)
           (else
            ((new-node 'set-prev!) back-ptr)
            ((back-ptr 'set-next!) new-node)
            (set! back-ptr new-node)
            front-ptr))))
       (define (delete-back!)
        (let ((old-rear back-ptr))
         (set! back-ptr (old-rear 'prev))
         ((back-ptr 'set-next!) '())
         ((old-rear 'set-prev!) '()) 
         front-ptr))
       (define (delete-front!)
        (let ((old-front front-ptr))
         (set! front-ptr (old-front 'next))
         ((old-front 'set-next!) '())
         front-ptr))
       (define (front-deque)
        (front-ptr 'value))
       (define (back-deque)
        (back-ptr 'value))
       (define (print)
        (define (print-loop item)
         (if (not (null? item))
             (begin 
              (display (item 'value))
              (display " ")
              (print-loop (item 'next)))))
        (print-loop front-ptr))
       (define (dispatch m)
        (cond ((eq? m 'insert-front!) insert-front!)
              ((eq? m 'insert-back!) insert-back!)
              ((eq? m 'delete-back!) delete-back!)
              ((eq? m 'delete-front!) delete-front!)
              ((eq? m 'front-deque) front-deque)
              ((eq? m 'back-deque) back-deque)
              ((eq? m 'print) print)
              (else
               (error
                "Unknown message -- DISPATCH" m))))
       dispatch))
      #+END_SRC
    
*** 3.3.3. Representing Tables
    When we studied various ways of representing sets in Chapter 2, we
    mentioned in Section 2.3.3. the task of maintaining a table of
    records indexed by identifying keys. In the implementation of
    data-directed programming in Section 2.4.3, we made extensive use
    of two-dimensional tables, in which information is stored and
    retrieved using two keys. Here we see how to build tables as
    mutable list structures.

    We first consider a one-dimensional table, in which each value is
    stored under a single key. We implement the table as a list of
    records, each of which is implemented as a pair consisting of a
    key and the associated value. The records are glued together to
    form a list by pairs whose cars point to successive records. These
    gluing pairs are called the _backbone_ of the table. In order to
    have a place that we can change when we add a new record to the
    table, we build the table as a _headed list_. A headed list has a
    special backbone pair at the beginning, which holds a dummy
    "record" -- in this case the arbitrarily chosen symbol \*table\*.
    
    To extract information from a table we use the lookup procedure,
    which takes a key as argument and returns the associated value (or
    false if there is no value stored under that key). lookup is
    defined in terms of the assoc operation, which expects a key and a
    list of records as arguments. Note that assoc never sees the dummy
    record. assoc returns the record that has the given key as its
    car. lookup then checks to see that the resulting record returned
    by assoc is not false, and returns the value (the cdr) of the
    record.

    #+BEGIN_SRC scheme
    (define (lookup key table)
     (let ((record (assoc key (cdr table))))
      (if record
          (cdr record)
          false)))
    (define (assoc key records)
     (cond ((null? records) false)
           ((equal? key (caar records)) (car records))
           (else (assoc key (cdr records)))))
    #+END_SRC

    To insert a value in a table under a specified key, we first use
    assoc to see if there is already a record in the table with this
    key. If not, we form a new record by consing the key with the
    value, and insert this at the head of the table's list of records,
    after the dummy record. If there already is a record with this
    key, we set the cdr of this record to the designated new
    value. The header of the table provides us with a fixed location
    to modify in order to insert the new record.

    #+BEGIN_SRC scheme
    (define (insert! key value table)
     (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value)
                          (cdr table))))
     'ok))
    #+END_SRC

    To construct the new table, we simply create a list containing the
    symbol \*table\*:

    #+BEGIN_SRC scheme
    (define (make-table)
     (list '*table*))
    #+END_SRC

**** Two-dimensional tables

     In a two-dimensional table, each value is indexed by two keys. We
     can construct such a table as a one-dimensional table in which
     each key identifies as a subtable. Figure 3.23 shows the
     box-and-pointer diagram for the table

     math: +: 43          letters:  a: 97
           -: 45                    b: 98
           *: 42

     which has two subtables (The subtables don't need a special
     header symbol, since the key that identifies the subtable serves
     this purpose.)

     When we look up an item, we use the first key to identify the
     correct subtable. Then we use the second key to identify the
     record within the subtable.

     #+BEGIN_SRC scheme
     (define (lookup key-1 key-2 table)
      (let ((subtable
             (assoc key-1 (cdr table))))
       (if subtable
           (let ((record
                  (assoc key-2 (cdr subtable))))
            (if record
                (cdr record)
                false))
          false)))
     #+END_SRC

     To insert a new item under a pair of keys, we use assoc to see if
     there is a subtable stored under the first key. If not, we build
     a new subtable containing a single record (key-2, value) and
     insert it into the table under the first key. If a subtable
     already exists for the first key, we insert the new record into
     this subtable, using the insertion method for one-dimensional
     tables described above:

     #+BEGIN_SRC scheme
     (define (insert! key-1 key-2 value table)
      (let ((subtable (assoc key-1 (cdr table))))
       (if subtable
           (let ((record (assoc key-2 (cdr subtable))))
            (if record
                (set-cdr! record value)
                (set-cdr! subtable
                          (cons (cons key-2 value)
                                (cdr subtable)))))
          (set-cdr! table
                    (cons (list key-1
                                (cons key-2 value))
                          (cdr table)))))
      'ok)
     #+END_SRC

**** Creating local tables

     The lookup and insert! operations defined above take the table as
     an argument. This enables us to use programs that access more
     than one table. Another way to deal with multiple tables is to
     have separate lookup and insert! procedures for each table. We
     can do this by representing a table procedurally, as an object
     that maintains an internal table as part of its local state. When
     sent an appropriate message, this "table object" supplies the
     procedure with which to operate on the internal table. Here is a
     generator for two-dimensional tables represented in this fashion:

     #+BEGIN_SRC scheme
     (define (make-table)
      (let ((local-table (list '*table*)))
       (define (lookup key-1 key-2)
        (let ((subtable
               (assoc key-1 (cdr local-table))))
         (if subtable
             (let ((record
                    (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
       (define (insert! key-1 key-2 value)
        (let ((subtable
               (assoc key-1 (cdr local-table))))
         (if subtable
             (let ((record
                    (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
        'ok)
      (define (dispatch m)
       (cond ((eq? m 'lookup-proc) lookup)
             ((eq? m 'insert-proc!) insert!)
             (else (error "Unknown operation: TABLE" m))))
      dispatch))
     #+END_SRC

     Using make-table, we could implement the get and put operations
     used in Section 2.4.3 for data-directed programming, as follows:

     #+BEGIN_SRC scheme
     (define operation-table (make-table))
     (define get (operation-table 'lookup-proc))
     (define put (operation-table 'insert-proc!))
     #+END_SRC

     get takes as arguments two keys, and put takes as arguments two
     keys and a value. Both operations access the same local table,
     which is encapsulated within the object created by teh call to
     make-table.

     - Exercise 3.24: In the table implementations above, the keys are
       tested for equality using equal? (called by assoc). This is not
       always the appropriate test. For instance, we might have a
       table with numeric keys in which we don't need an exact match
       to the number we're lookuping up, but only a number within some
       tolerance of it. Design a table constructor make-table that
       takes as an argument a same-key? procedure that will be used to
       test "equality" of keys. make-table should return a dispatch
       procedure that can be used to access appropriate lookup and
       insert! procedures for a local table.

       You also need to rewrite assoc.
       #+BEGIN_SRC scheme
       (define (assoc/key a-list key same-key?)
        (cond
         ((null? a-list) false)
         ((same-key? (caar a-list) key) (car a-list))
         (else (assoc/key (cdr a-list) key same-key?))))
       (define (make-table same-key?)
        (let ((local-table (list '*table*)))
         (define (lookup key)
          (let ((record (assoc/key (cdr local-table) key same-key?)))
           (if record
               (cdr record)
               false)))
         (define (insert! key value)
          (let ((record (assoc/key (cdr local-table) key same-key?)))
           (if record
               (set-cdr! record value)
               (set-cdr! local-table
                         (cons (cons key value)
                               (cdr local-table)))))
          'ok)
         (define (dispatch m)
          (cond
           ((eq? m 'lookup) lookup)
           ((eq? m 'insert!) insert!)
           (else (error "Unknown message -- DISPATCH" m))))
         dispatch))
       #+END_SRC

     - Exercise 3.25: Generalizing one- and two-dimensional tables,
       show how to implement a table in which values are stored under
       an arbitrary number of keys and different values may be stored
       under different numbers of keys. The lookup and insert!
       procedures should take as input a list of keys used to access
       the table. 

       #+BEGIN_SRC scheme
       (define (make-table)
        (let ((local-table (list '*table*)))

         (define (lookup . keys)
          (lookup-list keys local-table))
         (define (lookup-list keys record)
          (cond
           ((null? keys) (cdr record))
           (else
            (let ((entry (assoc (car keys) (cdr record))))
             (if entry
                 (lookup-list (cdr keys) entry)
                 false)))))

         (define (insert! . keys-and-value)
          (insert-list! keys-and-value local-table))
         (define (insert-list! keys-and-value entry)
          (cond
           ((null? (cdr keys-and-value))
            (set-cdr! entry (car keys-and-value))
            'ok)
           (else
            (let ((record (assoc (car keys-and-value) (cdr entry))))
             (if record
                 (insert-list! (cdr keys-and-value) record)
                 (let ((new-entry (cons (car keys-and-value) (list))))
                  (set-cdr! entry
                            (cons new-entry
                                  (cdr entry)))
                  (insert-list! (cdr keys-and-value) new-entry)))))))

         (define (dispatch m)
          (cond ((eq? m 'insert!) insert!)
                ((eq? m 'lookup) lookup)
                (else (error "Unknown message -- DISPATCH" m))))
         dispatch))
       #+END_SRC

     - Exercise 3.26 To search a table as implemented above, one needs
       to scan through the list of records. This is basically the
       unordered list representation of Section 2.3.3. For large
       tables, it may be more efficient to structure the table in a
       different manner. Describe a table implementation where the
       (key, value) records are organized using a binary tree,
       assuming that keys can be ordered in some way (e.g.,
       numerically or alphabetically).

       Well, you would write a tree implementation pretty much exactly
       like the tree set we already did, except you'd extract keys to
       compare. And you'd probably give equality/lessthan/greaterthan
       function(s) to the make-table procedure.

       #+BEGIN_SRC scheme
       (define (make-node key value left right)
        (list key value left right))

       (define (make-empty-node)
        (list '() '() '() '()))
 
       (define (empty-node? node)
        (and (null? (car node))
             (null? (cadr node))
             (null? (caddr node))
             (null? (cadddr node)))) 

       (define (node-key node)
        (car node))

       (define (node-value node)
        (cadr node))

       (define (node-left node)
        (caddr node))

       (define (node-right node)
        (cadddr node))

       (define (node-set-key! node key)
        (set-car! node key))
       (define (node-set-value! node value)
        (set-car! (cdr node) value))

       (define (node-set-right! node new-right-node)
        (set-car! (cdddr node) new-right-node))

       (define (node-set-left! node new-left-node)
        (set-car! (cddr node) new-left-node))

       (define (make-table compare) ;; compare returns 'equal, 'less, or 'greater
        (let ((local-table (make-empty-node)))
         (define (lookup key node)
          (cond
           ((empty-node? node) false)
           ((eq? (compare key (node-key node)) 'equal)
            (node-value node))
           ((eq? (compare key (node-key node))
                 'less)
            (lookup key (node-left node)))
           ((eq? (compare key (node-key node))
                 'greater)
            (lookup key (node-right node)))
           (else (error "Nonsensical comparison value -- LOOKUP"))))

         (define (insert! key value node)
          (cond
           ((empty-node? node)
            (node-set-key! node key)
            (node-set-value! node value)
            (node-set-right! node (make-empty-node))
            (node-set-left! node (make-empty-node)))
           ((eq? (compare key (node-key node)) 'equal)
            (node-set-value! node value))
           ((eq? (compare key (node-key node)) 'less)
                (insert! key value (node-left node)))
           ((eq? (compare key (node-key node)) 'greater)
                (insert! key value (node-right node)))
           (else
            (error "Node does not compare -- INSERT!" key value node))))

        (define (dispatch m)
         (cond ((eq? m 'insert!) 
                (lambda (key value) 
                 (insert!
                  key value local-table)))
               ((eq? m 'lookup)
                (lambda (key)
                 (lookup key local-table)))
               (else
                (error "Unknown message -- DISPATCH" m))))
       dispatch))
       #+END_SRC

     - Exercise 3.27: _Memoization_ (also called _tabulation_) is a
       technique that enables a procedure to record, in a local table,
       values that have previously been computed. This technique can
       make a vast difference in the performance of a program. A
       memoized procedure maintains a table in which values of
       previous calls are stored using as keys the arguments that
       produced the values. When the memoized procedure is asked to
       compute a value, it first checks the table to see if the value
       is already there and, if so, just returns that
       value. Otherwise, it computes the new value in the ordinary way
       and stores this in the table. As an example of memoization,
       recall from Section 1.2.2 the exponential process for computing
       Fibonacci numbers:

       #+BEGIN_SRC scheme
       (define (fib n)
        (cond ((= n 0) 0)
              ((= n 1) 1)
              (else (+ (fib (- n 1)) (fib (- n 2))))))
       #+END_SRC

       The memoized version of the same procedure is

       #+BEGIN_SRC scheme
       (define memo-fib
               (memoize
                (lambda (n)
                 (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (else (+ (memo-fib (- n 1))
                                (memo-fib (- n 2))))))))
       #+END_SRC

       where the memoizer is defined as

       #+BEGIN_SRC scheme
       (define (memoize f)
        (let ((table (make-table)))
         (lambda (x)
          (let ((previously-computed-result
                 (lookup x table)))
           (or previously-computed-result
              (let ((result (f x)))
               (insert! x result table)
               result))))))
       #+END_SRC

       Draw an environment diagram to analyze the computation of
       (memo-fib 3). Explain why memo-fib computes the nth Fibonacci
       number in a number of steps proportional to n. Would the scheme
       still work if we had simply defined memo-fib to be (memoize
       fib)?

       fib(n) becomes proportional to n because the first call in the
       else clause -- (memo-fib (- n 1)) will compute all the
       fibonacci numbers below n. In previous iterations of fib, the
       second call would take as much time as the first, but it's
       result has already been computed so it's O(1), not adding major
       time to the computation. The basic result is that only the
       first call to fib does anything; the second call is always
       pre-computed by the first.

       (memoize fib) would not work, because it doesn't include the
       recursive calls. It would only keep track of the end result and
       not make much of a difference except in really long runs and
       repeated top-level calls of memo-fib.

       
*** 3.3.4 A Simulator for Digital Circuits

    Designing complex digital systems, such as computers, is an
    important engineering activity. Digital systems are constructed by
    interconnecting simple elements. Although the behavior of these
    individual elements is simple, networks of them can have very
    complex behavior. Computer simulation of proposed circuit designs
    is an important tool used by digital systems engineers. In this
    section we design a system for performing digital logic
    simulations. This system typifies a kind of program called an
    _event-driven simulation_, in which actions ("events") trigger
    further events that happen at a later time, which in turn trigger
    more events, and so on.

    Our computational model of a circuit will be composed of objects
    that correspond to the elementary components from which the
    circuit is constructed. There are _wires_, which carry _digital
    signals_. A digital signal may at any moment have only one of two
    possible values, 0 and 1. There are also various types of digital
    _function boxes_, which connect wires carrying input signals to
    other output wires. Such boxes produce output signals computed
    from their input signals. Such boxes produce output signals
    computed from their input signals. The output signal is delayed by
    a time that depends on the type of the function box. For example,
    an _inverter_ is a primitive function box that inverts its
    input. If the input signal to an inverter changes to 0, then one
    inverter-delay later the inverter will change its output signal
    to 1. If the input signal to an inverter changes to 1, then one
    inverter-delay later then inverter will changes its output signal
    to 0. We draw an inverter symbolically as in Figure 3.24. An
    _and-gate_, also chown in Figure 3.24, is a primitive function box
    with two inputs and one output. It drives its output signal to a
    value that is the _logical and_ of the inputs. That is, if both of
    its input signals become 1, then one and-gate-delay time later the
    and-gate will force its output signal to be 1; otherwise the
    output will be 0. An _or-gate_ is a similar two-input primitive
    function box that drives its output signal to a value that is the
    _logical or_ of the inputs. That is, the output will become 1 if
    at least one of the input signals is 1; otherwise the output will
    become 0.
    
    We can connect primitive functions together to construct more
    complex functions. To accomplish this we wire the outputs of some
    function boxes to the inputs of other function boxes. For example,
    the _half-adder_ circuit shown in Figure 3.25 consists of an
    or-gate, two and-gates, and an inverter. It takes two input
    signals, A and B, and has two output signals, S and C. S will
    become 1 whenever precisely one of A and B is 1, and C will become
    1 whenever A and B are both 1. We can see from the figure that,
    because of the delays involved, the outputs may be generated at
    different times. Many of the difficulties in the design of digital
    circuits arise from this fact.

    We will now build a program for modeling the digital logic
    circuits we wish to study. The program will construct
    computational objects modeling the wires, which will "hold" the
    signals. Function boxes will be modeled by procedures that enforce
    the correct relationships among the signals.

    One basic element of our simulation will be a procedure make-wire,
    which constructs wires. For example, we can construct six wires as
    follows:

    #+BEGIN_SRC scheme
    (define a (make-wire))
    (define b (make-wire))
    (define c (make-wire))
    (define d (make-wire))
    (define e (make-wire))
    (define s (make-wire))
    #+END_SRC

    We attach a function box to a set of wires by calling a procedure
    that constructs that kind of box. The arguments to the constructor
    procedure are the wires to be attached to the box. For example,
    given that we can construct and-gates, or-gates, and inverters, we
    can wire together the half-adder shown in Figure 3.25:

    #+BEGIN_SRC scheme
    (or-gate a b d)
    ok
    (and-gate a b c)
    ok
    (inverter c e)
    ok
    (and-gate d e s)
    ok
    #+END_SRC

    Better yet, we can explicitly name this operation by defining a
    procedure half-adder that constructs this circuit, given the four
    external wires to be attached to the half-adder:

    #+BEGIN_SRC scheme
    (define (half-adder a b s c)
     (let ((d (make-wire))
           (e (make-wire)))
      (or-gate a b d)
      (and-gate a b c)
      (inverter c e)
      (and-gate d e s)
      'ok))
    #+END_SRC

    The advantage of making this definition is that we can use
    half-adder itself as a building block in creating more complex
    circuits. Figure 3.26, for example, shows a _full-adder_ composed
    of two half-adders and an or-gate. We can construct a full-adder
    as follows:

    #+BEGIN_SRC scheme
    (define (full-adder a b c-in sum c-out)
     (let ((s (make-wire))
           (c1 (make-wire))
           (c2 (make-wire)))
      (half-adder a c-in s c1)
      (half-adder a s sum c2)
      (or-gate c1 c2 c-out)
      'ok))
    #+END_SRC

    Having defined full-adder as a procedure, we can now use it as a
    building block for creating still more complex circuits. 

    In essence, our simulator provides us with the tools to construct
    a language of circuits. If we adopt the general perspective on
    languages with which we approached the study of Lisp in Section
    1.1, we can say that the primitive function boxes form the
    primitive elements of the language, that wiring boxes together
    provides a means of combination, and that specifying wiring
    patterns as procedures serves as a means of abstraction.

**** Primitive function boxes.

     The primitive function boxes implement the "forces" by which a
     change in the signal on one wire influences the signals on the
     other wires. To build function boxes, we use the following
     operations on wires:

     - (get-signal <wire>)

       returns the current value of the signal on the wire.

     - (set-signal! <wire> <new-value>)
       
       changes the value of the signal on the wire to the new value.

     - (add-action! <wire> <procedure of no arguments>)

       asserts that the designated procedure should be run whenever
       the signal on the wire changes value. Such procedures are the
       vehicles by which changes in the signal value on the wire are
       communicated to other wires.

       
     In addition, we will make use of a procedure after-delay that
     takes a time delay and a procedure to be run and executes the
     given procedure after the given delay. 

     Using these procedures, we can define the primitive digital logic
     functions. To connect an input to an output through an inverter,
     we use add-action! to associate with the input wire a procedure
     that will be run whenever the signal on the input wire changes
     value. The procedure computes the logical-not of the input
     signal, and then, after one inverter-delay, sets the output
     signal to be this new value:

     #+BEGIN_SRC scheme
     (define (inverter input output)
      (define (invert-input)
       (let ((new-value (logical-not (get-signal input))))
        (after-delay inverter-delay
                     (lambda () (set-signal! output new-value)))))
      (add-action! input invert-input)
      'ok)
     (define (logical-not s)
      (cond ((= s 0) 1)
            ((= s 1) 0)
            (else (error "Invalid signal" s))))
     #+END_SRC

     An and-gate is a little more complex. The action procedure must
     be run if either of the inputs to the gate changes. It computes
     the logical-and (using a procedure analogous to logical-not) of
     the values of the signals on the input wires and sets up a change
     to the new value to occur on the output wire after one
     and-gate-delay.

     #+BEGIN_SRC scheme
     (define (and-gate a1 a2 output)
      (define (and-action-procedure)
       (let ((new-value
              (logical-and (get-signal a1) (get-signal a2))))
        (after-delay
         and-gate-delay
         (lambda () (set-signal! output new-value)))))
     (add-action! a1 and-action-procedure)
     (add-action! a2 and-action-procedure)
     'ok)
     #+END_SRC

     - Exercise 3.28: Define an or-gate as a primitive function
       box. Your or-gate constructor should be similar to and-gate.

       #+BEGIN_SRC scheme
       (define (or-gate a1 a2 output)
        (define (or-action-procedure)
         (let ((new-value
                (logical-or (get-signal a1) (get-signal a2))))
          (after-delay
           or-gate-delay
           (lambda () (set-signal! output new-value)))))
        (add-action! a1 or-action-procedure)
        (add-action! a2 or-action-procedure)
        'ok)
       #+END_SRC

     - Exercise 3.29: Another way to construct an or-gate is as a
       compound digital logic device, built from and-gates and
       inverters. Define a procedure or-gate that accomplishes
       this. What is the delay time of the or-gate in terms of
       and-gate-delay and inverter-delay?

       Invert both inputs and the output to an and gate.

       #+BEGIN_SRC scheme
       (define (or-gate a1 a2 output)
        (let ((a1-inverted (make-wire))
              (a2-inverted (make-wire))
              (output-to-invert (make-wire)))
        (inverter a1 a1-inverted)
        (inverter a2 a2-inverted)
        (and-gate a1-inverted a2-inverted output-to-invert)
        (inverter output-to-invert output)))
       #+END_SRC
       
       Delay time is: (2 * inverter-delay + and-gate-delay), since two
       inverters are in parallel on the input we count that as one
       delay, the inverted output counts as another delay, and the
       and-gate-delay is for the and-gate.

     - Exercise 3.30: Figure 3.27 shows a _ripple-carry-adder_ formed
       by stringing together _n_ full-adders. This is the simplest
       form of parallel adder for adding two n-bit binary numbers. The
       inputs A1, A2, A3, ..., A_n and B_1, B_2, B_3, ..., B_n are the
       two binary numbers to be added (each A_k and B_k is a 0 or a
       1). The circuit generates S_1, S_2, S_3, ..., S_n, the n bits
       of the sum, and C, the carry from the addition. Write a
       procedure ripple-carry-adder that generates this circuit. The
       procedure should take as arguments three lists of _n_ wires
       each - the A_k, the B_k, and the S_k -- and also another wire
       C. The major drawback of the ripple-carry adder is the need to
       wait for the carry signals to propagate. What is the delay
       needed to obtain the complete output from an _n_-bit
       ripple-carry adder, expressed in terms of the delays for
       and-gates, or-gates, and inverters?

       #+BEGIN_SRC scheme
       (define (ripple-carry-adder a-wires b-wires s-wires c-wire)
        (let ((last-carry (fold
                       (lambda (a-wire b-wire s-wire carry-in)
                        (let ((carry-out (make-wire)))
                         (full-adder a-wire b-wire carry-in s-wire carry-out)
                         carry-out))
                       c-wire
                       a-wires
                       b-wires
                       s-wires)))
         'ok))
       #+END_SRC

       Each full adder requires the output of the last, so we have
       N*(full-adder-delay), which is:

       (max(and-delay + inverter-delay, or-delay) + and-delay +
        max((max(and-delay + inverter-delay, or-delay) + and-delay),
            or-delay))

       N * 2 * (max(and-delay + inverter-delay, or-delay) + and-delay)
       2 * N * and-delay + 2 * N * max(and-delay + inverter-delay, or-delay)
**** Representing wires

     A wire in our simulation will be a computational object with two
     local state variables: a signal-value (initially taken to be 0)
     and a collection of action-procedures to be run when the signal
     changes value. We implement the wire, using message-passing
     style, as a collection of local procedures together with a
     dispatch procedure that selects the appropriate local operation,
     just as we did with the simple bank-account object in Section
     3.1.1:

     #+BEGIN_SRC scheme
     (define (make-wire)
      (let ((signal-value 0) (action-procedures '()))
       (define (set-my-signal! new-value)
        (if (not (= signal-value new-value))
            (begin (set! signal-value new-value)
                   (call-each action-procedures))
            'done))
      (define (accept-action-procedure! proc)
       (set! action-procedures
             (cons proc action-procedures))
       (proc))
      (define (dispatch m)
       (cond ((eq? m 'get-signal) signal-value)
             ((eq? m 'set-signal!) set-my-signal!)
             ((eq? m 'add-action!) accept-action-procedure!)
             (else (error "Unknown operation: WIRE" m))))
      dispatch))
     #+END_SRC

     The local procedure set-my-signal! tests whether the new signal
     value changes the signal on the wire. If so, it runs each of the
     action procedures, using the following procedure call-each, which
     calls each of the items in a list of no-argument procedures:

     #+BEGIN_SRC scheme
     (define (call-each procedures)
      (if (null? procedures)
          'done
          (begin ((car procedures))
                 (call-each (cdr procedures)))))
     #+END_SRC

     The local procedure accept-action-procedure! adds the given
     procedure to the list of procedures to be run, and then runs the
     new procedure once.

     With the local dispatch procedure set up as specified, we can
     provide the following procedures to access the local operations
     on wires:

     #+BEGIN_SRC scheme
     (define (get-signal wire) (wire 'get-signal))
     (define (set-signal! wire new-value)
      ((wire 'set-signal!) new-value))
     (define (add-action! wire action-procedure)
      ((wire 'add-action!) action-procedure))
     #+END_SRC

     Wires, which have time-varying signals and may be incrementally
     attached to devices, are typical of mutable objects. We have
     modeled them as procedures with local state variables that are
     modified by assignment. When a new wire is created, a new set of
     state variables is allocated (by the let expression in make-wire)
     and a new dispatch procedure is constructed and returned,
     capturing the environment with the new state variables.

     The wires are shared among the various devices that have been
     connected to them. Thus, a change made by an interaction with one
     device will affect all the other devices attached to the
     wire. The wire communicates the change to its neighbors by
     calling the action procedures provided to it when the connections
     were established.

**** The agenda

     The only thing needed to complete the simulator is
     after-delay. The idea here is that we maintain a data structure,
     called an _agenda_, that contains a schedule of things to do. The
     following operations are defined for agendas:

     - (make-agenda) returns a new empty agenda.
     - (empty-agenda? <agenda>) is true if the specified agenda is
       empty.
     - (first-agenda-item <agenda>) returns the first item on the
       agenda.
     - (remove-first-agenda-item! <agenda>) modifies the agenda by
       removing the first item.
     - (add-to-agenda! <time> <action> <agenda>) modifies the agenda
       by adding the given action procedure to be run at the specified time.
     - (current-time <agenda>) returns the current simulation time.

       

     The particular agenda that we use is denoted by the-agenda. The
     procedure after-delay adds new elements to the-agenda:

     #+BEGIN_SRC scheme
     (define (after-delay delay action)
      (add-to-agenda! (+ delay (current-time the-agenda))
                      action
                      the-agenda))
     #+END_SRC

     The simulation is driven by the procedure propagate, which
     operates on the-agenda, executing each procedure on the agenda in
     sequence. In general, as the simulation runs, new items will be
     added to the agenda, and propagate will continue the simulation
     as long as there are items on the agenda:

     #+BEGIN_SRC scheme
     (define (propagate)
      (if (empty-agenda? the-agenda)
          'done
          (let ((first-item (first-agenda-item the-agenda)))
           (first-item)
           (remove-first-agenda-item! the-agenda)
           (propagate))))
     #+END_SRC


**** A sample simulation

     The following procedure, which places a "probe" on a wire, shows
     the simulator in action. The probe tells the wire that, whenever
     its signal changes value, it should print the new signal value,
     together with the current time and a name that identifies the
     wire:

     #+BEGIN_SRC scheme
     (define (probe name wire)
      (add-action! wire
                   (lambda ()
                    (newline)
                    (display name)
                    (display " ")
                    (display (current-time the-agenda))
                    (display " New-value = ")
                    (display (get-signal wire)))))
     #+END_SRC

     We begin by initializing the agenda and specifying delays for the
     primitive function boxes:

     #+BEGIN_SRC scheme
     (define the-agenda (make-agenda))
     (define inverter-delay 2)
     (define and-gate-delay 3)
     (define or-gate-delay 5)
     #+END_SRC

     Now we define four wires, placing probes on two of them:

     #+BEGIN_SRC scheme
     (define input-1 (make-wire))
     (define input-2 (make-wire))
     (define sum (make-wire))
     (define carry (make-wire))

     (probe 'sum sum)
     sum 0 New-value = 0

     (probe 'carry carry)
     carry 0 New-value = 0
     #+END_SRC

     Next we connect the wires in a half-adder circuit (as in Figure
     3.25), set the signal on input-1 to 1, and run the simulation:

     #+BEGIN_SRC scheme
     (half-adder input-1 input-2 sum carry)
     ok
 
     (set-signal! input-1 1)
     done

     (propagate)
     sum 8 New-value = 1
     done
     #+END_SRC

     The sum signal changes to 1 at time 8. We are now eight time
     units from the beginning of the simulation. At this point, we can
     set the signal on input-2 to 1 and allow the values to propagate:

     #+BEGIN_SRC scheme
     (set-signal! input-2 1)
     done

     (propagate)
     carry 11 New-value = 1
     sum 16 New-value = 0
     done
     #+END_SRC

     The carry changes to 1 at time 11 and the sum changes to 0 at
     time 16.

     - Exercise 3.31: The internal procedure accept-action-procedure!
       defined in make-wire specifies that when a new action procedure
       is added to a wire, the procedure is immediately run. Explain
       why this initialization is necessary. In particular, trace
       through the half-adder example in the paragraphs above and say
       how the system's response would differ if we had defined
       accept-action-procedure! as

       #+BEGIN_SRC scheme
       (define (accept-action-procedure! proc)
        (set! action-procedures
              (cons proc action-procedures)))
       #+END_SRC

       An important part of a half-adder is an inverter. And if we
       don't run the action procedure that sets the state of the wire
       at the beginning, the circuit will be in a state that makes no
       sense and is wrong, because E will be 0 and the input to the
       inverter will be 0, so the circuit will be wrong. In this case
       the value of the entire circuit would still eventually be
       correct but it would be wrong to start with and if we had an or
       gate instead of an and-gate in our circuit, the output would be
       wrong to begin with. That makes it so the entire circuit to
       begin with is wrong and inconsistent which you don't want.


**** Implementing the agenda

     Finally, we give details of the agenda data structure, which
     holds the procedures that are scheduled for future execution.

     The agenda is made up of _time segments_. Each time segment is a
     pair consisting of a number (the time) and a queue (see Exercise
     3.32) that holds the procedures that are scheduled to be run
     during that time segment. 

     #+BEGIN_SRC scheme
     (define (make-time-segment time queue)
      (cons time queue))
     (define (segment-time s) (car s))
     (define (segment-queue s) (cdr s))
     #+END_SRC

     We will operate on the time-segment queues using the queue
     operations described in Section 3.3.2.

     The agenda itself is a one-dimensional table of time segments. It
     differs from the tables described in Section 3.3.3 in that the
     segments will be sorted in order of increasing time. In addition,
     we store the _current time_ (i.e., the time of the last action
     that was processed) at the head of the agenda. A newly
     constructed agenda has no time segments and has a current time of
     0:

     #+BEGIN_SRC scheme
     (define (make-agenda) (list 0))
     (define (current-time agenda) (car agenda))
     (define (set-current-time! agenda time)
      (set-car! agenda time))
     (define (segments agenda) (cdr agenda))
     (define (set-segments! agenda segments)
      (set-cdr! agenda segments))
     (define (first-segment agenda) (car (segments agenda)))
     (define (rest-segments agenda) (cdr (segments agenda)))
     #+END_SRC

     An agenda is empty if it has no time segments:

     #+BEGIN_SRC scheme
     (define (empty-agenda? agenda)
      (null? (segments agenda)))
     #+END_SRC

     To add an action to an agenda, we first check if the agenda is
     empty. If so, we create a time segment for the action and install
     this in the agenda. Otherwise, we scan the agenda, examining the
     time of each segment. If we find a segment for our appointed
     time, we add the action to the associated queue. If we reach a
     time later than the one to which we are appointed, we insert a
     new time segment into the agenda just before it. If we reach the
     end of the agenda, we must create a new time segment at the end.

     #+BEGIN_SRC scheme
     (define (add-to-agenda! time action agenda)
      (define (belongs-before? segments)
       (or (null? segments)
           (< time (segment-time (car segments)))))
      (define (make-new-time-segment time action)
       (let ((q (make-queue)))
        (insert-queue! q action)
        (make-time-segment time q)))
      (define (add-to-segments! segments)
       (if (= (segment-time (car segments)) time)
           (insert-queue! (segment-queue (car segments))
                          action)
           (let ((rest (cdr segments)))
            (if (belongs-before? rest)
                (set-cdr!
                 segments
                 (cons (make-new-time-segment time action)
                       (cdr segments)))
                (add-to-segments! rest)))))
      (let ((segments (segments agenda)))
       (if (belongs-before? segments)
           (set-segments!
            agenda
            (cons (make-new-time-segment time action)
                  segments))
           (add-to-segments! segments))))
     #+END_SRC

     The procedure that removes the first item from the agenda
     deletes the item at the front of the queue in the first time
     segment. If this deletion makes the time segment empty, we remove
     it from the list of segments:

     #+BEGIN_SRC scheme
     (define (remove-first-agenda-item! agenda)
      (let ((q (segment-queue (first-segment agenda))))
       (delete-queue! q)
       (if (empty-queue? q)
           (set-segments! agenda (rest-segments agenda)))))
     #+END_SRC

     The first agenda item is found at the head of the queue in the
     first time segment. Whenever we extract an item, we also update
     the current time:

     #+BEGIN_SRC scheme
     (define (first-agenda-item agenda)
      (if (empty-agenda? agenda)
          (error "Agenda is empty: FIRST-AGENDA-ITEM")
          (let ((first-seg (first-segment agenda)))
           (set-current-time! agenda
                              (segment-time first-seg))
           (front-queue (segment-queue first-seg)))))
     #+END_SRC

     - Exercise 3.32: The procedures to be run during each time
       segment of the agenda are kept in a queue. Thus, the procedures
       for each segment are called in the order in which they were
       added to the agenda (first in, first out). Explain why this
       order must be used. In particular, trace the behavior of an
       and-gate whose inputs change from 0, 1 to 1, 0 in the same
       segment and say how the behavior would differ if we stored a
       segment's procedures in an ordinary list, adding and removing
       procedures only at the front (last in, first out). 

       If you do it the other way around, as a traditional list,
       because our gates capture the current state of the wires in
       their action procedures and _then_ schedule setting the output
       based on that value, you will get the wrong value. In order to
       change a set of inputs from 0, 1, to 1, 0, you have to have an
       intermediate state of 1, 1 and then 1, 0. If you use a
       traditional list structure, first the 1, 0 state will get
       reflected, which is correct -- but then the 1, 1 state will get
       reflected as the final result which is wrong and does not
       reflect the final states of the inputs.
     
*** 3.3.5 Propagation of Constraints

    Computer programs are traditionally organized as one-directional
    computations, which perform operations on prespecified arguments
    to produce desired outputs. On the other hand, we often model
    systems in terms of relations among quantities. For example, a
    mathematical model of a mechanical structure might include the
    information that the deflection _d_ of a medal rod is related to
    the force _F_ of the rod, the length _L_ of the rod, the
    cross-sectional area _A_, and the elastic modulus _E_ via the
    equation

    dAE = FL.

    Such an equation is not one-directional. Given any four of the
    quantities, we can use it to compute the fifth. Yet translating
    the equation into a traditional computer language would force us
    to choose one of the quantities to be computed in terms of the
    other four. Thus, a procedure for computing the area A could not
    be used to compute the deflection _d_, even though the
    computations of A and d arise from the same equation.

    In this section, we sketch the design of a language that enables
    us to work in terms of relations themselves. The primitive
    elements of the language are _primitive constraints_, which state
    that certain relations hold between quantities. For example,
    (adder a b c) specifies that the quantities _a_, _b_, and _c_ must
    be related by the equation _a + b = c_, (multiplier x y z)
    expresses the constraint _xy = z_, and (constant 3.14 x) says that
    the value of _x_ must be 3.14. 

    Our language provides a means of combining primitive constraints
    in order to express more complex relations. We combine constraints
    by constructing _constraint networks_, in which constraints are
    joined by _connectors_. A connector is an object that "holds" a
    value that may participate in one or more constraints. For
    example, we know that the relationship between Fahrenheit and
    Celsius temperatures is

    9C = 5(F - 32)

    Such a constraint can be thought of as a network consisting of
    primitive adder, multiplier, and constant constraints. In the
    figure, we see on the left a multiplier box with three terminals,
    labeled m1, m2, and p. These connect the multiplier to the rest of
    the network as follows: The m1 terminal is liked to a connector C,
    which will hold the Celsius temperature. The m2 terminal is linked
    to a connector w, which is also linked to a constant box that
    holds 9. The _p_ terminal, which the multiplier box constrains to
    be the product of _m1_ and _m2_, is linked to the _p_ terminal of
    another multiplier box, whose _m2_ is connected to a constant 5
    and whose _m1_ is connected to one of the terms in a sum.

    Computation by such a network proceeds as follows: When a
    connector is given a value (by the user or a constraint box to
    which it is linked), it awakens all of its associated constraints
    (except for the constraint that just awakened it) to inform them
    that it has a value.

    Each awakened constraint box then polls its connectors to see if
    there is enough information to determine a value for a
    connector. If so, the box sets that connector, which then awakens
    all of its associated constraints, and so on. For instance, in
    conversion between Celsius and Fahrenheit, w, x, and y are
    immediately set by the constant boxes to 9, 5, and 32,
    respectively. The connectors awaken the multipliers and the adder,
    which determine that there is not enough information to
    proceed. If the user (or some other part of the network) sets _C_
    to a value (say 25), the leftmost multiplier will be awakened, and
    it will set _u_ to 25 * 9 = 225. Then _u_ awakens the second
    multiplier, which sets _v_ to 45, and _v_ awakens the adder, which
    sets _f_ to 77.

**** Using the constraint system

     To use the constraint system to carry out the temperature
     computation outlined above, we first create two connectors, C and
     F, by calling the constructor make-connector, and link C and F in
     an appropriate network:

     #+BEGIN_SRC scheme 
     (define C (make-connector))
     (define F (make-connector))
     (celsius-fahrenheit-converter C F)
     ; => ok
     #+END_SRC

     The procedure that creates the network is defined as follows:

     #+BEGIN_SRC scheme
     (define (celsius-fahrenheit-converter c f)
      (let ((u (make-connector))
            (v (make-connector))
            (w (make-connector))
            (x (make-connector))
            (y (make-connector)))
      (multiplier c w u)
      (multiplier v x u)
      (adder v y f)
      (constant 9 w)
      (constant 5 x)
      (constant 32 y)
      'ok))
     #+END_SRC

     This procedure creates the internal connectors u, v, w, x, and y,
     and links them as shown in Figure 3.28 using the primitive
     constraint constructors adder, multiplier, and constant. Just as
     with the digital-circuit simulator of Section 3.3.4, expressing
     these combinations of primitive elements in terms of procedures
     automatically provides our language with a means of abstraction
     for compound objects.

     To watch the network in action, we can place probes on the
     connectors C and F, using a probe procedure similar to the one we
     used to monitor wires in Section 3.3.4. Placing a probe on a
     connector will cause a message to be printed whenever the
     connector is given a value:

     #+BEGIN_SRC scheme
     (probe "Celsius temp" C)
     (probe "Fahrenheit temp" F)
     #+END_SRC

     Next we set the value of C to 25. (The third argument to
     set-value! tells C that this directive comes from the user.)

     #+BEGIN_SRC scheme
     (set-value! C 25 'user)
     ; => Probe: Celsius temp = 25
     ; => Probe: Fahrenheit temp = 77
     ; => done
     #+END_SRC

     The probe on C awakens and reports the value. C also propagates
     its value through the network as described above. This sets F to
     77, which is reported by the probe on F.

     Now we can try to set F to a new value, say 212:

     #+BEGIN_SRC scheme 
     (set-value! F 212 'user)
     ; => Error! contradiction (77 212)
     #+END_SRC

     The connector complains that it has sensed a contradiction: Its
     value is 77, and someone is trying to set it to 212. If we really
     want to reuse the network with new values, we can tell C to
     forget its old value:

     #+BEGIN_SRC scheme
     (forget-value! C 'user)
     ; => Probe: Celsius temp = ? 
     ; => Probe: Fahrenheit temp = ? 
     ; done
     #+END_SRC
     
     C finds that the user, who set its value originally, is now
     retracting that value, so C agrees to lose its value, as shown by
     the probe, and informs the rest of the network of this fact. This
     information eventually propagates to F, which now finds that it
     has no reason for continuing to believe that its own value
     is 77. Thus, F also gives up its value, as shown by the probe.

     Now that F has no value, we are free to set it to 212:

     #+BEGIN_SRC scheme
     (set-value! F 212 'user)
     ; Probe: Fahrenheit temp = 212
     ; Probe: Celsius temp = 100
     ; done
     #+END_SRC

     This new value, when propagates through the network, forces C to
     have a value of 100, and this is registered by the probe on
     C. Notice that the very same network is being used to compute C
     given F and to compute F given C. This nondirectionality of
     computation is the distinguishing features of constraint-based
     systems.

**** Implementing the constraint system.

     The constraint system is implemented via procedural objects with
     local state, in a manner very similar to the digital-circuit
     simulator of Section 3.3.4. Although the primitive objects of the
     constraint system are somewhat more complex, the overall system
     is simpler, since there is no concern about agendas an dlogic
     delays.

     The basic operations on connectors are the following:

     - (has-value? <connector>) tells whether the connector has a
       value.
     - (get-value <connector>) returns the connector's current value.
     - (set-value! <connector> <new-value> <informant>)
     - (forget-value! <connecto> <retractor>) tells the connector that
       the retractor is requesting it to forget its value.
     - (connect <connector> <new-constraint>) tells the connector to
       participate in the new constraint.

       
     The connectors communicate with the constraints by means of the
     procedures inform-about-value, which tells the given constraint
     that the connector has a value, and inform-about-no-value, which
     tells the constraint that the connector has lost its value.

     adder constructs an adder constraint among summand connectors a1
     and a2 and a sum connector. An adder is implemented as a
     procedure with local state (the procedure me below):

     #+BEGIN_SRC scheme
     (define (adder a1 a2 sum)
      (define (process-new-value)
       (cond ((and (has-value? a1) (has-value? a2))
              (set-value! sum
                          (+ (get-value a1) (get-value a2))
                          me))
             ((and (has-value? a1) (has-value? sum))
              (set-value! a2
                          (- (get-value sum) (get-value a1))
                          me))
             ((and (has-value? a2) (has-value? sum))
              (set-value! a1
                          (- (get-value sum)
                             (get-value a2))
                          me))))
      (define (process-forget-value)
       (forget-value! sum me)
       (forget-value! a1 me)
       (forget-value! a2 me)
       (process-new-value))
      (define (me request)
       (cond ((eq? request 'I-have-a-value) (process-new-value))
             ((eq? request 'I-lost-my-value) (process-forget-value))
             (else (error "Unknown request: ADDER" request))))
      (connect a1 me)
      (connect a2 me)
      (connect sum me)
      me)
     #+END_SRC

     adder connects the new adder to the designated connectors and
     returns it as its value. The procedure me, which represents the
     adder, acts as a dispatch to the local procedures. The following
     "syntax interfaces" (see Footnote 27 in Section 3.3.4) are used
     in conjunction with the dispatch:

     #+BEGIN_SRC scheme
     (define (inform-about-value constraint)
      (constraint 'I-have-a-value))
     (define (inform-about-no-value constraint)
      (constraint 'I-lost-my-value))
     #+END_SRC

     The adder's local procedure process-new-value is called when the
     adder is informed that one of its connectors has a value. The
     adder first checks to see if both a1 and a2 have values. If so,
     it tells sum to set its value to the sum of the two addends. The
     informant argument to set-value! is me, which is the adder oject
     itself. If a1 and a2 do not both have values, then the adder
     checks to see if perhaps a1 and sum have values. If so, it tells
     sum to set its value to the sum of the two addends. The
     informant argument to set-value! is me, which is the adder object
     itself. If a1 and a2 do not both have values, then the adder
     checks to see if perhaps a1 and sum have values. If so, it sets
     a2 to the difference of these two. Finally, if a2 and sum have
     values, this gives the adder enough information to set a1. If the
     adder is told that one of its connectors has lost a value, it
     requests that all of its connectors now lose their values. (Only
     those values that were set by this adder are actually lost.) Then
     it runs process-new-value. The reason for this last step is that
     one or more connectors may still have a value (that is, a
     connector may have had a value that was not originally set by the
     adder), and these values may need to be propagated back through
     the adder. 

     A multiplier is very similar to an adder. It will set its product
     to 0 if either of the factors is 0, even if the other factor is
     not known.

     #+BEGIN_SRC scheme
     (define (multiplier m1 m2 product)
      (define (process-new-value)
       (cond ((or (and (has-value? m1) (= (get-value m1) 0))
                  (and (has-value? m2) (= (get-value m2) 0)))
              (set-value! product 0 me))
             ((and (has-value? m1) (has-value? m2))
              (set-value! product
                          (* (get-value m1) (get-value m2))
                          me))
             ((and (has-value? product) (has-value? m1))
              (set-value! m2
                          (/ (get-value product)
                             (get-value m1))
                          me))
             ((and (has-value? product) (has-value? m2))
              (set-value! m1
                          (/ (get-value product)
                             (get-value m2))
                          me))))
      (define (process-forget-value)
       (forget-value! product me)
       (forget-value! m1 me)
       (forget-value! m2 me)
       (process-new-value))
      (define (me request)
       (cond ((eq? request 'I-have-a-value) (process-new-value))
             ((eq? request 'I-lost-my-value) (process-forget-value))
             (else (error "Unknown request: MULTIPLIER"
                          request))))
      (connect m1 me)
      (connect m2 me)
      (connect product me)
      me)
     #+END_SRC

     A constant constructor simply sets the value of the designated
     connector. Any I-have-a-value or I-lost-my-value message sent to
     the constant box will produce an error.

     #+BEGIN_SRC scheme
     (define (constant value connector)
      (define (me request)
       (error "Unknown request: CONSTANT" request))
      (connect connector me)
      (set-value! connector value me)
      me)
     #+END_SRC

     Finally, a probe prints a message about the setting or unsetting
     of the designated connector:

     #+BEGIN_SRC scheme
     (define (probe name connector)
      (define (print-probe value)
       (newline) (display "Probe: ") (display name)
       (display " = ") (display value))
      (define (process-new-value)
       (print-probe (get-value connector)))
      (define (process-forget-value) (print-probe "?"))
      (define (me request)
       (cond ((eq? request 'I-have-a-value) (process-new-value))
             ((eq? request 'I-lost-my-value) (process-forget-value))
             (else (error "Unknown request: PROBE" request))))
      (connect connector me)
      me)
     #+END_SRC

**** Representing connectors

     A connector is represented as a procedural object with local
     state variables value, the current value of the connector;
     informant, the object that set the connector's value; and
     constraints, a list of the constraints in which the connector
     participates.

     #+BEGIN_SRC scheme
     (define (make-connector)
      (let ((value false) (informant false) (constraints '()))
       (define (set-my-value newval setter)
        (cond ((not (has-value? me))
               (set! value newval)
               (set! informant setter)
               (for-each-except setter
                                inform-about-value
                                constraints))
              ((not (= value newval))
               (error "Contradiction" (list value newval)))
              (else 'ignored)))
       (define (forget-my-value retractor)
        (if (eq? retractor informant)
            (begin (set! informant false)
                   (for-each-except retractor
                                    inform-about-no-value
                                    constraints))
            'ignored))
       (define (connect new-constraint)
        (if (not (memq new-constraint constraints))
            (set! constraints
                  (cons new-constraint constraints)))
        (if (has-value? me)
            (inform-about-value new-constraint))
        'done)
      (define (me request)
       (cond ((eq? request 'has-value?)
              (if informant true false))
             ((eq? request 'value) value)
             ((eq? request 'set-value!) set-my-value)
             ((eq? request 'forget) forget-my-value)
             ((eq? request 'connect) connect)
             (else (error "Unknown operation: CONNECTOR"
                          request))))
      me))
     #+END_SRC

     The connector's local procedure set-my-value is called when there
     is a request to set the connector's value. If the connector does
     not currently have a value, it will set its value and remember as
     informant the constraint that requested the value to be set. Then
     the connector will notify all of its participating constraints
     except the constraint that requested the value to be set. Then
     the connector will notify all of its participating constraints
     except the constraint that requested the value to be set. This is
     accomplished using the following iterator, which applies a
     designated procedure to all items in a list except a given one:

     #+BEGIN_SRC scheme
     (define (for-each-except exception procedure list)
      (define (loop items)
       (cond ((null? items) 'done)
             ((eq? (car items) exception) (loop (cdr items)))
             (else (procedure (car items))
                   (loop (cdr items)))))
      (loop list))
     #+END_SRC

     If a connector is asked to forget its value, it runs the local
     procedure forget-my-value, which first checks to make sure that
     the request is coming from the same object that set the value
     originally. If so, the connector informs its associated
     constraints about the loss of the value.

     The local procedure connect adds the designated enw constraint to
     the list of constraints if it is not already in that list. Then,
     if the connector has a value, it informs the new constraint of
     this fact.

     The connector's procedure me serves as a dispatch to the other
     internal procedures and also represents the connector as an
     object. The following procedures provide a syntax interface for
     the dispatch:

     #+BEGIN_SRC scheme
     (define (has-value? connector)
      (connector 'has-value?))
     (define (get-value connector)
      (connector 'value))
     (define (set-value! connector new-value informant)
      ((connector 'set-value!) new-value informant))
     (define (forget-value! connector retractor)
      ((connector 'forget) retractor))
     (define (connect connector new-constraint)
      ((connector 'connect) new-constraint))
     #+END_SRC

     - Exercise 3.33: Using primitive multiplier, adder, and constant
       constraints, define a procedure averager that takes three
       connectors a, b, and c as inputs and establishes the constraint
       that the value of c is the average of the values of a and b.

       #+BEGIN_SRC scheme
       (define (averager a b c)
        (define (process-new-value)
         (cond ((and (has-value? a) (has-value? b))
                (set-value! c
                            (/ (+ (get-value a) (get-value b))
                               2.0)
                            me))
               ((and (has-value? c) (has-value? b))
                (set-value! a
                            (- (* (get-value c) 2.0) 
                               (get-value b))
                            me))
               ((and (has-value? c) (has-value? a))
                (set-value! b
                            (- (* (get-value c) 2.0)
                               (get-value a))
                            me))))
        (define (process-forget-value)
         (forget-value! c me)
         (forget-value! a me)
         (forget-value! b me)
         (process-new-value))
        (define (me request)
         (cond ((eq? request 'I-have-a-value) (process-new-value))
               ((eq? request 'I-lost-my-value) (process-forget-value))
               (else (error "Unknown request: MULTIPLIER"
                            request))))
        (connect a me)
        (connect b me)
        (connect c me)
        me)
       #+END_SRC

     - Exercise 3.34: Louis Reasoner wants to build a squarer, a
       constraint device with two terminals such that the value of
       connector b on the second terminal will always be the square of
       the value a on the first terminal. He proposes the following
       simple device made from a multiplier:

       #+BEGIN_SRC scheme
       (define (squarer a b)
        (multiplier a a b))
       #+END_SRC

       There is a serious flaw in this idea. Explain.

       Given the nature of squaring, we should be able to get a value
       for a if b has a value. So if we know b is 4, a should
       be 2. But the multiplier doesn't work this way, it looks to see
       if the product is defined and at least one of the inputs. But
       since both the inputs are the same, they will be both undefined
       if the value of b is defined, an the value for a will not be set.

     - Exercise 3.35: Ben Bitdiddle tells Louis that one way to avoid
       the trouble in Exercise 3.34 is to define a squarer as a new
       primitive constraint. Fill in the missing portions in ABen's
       outline for a procedure to implement such a constraint:

       #+BEGIN_SRC scheme
       (define (squarer a b)
        (define (process-new-value)
         (if (has-value? b)
             (if (< (get-value b) 0)
                 (error "square less than 0: SQUARER"
                        (get-value b))
                 <alternative1>)
            <alternative2>))
        (define (process-forget-value) <body1>)
        (define (me request) <body2>)
        <rest of definition>
        me)
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (squarer a b)
        (define (process-new-value)
         (if (has-value? b)
             (if (< (get-value b) 0)
                 (error "square less than 0: SQUARER"
                        (get-value b))
                 (set-value! a
                             (sqrt (get-value b))
                             me))
            (if (has-value? a)
                (set-value! b
                            (square (get-value a))
                            me))))
        (define (process-forget-value)
         (forget-value! a me)
         (forget-value! b me)
         (process-new-value))
        (define (me request) 
         (cond ((eq? request 'I-have-a-value)
                (process-new-value))
               ((eq? request 'I-lost-my-value)
                (process-forget-value))
               (else (error "Unknown request: SQUARER" request))))
        (connect a me)
        (connect b me)
        me)
       #+END_SRC

     - Exercise 3.36: Suppose we evaluate the following sequence of
       expressions in the global environment:

       #+BEGIN_SRC scheme
       (define a (make-connector))
       (define b (make-connector))
       (set-value! a 10 'user)
       #+END_SRC

       At some time during the evaluation of the set-value!, the
       following expression from the connector's local procedure is
       evaluated:

       #+BEGIN_SRC scheme
       (for-each-except setter inform-about-value constraints)
       #+END_SRC

       Draw an environment diagram showing the environment in which
       the above expression is evaluated.

     - Exercise 3.37: The celsius-fahrenheit-converter procedure is
       cumbersome when compared with a more expression-oriented style
       of definition, such as

       #+BEGIN_SRC scheme
       (define (celsius-fahrenheit-converter x)
        (c+ (c* (c/ (cv 9) (cv 5))
                x)
            (cv 32)))
       (define C (make-connector))
       (define F (celsius-fahrenheit-converter C))
       #+END_SRC

       Here c+, c*, etc. are the "constraint" versions of the
       arithmetic operations. For example, c+ takes two connectors as
       arguments and returns a connector that is related to these by
       an adder constraint:

       #+BEGIN_SRC scheme
       (define (c+ x y)
        (let ((z (make-connector)))
         (adder x y z)
         z))
       #+END_SRC

       Define analogous procedures c-, c*, c/, and cv (constant value)
       that enable us to define compound constraints as in the
       converter example above.


       #+BEGIN_SRC scheme
       (define (c- x y)
        (let ((z (make-connector)))
         (adder z y x)
         z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (c* x y)
        (let ((z (make-connector)))
         (multiplier x y z)
         z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (c/ x y)
        (let ((z (make-connector)))
         (multiplier y z x)
         z))
       #+END_SRC

       #+BEGIN_SRC scheme
       (define (cv x)
        (let ((z (make-connector)))
         (set-value! z x 'user)
         z))
       #+END_SRC
       

** 3.4 Concurrency: Time is of the Essence

   We've seen the power of computational objects with local state as
   tools for modeling. Yet, as Section 3.1.3. warned, this power
   extracts a price: the loss of referential transparency, giving rise
   to a thicket of questions about sameness and change, and the need
   to abandon the substitution model of evaluation in favor of the
   more intricate environment model. 

   The central issue lurking beneath the complexity of state,
   sameness, and change is that by introducing assignment we are
   forced to admit _time_ into our computational models. Before we
   introduced assignment, all our programs were timeless, in the sense
   that any expression that has a value always has the same value. In
   contrast, recall the example of modeling withdrawals from a bank
   account and returning the resulting balance, introduced at the
   beginning of Section 3.1.1:

   #+BEGIN_SRC scheme
   (withdraw 25)
   75
   (withdraw 25)
   50
   #+END_SRC
   
   Here successive evaluations of the same expression yield different
   values. This behavior arises from the fact that the execution of
   assignment statements (in this case, assignments to the variable
   balance) delineates _moments in time_ when values change. The
   result of evaluating an expression depends not only on the
   expression itself, but also on whether the evaluation occurs before
   or after these moments. Building models in terms of computational
   objects with local state forces us to confront time as an essential
   concept in programming.

   We can go further in structuring computational models to match our
   perception of the physical world. Objects in the world do not
   change one at a time in sequence. Rather we perceive them as acting
   _concurrently_ -- all at once. So it is often natural to model
   systems as collections of computational processes that execute
   concurrently. Just as we can make our programs modular by
   organizing models in terms of objects with local state, it is often
   appropriate to divide computational models into parts that evolve
   separately and concurrently. Even if the programs are to be
   executed on a sequential computer, the practice of writing programs
   as if they were to be executed concurrently forces the programmer
   to avoid inessential timing constraints and thus makes programs
   more modular.

   In addition to making programs more modular, concurrent computation
   can provide a speed advantage over sequential
   computation. Sequential computers execute only one operation at a
   time, so the amount of time it takes to perform a task is
   proportional to the total number of operations performed. However,
   if it is possible to decompose a problem into pieces that are
   relatively independent and need to communicate only rarely, it may
   be possible to allocate pieces to separate computing processors,
   producing a speed advantage proportional to the number of
   processors available. 
   
   Unfortunately, the complexities introduced by assignment become
   even more problematic in the presence of concurrency. The fact of
   concurrent execution, either because the world operates in parallel
   or because our computers do, entails additional complexity in our
   understanding of time.

*** 3.4.1 The Nature of Time in Concurrent Systems

    On the surface, time seems straightforward. It is an ordering
    imposed on events. For any events A and B, either A occurs before
    B, A and B are simultaneous, or A occurs after B. For instance,
    returning to the bank account example, suppose that Peter
    withdraws $10 and Paul withdraws $25 from a joint account that
    initially contains $100, leaving $65 in the account. Depending on
    the order of the two withdrawals, the sequence of balances in the
    account is either $100 -> $90 -> $65 or $100 -> $75 -> $65. In a
    computer implementation of the banking system, this changing
    sequence of balances could be modeled by successive assignments to
    a variable balance.

    In complex situations, however, such a view can be
    problematic. Suppose that Peter and Paul, and other people
    besides, are accessing the same bank account through a network of
    banking machines distributed all over the world. The actual
    sequence of balances in the account will depend critically on the
    detailed timing of the accesses and the details of the
    communication among the machines.

    This indeterminancy in the order of events can pose serious
    problems in the design of concurrent systems. For instance,
    suppose that the withdrawals made by Peter and Paul are
    implemented as two separate processes sharing a common variable
    balance, each process specified by the procedure given in Section
    3.1.1:

    #+BEGIN_SRC scheme
    (define (withdraw amount)
     (if (>= balance amount)
         (begin
          (set! balance (- balance amount))
          balance)
         "Insufficient funds"))
    #+END_SRC

    If the two processes operate independently, then Peter might test
    the balance and attempt to withdraw a legitimate amount. However,
    Paul might withdraw some funds in between the time that Peter
    checks the balance and the time Peter completes the withdrawal,
    thus invalidating Peter's test.

    Things can be worse still. Consider the expression

    #+BEGIN_SRC scheme
    (set! balance (- balance amount))
    #+END_SRC

    executed as part of each withdrawal process. This consists of
    three steps: (1) accessing the value of the balance variable; (2)
    computing the new balance; (3) setting balance to this new
    value. If Peter and Paul's withdrawals execute this statement
    concurrently, then the two withdrawals might interleave the order
    in which they access balance and set it to the new value.

    The timing diagram in Figure 3.29 depicts an order of events where
    balance starts at 100, Peter withdraws 10, Paul withdraws 25, and
    yet the final value of balance is 75. As shown in the diagram, the
    reason for this anomaly is that Paul's assignment of 75 to balance
    is made under the assumption that the value of balance to be
    decremented is 100. That assumption, however, became invalid when
    Peter changed balance to 90. This is a catastrophic failure for
    the banking system, because the total amount of money in the
    system is not conserved. Before the transactions, the total amount
    of money was $100. Afterwards, Peter has $10, Paul has $25, and
    the bank has $75. 

    The general phenomenon illustrated here is that several processes
    may share a common state variable. What makes this complicated is
    that more than one process may be trying to manipulate the shared
    state at the same time. For the bank account example, during each
    transaction, each customer should be able to act as if the other
    customers did not exist. When a customer changes the balance in a
    way that depends on the balance, he must be able to assume that,
    just before the moment of change, the balance is still what he
    thought it was.

**** Correct behavior of concurrent programs

     The above example typifies the subtle bugs that can creep into
     concurrent programs. The root of this complexity lies in the
     assignments to variables that are shared among the different
     processes. We already know that we must be careful in writing
     programs that use set!, because the results of a computation
     depend on the order in which the assignments occur. With
     concurrent processes we must be especially careful about
     assignments, because we may not be able to control the order of
     assignments made by the different processes. If several such
     changes might be made concurrently (as with two depositors
     accessing a joint account) we need some way to ensure that our
     system behaves correctly. For example, in the case of withdrawals
     from a joint bank account, we must ensure that money is
     conserved. To make concurrent programs behave correctly, we may
     have to place some restrictions on concurrent execution.

     One possible restriction on concurrency would stipulate that no
     two operations that change any shared state variables can occur
     at the same time. This is an extremely stringent requirement. For
     distributed banking, it would require the system designer to
     ensure that only one transaction could proceed at a time. This
     would be both inefficient and overly conservative. Figure 3.30
     shows Peter and Paul sharing a bank account, where Paul has a
     private account as well. The diagram illustrates two withdrawals
     from the shared account (one by Peter and one by Paul) and a
     deposit to Paul's private account. The two withdrawals from the
     shared account must not be concurrent (since both access and
     update the same account), and Paul's deposit and withdrawal must
     not be concurrent (since both access and update the same
     account), and Paul's deposit and withdrawal must not be
     concurrent (since both access and update the amount in Paul's
     wallet). But there should be no problem permitting Paul's deposit
     to his private account to proceed concurrently with Peter's
     withdrawal from the shared account.

     A less stringent restriction on concurrency would ensure that a
     concurrent system produces the same result as if the processes
     had run sequentially in some order. There are two important
     aspects to this requirement. First, it does not require the
     processes to actually run sequentially, but only to produce
     results that are the same _as if_ they had run sequentially. For
     the example in Figure 3.30, the designer of the bank account
     system can safely allow Paul's deposit and Peter's withdrawal to
     happen concurrently, because the net result will be the same as
     if the two operations had happened sequentially. Second, there
     may be more than one possible "correct" result produced by a
     concurrent program, because we require only that the result be
     the same as for _some_ sequential order. For example, suppose
     that Peter and Paul's joint account starts out with $100, and
     Peter deposits $40 while Paul concurrently withdraws half the
     money in the account. The sequential execution could result in
     the account balance being either $70 or $90 (see Exercuse 3.38).
     
     There are still weaker requirements for correct execution of
     concurrent programs. A program for simulating diffusion (say, the
     flow of heat in an object) might consist of a large number of
     processes, each one representing a small volume of space, that
     update their values concurrently. Each process repeatedly changes
     its value to the average of tis own value and its neightbors'
     values. This algorithm converges to the one right answer
     independent of the order in which the operations are done; there
     is no need for any restrictions on concurrent use of the shared
     values.

     - Exercise 3.38: Suppose that Peter, Paul, and Mary share a joint
       bank account that initially contains $100. Concurrently, Peter
       deposits $10, Paul withdraws $20, and Mary withdraws half the
       money in the account, by executing the following commands:

       #+BEGIN_SRC scheme
       Peter: (set! balance (+ balance 10))
       Paul:  (set! balance (- balance 20))
       Mary:  (set! balance (- balance (/ balance 2)))
       #+END_SRC

       a. List all the different possible values for balance after
       these three transactions have been completed, assuming that the
       banking system forces the three processes to run sequentially
       in some order.

       If executed Peter/Paul/Mary: 45
                   Paul/Peter/Mary: 45
                   Mary/Peter/Paul: 40
                   Mary/Paul/Peter: 40
                   Paul/Mary/Peter: 50
                   Peter/Mary/Paul: 35

       So there are six possible orders, but only four possible
       balances: 35, 40, 45, and 50.

       b. What are some other values that could be produced if the
       sysetm allows the processes to be interleaved? Draw timing
       diagrams like the one in Figure 3.29 to explain how these
       values occur.

       If Peter, Paul, and Mary all access at the same time, you can
       get the bank account set to 80, 50, or 100 (50 is a correct
       result but 80 or 110 is not). That's if they all access it at
       the same time, and compute the results separately. Then they
       all have their results and write back independently. Depending
       on the order, one of those values can get written back.

       Another thing that can happen is partial ordering. If peter
       runs his transaction alone, and sets balance to 110, and Mary
       and Paul go in parallel, then the value could be set to 55 or
       90, neither of which are correct.

*** 3.4.2 Mechanisms for Controlling Concurrency

    We've seen that the difficulty in dealing with concurrent
    processes is rooted in the need to consider the interleaving of
    the order of events in the different processes. For example,
    suppose we have two processes, one with three ordered events (a,
    b, c) and one with three ordered events (x, y, z). If the two
    processes run concurrently, with no constraints on how their
    execution is interleaved, then there are 20 different possible
    orderings for the events that are consistent with the individual
    orderings for two processes:

    #+BEGIN_EXAMPLE
    (a,b,c,x,y,z) (a,x,b,y,c,z) (x,a,b,c,y,z) (x,a,y,z,b,c)
    (a,b,x,c,y,z) (a,x,b,y,z,c) (x,a,b,y,c,z) (x,y,a,b,c,z)
    (a,b,x,y,c,z) (a,x,y,b,c,z) (x,a,b,y,z,c) (x,y,a,b,z,c)
    (a,b,x,y,z,c) (a,x,y,b,z,c) (x,a,y,b,c,z) (x,y,a,z,b,c)
    (a,x,b,c,y,z) (a,x,y,z,b,c) (x,a,y,b,z,c) (x,y,z,a,b,c)
    #+END_EXAMPLE

    As programmers designing this system, we would have to consier the
    effects of each of these 20 orderings and check that each behavior
    is acceptable. Such an approach rapidly becomes unwieldly as the
    numbers of processes and events increase.

    A more practical approach to the design of concurrent systems is
    to devise general mechanisms that allow us to constrain the
    interleaving of concurrent processes so that we can be sure that
    the program behavior is correct. Many mechanisms have been
    developed for this purpose. In this section, we describe one of
    them, the _serializer_. 

**** Serializing access to shared state

     Serialization implements the following idea: Processes will
     execute concurrently, but there will be certain collections of
     procedures that cannot be executed concurrently. More precisely,
     serialization creates distinguished sets of procedures such that
     only one execution of a procedure in each serialized set is
     permitted to happen at a time. If some procedure in the set is
     being executed, then a process that attempts to execute any
     procedure in the set will be forced to wait until the first
     execution has finished.

     We can use serialization to control access to shared
     variables. For example, if we want to update a shared variable
     based on the previous value of the variable, we put the access to
     the previous value of the variable and the assignment of the new
     value to the variable in the same procedure. We then ensure that
     no other procedure that assigns to the variable can run
     concurrently with this procedure by serializing all of these
     procedures with the same serializer. This guarantees that the
     value of the variable cannot be changed between an access and the
     corresponding assignment.

**** Serializers in Scheme
     To make the above mechanism more concrete, suppose that we have
     extended Scheme to include a procedure called parallel-execute:

     #+BEGIN_SRC scheme
     (parallel-execute <p1> <p2> ... <pk>)
     #+END_SRC

     Each <p> must be a procedure of no arguments. parallel-execute
     creates a separate process for each <p> (to no arguments). These
     processes all run concurrently.

     As an example of how this is used, consider

     #+BEGIN_SRC scheme
     (define x 10)
     (parallel-execute
      (lambda () (set! x (* x x)))
      (lambda () (set! x (+ x 1))))
     #+END_SRC

     This creates two concurrent processes -- P_1, which sets x to x
     times x, and P_2, which increments x. After execution is
     complete, x will be left with one of five possible values,
     depending on the interleaving of the events of P_1 and P_2:

     #+BEGIN_EXAMPLE
     101: P_1 sets x to 100 and then P_2 increments x to 101.
     121: P_2 increments x to 11 and P_1 sets x to x * x.
     110: P_2 changes x from 10 to 11 between the two times that
          P_1 accesses the value of x during the evaluation of (* x x).
      11: P_2 accesses x, then P_1 sets x to 100, then P_2 sets x.
     100: P_1 accesses x (twice), then P_2 sets x to 11, then P_1 sets x.
     #+END_EXAMPLE
     
     We can constrain the concurrency by using serialized procedures,
     which are created by _serializers_. Serializers are constructed
     by make-serializer, whose implementation is given below. A
     serializer takes a procedure as argument and returns a serialized
     procedure that behaves like the original procedure. All calls to
     a given serializer return serialized procedures in the same set.

     Thus, in contrast to the example above, executing

     #+BEGIN_SRC scheme
     (define x 10)
     (define s (make-serializer))
     (parallel-execute
      (s (lambda () (set! x (* x x))))
      (s (lambda () (set! x (+ x 1)))))
     #+END_SRC

     can produce only two possible values for x, 101 or 121. The other
     possibilities are eliminated, because the execution of P_1 and
     P_2 cannot be interleaved. 

     Here is a version of the make-account procedure from Section
     3.1.1, where the deposits and withdrawals have been serialized:

     #+BEGIN_SRC scheme
     (define (make-account balance)
      (define (withdraw amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount))
                  balance)
           "Insufficient funds"))
      (define (deposit amount)
       (set! balance (+ balance amount))
       balance)
      (let ((protected (make-serializer)))
       (define (dispatch m)
        (cond ((eq? m 'withdraw) (protected withdraw))
              ((eq? m 'deposit) (protected deposit))
              ((eq? m 'balance) balance)
              (else (error "Unknown request: MAKE-ACCOUNT"
                           m))))
       dispatch))
     #+END_SRC

     With this implementation, two processes cannot be withdrawing
     from or depositing into a single account concurrently. This
     eliminates the source of the error illustrated in Figure 3.29,
     where Peter changes the account balance between the times when
     Paul accesses the balance to compute the new value and when Paul
     actually performs the assignment. On the other hand, each account
     has its own serializer, so that deposits and withdrawals for
     different accounts can proceed concurrently. This eliminates the
     source of error illustrated in Figure 3.29, where Peter changes
     the account balance between the times when Paul accesses the
     balance to compute the new value and when Paul actually performs
     the assignment. On the other hand, each account has its own
     serializer, so that deposits and withdrawals for different
     accounts can proceed concurrently.  

     - Exercise 3.39: Which of the five possibilities in the parallel
       execution show above remain if we instead serialize execution
       as follows:

       #+BEGIN_SRC scheme
       (define x 10)
       (define s (make-serializer))
       (parallel-execute
        (lambda () (set! x ((s (lambda () (* x x))))))
        (s (lambda () (set! x (+ x 1)))))
       #+END_SRC

       You can now no longer compute (* x x) -- or access x to do so
       -- at the same time as setting x to x + 1, so you definitely
       can no longer end up with 110. But you can compute (* x x) and
       then set it while the other process is still accessing and
       setting:

       #+BEGIN_EXAMPLE
       100 -- P_1 computes (* x x), then is out of the serializer, so P_2 
              accesses x -- which is still 10 -- and sets it to x + 1, which is 11. 
              Then, P_2 finishes and writes 100.
       121 -- P_2 is first, accesses x as 10, and writes 11. During this time P_1 
              is blocked by the serializer from doing anything. Then P_2 computes 
              (* x x), and that is (* 11 11), and writes 121.
       101 -- P_1 sets x to 100 and P_2 increments it to 101.
       #+END_EXAMPLE'

       So it can no longer be 11 or 110.

     - Exercise 3.40: Give all possible values of x that can result
       from executing

       #+BEGIN_SRC scheme
       (define x 10)
       (parallel-execute (lambda () (set! x (* x x)))
                         (lambda () (set! x (* x x x))))
       #+END_SRC

       #+BEGIN_EXAMPLE
       10^5 -- sequential execution of P_1 then P_2 without anything special.
       10
       #+END_EXAMPLE

       Which of these possibilities remain if we instead use
       serialized procedures:

       #+BEGIN_SRC scheme
       (define x 10)
       (define s (make-serializer))
       (parallel-execute (s (lambda () (set! x (* x x))))
                         (s (lambda () (set! x (* x x x)))))
       #+END_SRC

       

     - Exercise 3.41: Ben Bitdiddle worries that it would be better to
       implement the bank account as follows (where the commented line






    
