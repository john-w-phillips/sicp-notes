* Chapter 3
** Modularity Objects and State
   The preceding chapters introduced the basic elements from which
   programs are made. We saw how primitive procedures and primitive
   data are combined to construct compound entities, and we learned
   that abstraction is vital in helping us to cope with the complexity
   of large systems. But these tools are not sufficient for designing
   programs. Effective program synthesis also requires organizational
   principles that can guide us in formulating the overall design of a
   program. In particular, we need strategies to help us structure
   large systems so that they will be _modular_, that is, so that they
   can be divided "naturally" into coherent parts that can be
   separately developed and maintained.
   
   One powerful design strategy, which is particularly appropriate to
   the construction of programs for modeling physical systems, is to
   base the structure of our programs on the structure of the system
   being modeled. For each object in the system, we construct a
   corresponding computational object. For each system action, we
   define a symbolic operation in our computational model. Our hope in
   using this strategy is that extending the model to accommodate new
   objects or new actions will require no strategic changes to the
   program, only the addition of the new symbolic analogs of those
   objects or actions. If we have been successful in our system
   organization, then to add a new feature or debug an old one we will
   have to work on only a localized part of the system. 

   To a large extent, then, the way we organize a large program is
   dictated by our perception of the system to be modeled. In this
   chapter we will investigate two prominent organizational strategies
   arising from two rather different "world views" of the structure of
   systems. The first organizational strategy concentrates on
   _objects_, viewing a large system as a collection of distinct
   objects whose behaviors may change over time. An alternative
   organizational strategy concetrates on the _streams_ of information
   that flow in the system, much as an electrical engineer views a
   signal-processing system.

   Both the object-based approach and the stream-processing approach
   raise significant linguistic issues in programming. With objects,
   we must be concerned with how a computational object can change and
   yet maintain its identity. This will force us to abandon our old
   substitution model of computation in favor of a more mechanistic
   but less theoretically tractable _environment model_ of
   computation. The difficulties of dealing with objects, change, and
   identity are fundamental consequences of the need to grapple with
   time in our computational models. These difficulties become even
   greater when we allow the possibility of concurrent execution of
   programs. The stream approach can be most fully exploited when we
   decouple simulated time in our model from the order of the events
   that take place in the computer during evaluation. We will
   accomplish this using a technique known as _delayed evaluation_.

** 3.1 Assignment and Local State

   We ordinarily view the world as populated by independent objects,
   each of which has a state that changes over timne. An object is
   said to "have state" if its behavior is influenced by its
   history. A bank account, for example, has a state in that the
   answer to the question "Can I withdraw $100?" depends upon the
   history of deposit and withdrawal transactions. We can characterize
   an object's state by one or more _state variables_, which among
   them maintain enough information about history to determine the
   object's current behavior. In a simple banking system, we could
   characterize the state of an account by a balance rather than by
   remembering the entire history of account transactions.
   
   In a system composed of many objects, the objects are rarely
   completely independent. Each may influence the states of others
   through interactions, which serve to couple the state variables of
   one object to those of other objects. Indeed, the view that a
   system is composed of separate objects is most useful when the
   state variables of the system can be grouped into closely coupled
   subsystems that are only loosely coupled to other subsystems. 
   
   This view of a system can be a powerful framework for organizing
   computational models of the system. For such a model to be modular,
   it should be decomposed into computational objects that model the
   actual objects in the system. Each computational object must have
   its own _local state variables_ describing the actual object's
   state. Since the states of objects in the system being modeled
   change over time, the state variables of the corresponding
   computational objects must also change. If we choose to model the
   flow of time in the system by the elapsed time in the computer,
   then we must have a way to construct computational objects whose
   behaviors change as our programs run. In particular, if we wish to
   model state variables by ordinary symbolic names in the programming
   language, then the language must provide an _assignment operator_
   to enable us to change the value associated with a name. 

*** 3.1.1. Local State Variables

    To illustarate what we mean by having a computational object with
    time-varying state, let us model the situation of withdrawing
    money from a bank account. We will do this using a procedure
    withdraw, which takes as argument an amount to be withdrawn. If
    there is enough money in the account to accommodate the
    withdrawal, then withdraw should return the balance remaining
    after the withrdrawal. Otherwise, withdraw should return the
    message _Insufficient funds_. For example, if we begin with $100
    in the account, we should obtain the following sequence of
    responses using withdraw:

    #+BEGIN_SRC scheme
    (withdraw 25)
    75
    (withdraw 25)
    50
    (withdraw 60)
    "Insufficient funds"
    (withdraw 15)
    35
    #+END_SRC

    Observe that the expression (withdraw 25), evaluated twice, yields
    different values. This is a new kind of behavior for a
    procedure. Until now, all our procedures could be viewed as
    specifications for computing mathematical functions. A call to a
    procedure computed the value of the function applied to the given
    arguments, and two calls to the same procedure with the same
    arguments always produced the same result. To implement withdraw,
    we can use a variable balance to indicate the balance of money in
    the account and define withdraw as a procedure that accesses
    balance. The withdraw procedure checks to see if balance is at
    least as large as the requested amount. If so, withdraw decrements
    balance by amount and returns the new value of balance. Otherwise,
    withdraw returns the _Insufficient Funds_ message. Here are the
    definitions of balance and withdraw:

    #+BEGIN_SRC scheme
    (define balance 100)
    (define (withdraw amount)
     (if (>= balance amount)
         (begin (set! balance (- balance amount))
                balance)
         "Insufficient funds"))
    #+END_SRC

    Decrementing balance is accomplished by the expression 

    #+BEGIN_SRC scheme
    (set! balance (- balance amount))
    #+END_SRC

    This uses the set! special form, whose syntax is

    #+BEGIN_SRC scheme
    (set! <name> <new-value>)
    #+END_SRC

    Here <name> is a symbol and <new-value> is any expression. set!
    changes <name> so that its value is the result obtained by
    evaluating <new-value>. In the case at hand, we are changing
    balance so that its new value will be the result of subtracting
    amount from the previous value of balance. 
    
    withdraw also uses the begin special form to cause two expressions
    to be evaluated in the case where the if test is true: first
    decrementing balance and then returning the value of balance. In
    general, evaluating the expression

    #+BEGIN_SRC scheme
    (begin <exp1> <exp2> ... <expk>)
    #+END_SRC

    causes the expression <exp1> through <expk> to be evaluated in
    sequence and the value of the final expression <expk> to be
    returned as the value of the entire begin form.

    Although withdraw works as desired, the variable balance presents
    a problem. As specified above, balance is a name defined in the
    global environment and is freely accessible to be examined or
    midified by any procedure. It would be much better if we could
    somehow make balance internal to withdraw, so that withdraw would
    be the only procedure that could access balance directly and any
    other procedure could access balance directly and any other
    procedure could access balance only indirectly (through calls to
    withdraw). This would more accurately model the notion that
    balance is a local state variable used by withdraw to keep track
    of the state of the account.

    We can make balance internal to withdraw by rewriting the
    definition as follows:

    #+BEGIN_SRC scheme
    (define new-withdraw
     (let ((balance 100))
      (lambda (amount)
       (if (>= balance amount)
           (begin (set! balance (- balance amount))
                  balance)
           "Insufficient funds"))))
    #+END_SRC

    What we have done here is use let to establish an environment with
    a locla variable balance, bound to the initial value 100. Within
    this local environment, we use lambda to create a procedure that
    takes amount as an argument and behaves like our previous withdraw
    procedure. This procedure -- returned as the result of evaluating
    the let expression -- is new-withdraw, which behaves in precisely
    the same way as withdraw but whose variable balance is not
    accessible by any other procedure. 

    Combining set! with local variables is the general programming
    technique we will use for constructing computational objects with
    local-state. Unfortunately, using this technique raises a serious
    problem: When we first introduced procedures, we also introduced
    the substitution model of evaluation (Section 1.1.5) to provide an
    interpretation of what procedure application means. We said that
    applying a procedure should be interpreted as evaluating the body
    of the procedure with the formal parameters replaced by their
    values. The trouble is that, as soon as we introduce assignment
    into our language, substitution is no longer an adequate model of
    procedure application. (We will see why this is so in section
    3.1.3). As a consequence, we technically have at this point no way
    to understand why the new-withdraw procedure behaves as claimed
    above. In order to really understand a procedure such as
    new-withdraw, we will need to develop a new model of procedure
    application. In section 3.2 we will introduce such a model,
    together with an explanation of set! and local variables. First,
    however, we examine some variations on the theme established by
    new-withdraw.

    The following procedure, make-withdraw, creates "withdrawal
    processors." The formal parameter balance in make-withdraw
    specifies the initial amount of money in the account.

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    make-withdraw can be used as follows to create two objects W1 and
    W2:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    (define W2 (make-withdraw 100))
 
    (W1 50)
     50
    (W2 70)
    30
    (W2 40)
    "Insufficient funds"
    (W1 40)
    10
    #+END_SRC

    Observe that W1 and W2 are completely independent objects, each
    with its own local state variable balance. Withdrawals from one do
    not affect the other.

    We can also create objects that handle deposits as well as
    withdrawals, and thus we can represent simple bank accounts. Here
    is a procedure that returns a "bank-accoutn object" with a
    specified initial balance:

    #+BEGIN_SRC scheme
    (define (make-account balance)
     (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
     (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
     (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
     dispatch)
    #+END_SRC

    Each call to make-account sets up an environment with a local
    state variable balance. Within this environment, make-account
    defines procedures deposit and withdraw that access balance and an
    additional procedure dispatch that takes a "message" as input and
    returns one of the two local procedures. The dispatch procedure
    itself is returned as the value that represents the bank-account
    object. This is precisely the _message-passing_ style of
    programming that we saw in section 2.4.3, although here we are
    using it in conjunction with the ability to modify local
    variables. make-account can be used as follows:

    #+BEGIN_SRC scheme
    (define acc (make-account 100))
    ((acc 'withdraw) 50)
    50
    ((acc 'withdraw) 60)
    "Insufficient funds"
    ((acc 'deposit) 40)
    90
    ((acc 'withdraw) 60)
    30
    #+END_SRC

    Each call to acc returns the locally defined deposit or withdraw
    procedure, which is then applied to the specified amount. As was
    the case with make-withdraw, another call to make-account

    #+BEGIN_SRC scheme
    (define acc2 (make-account 100))
    #+END_SRC

    will produce a completely separate account object, which maintains
    its own local balance. 

    - Exercise 3.1 An _accumulator_ is a procedure that is called
      repeatedly with a single numeric argument and accumulates its
      arguments into a sum. Each time it is called, it returns the
      currently accumulated sum. Write a procedure make-accumulator
      that generates accumulators, each maintaining an independent
      sum. The input to make-accumulator should specify the initial
      value of the sum; for example 

      #+BEGIN_SRC scheme
      (define A (make-accumulator 5))
      (A 10)
      15
      (A 10)
      25
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-accumulator value)
       (lambda (amount) 
        (begin
         (set! value (+ value amount))
         value)))
      #+END_SRC

    - Exercise 3.2: In software-testing applications, it is useful to
      be able to count the number of times a given procedure is called
      during the course of a computation. Write a procedure
      make-monitored that takes as input a procedure, f, that itself
      takes one input. The result returned by make-monitored is a
      third procedure, say mf, that keeps track of the number of times
      it has been called by maintaining an internal counter. If the
      input to mf is the special symbol how-many-calls? then mf
      returns the value of the counter. If the input is the special
      symbol reset-count, then mf resets the counter to zero. For any
      other input, mf returns the result of calling f on that input
      and increments the counter. For instance, we could make a
      monitored version of the sqrt procedure:

      #+BEGIN_SRC scheme
      (define s (make-monitored sqrt))
      (s 100)
      10
      (s 'how-many-calls?)
      1
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (make-monitored f)
       (let ((counter 0))
        (define (count-call param)
         (begin (set! counter (+ counter 1))
                (f param)))
        (define (get-calls)
         counter)
        (define (reset-calls)
         (begin
          (set! counter 0)
          counter))
        (define (dispatch value)
         (cond
          ((eq? value 'how-many-calls?)
           (get-calls))
          ((eq? value 'reset-count)
           (reset-calls))
          (else
           (count-call value))))
        dispatch))
      #+END_SRC

    - Exercise 3.3: Modify the make-account procedure so that it
      creates password-protected accounts. That is, make-account
      sohould take a symbol as an additional argument, as in 

      #+BEGIN_SRC scheme
      (define acc (make-account 100 'secret-password))
      #+END_SRC

      The resulting account object should process a request only if it
      is accompanied by the password with which the account was
      created, and should otherwise return a complaint:

      #+BEGIN_SRC scheme
      ((acc 'secret-password 'withdraw) 40)
      60
      ((acc 'some-other-password 'deposit) 50)
      "Incorrect password"
      #+END_SRC
      
      #+BEGIN_SRC scheme
      (define (make-account password balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (incorrect-password amount)
        "Incorrect password")
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request: MAKE-ACCOUNT"
                           m))))

       (define (dispatch-check-password password-attempt m)
        (if (eq? password-attempt password)
            (dispatch m)
            incorrect-password))
       dispatch-check-password)
      #+END_SRC

    - Exercise 3.4 Modify the make-account procedure of Exercise 3.3
      by adding another local state variable so that, if an account is
      accessed more than seven consecutive times with an incorrect
      password, it invokes the procedure call-the-cops.

      #+BEGIN_SRC scheme
      (define (call-the-cops)
       (display "Calling the cops!"))
      (define (make-account password balance)
       (let ((incorrect-password-counter 0))
        (define (withdraw amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))
        (define (deposit amount)
         (begin
          (set! balance (+ balance amount))
           balance))
        (define (invalid-password amount)
         "Invalid password")
        (define (handle-incorrect-password)
         (cond
          ((>= incorrect-password-counter 7)
           (begin
            (call-the-cops)
            invalid-password))
          (else
           (begin
            (set! incorrect-password-counter (+ 1 incorrect-password-counter))
            invalid-password))))
        (define (dispatch m)
         (cond ((eq? m 'withdraw) withdraw)
               ((eq? m 'deposit) deposit)
               (else (error "Unknown request: MAKE-ACCOUNT"
                            m))))
        (define (dispatch-check-password password-attempt m)
         (if (eq? password-attempt password)
             (begin
              (set! incorrect-password-counter 0)
              (dispatch m))
             (handle-incorrect-password)))
        dispatch-check-password))
      #+END_SRC

*** 3.1.2 The Benefits of Introducing Assignment

    As we shall see, introducing assignment into our programming
    language leads us into a thicket of difficult conceptual
    issues. Nevertheless, viewing systems as collections of objects
    with local state is a powerful technique for maintaining a modular
    design. As a simple example, consider the design of a procedure
    rand that, whenever it is called, returns an integer chosen at
    random.

    It is not at all clear what is meant by "chosen at random." What
    we presumably want is for successive calls to rand to produce a
    sequence of numbers that has statistical properties of uniform
    distribution. We will not discuss methods for generating suitable
    sequences here. Rather, let us assume that we have a procedure
    rand-update that has the property that if we start with a given
    number x_1 and form

    x_2 = (rand-update x_1)
    x_3 = (rand-update x_2)

    then the sequence of values x_1, x_2, x_3,... will have the
    desired statistical properties.

    We can implement rand as a procedure with a local state variable x
    that is initialized to some fixed value random-init. Each call to
    rand computes rand-update of the current value of x, returns this
    as the random number, and also stores this as the new value of x.

    #+BEGIN_SRC scheme
    (define rand (let ((x random-init))
                  (lambda ()
                   (set! x (rand-update x))
                   x)))
    #+END_SRC
      
    Of course, we could generate the same sequence of random numbers
    without using assignment by simply calling rand-update
    directly. However, this would mean that any part of our program
    that used random numbers would have to explicitly remember the
    current value of x to be passed as an argument to rand-update. To
    realize what an annoyance this would be, consider using random
    numbers to implement a technique called _Monte Carlo simulation_. 

    The Monte Carlo method consists of choosing sample experiments at
    random from a large set and then making deductions on the basis of
    the probabilities estimated from tabulating the results of those
    experiments. For example, we an approximate pi using the fact that
    6/\pi^2 is the probability that two integers chosen at random will
    have no factors in common; that is, that their greatest common
    divisor will be 1. To obtain the approximation to \pi, we perform
    a large number of experiments. In each experiment we choose two
    integers at random and perform a test to see if their GCD
    is 1. The fraction of times that the test is passed gives us our
    estimate of 6/\pi^2, and from this we obtain our approximation to
    \pi.

    The heart of our program is a procedure monte-carlo, which takes
    as arguments the number of times to try an experiment, together
    with the experiment, represented as a no-argument procedure that
    will return either true or false each time it is run. monte-carlo
    runs the experiment for the designated number of trials and
    returns a number telling the fraction of the trials in which the
    experiment was found to be true.

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (monte-carlo trials cesaro-test))))
    (define (cesaro-test)
     (= (gcd (rand) (rand)) 1))
    (define (monte-carlo trials experiment)
     (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1)
                   (+ trials-passed 1)))
            (else (iter (- trials-remaining 1)
                        trials-passed))))
     (iter trials 0))
    #+END_SRC

    Now let us try the same computation using rand-update directly
    rather than rand, the way we would be forced to proceed if we did
    not use assignment to model local state:

    #+BEGIN_SRC scheme
    (define (estimate-pi trials)
     (sqrt (/ 6 (random-gcd-test trials random-init))))
    (define (random-gcd-test trials initial-x)
     (define (iter trials-remaining trials-passed x)
      (let ((x1 (rand-update x)))
       (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trails-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trails-remaining 1)
                     trials-passed
                     x2))))))
     (iter trials 0 initial-x)) 
    #+END_SRC

    While the program is still simple, it betrays some painful
    breaches of modularity. In our first version of the program, using
    rand, we can express the Monte Carlo method directly as a general
    monte-carlo procedure that takes as an argument an arbitrary
    experiment procedure. In our second version of the program, with
    no local state for the random-number generator, random-gcd-test
    must explicitly manipulate the random numbers x1 and x2 and
    recycle x2 throguh the iterative loop as the new input to
    rand-update. This explicit handling of the random numbers
    intertwines the structure of accumulating test results with the
    fact that our particular experiment uses two random numbers,
    whereas other Monte Carlo experiments might use one random number
    or three. Even the top-level procedure estimate-pi has to be
    concerned with supplying an initial random number. The fact that
    the random-number generator's insides are leaking out into other
    parts of the program makes it difficult for us to isolate the
    Monte Carlo idea so that it can be applied to other tasks. In the
    first version of the program, assignment encapsulates the state of
    the random-number generator within the rand procedure, so that the
    details of random-number generation remain independent of the rest
    of the program. 

    The general phenomenon illustrated by the Monte Carlo example is
    this: From the point of view of one part of a complex process, the
    other parts appear to change with time. They have hidden
    time-varying local state. If we wish to write computer programs
    whose structure reflects this decomposition, we make computational
    objects (such as bank accounts and random-number generators) whose
    behavior changes with time. We model state with local state
    variables, and we model the changes of state with assignments to
    those variables.

    It is tempting to conclude this discussion by saying that, by
    introducing assignment and the technique of hiding state in local
    variables, we are able to structure systems in a more modular
    fashion than if all state had to be manipulated explicitly, by
    passing additional parameters. Unfortunately, as we shall see, the
    story is not so simple.

    - Exercise 3.5. _Monte Carlo integration_ is a method of
      estimating definite integrals by means of Monte Carlo
      simulation. Consider computing the area of a region of space
      described by a predicate P(x, y) that is true for points (x, y)
      in the region and false for points not in the region. For
      example, the region contained within a circle of radius 3
      centered at (5, 7) is described by the predicate that tests
      whether (x - 5)^2 + (y-7)^2 <= 3^2. To estimate the area of the
      region described by such a predicate, begin by choosing a
      rectangle that contains the region. For example, a rectangle
      with diagonally opposite corners at (2, 4) and (8, 10) contains
      the circle above. The desired integral is the area of that
      portion of the rectangle that lies in the region. We can
      estimate the integral by picking, at random, points (x, y) that
      lie in the rectangle, and testing P(x, y) for each point to
      determine whether the point lies in the region. If we try this
      with many points, then the fraction of points that fall in the
      region should give an estimate of the proportion of the
      rectangle that lies in the region. If we try this with many
      points, then the fraction of points that fall in the region
      should give an estimate of the proportion of the rectangle that
      lies in the region. Hence, multiplying this fraction by the area
      of the entire rectangle should produce an estimate of the
      integral.

      Implement Monte Carlo integration as a procedure
      estimate-integral that takes as arguments a predicate P, upper
      and lower bounds x1, x2, y1, and y2 for the rectangle, and the
      number of trials to perform in order to produce the
      estimate. Your procedure should use the same monte-carlo
      procedure that was used above to estimate pi. Use your
      estimate-integral to produce an estimate4 of pi by measuring the
      area of a unit circle.

      You will find it useful to have a procedure that returns a
      number chosen at random from a given range. The following
      random-in-range procedure implements this in terms of the random
      procedure used in section 1.2.6, which returns a nonnegative
      number less than its input.

      #+BEGIN_SRC scheme
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))
      #+END_SRC

      #+BEGIN_SRC scheme
      (define (estimate-pi ntrials)
       (estimate-integral (lambda (x y) (<= (+ (square x)
                                               (square y))
                                             1))
                          -1.0 1.0 -1.0 1.0 ntrials))
      (define (estimate-integral P x1 x2 y1 y2 ntrials)
       (* (monte-carlo ntrials
                    (lambda ()
                     (let ((p-x (random-in-range x1 x2))
                           (p-y (random-in-range y1 y2)))
                      (P p-x p-y))))
          (* (- x2 x1) (- y2 y1))))
      (define (random-in-range low high)
       (let ((range (- high low)))
        (+ low (random range))))

      (define (monte-carlo trials experiment)
       (define (iter trials-remaining trials-passed)
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((experiment)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)))
              (else (iter (- trials-remaining 1)
                          trials-passed))))
       (iter trials 0))
      #+END_SRC

    - Exercise 3.6 It is useful to be able to reset a random-number
      generator to produce a sequence starting from a given
      value. Design a new rand procedure that is called with an
      argument that is either the symbol generate or the symbol reset
      and behaves as follows: (rand 'generate) produces a new random
      number; ((rand 'reset) <new-value>) resets the internal state
      variable to the designated <new-value>. Thus, by resetting the
      state, one can generate repeatable sequences. These are very
      handy to have when testing and debugging programs that use
      random numbers.

      #+BEGIN_SRC scheme
      (define SEED 0)
      (define (rand param)
       (let ((last-value SEED))
        (cond ((eq? param 'generate)
               (let ((val (rand-update last-value)))
                (set! last-value val)
                val))
              (else
               (lambda (new-value)
                (set! last-value new-value)
                new-value)))))
      #+END_SRC

*** 3.1.3 The Costs of Introducing Assignment

    As we have seen, the set! operation enables us to model objects
    that have local state. However, this advantage comes at a
    price. Our programming language can no longer be interpreted in
    terms of the substitution model of procedure application that we
    introduced in Section 1.1.5. Moreover, no simple model with "nice"
    mathematical properties can be an adequate framework for dealing
    with objects and assignment in programming languages. 

    So long as we do not use assignments, two evaluations of the same
    procedure with the same arguments will produce the same result, so
    that procedures can be viewed as computing mathematical
    functions. Programming without any use of assignments, as we did
    throughout the first two chapters of this book, is accordingly
    known as _functional programming_. 

    To understand how assignment complicates matters, consider a
    simplified version of the make-withdraw procedure of Section 3.1.1
    that does not bother to check for an insufficient amount:

    #+BEGIN_SRC scheme
    (define (make-simplified-withdraw balance)
     (lambda (amount)
      (set! balance (- balance amount))
      balance))
    (define W (make-simplified-withdraw 25))
    (W 20)
    5
    (W 10)
    -5
    #+END_SRC

    Compare this procedure with the following make-decrementer
    procedure, which does not use set!:

    #+BEGIN_SRC scheme
    (define (make-decrementer balance)
     (lambda (amount)
      (- balance amount)))
    #+END_SRC

    make-decrementer returns a procedure that subtracts its input from
    a designated amount balance, but there is no accumulated effect
    over successive calls, as with make-simplified-withdraw:

    #+BEGIN_SRC scheme
    (define D (make-decrementer 25))
    (D 20)
    5
    (D 10)
    15
    #+END_SRC

    We can use the substitution model to explain how make-decrementer
    works. For instance, let us analyze the evaluation of the
    expression

    #+BEGIN_SRC scheme
    ((make-decrementer 25) 20)
    #+END_SRC

    We first simplify the operator of the combination by substituting
    25 for balance in the body of make-decrementer. This reduces the
    expression to

    #+BEGIN_SRC scheme
    ((lambda (amount) (- 25 amount)) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (- 25 20)
    #+END_SRC
    
    The final answer is 5. Observe, however, what happens if we
    attempt a similar substitution analysis with
    make-simplified-withdraw:

    #+BEGIN_SRC scheme
    ((make-simplified-withdraw 25) 20)
    #+END_SRC

    We first simplify the operator by substituting 25 for balance in
    the body of make-simplified-withdraw. This reduces the expression
    to
    
    #+BEGIN_SRC scheme
    ((lambda (amount) (set! balance (- 25 amount)) 25) 20)
    #+END_SRC

    Now we apply the operator by substituting 20 for amount in the
    body of the lambda expression:

    #+BEGIN_SRC scheme
    (set! balance (- 25 20)) 25
    #+END_SRC

    If we adhered to the substitution model, we would have to say that
    the meaning of the procedure application is to first set balance
    to 5 and then return 25 as the value of the expression. This gets
    the wrong answer. In order to get the correct answer, we would
    have to somehow distinguish the first occurrence of balance
    (before the effect of the set!) from the second occurrence of
    balance (after the effect of the set!), and the substitution model
    cannot do this.

    The trouble here is that substitution is based ultimately on the
    notion that the symbols in our language are essentially names for
    values. But as soon as we introduce set! and the idea that the
    value of a variable can change, a variable can no longer be simply
    a name. Now a variable somehow refers to a place where a value can
    be stored, and the value stored at this place can change. In
    section 3.2 we will see how environments play this role of "place"
    in our computational model.

**** Sameness and change

     The issue surfacing here is more profound than the mere breakdown
     of a particular model of computation. As soon as we introduce
     change into our computational models, many notions that were
     previously straightforward become problematical. Consider the
     concept of two things being "the same."

     Suppose we call make-decrementer twice with the same argument to
     create two procedures:

     #+BEGIN_SRC scheme
     (define D1 (make-decrementer 25))
     (define D2 (make-decrementer 25))
     #+END_SRC

     Are D1 and D2 the same? An acceptable answer is yes, because D1
     and D2 have the same computational behavior -- each is a
     procedure that subtracts its input from 25. In fact, D1 could be
     substituted for D2 in any computation without changing the
     result.
     
     Contrast this with making two calls to make-simplified-withdraw:

     #+BEGIN_SRC scheme
     (define W1 (make-simplified-withdraw 25))
     (define W2 (make-simplified-withdraw 25))
     #+END_SRC

     Are W1 and W2 the same? Surely not, because calls to W1 and W2
     have distinct effects, as shown by the following sequence of
     interactions:

     #+BEGIN_SRC scheme
     (W1 20)
     5
     (W1 20)
     -15
     (W2 20)
     5
     #+END_SRC

     Even though W1 and W2 are "equal" in the sense that they are both
     created by evaluating the same expression,
     (make-simplified-withdraw 25), it is not true that W1 could be
     substituted for W2 in any expression without changing the result
     of evaluating the expression. 

     A language that supports the concept that "equals can be
     substituted for equals" in an expression without changing the
     value of the expression is said to be _referentially
     transparent._ Referential transparency is violated when we
     include set! in our computer language. This makes it tricky to
     determine when we can simplify expressions by substituting
     equivalent expressions. Consequently, reasoning about programs
     that use assignment becomes drastically more difficult.

     Once we forgo referential transparency, the notion of what it
     means for computational objects to be "the same" becomes
     difficult to capture in a formal way. Indeed, the meaning of
     "same" in the real world that our programs model is hardly clear
     in itself. In general, we can determine that two apparently
     identical objects are indeed "the same one" only by modifying one
     object and then observing whether the other object has changed in
     the same way. But how can we tell if an object has "changed"
     other than by observing the "same" object twice and seeing
     whether some property of the object differs from one observation
     to the next? Thus, we cannot determine "change" without some _a
     priori_ notion of "sameness," and we cannot determine sameness
     without observing the effects of change.

     As an example of how this issue arises in programming, consider
     the situation where Peter and Paul have a bank account with $100
     in it. There is a substantial difference between modeling this as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc (make-account 100))
     #+END_SRC

     and modeling it as

     #+BEGIN_SRC scheme
     (define peter-acc (make-account 100))
     (define paul-acc peter-acc)
     #+END_SRC

     In the first situation, the two bank accounts are
     distinct. Transactions made by Peter will not affect Paul's
     account, and vice versa. In the second situation, however, we
     have defined paul-acc to be _the same thing_ as peter-acc. In
     effect, Peter and Paul now have a joint bank account, and if
     Peter makes a withdrawal from peter-acc Paul will observe less
     money in paul-acc. In effect, Peter and Paul now have a joint
     bank account, and if Peter makes a withdrawal from peter-acc Paul
     will observe less money in paul-acc. These two similar but
     distinct situations can cause confusion in building computational
     models. With the shared account, in particular, it can be
     especially confusing that there is one object (the bank account)
     that has two different names (peter-acc and paul-acc); if we are
     searching for all the places in our program where paul-acc can be
     changed, we must remember to look also at things that change
     peter-acc.

     With reference to the above remarks on "sameness" and "change,"
     observe that if Peter and Paul could only examine their bank
     balances, and could not perform operations that changed the
     balance, then the issue of whether the two accounts are distinct
     would be moot. In general, so long as we never modify data
     objects, we can regard a compound data object to be precisely the
     totality of its pieces. For example, a rational number is
     determined by giving its numerator and its denominator. But this
     view is no longer valid in the presence of change, where a
     compound data object has an "identity" that is something
     different from the pieces of which it is composed. A bank account
     is still "the same" bank account even if we change the balance by
     making a withdrawal; conversely, we could have two different bank
     accounts with the same state information. This complication is a
     consequence, not of our programming language, but of our
     perception of a bank account as an object. We do not, for
     example, ordinarily regard a rational number as a changeable
     object with identity, such that we could change the numerator and
     still have "the same" rational number.

**** Pitfalls of imperative programming

     In contrast to functional programming, programming that makes
     extensive use of assignment is known as _imperative programming._
     In addition to raising complications about computational models,
     programs written in imperative style are susceptible to bugs that
     cannot occur in functional programs. For example, recall the
     iterative factorial program from section 1.2.1:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product) (+ counter 1))))
      (iter 1 1))
     #+END_SRC

     Instead of passing arguments in the internal iterative loop, we
     could adopt a more imperative style by using explicit assignment
     to update the values of the variables product and counter:

     #+BEGIN_SRC scheme
     (define (factorial n)
      (let ((product 1)
            (counter 1))
       (define (iter)
        (if (> counter n)
            product
            (begin (set! product (* counter product))
                   (set! counter (+ counter 1))
                   (iter))))
       (iter)))
     #+END_SRC

     This does not change the results produced by the program, but it
     does introduce a subtle trap. How do we decide the order of the
     assignments? As it happens, the program is correct as
     written. But writing the assignments in the opposite order

     #+BEGIN_SRC scheme
     (set! counter (+ counter 1))
     (set! product (* counter product))
     #+END_SRC

     would have produced a different, incorrect result. In general,
     programming with assignment forces us to carefully consider the
     relative orders of the assignments to make sure that each
     statement is using the correct version of the variables that have
     been changed. This issue simply does not arise in functional
     programs.

     The complexity of imperative programs becomes even worse if we
     consider applications in which several processes execute
     concurrently. We will return to this in section 3.4. First,
     however, we will address the issue of providing a computational
     model for expressions that involve assignment, and explore the
     uses of objects with local state in designing simulations.

     - Exercise 3.7: Consider the bank account objects created by
       make-account, with the password modification described in
       Exercise 3.3. Suppose that our banking system requires the
       ability to make joint accounts. Define a procedure make-joint
       that accomplishes this. make-joint should take three
       arguments. The first is a password-protected account. The
       second argument must match the password with which the account
       was defined in order for the make-joint operation to
       proceed. The third argument is a new password. make-joint is to
       create an additional access to the original account using the
       new password. For example, if peter-acc is a bank account with
       password open-sesame, then

       #+BEGIN_SRC scheme
       (define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))
       #+END_SRC
       
       will allow one to make transactions on peter-acc using the name
       paul-acc and the password rosebud. You may wish to modify your
       solution in Exercise 3.3 to accommodate this new feature.

       #+BEGIN_SRC scheme
       (define (make-joint account old-pass new-pass)
        (define (joint-account pass m)
         (if (eq? new-pass pass)
             (account old-pass m)
             (account old-pass 'incorrect-password)))
        (if (account old-pass 'password-matches?)
            joint-account
            "Incorrect password"))

       (define (call-the-cops)
        (display "Calling the cops!"))

       (define (make-account password balance)
        (let ((incorrect-password-counter 0))
         (define (password-matches? pass)
          (if (eq? password pass)
              true
              (begin (handle-incorrect-password)
                     false)))
         (define (withdraw amount)
          (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds"))
         (define (deposit amount)
          (begin
           (set! balance (+ balance amount))
            balance))
         (define (invalid-password amount)
          "Invalid password")
         (define (handle-incorrect-password)
          (cond
           ((>= incorrect-password-counter 7)
            (begin
             (call-the-cops)
             invalid-password))
           (else
            (begin
             (set! incorrect-password-counter (+ 1 incorrect-password-counter))
             invalid-password))))
         (define (dispatch m)
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                ((eq? m 'password-matches?) password-matches?)
                ((eq? m 'incorrect-password) invalid-password)
                (else (error "Unknown request: MAKE-ACCOUNT"
                             m))))
         (define (dispatch-check-password password-attempt m)
          (cond ((eq? m 'password-matches?)
                 (password-matches? password-attempt))
                ((eq? m 'incorrect-password)
                 (begin (handle-incorrect-password)
                        invalid-password))
                ((eq? password-attempt password)
                 (begin
                  (set! incorrect-password-counter 0)
                  (dispatch m)))
                (else
                 (handle-incorrect-password))))
         dispatch-check-password))
       #+END_SRC

     - Exercise 3.8: When we defined the evaluation model in Section
       1.1.3, we said that the first step in evaluating an expression
       is to evaluate its subexpressions. But we never specified the
       order in which the subexpressions should be evaluated
       (e.g. left to right or right to left). When we introduce
       assignment, the order in which the arguments to a procedure are
       evaluated can make a difference to the result. Define a simple
       procedure f such that evaluating

       #+BEGIN_SRC scheme
       (+ (f 0) (f 1))
       #+END_SRC

       will return 0 if the arguments to + are evaluated from left to
       right but will return 1 if the arguments are evaluated from
       right to left.

       #+BEGIN_SRC scheme
       (define f 
        (let ((zero-found false))
         (lambda (x)
          (cond 
           (zero-found 0)
           ((= 0 x) 
            (begin (set! zero-found true)
                   x))
           (else x)))))
       #+END_SRC

       It turns out MIT scheme is right-left for + at least. It is
       left-to-right for or.

** 3.2 The Environment Model of Evaluation

   When we introduced compound procedures in Chapter 1, we used the
   substitution model of evaluation (Section 1.1.5) to define what is
   meant by applying a procedure to arguments: 

   * To apply a compound procedure to arguments, evaluate the body of
     the procedure with each formal parameter replaced by the
     corresponding argument.

     
   Once we admit assignment into our programming language, such a
   definition is no longer adequate. In particular, Section 3.1.3
   argued that, in the presence of assignment, a variable can no
   longer be considered to be merely the name for a value. Rather, a
   variable must somehow designate a "place" in which values can be
   stored. In our new model of evaluation, these places will be
   maintained in structures called _environments_. 

   An environment is a sequence of _frames_. Each frame is a table
   (possibly empty) of _bindings_, which associate variable names with
   their corresponding values. (A single frame may contain at most one
   binding for any variable.) Each frame also has a pointer to its
   _enclosing environment_, unless, for the purposes of discussion,
   the frame is considered to be _global_. The _value of a variable_
   with respect to an environment is the value given by the binding of
   the variable in the first frame in the environment that contains a
   binding for that variable. If no frame in the sequence specifies a
   binding for the variable, then the variable is said to be _unbound_
   in the environment. 

   Figure 3.1 shows a simple environment structure consisting of three
   frames, labeled I, II, and III. In the diagram, A, B, C, and D are
   pointers to environments. C and D point to the same
   environment. The variables z and x are bound in frame II, while y
   and x are bound in frame I. The value of x in environment D
   is 3. The value of x with respect to environment B is also 3. This
   is determined as follows: We examine the first frame in the
   sequence (frame III) and do not find a binding for x, so we proceed
   to the enclosing environment D and find the binding in frame I. On
   the other hand, the value of x in environment A is 7, because the
   first frame in the sequence (Frame II) contains a binding of x
   to 7. With respect to environment A, the binding of x to 7 in frame
   II is said to _shadow_ the binding of x to 3 in frame I.

   The environment is crucial to the evaluation process, because it
   determines the context in which an expression should be
   evaluated. Indeed, one could say that expressions in a programming
   language do not, in themselves, have any meaning. Rather, an
   expression acquires a meaning only with respect to some environment
   in which it is evaluated. Even the interpretation of an expression
   as straightforward as (+ 1 1) depends on an understanding that one
   is operating in a context in which + is the symbol for
   addition. Thus, in our model of evaluation we will always speak of
   evaluating an expression with respect to some environment. To
   describe interactions with the interpreter, we will suppose that
   there is a global environment, consisting of a single frame (with
   no enclosing environment) that includes values for the symbols
   associated with the primitive procedures. For example, the idea
   that + is the symbol for addition is captured by saying that the
   symbol + is bound in the global environment to the primitive
   addition procedure. 

*** 3.2.1 The Rules for Evaluation

    The overall specification of how the interpreter evaluates a
    combination remains the same as when we first introduced it in
    section 1.1.3:

    * To evaluate a combination:

      1. Evaluate the subexpressions of the combination.

      2. Apply the value of the operator subexpression to the values
         of the operand subexpressions.

	 
    The environment model of evaluation replaces the substitution
    model in specifying what it means to apply a compound procedure to
    arguments. 
    
    In the environment model of evaluation, a procedure is always a
    pair consisting of some code and a pointer to an
    environment. Procedures are created in one way only: by evaluating
    a lambda-expression. This produces a procedure whose code is
    obtained from the text of the lambda-expression and whose
    environment is the environment in which the lambda-expression was
    evaluated to produce the procedure. For example, consider the
    procedure definition

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    #+END_SRC

    evaluated in the global environment. The procedure definition
    syntax is just syntactic sugar for an underlying implicit
    lambda-expression. It would have been equivalent to have used

    #+BEGIN_SRC scheme
    (define square
     (lambda (x) (* x x)))
    #+END_SRC

    which evaluates (lambda (x) (* x x)) and binds square to the
    resulting value, all in the global environment.

    Figure 3.2 shows the result of evaluating this define
    expression. The procedure object is a pair whose code specifies
    that the procedure has one formal parameter, namely x, and a
    procedure body (* x x). The environment part of the procedure is a
    pointer to the global environment, since that is the environment
    in which the lambda-expression was evaluated to produce the
    procedure. A new binding, which associates the procedure object
    with the symbol square, has been added to the global frame. In
    general, define creates definitions by adding bindings to frames.

    Now that we have seen how procedures are created, we can describe
    how procedures are applied. The environment model specifies: To
    apply a procedure to arguments, create a new environment
    containing a frame that binds the parameters to the values of the
    arguments. The enclosing environment in this frame is the
    environment specified by the procedure. Now, within this new
    environment, evaluate the procedure body. 

    To show how this rule is followed, Figure 3.3 illustrates the
    environment structure created by evaluating the expression
    (square 5) in the global environment, where square is the
    procedure generated in figure 3.2. Applying the procedure results
    in the creation of a new environment, labeled E1 in the figure,
    that begins with a frame in which x, the formal parameter for the
    procedure, is bound to the argument 5. The pointer leading upward
    from this frame shows that the frame's enclosing environment is
    the global environment. The global environment is chosen here,
    because this is the environment that is indicated as part of the
    square procedure object. Within E1, we evaluate the body of the
    procedure, (* x x). Since the value of x in E1 is 5, the result is
    (* 5 5), or 25. 

    The environment model of procedure application can be summarized
    by two rules:


    * A procedure object is applied to a set of arguments by
      constructing a frame, binding the formal parameters of the
      procedure to the arguments of the call, and then evaluating the
      body of the procedure in the context of the new environment
      constructed. The new frame has as its enclosing environment the
      environment part of the procedure object being applied.
    * A procedure is created by evaluating a lambda-expression
      relative to a given environment. The resulting procedure object
      is a pair consisting of the text with the lambda-expression and
      a pointer to the environment in which the procedure was created.


    We also specify that defining a symbol using define creates a
    binding in the current environment frame and assigns to the symbol
    the indicated value. Finally, we specify the behavior of set!, the
    operation that forced us to introduce the environment model in the
    first place. Evaluating the expression (set! <variable> <value>)
    in some environment locates the binding of the variable in the
    environment and changes that binding to indicate the new
    value. That is, one finds the first frame in the environment that
    contains a binding for the variable and modifies that frame. If
    the variable is unbound in the environment, then set! signals an
    error. 

    These evaluation rules, though considerably more complex than the
    substitution model, are still reasonably
    straightforward. Moreover, the evaluation model, though abstract,
    provides a correct description of how the interpreter evaluates
    expressions. In chapter 4 we shall see how this model can serve as
    a blueprint for implementing a working interpreter. The following
    sections elaborate the details of the model by analyzing some
    illustrative programs.

*** 3.2.2 Applying Simple Procedures

    When we introduced the substitution model in Section 1.1.5 we
    showed how the combination (f 5) evaluates to 136, given the
    following procedure definitions:

    #+BEGIN_SRC scheme
    (define (square x)
     (* x x))
    (define (sum-of-squares x y)
     (+ (square x) (square y)))
    (define (f a)
     (sum-of-squares (+ a 1) (* a 2)))
    #+END_SRC

    We can analyze the same example using the environment
    model. Figure 3.4 shows the three procedure objects created by
    evaluating the definitions of f, square, and sum-of-squares in the
    global environment. Each procedure object consists of some code,
    together with a pointer to the global environment. 

    In figure 3.5 we see the environment structure created by
    evaluating the expression (f 5). The call to f creates a new
    environment E1 beginning with a frame in which a, the formal
    parameter of f, is bound to the argument 5. In E1, we evaluate the
    body of f:

    #+BEGIN_SRC scheme
    (sum-of-squares (+ a 1) (* a 2))
    #+END_SRC

    To evaluate this combination, we first evaluate the
    subexpressions. The first subexpression, sum-of-squares, has a
    value that is a procedure object. (Notice how this value is found:
    We first look into the first frame of E1, which contains no
    binding for sum-of-squares. Then we proceed to the enclosing
    environment, i.e. the global environment, and find the binding
    shown in figure 3.4.) The other two subexpressions are evaluated
    by applying the primitive operations + and * to evaluate the two
    combinations (+ a 1) and (* a 2) to obtain 6 and 10, respectively.

    Now we apply the procedure object sum-of-squares to the arguments
    6 and 10. This results in a new environment E2 in which the formal
    parameters x and y are bound to the arguments. Within E2 we
    evaluate the combination (+ (square x) (square y)). This leads us
    to evaluate (square x), where square is found in the global frame
    and x is 6. Once again, we set up a new environment, E3, in which
    x is bound to 6, and within this we evaluate the body of square,
    which is (* x x). Also as part of applying sum-of-squares, we must
    evaluate the subexpression (square 6), where y is 10. This second
    call to square creates another environment, E4, in which x, the
    formal parameter of square, is bound to 10. And within E4 we must
    evaluate (* x x).

    The important point to observe is that each call to square creates
    a new environment containing a binding for x. We can see here how
    the different frames serve to keep separate the different local
    variables all named x. Notice that each frame created by square
    points to the global environment, since this is the environment
    indicated by the square procedure object.

    After the subexpressions are evaluated, the results are
    returned. The values generated by the two calls to square are
    added by sum-of-squares, and this result is returned by f. Since
    our focus here is on the environment structures, we will not dwell
    on how these returned values are passed from call to call;
    however, this is also an important aspect of the evaluation
    process, and we will return to it in detail in chapter 5. 

    - Exercise 3.9: In Section 1.2.1 we used the substitution model
      to analyze two procedures for computing factorials, a recursive
      version

      #+BEGIN_SRC scheme
      (define (factorial n)
       (if (= n 1) 1 (* n (factorial (- n 1)))))
      #+END_SRC

      and an iterative version

      #+BEGIN_SRC scheme
      (define (factorial n) (fact-iter 1 1 n))
      (define (fact-iter product counter max-count)
       (if (> counter max-count)
           product
           (fact-iter (* counter product)
                      (+ counter 1)
                      max-count)))
      #+END_SRC

      Show the environment structures created by evaluating
      (factorial 6) using each version of the factorial procedure.

*** 3.2.3 Frames as the Repository of Local State

    We can turn to the environment model to see how procedures and
    assignment can be used to represent objects with local state. As
    an example, consider the "withdrawal processor" from Section 3.1.1
    created by calling the procedure

    #+BEGIN_SRC scheme
    (define (make-withdraw balance)
     (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
    #+END_SRC

    Let us describe the evaluation of

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    followed by

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    Figure 3.6 shows the result of defining the make-withdraw
    procedure in the global environment. This produces a procedure
    object that contains a pointer to the global environment. So far,
    this is no different from the examples we have already seen,
    except that the body of the procedure is itself a
    lambda-expression.

    The interesting part of the computation happens when we apply the
    procedure make-withdraw to an argument:

    #+BEGIN_SRC scheme
    (define W1 (make-withdraw 100))
    #+END_SRC

    We begin, as usual, by setting up an environment E1 in which the
    formal parameter balance is bound to the argument 100. Within this
    environment, we evaluate the body of make-withdraw, namely the
    lambda-expression. This constructs a new procedure object, whose
    code is as specified by the lambda and whose environment is E1,
    the environment in which the lambda was evaluated to produce the
    procedure. The resulting procedure object is the value returned by
    the call to make-withdraw. This is bound to W1 in the global
    environment, since the define itself is being evaluated in the
    global environment. Figure 3.7 shows the resulting environment
    structure.

    Now we can analyze what happens when W1 is applied to an argument:

    #+BEGIN_SRC scheme
    (W1 50)
    50
    #+END_SRC

    We begin by constructing a frame in which amount, the formal
    parameter of W1, is bound to the argument 50. The crucial point to
    observe is that this frame has as its enclosing environment not
    the global environment, but rather the environment E1, because
    this is the environment that is specified by the W1 procedure
    object. Within this new environment, we evaluate the body of the
    procedure:

    #+BEGIN_SRC scheme
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")
    #+END_SRC

    The resulting environment structure is shown in Figure 3.8. The
    expression being evaluated references both amount and
    balance. amount will be found in the first frame in the
    environment, while balance will be found by following the
    enclosing-environment pointer to E1.

    When the set! is executed, the binding of balance in E1 is
    changed. At the completion of the call to W1, balance is 50, and
    the frame that contains balance is still pointed to by the
    procedure object W1. The frame that binds amount (in which we
    executed the code that changed balance) is no longer relevant,
    since the procedure call that constructed it has terminated, and
    there are no pointers to that frame from other parts of the
    environment. The next time W1 is called, this will build a new
    frame that binds amount and whose enclosing environment is E1. We
    see that E1 serves as the "place" that holds the local state
    variable for the procedure object W1. Figure 3.9 shows the
    situation after the call to W1. 

    Observe what happens when we create a second "withdraw" object by
    making another call to make-withdraw:

    #+BEGIN_SRC scheme
    (define W2 (make-withdraw 100))
    #+END_SRC

    This produces the environment structure of Figure 3.10, which
    shows that W2 is a procedure object, that is, a pair with some
    code and an environment. The environment E2 for W2 was created by
    the call to make-withdraw. It contains a frame with its own local
    binding for balance. On the other hand, W1 and W2 have the same
    code: the code specified by the lambda-expression in the body of
    make-withdraw. We see here why W1 and W2 behave as independent
    objects. Calls to W1 reference the state variable balance stored
    in E1, whereas calls to W2 reference the balance stored in
    E2. Thus, changes to the local state of one object do not affect
    the other object.

    - Exercise 3.10: In the make-withdraw procedure, the local
      variable balance is created as a parameter of make-withdraw. We
      could also create the local state variable explicitly, using
      let, as follows:

      #+BEGIN_SRC scheme
      (define (make-withdraw initial-amount)
       (let ((balance initial-amount))
        (lambda (amount)
         (if (>= balance amount)
             (begin (set! balance (- balance amount))
                    balance)
             "Insufficient funds"))))
      #+END_SRC
      Recall from Section 1.3.2 that let is simply syntactic sugar for
      a procedure call:

      #+BEGIN_SRC scheme
      (let ((<var> <exp>)) <body>)
      #+END_SRC

      is interpreted as an alternate syntax for
      
      #+BEGIN_SRC scheme
      ((lambda (<var>) <body>) <exp>)
      #+END_SRC

      Use the environment model to analyze this alternate version of
      make-withdraw, drawing figures like the ones above to illustrate
      the interactions

      #+BEGIN_SRC scheme
      (define W1 (make-withdraw 100))
      (W1 50)
      (define W2 (make-withdraw 100))
      #+END_SRC

      Show that the two versions of make-withdraw create objects with
      the same behavior. How do the environment structures differ for
      the two versions?

      In the end, the frame holding the balance has the exact same
      value. The only difference in the environment structures is that
      an extra (and mostly unused) frame is created before the final
      frame that holds the balance. 

*** 3.2.4. Internal Definitions
    Section 1.1.8 introduced the idea that procedures can have
    internal definitions, thus leading to a block structure as in the
    following procedure to compute square roots:

    #+BEGIN_SRC scheme
    (define (sqrt x)
     (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))
     (define (improve guess)
      (average guess (/ x guess)))
     (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
     (sqrt-iter 1.0))
    #+END_SRC

    Now we can use the environment model to see why these internal
    definitions behave as desired. Figure 3.11 shows the point in the
    evaluation of the expression (sqrt 2) where the internal procedure
    good-enough? has been called for the first time with guess equal
    to 1. 

    Observe the structure of the environment. sqrt is a symbol in the
    global environment that is bound to a procedure object whose
    associated environment is the global environment. When sqrt was
    called, a new environment E1 was formed, subordinate to the global
    environment, in which the parameter x is bound to 2. The body of
    sqrt was then evaluated in E1. Since the first expression in the
    body of sqrt is

    #+BEGIN_SRC scheme
    (define (good-enough? guess)
     (< (abs (- (square guess) x)) 0.001))
    #+END_SRC

    evaluating this expression defined the procedure good-enough? in
    the environment E1. To be more precise, the symbol good-enough?
    was added to the first frame of E1, bound to a procedure object
    whose associated environment is E1. Similarly, improve and
    sqrt-iter were defined as procedures in E1. For conciseness,
    figure 3.11 shows only the procedure object for good-enough?.

    After the local procedures were defined, the expression (sqrt-iter
    1.0) was evaluated, still in the environment E1. So the procedure
    object bound to sqrt-iter in E1 was called with 1 as an
    argument. This created an environment E2 in which guess, the
    parameter of sqrt-iter, is bound to 1. sqrt-iter in turn called
    good-enough? with the value of guess (from E2) as the argument
    for good-enough?. This set up another environment, E3, in which
    guess (the parameter of good-enough?) is bound to 1. Although
    sqrt-iter and good-enough? both have a parameter named guess,
    these are two distinct local variables located in different
    frames. Also, E2 and E3 both have E1 as their enclosing
    environment, because the sqrt-iter and good-enough? procesures
    both have E1 as their environment part. One consequence of this is
    that the symbol x that appears in the body of good-enough? will
    reference the binding of x that appears in E1, namely the value of
    x with which the original sqrt procedure was called.

    The environment model thus explains the two key properties that
    make local procedure definitions a useful technique for
    modularizing programs:

    * The names of the local procedures do not interfere with names
      external to the enclosing procedure, because the local procedure
      names will be bound in the frame that the procedure creates when
      it is run, rather than being bound in the global environment.
    * The local procedures can access the arguments of the enclosing
      procedure, simply by using parameter names as free
      variables. This is because the body of the local procedure is
      evaluated in an environment that is subordinate to the
      evaluation environment for the enclosing procedure.

      

    - Exercise 3.11: In section 3.2.3 we saw how the environment model
      described the behavior of procedures with local state. Now we
      have seen how internal definitions work. A typical
      message-passing procedure contains both of these
      aspects. Consider the bank account procedure of Section 3.1.1:

      #+BEGIN_SRC scheme
      (define (make-account balance)
       (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Insufficient funds"))
       (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
       (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else
               (error "Unknown request: MAKE-ACCOUNT" 
                      m))))
       dispatch)
      #+END_SRC

      Show the environment structure generated by the sequence of
      interactions

      #+BEGIN_SRC scheme
      (define acc (make-account 50))
      ((acc 'deposit) 40)
      90
      ((acc 'withdraw) 60)
      30
      #+END_SRC

      Where is the local state for acc kept? Suppose we define another
      account

      #+BEGIN_SRC scheme
      (define acc2 (make-account 100))
      #+END_SRC
      
      How are the local states for the two accounts kept distinct?
      Which parts of the environment structure are shared between acc
      and acc2?
      
      The states are kept distinct because distinct frames are created
      for each account, acc points to a procedure whose environment
      pointer points to a different frame than acc2. Each state is
      kept around in a frame created by the make-account
      procedure. acc and acc2 only share their parent environment, the
      global environment. Also, in our current model, the body
      pointers for all the methods they define would be shared, just
      not the environments.

** 3.3 Modeling with Mutable Data
   Chapter 2 dealt with compound data as a means for constructing
   computational objects that have several parts, in order to model
   real-world objects that have several aspects. In that chapter we
   introduced the discipline of data abstraction, according to which
   data structures are specified in terms of constructors, which
   create data objects, and selectors, which access the parts of
   compound data objects. But we now know that there is another aspect
   of data that chapter 2 did not address. The desire to model systems
   composed of objects that have changing state leads us to the need
   to modify compound data objects, as well as to construct and select
   from them. In order to model compound objects with changing state,
   we will design data abstractions to include, in addition to
   selectors and constructors, operations called _mutators_, which
   modify data objects. For instance, modeling a banking system
   requires us to change account balances. Thus, a data structure for
   representing bank accounds might admit an operation

   #+BEGIN_SRC scheme
   (set-balance! <account> <new-value>)
   #+END_SRC

   that changes the balance of the designated account to the
   designated new value. Data objects for which mutators are defined
   are known as _mutable data objects_. 

   Chapter2 introduced pairs as a general-purpose "glue" for
   synthesizing compound data. We begin this section by defining basic
   mutators for pairs, so that pairs can serve as building blocks for
   constructing mutable data objects. These mutators greatly enhance
   the representational power of pairs, enabling us to build data
   structures other than the sequences and trees that we worked with
   in Section 2.2. We also present some examples of simulations in
   which complex systems are modeled as collections of objects with
   local state.

*** 3.3.1 Mutable List Structure
    The basic operations on pairs -- cons, car, and cdr -- can be sued
    to construct list structure and to select parts from list
    structure, but they are incapable of modifying list structure. The
    same is true of the list operations we have used so far, such as
    append and list, since these can be defined in terms of cons, car,
    and cdr. To modify list structures we need new operations.

    The primitive mutators for pairs are set-car! and
    set-cdr!. set-car! takes two arguments, the first of which must be
    a pair. It modifies this pair, replacing the car pointer by a
    pointer to the second argument of set-car!.

    As an example, suppose that x is bound to the list ((a b) c d) and
    y to the list (e f) as illustrated in Figure 3.12. Evaluating the
    expression (set-car! x y) modifies the pair to which x is bound,
    replacing its car by the value of y. The result of the operation
    is shown in figure 3.13. The structure x has been modified and
    would now be printed as ((e f) c d). The pairs representing the
    list (a b), identified by the pointer that was replaced, are now
    detached from the original structure.

    Compare figure 3.13 with figure 3.14, which illustrates the result
    of executing (define z (cons y (cdr x))) with x and y bound to the
    original lists of Figure 3.12. The variable z is now bound to a
    new pair created by the cons operation; the list to which x is
    bound is unchanged. The set-cdr! operation is similar to
    set-car!. The only difference is that the cdr pointer of the pair,
    rather than the car pointer, is replaced. The effect of executing
    (set-cdr! x y) on the lists of Figure 3.12 is shown in Figure
    3.15. Here the cdr pointer of x has been replaced by the pointer
    to (e f). Also, the list (c d), which used to be the cdr of x, is
    now detached from the structure. 

    cons builds new list structure by creating new pairs, while
    set-car! and set-cdr! modify existing pairs. Indeed, we could
    implement cons in terms of the two mutators, together with a
    procedure get-new-pair, which returns a new pair that is not part
    of any existing list structure. We obtain the new pair, set its
    car and cdr pointers to the designated objects, and return the new
    pair as the result of cons.
    
    #+BEGIN_SRC scheme
    (define (cons x y)
     (let ((new (get-new-pair)))
      (set-car! new x)
      (set-cdr! new y)
      new))
    #+END_SRC

    - Exercise 3.12: The following procedure for appending lists was
      introduced in Section 2.2.1:

      #+BEGIN_SRC scheme
      (define (append x y)
       (if (null? x)
           y
           (cons (car x) (append (cdr x) y))))
      #+END_SRC

      append forms a new list by successively consing the elements of
      x onto y. The procedure append! is similar to append, but it is
      a mutator rather than a constructor. It appends the lists by
      splicing them together, modifying the final pair of x so that
      its cdr is now y. (It is an error to call append! with an empty
      x.)

      #+BEGIN_SRC scheme
      (define (append! x y)
       (set-cdr! (last-pair x) y)
       x)
      #+END_SRC

      Here last-pair is a procedure that returns the last pair in its
      argument:

      #+BEGIN_SRC scheme
      (define (last-pair x)
       (if (null? (cdr x)) x (last-pair (cdr x))))
      #+END_SRC

      Consider the interaction

      #+BEGIN_SRC scheme
      (define x (list 'a 'b))
      (define y (list 'c 'd))
      (define z (append x y))
      z
      ; => (a b c d)
      (cdr x)
      <response>

      (define w (append! x y))
      w
      ; => (a b c d)
      (cdr x)
      <response>  
      #+END_SRC
    
      What are the missing <response>s? Draw box-and-pointer diagrams
      to explain your answer.

      #+BEGIN_SRC scheme
      (define x (list 'a 'b))
      (define y (list 'c 'd))
      (define z (append x y))
      z
      ; => (a b c d)
      (cdr x)
      (b)

      (define w (append! x y))
      w
      ; => (a b c d)
      (cdr x)
      (b c d) 
      #+END_SRC

    - Exercise 3.13: Consider the following make-cycle procedure,
      which uses the last-pair procedure defined in Exercise 3.12:

      #+BEGIN_SRC scheme
      (define (make-cycle x)
       (set-cdr! (last-pair x) x)
       x)
      #+END_SRC

      Draw a box-and-pointer diagram that shows the structure z
      created by

      #+BEGIN_SRC scheme
      (define z (make-cycle (list 'a 'b 'c)))
      #+END_SRC

      What happens if we try to compute (last-pair z)?

      If you try to evaluate last-pair z it hangs forever, because you
      removed null from the list. The list is an infinite loop and you
      never stop cdr-ing.

    - Exercise 3.14: The following procedure is quite useful, although
      obscure:

      #+BEGIN_SRC scheme
      (define (mystery x)
       (define (loop x y)
        (if (null? x)
            y
            (let ((temp (cdr x)))
             (set-cdr! x y)
             (loop temp x))))
       (loop x '()))
      #+END_SRC

      loop uses the "temporary" variable temp to hold the old value of
      the cdr of x, since the set-cdr! on the next line destroys the
      cdr. Explain what mystery does in general. Suppose v is defined
      by (define v (list 'a 'b 'c 'd)). Draw the box-and-pointer
      diagram that represents the list to which v is bound. Suppose
      that we now evaluate (define w (mystery v)). Draw
      box-and-pointer diagrams that show the structures v and w after
      evaluating this expression. What would be printed as the values
      of v and w?

      This is a procedure that reverses the list. It reverses its
      parameter, so that the return value has the reversed list. But
      the input parameter is turned into only its first element. If
      you alter the last pair of the output list, you will alter the
      input value.

       
**** Sharing and identity

     We mentioned in Section 3.13 the theoretical issues of "sameness"
     and "change" raised by the introduction of assignment. These
     issues arise in practice when individual pairs are _shared_ among
     different data objects. For example, consider the structure
     formed by

     #+BEGIN_SRC scheme
     (define x (list 'a 'b))
     (define z1 (cons x x))
     #+END_SRC

     As shown in Figure 3.16, is a pair whose car and cdr both point
     to the same pair x. This sharing of x by the car and cdr of z1 is
     a consequence of the straightforward way in which cons is
     implemented. In general, using cons to construct lists will
     result in an interlinked structure of pairs in which many
     individual pairs are shared by many different structures.

     In contrast to Figure 3.16, Figure 3.17 shows the structure
     created by

     #+BEGIN_SRC scheme
     (define z2 (cons (list 'a 'b) (list 'a 'b)))
     #+END_SRC

     In this structure, the pairs in the two (a b) lists are distinct,
     although the actual symbols are shared.

     When thought of as a list, z1 and z2 represent "the same" list,
     ((a b) a b). In general, sharing is completely undetectable if we
     operate on lists using only cons, car, and cdr. However, if we
     allow mutators on list structure, sharing becomes significant. As
     an example of the difference that sharing can make, consider the
     following procedure, which modifies the car of the structure to
     which it is applied:

     #+BEGIN_SRC scheme
     (define (set-to-wow! x) (set-car! (car x) 'wow) x)
     #+END_SRC

     Even though z1 and z2 are "the same" structure, applying
     set-to-wow! to them yields different results. With z1, altering
     the car also changes the cdr, because in z1 the car and the cdr
     are the same pair. With z2, the car and cdr are distinct, so
     set-to-wow! modifies only the car:

     #+BEGIN_SRC scheme
     z1
     ((a b) a b)
     (set-to-wow! z1)
     ((wow b) wow b)
     z2
     ((a b) a b)
     (set-to-wow! z2)
     ((wow b) a b)
     #+END_SRC
     
     One way to detect sharing in list structures is to use the
     predicate eq?, which we introduced in Section 2.3.1 as a way to
     test whether two symbols are equal. More generally, (eq? x y)
     tests whether x and y are the same object (that is, whether x and
     y are equal as pointers). Thus, with z1 and z2 as defined in
     Figure 3.16 and Figure 3.17, (eq? (car z1) (cdr z1)) is true and
     (eq? (car z2) (cdr z2)) is false.

     As will be seen in the following sections, we can exploit sharing
     to greatly extend the repertoire of data structures that can be
     represented by pairs. On the other hand, sharing can also be
     dangerous, since modifications made to structures will also
     affect other structures that happen to share the modified
     parts. The mutation operations set-car! and set-cdr! should be
     used with care; unless we have a good understanding of how our
     data objects are shared, mutation can have unanticipated results.

     - Exercise 3.15: Draw box-and-pointer diagrams to explain the
       effect of set-to-wow! on the structures z1 and z2 above.

     - Exercise 3.16: Ben Bitdiddle decides to write a procedure to
       count the number of pairs in any list structure. "It's easy,"
       he reasons. "The number of pairs in any structure is the number
       in the car plus the number in the cdr plus one more to count
       the current pair." So ben writes the following procedure:

       #+BEGIN_SRC scheme
       (define (count-pairs x)
        (if (not (pair? x))
            0
            (+ (count-pairs (car x))
               (count-pairs (cdr x))
               1)))
       #+END_SRC

       Show that this procedure is not correct. In particular, draw
       box-and-pointer diagrams representing list structures made up
       of exactly three pairs for w hich Ben's procedure would return
       3, 4, 7, and never at all.

       #+BEGIN_SRC scheme
       ;; 3
       (define x1 (list 'a 'b 'c))
       ;; 4
       (define b '(b))
       (define a (cons 'a b))
       (define x2 (cons a b))
       ;; 7
       (define a '(a))
       (define b (cons a a))
       (define x3 (cons b b))
       ;; never
       (define x4 (list 1 2 3))
       (set-cdr! (last-pair x4) x4)
       #+END_SRC

     - Exercise 3.17 Devise a correct version of the count-pairs
       procedure of Exercise 3.16 that returns the number of distinct
       pairs in any structure (Hint: Traverse the structure,
       maintaining an auxiliary data structure that is used to keep
       track of which pairs have already been counted.)

       #+BEGIN_SRC scheme
       (define (count-pairs pairs)
        (define (empty-pairset) '())
        (define (adjoin-to-pairs x pairset) (cons x pairset))
        (define (already-seen? x pairset)
         (if (null? pairset) 
             false
             (or (eq? x (car pairset)) (already-seen? x (cdr pairset)))))
        (define (union-already-seen set1 set2)
          (append set1 set2))

        (define (make-result n found-pairs) (list n found-pairs))
        (define (already-seen result) (cadr result))
        (define (npairs result) (car result))
        (define (add-pair results)
         (make-result (+ 1 (npairs results)) (already-seen results)))
        (define (join-results result1 result2)
         (list (+ (npairs result1)
                  (npairs result2))
               (union-already-seen 
                (already-seen result1)
                (already-seen result2))))

        (define (count-pairs-iter seen-pairs x)
         (cond 
          ((not (pair? x)) (make-result 0 seen-pairs))
          ((already-seen? x seen-pairs)
           (make-result 0 seen-pairs))
          (else
           (let ((new-pairs (adjoin-to-pairs x seen-pairs)))
            (let ((results-car (count-pairs-iter 
                                new-pairs
                                (car x))))
             (add-pair
              (join-results
                results-car
                (count-pairs-iter
                  (already-seen results-car)
                 (cdr x)))))))))
        (npairs (count-pairs-iter (empty-pairset) pairs)))
       #+END_SRC

     - Exercise 3.18: Write a procedure that examines a list and
       determines whether it contains a cycle, that is, whether a
       program that tried to find the end of the list by taking
       successive cdrs would go into an infinite loop. Exercise 3.13
       constructed such lists.

       #+BEGIN_SRC scheme
       (define (is-cycle? a-list)
        (define (empty-pairset) '())
        (define (adjoin-to-pairs x pairset) (cons x pairset))
        (define (already-seen? x pairset)
         (if (null? pairset) 
             false
             (or (eq? x (car pairset)) (already-seen? x (cdr pairset)))))
        (define (union-already-seen set1 set2)
          (append set1 set2))

        (define (is-cycle-iter found-nodes a-list)
         (cond
          ((null? a-list) false)
          ((already-seen? a-list found-nodes) true)
          (else (is-cycle-iter (adjoin-to-pairs a-list found-nodes)
                               (cdr a-list)))))
        (is-cycle-iter (empty-pairset) a-list))
       #+END_SRC

     - Redo Exercise 3.18 using an algorithm that takes only a
       constant amount of space. (This requires a very clever idea).

       What you could potentially do is destruct the list by setting
       cdrs as you go to known values; and if you ever hit a 'marked'
       node, you know that you found a cycle.

       #+BEGIN_SRC scheme
       (define (is-cycle2? a-list)
        (define HAS-BEEN-TOUCHED 'touched)
        (define (get-next-item a-list)
         (let ((saved (cdr a-list)))
          (set-cdr! a-list HAS-BEEN-TOUCHED)
          saved))
        (define (is-cycle-iter a-list)
         (cond
          ((null? a-list) false)
          ((eq? (cdr a-list) HAS-BEEN-TOUCHED)
           true)
          (else (is-cycle-iter (get-next-item a-list)))))
        (is-cycle-iter a-list))
       #+END_SRC

       This works without extra space but it destroys the list. So you
       need to copy the list if you want it afterwards, which is
       similar to having a O(n) space requirement except
       offloaded. You could save the old CDR by making the list a pair
       whose car is 'touched and whose cdr is the old cdr, but this
       involves creating O(n) pairs; you just store them in the data
       structure instead of in a parameter, so it is also O(n) space
       requirement effectively.

       The Floyd algorithm would be:

       (define (is-cycle-floyd? a-list)
        (define (get-n-cdrs-or-null n a-list)
         (cond
          ((null? a-list) '())
          ((= 0 n) a-list)
          (else (get-n-cdrs-or-null (- n 1) (cdr a-list)))))

        (define (hare-next a-list)
         (get-n-cdrs-or-null 2 a-list))

        (define (tortoise-next a-list)
         (get-n-cdrs-or-null 1 a-list))

        (define (is-cycle-floyd-iter hare tortoise)
         (let ((hareplace (hare-next hare))
               (tortoiseplace (tortoise-next tortoise)))
          (cond
           ((or (null? hareplace)
                (null? tortoiseplace))
            false)
           ((eq? hareplace tortoiseplace)
            true)
           (else (is-cycle-floyd-iter hareplace tortoiseplace)))))
        (is-cycle-floyd-iter a-list (hare-next a-list)))


**** Mutation is just assignment

     When we introduced compound data, we observed in Section 2.1.3
     that pairs can be represented purely in terms of procedures:

     #+BEGIN_SRC scheme
     (define (cons x y)
      (define (dispatch m)
       (cond ((eq? m 'car) x)
             ((eq? m 'cdr) y)
             (else (error "Undefined operation: CONS" m))))
      dispatch)
     (define (car z) (z 'car))
     (define (cdr z) (z 'cdr))
     #+END_SRC

     The same observation is true for mutable data. We can implement
     mutable data objects as procedures using assignment and local
     state. For instance, we can extend the above pair implementation
     to handle set-car! and set-cdr! in a manner analogous to the way
     we implemented bank accounts using make-account in Section 3.1.1:

     #+BEGIN_SRC scheme
     (define (cons x y)
      (define (set-x! v) (set! x v))
      (define (set-y! v) (set! y v))
      (define (dispatch m)
       (cond ((eq? m 'car) x)
             ((eq? m 'cdr) y)
             ((eq? m 'set-car!) set-x!)
             ((eq? m 'set-cdr!) set-y!)
             (else
              (error "Undefined operation: CONS" m))))
      dispatch)
     (define (car z) (z 'car))
     (define (cdr z) (z 'cdr))
     (define (set-car! z new-value)
      ((z 'set-car!) new-value)
      z)
     (define (set-cdr! z new-value)
      ((z 'set-cdr!) new-value)
      z)
     #+END_SRC

     Assignment is all that is needed, theoretically, to account for
     the behavior of mutable data. As soon as we admit set! to our
     language, we raise all of the issues, not only of assignment, but
     of mutable data in general.

     - Exercise 3.20 Draw environment diagrams to illustrate the
       evaluation of the sequence of expressions

       #+BEGIN_SRC scheme
       (define x (cons 1 2))
       (define z (cons x x))
       (set-car! (cdr z) 17)
       (car x)
       17
       #+END_SRC
     
       using the procedural implementation of pairs given
       above. (Compare Exercise 3.11).

*** 3.3.2 Representing Queues

    The mutators set-car! and set-cdr! enable us to use pairs to
    construct data structures that cannot be built with cons, car, and
    cdr alone. This section shows how to use pairs to represent a data
    structure called a queue. Section 3.3.3 will show how to represent
    data structures called tables.

    A _queue_ is a sequence in which items are inserted at one end
    (called the _rear_ of the queue) and deleted from the other end
    (the _front_). Figure 3.18 shows an initially empty queue in which
    items a and b are inserted. Then a is removed, c and d are
    inserted, and b is removed. Because items are always removed in
    the order in which they are inserted, a queue is sometimes called
    a FIFO (first in, first out) buffer.

    #+BEGIN_SRC scheme
    Operation                    Resulting Queue
    (define q (make-queue))
    (insert-queue! q 'a)         a
    (insert-queue! q 'b)         a b
    (delete-queue! q)            b
    (insert-queue! q 'c)         b c
    (insert-queue! q 'd)         b c d
    (delete-queue! q)            c d
    #+END_SRC

    In terms of data abstraction, we can regard a queue as defined by
    the following set of operations:

    - A constructor: (make-queue) returns an empty queue (a queue
      containing no items).
    - two selectors:

      (empty-queue? <queue>) tests if the queue is empty.
      (front-queue <queue>) returns the object at the front of the
      queue, signaling an error if the queue is empty; it does not
      modify the queue.
    - Two mutators:
      
      (insert-queue! <queue> <item>) inserts the item at the rear of
      the queue and returns the modified queue as its value.

      (delete-queue! <queue>) removes the item at the front of the
      queue and returns the modified queue as its value, signaling an
      error if the queue is empty before the deletion.


    Because a queue is a sequence of items, we could certainly
    represent it as an ordinary list; the front of the queue would be
    the car of the list, inserting an item in the queue would amount
    to appending a new element at the end of the list, and deleting an
    item would amount to appending a new element at the end of the
    list, and deleting an item from the queue would just be taking the
    cdr of the list. However, this representation is inefficient,
    because in order to insert an item we must scan the list until we
    reach the end. Since the only method we have for scanning a list
    is by successive cdr operations, this scanning requires O(n) steps
    for a list of _n_ items. A simple modification to the list
    representation overcomes this disadvantage by allowing the queue
    operations to be implemented so that they require O(1) steps; that
    is, so that the number of steps needed is independent of the
    length of the queue.

    The difficulty with the list representation arises from the need
    to scan to find the end of the list. The reason we need to scan is
    that, although the standard way of representing a list as a chain
    of pairs readily provides us with a pointer to the beginning of
    the list, it gives us no easily accessible pointer to the end. The
    modification that avoids the drawback is to represent the queue as
    a list, it gives us no easily accessible pointer to the end. The
    modification that avoids the drawback is to represent the queue as
    a list, together with an additional pointer that indicates the
    final pair in the list. That way, when we go to insert an item, we
    can consult the rear pointer and so avoid scanning the list.

    A queue is represented, then, as a pair of pointers, front-ptr and
    rear-ptr, which indicate, respectively, the first and last pairs
    in an ordinary list. Since we would like the queue to be an
    identifiable object, we can use cons to combine the two
    pointers. Thus, the queue itself will be the cons of two
    pointers. 

    To define the queue operations we use the following procedures,
    which enable us to select and to modify the front and rear
    pointers of a queue:

    #+BEGIN_SRC scheme
    (define (front-ptr queue) (car queue))
    (define (rear-ptr queue) (cdr queue))
    (define (set-front-ptr! queue item)
     (set-car! queue item))
    (define (set-rear-ptr! queue item)
     (set-cdr! queue item))
    #+END_SRC

    Now we can implement the actual queue operations. We will consider
    a queue to be empty if its front pointer is the empty list:

    #+BEGIN_SRC scheme
    (define (empty-queue? queue)
     (null? (front-ptr queue)))
    #+END_SRC

    The make-queue constructor returns, as an initially empty queue, a
    pair whose car and cdr are both the empty list:

    #+BEGIN_SRC scheme
    (define (make-queue) (cons '() '()))
    #+END_SRC

    To select the item at the front of the queue, we return the car of
    the pair indicated by the front pointer:

    #+BEGIN_SRC scheme
    (define (front-queue queue)
     (if (empty-queue? queue)
         (error "FRONT called with an empty queue" queue)
         (car (front-ptr queue))))
    #+END_SRC

    To insert an item in a queue, we follow the method whose result is
    indicated in Figure 3.20. We first create a new pair whose car is
    the item to be inserted and whose cdr is the empty list. If the
    queue was initially empty, we set the front and rear pointers of
    the queue to this new pair. Otherwise, we modify the final pair in
    the queue to point to the new pair, and also set the rear pointer
    to the new pair.

    #+BEGIN_SRC scheme
    (define (insert-queue! queue item)
     (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else 
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
    #+END_SRC

    To delete the item at the front of the queue, we merely modify the
    front pointer so that it now poitns to the second item in the
    queue, which can be found by following the cdr pointer of the
    first item (see Figure 3.21):

    #+BEGIN_SRC scheme
    (define (delete-queue! queue)
     (cond ((empty-queue? queue)
            (error "DELETE! called with an empty queue" queue))
           (else (set-front-ptr! queue (cdr (front-ptr queue)))
                 queue)))
    #+END_SRC

    - Exercise 3.21: Ben Bitdiddle decides to test the queue
      implementation described above. He types in the procedures to
      the Lisp interpreter and proceeds to try them out:

      #+BEGIN_SRC scheme
      (define q1 (make-queue))
      (insert-queue! q1 'a)
      ((a) a)
      (insert-queue! q1 'b)
      ((a b) b)
      (delete-queue! q1)
      ((b) b)
      (delete-queue! q1)
      (() b)
      #+END_SRC

      "It's all wrong!" he complains. "The interpreter's response
      shows that the last item is inserted into the queue twice. And
      when I delete both items, the second b is still there, so the
      queue isn't empty, even though it's supposed to be." Eva Lu Ator
      suggests that Ben has misunderstood what is happening. "It's 
      just that the standard Lisp printer doesn't know how to make
      sense of the queue representation. If you want to see the queue
      printed correctly, you'll have to define your own print
      procedure for queues." Explain what Eva Lu is talking about. In
      particular, show why Ben's examples produce the printed results
      that they do. Define a procedure print-queue that takes a queue
      as input and prints the sequence of items in the queue.

      The interpreter prints cons cells as lists, where the car is the
      first element and the cdr is the rest. So the car of the cons
      cell points to the front of the queue as a list, (a b) in this
      case. And the rear pointer points to the last element, which is
      (cons b '()). So it will always print ((<entire-queue>)
      <last-element>). When we delete all elements in the queue, we
      only update the front-ptr and never rear-ptr. The result is that
      rear-ptr is left alone and still points to the element that was
      the rear, even when we deleted it.

      #+BEGIN_SRC scheme
      (define (print-queue queue)
        (map (lambda (x) (begin (display x) (display " "))) (front-ptr queue))
        (newline))
      #+END_SRC

    - Exercise 3.22: Instead of representing a queue as a pair of
      pointers, we can build a queue as a procedure with local
      state. The local state will consist of pointers to the beginning
      and the end of an ordinary list. Thus, the make-queue procedure
      will have the form

      #+BEGIN_SRC scheme
      (define (make-queue)
       (let ((front-ptr ...)
             (rear-ptr ...))
        <definitions of internal procedures>
        (define (dispatch m) ...)
        dispatch))
      #+END_SRC

      Complete the definition of make-queue and provide
      implementations of the queue operations using this
      representation.

      #+BEGIN_SRC scheme
      (define (make-queue)
       (let ((front-ptr '())
             (rear-ptr '()))
        (define (insert-queue! item)
         (let ((new-pair (cons item '())))
          (cond ((null? front-ptr)
                 (set! front-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr)
                (else
                 (set-cdr! rear-ptr new-pair)
                 (set! rear-ptr new-pair)
                 front-ptr))))
        (define (delete-queue!)
          (set! front-ptr (cdr front-ptr))
          front-ptr)
        (define (front-queue)
         (car front-ptr))
        (define (dispatch m)
         (cond
          ((eq? m 'insert-queue!) insert-queue!)
          ((eq? m 'delete-queue!) delete-queue!)
          ((eq? m 'front-queue) front-queue)
          (else
           (error "Unknown message -- DISPATCH" m))))
        dispatch))
      (define (front-queue q)
       ((q 'front-queue)))
      (define (insert-queue! q item)
       ((q 'insert-queue!) item))
      (define (delete-queue! q)
       ((q 'delete-queue!)))
      #+END_SRC

    - Exercise 3.23: A _dequeue_ ("double-ended queue") is a sequence
      in which items can be inserted and deleted at either the front
      or the rear. Operations on deques are the constructor
      make-deque, the predicate empty-deque?, selectors front-deque
      and rear-deque, mutators front-insert-deque!,
      rear-insert-deque!, front-delete-deque!, and
      rear-delete-deque!. Show how to represent deques using pairs,
      and give implementations of the operations. All operations
      should be accomplished in O(1) steps.

      We already have a front-and-rear pointer system, but the problem
      is that if we want to delete items from the back of the queue,
      the oldest items, we won't know where to put our pointer,
      because we can't find out what pointed to it. So instead each
      item needs to hold: 

      - the item

      - The item before (towards the front)

      - The item after (towards the back).

      And we keep the front and rear pointers. 

      #+BEGIN_SRC scheme
      (define (make-deque-item value next prev)
       (define (set-next! new-next)
        (set! next new-next)
        next)
       (define (set-prev! new-prev)
        (set! prev new-prev)
        prev)
       (define (dispatch m)
        (cond
         ((eq? m 'value) value)
         ((eq? m 'next) next)
         ((eq? m 'prev) prev)
         ((eq? m 'set-next!) set-next!)
         ((eq? m 'set-prev!) set-prev!)
         (else
          (error "Unknown message -- DISPATCH" m))))
       dispatch)
      (define (make-deque)
       (let ((front-ptr '())
             (back-ptr '()))
        (define (insert-front! item)
         (let ((new-node (make-deque-item item '() '())))
          (cond
           ((null? front-ptr)
            (set! front-ptr new-node)
            (set! back-ptr new-node)
            front-ptr)
          (else
           ((new-node 'set-next!) front-ptr)
           ((front-ptr 'set-prev!) new-node)
           (set! front-ptr new-node)
           front-ptr))))
        (define (insert-back! item)
         (let ((new-node (make-deque-item item '() '())))
          (cond
           ((null? front-ptr)
            (set! front-ptr new-node)
            (set! back-ptr new-node)
            front-ptr)
           (else
            ((new-node 'set-prev!) back-ptr)
            ((back-ptr 'set-next!) new-node)
            (set! back-ptr new-node)
            front-ptr))))
       (define (delete-back!)
        (let ((old-rear back-ptr))
         (set! back-ptr (old-rear 'prev))
         ((back-ptr 'set-next!) '())
         ((old-rear 'set-prev!) '()) 
         front-ptr))
       (define (delete-front!)
        (let ((old-front front-ptr))
         (set! front-ptr (old-front 'next))
         ((old-front 'set-next!) '())
         front-ptr))
       (define (front-deque)
        (front-ptr 'value))
       (define (back-deque)
        (back-ptr 'value))
       (define (print)
        (define (print-loop item)
         (if (not (null? item))
             (begin 
              (display (item 'value))
              (display " ")
              (print-loop (item 'next)))))
        (print-loop front-ptr))
       (define (dispatch m)
        (cond ((eq? m 'insert-front!) insert-front!)
              ((eq? m 'insert-back!) insert-back!)
              ((eq? m 'delete-back!) delete-back!)
              ((eq? m 'delete-front!) delete-front!)
              ((eq? m 'front-deque) front-deque)
              ((eq? m 'back-deque) back-deque)
              ((eq? m 'print) print)
              (else
               (error
                "Unknown message -- DISPATCH" m))))
       dispatch))
      #+END_SRC
    
*** 3.3.3. Representing Tables
    When we studied various ways of representing sets in Chapter 2, we
    mentioned in Section 2.3.3. the task of maintaining a table of
    records indexed by identifying keys. In the implementation of
    data-directed programming in Section 2.4.3, we made extensive use
    of two-dimensional tables, in which information is stored and
    retrieved using two keys. Here we see how to build tables as
    mutable list structures.

    We first consider a one-dimensional table, in which each value is
    stored under a single key. We implement the table as a list of
    records, each of which is implemented as a pair consisting of a
    key and the associated value. The records are glued together to
    form a list by pairs whose cars point to successive records. These
    gluing pairs are called the _backbone_ of the table. In order to
    have a place that we can change when we add a new record to the
    table, we build the table as a _headed list_. A headed list has a
    special backbone pair at the beginning, which holds a dummy
    "record" -- in this case the arbitrarily chosen symbol \*table\*.
    
    To extract information from a table we use the lookup procedure,
    which takes a key as argument and returns the associated value (or
    false if there is no value stored under that key). lookup is
    defined in terms of the assoc operation, which expects a key and a
    list of records as arguments. Note that assoc never sees the dummy
    record. assoc returns the record that has the given key as its
    car. lookup then checks to see that the resulting record returned
    by assoc is not false, and returns the value (the cdr) of the
    record.

    #+BEGIN_SRC scheme
    (define (lookup key table)
     (let ((record (assoc key (cdr table))))
      (if record
          (cdr record)
          false)))
    (define (assoc key records)
     (cond ((null? records) false)
           ((equal? key (caar records)) (car records))
           (else (assoc key (cdr records)))))
    #+END_SRC

    To insert a value in a table under a specified key, we first use
    assoc to see if there is already a record in the table with this
    key. If not, we form a new record by consing the key with the
    value, and insert this at the head of the table's list of records,
    after the dummy record. If there already is a record with this
    key, we set the cdr of this record to the designated new
    value. The header of the table provides us with a fixed location
    to modify in order to insert the new record.

    #+BEGIN_SRC scheme
    (define (insert! key value table)
     (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value)
                          (cdr table))))
     'ok))
    #+END_SRC

    To construct the new table, we simply create a list containing the
    symbol \*table\*:

    #+BEGIN_SRC scheme
    (define (make-table)
     (list '*table*))
    #+END_SRC

**** Two-dimensional tables

     In a two-dimensional table, each value is indexed by two keys. We
     can construct such a table as a one-dimensional table in which
     each key identifies as a subtable. Figure 3.23 shows the
     box-and-pointer diagram for the table

     math: +: 43          letters:  a: 97
           -: 45                    b: 98
           *: 42

     which has two subtables (The subtables don't need a special
     header symbol, since the key that identifies the subtable serves
     this purpose.)

     When we look up an item, we use the first key to identify the
     correct subtable. Then we use the second key to identify the
     record within the subtable.

     #+BEGIN_SRC scheme
     (define (lookup key-1 key-2 table)
      (let ((subtable
             (assoc key-1 (cdr table))))
       (if subtable
           (let ((record
                  (assoc key-2 (cdr subtable))))
            (if record
                (cdr record)
                false))
          false)))
     #+END_SRC

     To insert a new item under a pair of keys, we use assoc to see if
     there is a subtable stored under the first key. If not, we build
     a new subtable containing a single record (key-2, value) and
     insert it into the table under the first key. If a subtable
     already exists for the first key, we insert the new record into
     this subtable, using the insertion method for one-dimensional
     tables described above:

     #+BEGIN_SRC scheme
     (define (insert! key-1 key-2 value table)
      (let ((subtable (assoc key-1 (cdr table))))
       (if subtable
           (let ((record (assoc key-2 (cdr subtable))))
            (if record
                (set-cdr! record value)
                (set-cdr! subtable
                          (cons (cons key-2 value)
                                (cdr subtable)))))
          (set-cdr! table
                    (cons (list key-1
                                (cons key-2 value))
                          (cdr table)))))
      'ok)
     #+END_SRC

**** Creating local tables

     The lookup and insert! operations defined above take the table as
     an argument. This enables us to use programs that access more
     than one table. Another way to deal with multiple tables is to
     have separate lookup and insert! procedures for each table. We
     can do this by representing a table procedurally, as an object
     that maintains an internal table as part of its local state. When
     sent an appropriate message, this "table object" supplies the
     procedure with which to operate on the internal table. Here is a
     generator for two-dimensional tables represented in this fashion:

     #+BEGIN_SRC scheme
     (define (make-table)
      (let ((local-table (list '*table*)))
       (define (lookup key-1 key-2)
        (let ((subtable
               (assoc key-1 (cdr local-table))))
         (if subtable
             (let ((record
                    (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
       (define (insert! key-1 key-2 value)
        (let ((subtable
               (assoc key-1 (cdr local-table))))
         (if subtable
             (let ((record
                    (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
        'ok)
      (define (dispatch m)
       (cond ((eq? m 'lookup-proc) lookup)
             ((eq? m 'insert-proc!) insert!)
             (else (error "Unknown operation: TABLE" m))))
      dispatch))
     #+END_SRC

     Using make-table, we could implement the get and put operations
     used in Section 2.4.3 for data-directed programming, as follows:

     #+BEGIN_SRC scheme
     (define operation-table (make-table))
     (define get (operation-table 'lookup-proc))
     (define put (operation-table 'insert-proc!))
     #+END_SRC

     get takes as arguments two keys, and put takes as arguments two
     keys and a value. Both operations access the same local table,
     which is encapsulated within the object created by teh call to
     make-table.

     - Exercise 3.24: In the table implementations above, the keys are
       tested for equality using equal? (called by assoc). This is not
       always the appropriate test. For instance, we might have a
       table with numeric keys in which we don't need an exact match
       to the number we're lookuping up, but only a number within some
       tolerance of it. Design a table constructor make-table that
       takes as an argument a same-key? procedure that will be used to
       test "equality" of keys. make-table should return a dispatch
       procedure that can be used to access appropriate lookup and
       insert! procedures for a local table.

       You also need to rewrite assoc.
       #+BEGIN_SRC scheme
       (define (assoc/key a-list key same-key?)
        (cond
         ((null? a-list) false)
         ((same-key? (caar a-list) key) (car a-list))
         (else (assoc/key (cdr a-list) key same-key?))))
       (define (make-table same-key?)
        (let ((local-table (list '*table*)))
         (define (lookup key)
          (let ((record (assoc/key (cdr local-table) key same-key?)))
           (if record
               (cdr record)
               false)))
         (define (insert! key value)
          (let ((record (assoc/key (cdr local-table) key same-key?)))
           (if record
               (set-cdr! record value)
               (set-cdr! local-table
                         (cons (cons key value)
                               (cdr local-table)))))
          'ok)
         (define (dispatch m)
          (cond
           ((eq? m 'lookup) lookup)
           ((eq? m 'insert!) insert!)
           (else (error "Unknown message -- DISPATCH" m))))
         dispatch))
       #+END_SRC

     - Exercise 3.25: Generalizing one- and two-dimensional tables,
       show how to implement a table in which values are stored under
       an arbitrary number of keys and different values may be stored
       under different numbers of keys. The lookup and insert!
       procedures should take as input a list of keys used to access
       the table. 

       #+BEGIN_SRC scheme
       (define (make-table)
        (let ((local-table (list '*table*)))

         (define (lookup . keys)
          (lookup-list keys local-table))
         (define (lookup-list keys record)
          (cond
           ((null? keys) (cdr record))
           (else
            (let ((entry (assoc (car keys) (cdr record))))
             (if entry
                 (lookup-list (cdr keys) entry)
                 false)))))

         (define (insert! . keys-and-value)
          (insert-list! keys-and-value local-table))
         (define (insert-list! keys-and-value entry)
          (cond
           ((null? (cdr keys-and-value))
            (set-cdr! entry (car keys-and-value))
            'ok)
           (else
            (let ((record (assoc (car keys-and-value) (cdr entry))))
             (if record
                 (insert-list! (cdr keys-and-value) record)
                 (let ((new-entry (cons (car keys-and-value) (list))))
                  (set-cdr! entry
                            (cons new-entry
                                  (cdr entry)))
                  (insert-list! (cdr keys-and-value) new-entry)))))))

         (define (dispatch m)
          (cond ((eq? m 'insert!) insert!)
                ((eq? m 'lookup) lookup)
                (else (error "Unknown message -- DISPATCH" m))))
         dispatch))
       #+END_SRC

     - Exercise 3.26 To search a table as implemented above, one needs
       to scan through the list of records. This is basically the
       unordered list representation of Section 2.3.3. For large
       tables, it may be more efficient to structure the table in a
       different manner. Describe a table implementation where the
       (key, value) records are organized using a binary tree,
       assuming that keys can be ordered in some way (e.g.,
       numerically or alphabetically).

       Well, you would write a tree implementation pretty much exactly
       like the tree set we already did, except you'd extract keys to
       compare. And you'd probably give equality/lessthan/greaterthan
       function(s) to the make-table procedure.

       #+BEGIN_SRC scheme
       (define (make-node key value left right)
        (list key value left right))

       (define (make-empty-node)
        (list '() '() '() '()))
 
       (define (empty-node? node)
        (and (null? (car node))
             (null? (cadr node))
             (null? (caddr node))
             (null? (cadddr node)))) 

       (define (node-key node)
        (car node))

       (define (node-value node)
        (cadr node))

       (define (node-left node)
        (caddr node))

       (define (node-right node)
        (cadddr node))

       (define (node-set-key! node key)
        (set-car! node key))
       (define (node-set-value! node value)
        (set-car! (cdr node) value))

       (define (node-set-right! node new-right-node)
        (set-car! (cdddr node) new-right-node))

       (define (node-set-left! node new-left-node)
        (set-car! (cddr node) new-left-node))

       (define (make-table compare) ;; compare returns 'equal, 'less, or 'greater
        (let ((local-table (make-empty-node)))
         (define (lookup key node)
          (cond
           ((empty-node? node) false)
           ((eq? (compare key (node-key node)) 'equal)
            (node-value node))
           ((eq? (compare key (node-key node))
                 'less)
            (lookup key (node-left node)))
           ((eq? (compare key (node-key node))
                 'greater)
            (lookup key (node-right node)))
           (else (error "Nonsensical comparison value -- LOOKUP"))))

         (define (insert! key value node)
          (cond
           ((empty-node? node)
            (node-set-key! node key)
            (node-set-value! node value)
            (node-set-right! node (make-empty-node))
            (node-set-left! node (make-empty-node)))
           ((eq? (compare key (node-key node)) 'equal)
            (node-set-value! node value))
           ((eq? (compare key (node-key node)) 'less)
                (insert! key value (node-left node)))
           ((eq? (compare key (node-key node)) 'greater)
                (insert! key value (node-right node)))
           (else
            (error "Node does not compare -- INSERT!" key value node))))

        (define (dispatch m)
         (cond ((eq? m 'insert!) 
                (lambda (key value) 
                 (insert!
                  key value local-table)))
               ((eq? m 'lookup)
                (lambda (key)
                 (lookup key local-table)))
               (else
                (error "Unknown message -- DISPATCH" m))))
       dispatch))
       #+END_SRC

     - Exercise 3.27: _Memoization_ (also called _tabulation_) is a
       technique that enables a procedure to record, in a local table,
       values that have previously been computed. This technique can
       make a vast difference in the performance of a program. A
       memoized procedure maintains a table in which values of
       previous calls are stored using as keys the arguments that
       produced the values. When the memoized procedure is asked to
       compute a value, it first checks the table to see if the value
       is already there and, if so, just returns that
       value. Otherwise, it computes the new value in the ordinary way
       and stores this in the table. As an example of memoization,
       recall from Section 1.2.2 the exponential process for computing
       Fibonacci numbers:

       #+BEGIN_SRC scheme
       (define (fib n)
        (cond ((= n 0) 0)
              ((= n 1) 1)
              (else (+ (fib (- n 1)) (fib (- n 2))))))
       #+END_SRC

       The memoized version of the same procedure is

       #+BEGIN_SRC scheme
       (define memo-fib
               (memoize
                (lambda (n)
                 (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (else (+ (memo-fib (- n 1))
                                (memo-fib (- n 2))))))))
       #+END_SRC

       where the memoizer is defined as

       #+BEGIN_SRC scheme
       (define (memoize f)
        (let ((table (make-table)))
         (lambda (x)
          (let ((previously-computed-result
                 (lookup x table)))
           (or previously-computed-result
              (let ((result (f x)))
               (insert! x result table)
               result))))))
       #+END_SRC

       Draw an environment diagram to analyze the computation of
       (memo-fib 3). Explain why memo-fib computes the nth Fibonacci
       number in a number of steps proportional to n. Would the scheme
       still work if we had simply defined memo-fib to be (memoize
       fib)?

       
